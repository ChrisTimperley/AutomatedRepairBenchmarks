/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is true */

#line 214 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 183 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 36 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 46 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
#line 46 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_slist __pthread_slist_t;
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion____missing_field_name_7 {
   int __spins ;
   __pthread_slist_t __list ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion____missing_field_name_7 __annonCompField1 ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_6 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
#line 54 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_6 pthread_mutex_t;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 146 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 92 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 136 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 137 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 219 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 130 "main.h"
struct __anonstruct_CONFIG_72 {
   char config_filename[255] ;
   char server_base_dir[255] ;
   char server_bin_dir[255] ;
   char server_cgi_dir[255] ;
   char server_etc_dir[255] ;
   char server_htdocs_dir[255] ;
   char server_hostname[64] ;
   short server_port ;
   short server_loglevel ;
   short server_maxconn ;
   short server_maxidle ;
};
#line 130 "main.h"
typedef struct __anonstruct_CONFIG_72 CONFIG;
#line 143 "main.h"
struct __anonstruct_CONNDATA_73 {
   char in_Connection[16] ;
   int in_ContentLength ;
   char in_ContentType[128] ;
   char in_Cookie[1024] ;
   char in_Host[64] ;
   char in_IfModifiedSince[64] ;
   char in_PathInfo[128] ;
   char in_Protocol[16] ;
   char in_QueryString[1024] ;
   char in_Referer[128] ;
   char in_RemoteAddr[16] ;
   int in_RemotePort ;
   char in_RequestMethod[8] ;
   char in_RequestURI[1024] ;
   char in_ScriptName[128] ;
   char in_UserAgent[128] ;
   short out_status ;
   char out_CacheControl[16] ;
   char out_Connection[16] ;
   int out_ContentLength ;
   char out_Date[64] ;
   char out_Expires[64] ;
   char out_LastModified[64] ;
   char out_Pragma[16] ;
   char out_Protocol[16] ;
   char out_Server[128] ;
   char out_ContentType[128] ;
   char out_ReplyData[65536] ;
   short out_headdone ;
   short out_bodydone ;
   short out_flushed ;
   char envbuf[8192] ;
};
#line 143 "main.h"
typedef struct __anonstruct_CONNDATA_73 CONNDATA;
#line 180 "main.h"
struct __anonstruct_CONNECTION_74 {
   pthread_t handle ;
   unsigned long id ;
   short socket ;
   struct sockaddr_in ClientAddr ;
   time_t ctime ;
   time_t atime ;
   char *PostData ;
   CONNDATA *dat ;
};
#line 180 "main.h"
typedef struct __anonstruct_CONNECTION_74 CONNECTION;
#line 190 "main.h"
struct __anonstruct_pipe_fd_75 {
   int in ;
   int out ;
};
#line 190 "main.h"
typedef struct __anonstruct_pipe_fd_75 pipe_fd;
#line 199 "main.h"
struct __anonstruct_Lock_76 {
   pthread_mutex_t Crypt ;
   pthread_mutex_t Global ;
   pthread_mutex_t SQL ;
};
#line 60 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_3 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_3 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_5 {
   char __size[36] ;
   long __align ;
};
#line 39 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_5 pthread_attr_t;
#line 75 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_8 {
   char __size[4] ;
   long __align ;
};
#line 75 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_8 pthread_mutexattr_t;
#line 37 "/usr/include/bits/socket.h"
typedef __socklen_t socklen_t;
#line 96 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_46 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_47 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_48 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_49 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_50 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_51 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_45 {
   int _pad[128U / sizeof(int ) - 3U] ;
   struct __anonstruct__kill_46 _kill ;
   struct __anonstruct__timer_47 _timer ;
   struct __anonstruct__rt_48 _rt ;
   struct __anonstruct__sigchld_49 _sigchld ;
   struct __anonstruct__sigfault_50 _sigfault ;
   struct __anonstruct__sigpoll_51 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_45 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_63 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_63 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
#line 1 "cgi.o"
#pragma merger(0,"/tmp/cil-Q4JTvEFY.i","-Wall,-O2,-s")
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 363
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 765
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 591 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 331
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 136 "/usr/include/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 320 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 199 "main.h"
struct __anonstruct_Lock_76 Lock  ;
#line 204 "main.h"
unsigned char program_name[255]  ;
#line 205 "main.h"
CONFIG config  ;
#line 206 "main.h"
CONNECTION *conn  ;
#line 239
int cgi_main(void) ;
#line 247
void fixslashes(char *pOriginal ) ;
#line 251
char *strcasestr(char *src , char *query ) ;
#line 255
void printerror(int sid , int status , char *title , char *text ) ;
#line 262
void logaccess(int loglevel , char const   *format  , ...) ;
#line 263
void logerror(char const   *format  , ...) ;
#line 264
int getsid(void) ;
#line 265
void flushbuffer(int sid ) ;
#line 266
int prints(char const   *format  , ...) ;
#line 268
int closeconnect(int sid , int exitflag ) ;
#line 23 "cgi.c"
void cgi_makeargs(int sid , char **args ) 
{ char *ptemp ;
  char progname[255] ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  void *tmp___26 ;
  char *tmp___28 ;
  void *tmp___29 ;
  char *tmp___31 ;

  {
#line 28
  if (0) {
#line 28
    if (0) {
#line 28
      __s1_len___0 = strlen((char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 28
      __s2_len___0 = strlen("/cgi-bin/");
#line 28
      if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI)) == 1U)) {
        goto _L___2;
      } else {
#line 28
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 28
          if (! ((unsigned int )((void const   *)("/cgi-bin/" + 1)) - (unsigned int )((void const   *)"/cgi-bin/") == 1U)) {
#line 28
            tmp___22 = 1;
          } else {
#line 28
            if (__s2_len___0 >= 4U) {
#line 28
              tmp___22 = 1;
            } else {
#line 28
              tmp___22 = 0;
            }
          }
        } else {
#line 28
          tmp___22 = 0;
        }
      }
#line 28
      if (tmp___22) {
#line 28
        tmp___18 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
      } else {
#line 28
        tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
#line 28
        tmp___18 = tmp___21;
      }
    } else {
#line 28
      tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                  "/cgi-bin/");
#line 28
      tmp___18 = tmp___21;
    }
#line 28
    tmp___12 = tmp___18;
  } else {
#line 28
    tmp___12 = strncmp((char const   *)(((conn + sid)->dat)->in_RequestURI), "/cgi-bin/",
                       9U);
  }
#line 28
  if (tmp___12 != 0) {
#line 28
    return;
  }
#line 29
  tmp___25 = calloc(255U, sizeof(char ));
#line 29
  *(args + 0) = (char *)tmp___25;
#line 30
  snprintf((char * __restrict  )(progname), sizeof(progname) - 1U, (char const   * __restrict  )"%s",
           ((conn + sid)->dat)->in_RequestURI + 9);
#line 31
  tmp___28 = __builtin_strchr(progname, '?');
#line 31
  ptemp = tmp___28;
#line 31
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 32
    tmp___26 = calloc(255U, sizeof(char ));
#line 32
    *(args + 1) = (char *)tmp___26;
#line 33
    snprintf((char * __restrict  )*(args + 1), 254U, (char const   * __restrict  )"%s",
             ptemp + 1);
#line 34
    *ptemp = (char )'\000';
  }
#line 36
  tmp___31 = __builtin_strchr(progname, '/');
#line 36
  ptemp = tmp___31;
#line 36
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 37
    tmp___29 = calloc(255U, sizeof(char ));
#line 37
    *(args + 2) = (char *)tmp___29;
#line 38
    snprintf((char * __restrict  )*(args + 2), 254U, (char const   * __restrict  )"%s",
             ptemp);
#line 39
    *ptemp = (char )'\000';
  }
#line 41
  snprintf((char * __restrict  )*(args + 0), 254U, (char const   * __restrict  )"%s/%s",
           config.server_cgi_dir, progname);
#line 42
  fixslashes(*(args + 0));
#line 43
  return;
}
}
#line 45 "cgi.c"
void cgi_makeenv(int sid , char **env , char **args ) 
{ char *ptemp ;
  int n ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  void *tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  void *tmp___30 ;
  int tmp___31 ;
  void *tmp___32 ;
  int tmp___33 ;
  void *tmp___34 ;
  int tmp___35 ;
  void *tmp___36 ;
  int tmp___37 ;
  void *tmp___38 ;
  int tmp___39 ;
  char *tmp___41 ;
  void *tmp___42 ;
  int tmp___43 ;
  void *tmp___44 ;
  int tmp___45 ;
  void *tmp___46 ;
  int tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  void *tmp___51 ;
  int tmp___52 ;
  void *tmp___53 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___54 ;
  void *tmp___55 ;
  int tmp___56 ;
  void *tmp___57 ;
  int tmp___58 ;
  void *tmp___59 ;
  int tmp___60 ;
  void *tmp___61 ;
  int tmp___62 ;
  char *tmp___64 ;
  char *tmp___66 ;
  void *tmp___67 ;
  int tmp___68 ;
  void *tmp___69 ;
  int tmp___70 ;
  void *tmp___71 ;
  int tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  void *tmp___75 ;
  int tmp___76 ;

  {
#line 48
  n = 0;
#line 50
  if (0) {
#line 50
    if (0) {
#line 50
      __s1_len___0 = strlen((char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 50
      __s2_len___0 = strlen("/cgi-bin/");
#line 50
      if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI)) == 1U)) {
        goto _L___2;
      } else {
#line 50
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 50
          if (! ((unsigned int )((void const   *)("/cgi-bin/" + 1)) - (unsigned int )((void const   *)"/cgi-bin/") == 1U)) {
#line 50
            tmp___22 = 1;
          } else {
#line 50
            if (__s2_len___0 >= 4U) {
#line 50
              tmp___22 = 1;
            } else {
#line 50
              tmp___22 = 0;
            }
          }
        } else {
#line 50
          tmp___22 = 0;
        }
      }
#line 50
      if (tmp___22) {
#line 50
        tmp___18 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
      } else {
#line 50
        tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
#line 50
        tmp___18 = tmp___21;
      }
    } else {
#line 50
      tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                  "/cgi-bin/");
#line 50
      tmp___18 = tmp___21;
    }
#line 50
    tmp___12 = tmp___18;
  } else {
#line 50
    tmp___12 = strncmp((char const   *)(((conn + sid)->dat)->in_RequestURI), "/cgi-bin/",
                       9U);
  }
#line 50
  if (tmp___12 != 0) {
#line 50
    return;
  }
#line 57
  tmp___29 = strcasecmp((char const   *)(((conn + sid)->dat)->in_RequestMethod), "POST");
#line 57
  if (tmp___29 == 0) {
#line 58
    tmp___25 = calloc(1024U, sizeof(char ));
#line 58
    *(env + n) = (char *)tmp___25;
#line 59
    tmp___26 = n;
#line 59
    n ++;
#line 59
    snprintf((char * __restrict  )*(env + tmp___26), 1023U, (char const   * __restrict  )"CONTENT_LENGTH=%d",
             ((conn + sid)->dat)->in_ContentLength);
#line 60
    tmp___27 = calloc(1024U, sizeof(char ));
#line 60
    *(env + n) = (char *)tmp___27;
#line 61
    tmp___28 = n;
#line 61
    n ++;
#line 61
    snprintf((char * __restrict  )*(env + tmp___28), 1023U, (char const   * __restrict  )"CONTENT_TYPE=%s",
             ((conn + sid)->dat)->in_ContentType);
  }
#line 63
  tmp___30 = calloc(1024U, sizeof(char ));
#line 63
  *(env + n) = (char *)tmp___30;
#line 64
  tmp___31 = n;
#line 64
  n ++;
#line 64
  snprintf((char * __restrict  )*(env + tmp___31), 1023U, (char const   * __restrict  )"DOCUMENT_ROOT=%s",
           config.server_htdocs_dir);
#line 65
  tmp___32 = calloc(1024U, sizeof(char ));
#line 65
  *(env + n) = (char *)tmp___32;
#line 66
  tmp___33 = n;
#line 66
  n ++;
#line 66
  snprintf((char * __restrict  )*(env + tmp___33), 1023U, (char const   * __restrict  )"GATEWAY_INTERFACE=CGI/1.1");
#line 67
  tmp___34 = calloc(1024U, sizeof(char ));
#line 67
  *(env + n) = (char *)tmp___34;
#line 68
  tmp___35 = n;
#line 68
  n ++;
#line 68
  snprintf((char * __restrict  )*(env + tmp___35), 1023U, (char const   * __restrict  )"HTTP_CONNECTION=%s",
           ((conn + sid)->dat)->in_Connection);
#line 69
  tmp___36 = calloc(1024U, sizeof(char ));
#line 69
  *(env + n) = (char *)tmp___36;
#line 70
  tmp___37 = n;
#line 70
  n ++;
#line 70
  snprintf((char * __restrict  )*(env + tmp___37), 1023U, (char const   * __restrict  )"HTTP_COOKIE=%s",
           ((conn + sid)->dat)->in_Cookie);
#line 71
  tmp___38 = calloc(1024U, sizeof(char ));
#line 71
  *(env + n) = (char *)tmp___38;
#line 72
  tmp___39 = n;
#line 72
  n ++;
#line 72
  snprintf((char * __restrict  )*(env + tmp___39), 1023U, (char const   * __restrict  )"HTTP_HOST=%s",
           ((conn + sid)->dat)->in_Host);
#line 73
  tmp___41 = __builtin_strchr(*(env + (n - 1)), ':');
#line 73
  ptemp = tmp___41;
#line 73
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 73
    *ptemp = (char )'\000';
  }
#line 74
  tmp___42 = calloc(1024U, sizeof(char ));
#line 74
  *(env + n) = (char *)tmp___42;
#line 75
  tmp___43 = n;
#line 75
  n ++;
#line 75
  snprintf((char * __restrict  )*(env + tmp___43), 1023U, (char const   * __restrict  )"HTTP_USER_AGENT=%s",
           ((conn + sid)->dat)->in_UserAgent);
#line 76
  ptemp = getenv("PATH");
#line 76
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 77
    tmp___44 = calloc(1024U, sizeof(char ));
#line 77
    *(env + n) = (char *)tmp___44;
#line 78
    tmp___45 = n;
#line 78
    n ++;
#line 78
    snprintf((char * __restrict  )*(env + tmp___45), 1023U, (char const   * __restrict  )"PATH=%s",
             ptemp);
  }
#line 80
  if ((unsigned int )*(args + 2) != (unsigned int )((void *)0)) {
#line 81
    tmp___46 = calloc(1024U, sizeof(char ));
#line 81
    *(env + n) = (char *)tmp___46;
#line 82
    tmp___47 = n;
#line 82
    n ++;
#line 82
    snprintf((char * __restrict  )*(env + tmp___47), 1023U, (char const   * __restrict  )"PATH_INFO=%s",
             *(args + 2));
  }
#line 84
  tmp___48 = calloc(1024U, sizeof(char ));
#line 84
  *(env + n) = (char *)tmp___48;
#line 85
  if ((unsigned int )*(args + 1) != (unsigned int )((void *)0)) {
#line 86
    tmp___49 = n;
#line 86
    n ++;
#line 86
    snprintf((char * __restrict  )*(env + tmp___49), 1023U, (char const   * __restrict  )"QUERY_STRING=%s",
             *(args + 1));
  } else {
#line 88
    tmp___50 = n;
#line 88
    n ++;
#line 88
    snprintf((char * __restrict  )*(env + tmp___50), 1023U, (char const   * __restrict  )"QUERY_STRING=");
  }
#line 90
  tmp___51 = calloc(1024U, sizeof(char ));
#line 90
  *(env + n) = (char *)tmp___51;
#line 91
  tmp___52 = n;
#line 91
  n ++;
#line 91
  snprintf((char * __restrict  )*(env + tmp___52), 1023U, (char const   * __restrict  )"REMOTE_ADDR=%s",
           ((conn + sid)->dat)->in_RemoteAddr);
#line 92
  tmp___53 = calloc(1024U, sizeof(char ));
#line 92
  *(env + n) = (char *)tmp___53;
#line 93
  __x = (conn + sid)->ClientAddr.sin_port;
#line 93
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 93
  tmp___54 = n;
#line 93
  n ++;
#line 93
  snprintf((char * __restrict  )*(env + tmp___54), 1023U, (char const   * __restrict  )"REMOTE_PORT=%d",
           __v);
#line 94
  tmp___55 = calloc(1024U, sizeof(char ));
#line 94
  *(env + n) = (char *)tmp___55;
#line 95
  tmp___56 = n;
#line 95
  n ++;
#line 95
  snprintf((char * __restrict  )*(env + tmp___56), 1023U, (char const   * __restrict  )"REQUEST_METHOD=%s",
           ((conn + sid)->dat)->in_RequestMethod);
#line 96
  tmp___57 = calloc(1024U, sizeof(char ));
#line 96
  *(env + n) = (char *)tmp___57;
#line 97
  tmp___58 = n;
#line 97
  n ++;
#line 97
  snprintf((char * __restrict  )*(env + tmp___58), 1023U, (char const   * __restrict  )"REQUEST_URI=%s",
           ((conn + sid)->dat)->in_RequestURI);
#line 98
  tmp___59 = calloc(1024U, sizeof(char ));
#line 98
  *(env + n) = (char *)tmp___59;
#line 99
  tmp___60 = n;
#line 99
  n ++;
#line 99
  snprintf((char * __restrict  )*(env + tmp___60), 1023U, (char const   * __restrict  )"SCRIPT_FILENAME=%s",
           *(args + 0));
#line 100
  tmp___61 = calloc(1024U, sizeof(char ));
#line 100
  *(env + n) = (char *)tmp___61;
#line 101
  tmp___62 = n;
#line 101
  n ++;
#line 101
  snprintf((char * __restrict  )*(env + tmp___62), 1023U, (char const   * __restrict  )"SCRIPT_NAME=%s",
           ((conn + sid)->dat)->in_RequestURI);
#line 102
  tmp___64 = __builtin_strchr(*(env + (n - 1)), '?');
#line 102
  ptemp = tmp___64;
#line 102
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 102
    *ptemp = (char )'\000';
  }
#line 103
  tmp___66 = __builtin_strchr(*(env + (n - 1)) + 21, '/');
#line 103
  ptemp = tmp___66;
#line 103
  if ((unsigned int )ptemp != (unsigned int )((void *)0)) {
#line 103
    *ptemp = (char )'\000';
  }
#line 104
  tmp___67 = calloc(1024U, sizeof(char ));
#line 104
  *(env + n) = (char *)tmp___67;
#line 105
  tmp___68 = n;
#line 105
  n ++;
#line 105
  snprintf((char * __restrict  )*(env + tmp___68), 1023U, (char const   * __restrict  )"SERVER_NAME=%s",
           config.server_hostname);
#line 106
  tmp___69 = calloc(1024U, sizeof(char ));
#line 106
  *(env + n) = (char *)tmp___69;
#line 107
  tmp___70 = n;
#line 107
  n ++;
#line 107
  snprintf((char * __restrict  )*(env + tmp___70), 1023U, (char const   * __restrict  )"SERVER_PORT=%d",
           config.server_port);
#line 108
  tmp___71 = calloc(1024U, sizeof(char ));
#line 108
  *(env + n) = (char *)tmp___71;
#line 109
  tmp___72 = n;
#line 109
  n ++;
#line 109
  snprintf((char * __restrict  )*(env + tmp___72), 1023U, (char const   * __restrict  )"SERVER_PROTOCOL=HTTP/1.1");
#line 110
  tmp___73 = calloc(1024U, sizeof(char ));
#line 110
  *(env + n) = (char *)tmp___73;
#line 111
  tmp___74 = n;
#line 111
  n ++;
#line 111
  snprintf((char * __restrict  )*(env + tmp___74), 1023U, (char const   * __restrict  )"SERVER_SIGNATURE=<ADDRESS>%s</ADDRESS>",
           "Null httpd 0.5.0");
#line 112
  tmp___75 = calloc(1024U, sizeof(char ));
#line 112
  *(env + n) = (char *)tmp___75;
#line 113
  tmp___76 = n;
#line 113
  n ++;
#line 113
  snprintf((char * __restrict  )*(env + tmp___76), 1023U, (char const   * __restrict  )"SERVER_SOFTWARE=%s",
           "Null httpd 0.5.0");
#line 120
  free((void *)*(args + 1));
#line 121
  *(args + 1) = (char *)((void *)0);
#line 122
  free((void *)*(args + 2));
#line 123
  *(args + 2) = (char *)((void *)0);
#line 124
  return;
}
}
#line 126 "cgi.c"
int cgi_main(void) 
{ char *cgi_types[3][2] ;
  int pset1[2] ;
  int pset2[2] ;
  char *args[10] ;
  char *env[50] ;
  char cgifilename[255] ;
  char *extension ;
  char szBuffer[8192] ;
  pipe_fd local ;
  pipe_fd remote ;
  int sid ;
  int tmp ;
  int nOutRead ;
  int pid ;
  unsigned int i ;
  unsigned int n ;
  void *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 142
  cgi_types[0][0] = (char *)".php";
#line 142
  cgi_types[0][1] = (char *)"/usr/bin/php";
#line 142
  cgi_types[1][0] = (char *)".pl";
#line 142
  cgi_types[1][1] = (char *)"/usr/bin/perl";
#line 142
  cgi_types[2][0] = (char *)((void *)0);
#line 142
  cgi_types[2][1] = (char *)((void *)0);
#line 157
  tmp = getsid();
#line 157
  sid = tmp;
#line 163
  memset((void *)(args), 0, sizeof(args));
#line 164
  cgi_makeargs(sid, args);
#line 165
  memset((void *)(env), 0, sizeof(env));
#line 166
  cgi_makeenv(sid, env, args);
#line 167
  snprintf((char * __restrict  )(cgifilename), sizeof(cgifilename) - 1U, (char const   * __restrict  )"%s",
           args[0]);
#line 168
  i = 0U;
#line 168
  while (i < 10U) {
#line 168
    free((void *)args[i]);
#line 168
    i ++;
  }
#line 169
  n = 0U;
#line 170
  extension = strrchr((char const   *)(cgifilename), '.');
#line 170
  if ((unsigned int )extension != (unsigned int )((void *)0)) {
#line 171
    i = 0U;
#line 171
    while ((unsigned int )cgi_types[i][0] != (unsigned int )((void *)0)) {
#line 172
      if (0) {
#line 172
        __s1_len = strlen((char const   *)extension);
#line 172
        __s2_len = strlen((char const   *)cgi_types[i][0]);
#line 172
        if (! ((unsigned int )((void const   *)(extension + 1)) - (unsigned int )((void const   *)extension) == 1U)) {
          goto _L___0;
        } else {
#line 172
          if (__s1_len >= 4U) {
            _L___0: /* CIL Label */ 
#line 172
            if (! ((unsigned int )((void const   *)(cgi_types[i][0] + 1)) - (unsigned int )((void const   *)cgi_types[i][0]) == 1U)) {
#line 172
              tmp___10 = 1;
            } else {
#line 172
              if (__s2_len >= 4U) {
#line 172
                tmp___10 = 1;
              } else {
#line 172
                tmp___10 = 0;
              }
            }
          } else {
#line 172
            tmp___10 = 0;
          }
        }
#line 172
        if (tmp___10) {
#line 172
          tmp___6 = __builtin_strcmp((char const   *)extension, (char const   *)cgi_types[i][0]);
        } else {
#line 172
          tmp___9 = __builtin_strcmp((char const   *)extension, (char const   *)cgi_types[i][0]);
#line 172
          tmp___6 = tmp___9;
        }
      } else {
#line 172
        tmp___9 = __builtin_strcmp((char const   *)extension, (char const   *)cgi_types[i][0]);
#line 172
        tmp___6 = tmp___9;
      }
#line 172
      if (tmp___6 == 0) {
#line 173
        tmp___0 = calloc(255U, sizeof(char ));
#line 173
        args[n] = (char *)tmp___0;
#line 174
        snprintf((char * __restrict  )args[n], 254U, (char const   * __restrict  )"%s",
                 cgi_types[i][1]);
#line 175
        n ++;
#line 176
        break;
      }
#line 171
      i ++;
    }
  }
#line 180
  tmp___11 = calloc(255U, sizeof(char ));
#line 180
  args[n] = (char *)tmp___11;
#line 181
  snprintf((char * __restrict  )args[n], 254U, (char const   * __restrict  )"%s",
           cgifilename);
#line 234
  tmp___12 = pipe((int *)(pset1));
#line 234
  if (tmp___12 == -1) {
    goto _L___1;
  } else {
#line 234
    tmp___13 = pipe((int *)(pset2));
#line 234
    if (tmp___13 == -1) {
      _L___1: /* CIL Label */ 
#line 235
      i = 0U;
#line 235
      while (i < 10U) {
#line 235
        free((void *)args[i]);
#line 235
        i ++;
      }
#line 236
      i = 0U;
#line 236
      while (i < 50U) {
#line 236
        free((void *)env[i]);
#line 236
        i ++;
      }
#line 237
      close(pset1[0]);
#line 238
      close(pset1[1]);
#line 239
      logerror("pipe() error");
#line 240
      printerror(sid, 500, (char *)"Internal Server Error", (char *)"Unable to create pipe.");
#line 241
      return (-1);
    }
  }
#line 243
  local.in = pset1[0];
#line 243
  remote.out = pset1[1];
#line 244
  remote.in = pset2[0];
#line 244
  local.out = pset2[1];
#line 245
  logaccess(1, "Executing CGI [%s %s]", args[0], args[1]);
#line 246
  pid = fork();
#line 247
  if (pid < 0) {
#line 248
    logerror("fork() error");
#line 249
    return (-1);
  } else {
#line 250
    if (pid == 0) {
#line 251
      close(local.in);
#line 252
      close(local.out);
#line 253
      tmp___14 = fileno(stdin);
#line 253
      dup2(remote.in, tmp___14);
#line 254
      tmp___15 = fileno(stdout);
#line 254
      dup2(remote.out, tmp___15);
#line 259
      execve((char const   *)args[0], (char * const  *)(args), (char * const  *)(env));
#line 260
      logerror("execve() error [%s][%s]", args[0], args[1]);
#line 261
      exit(0);
    } else {
#line 263
      close(remote.in);
#line 264
      close(remote.out);
    }
  }
#line 267
  if (((conn + sid)->dat)->in_ContentLength > 0) {
#line 271
    write(local.out, (void const   *)(conn + sid)->PostData, (unsigned int )((conn + sid)->dat)->in_ContentLength);
  }
#line 274
  ((conn + sid)->dat)->out_headdone = (short)1;
#line 275
  ((conn + sid)->dat)->out_status = (short)200;
#line 276
  tmp___16 = strcasestr(((conn + sid)->dat)->in_Protocol, (char *)"HTTP/1.1");
#line 276
  if ((unsigned int )tmp___16 != (unsigned int )((void *)0)) {
#line 277
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.1");
  } else {
#line 279
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.0");
  }
#line 281
  snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
           (char const   * __restrict  )"Close");
#line 282
  prints("%s %d OK\r\n", ((conn + sid)->dat)->out_Protocol, ((conn + sid)->dat)->out_status);
#line 283
  prints("Connection: %s\r\n", ((conn + sid)->dat)->out_Connection);
#line 284
  flushbuffer(sid);
#line 285
  while (1) {
#line 286
    memset((void *)(szBuffer), 0, sizeof(szBuffer));
#line 290
    nOutRead = read(local.in, (void *)(szBuffer), 8191U);
#line 292
    if (nOutRead > 0) {
#line 293
      send((int )(conn + sid)->socket, (void const   *)(szBuffer), (unsigned int )nOutRead,
           0);
    }
#line 285
    if (! (nOutRead > 0)) {
#line 285
      break;
    }
  }
#line 296
  flushbuffer(sid);
#line 298
  i = 0U;
#line 298
  while (i < 10U) {
#line 298
    free((void *)args[i]);
#line 298
    i ++;
  }
#line 299
  i = 0U;
#line 299
  while (i < 50U) {
#line 299
    free((void *)env[i]);
#line 299
    i ++;
  }
#line 308
  close(local.in);
#line 309
  close(local.out);
#line 311
  ((conn + sid)->dat)->out_bodydone = (short)1;
#line 312
  flushbuffer(sid);
#line 313
  closeconnect(sid, 1);
#line 314
  return (0);
}
}
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
#line 1 "config.o"
#pragma merger(0,"/tmp/cil-0UGylSng.i","-Wall,-O2,-s")
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 216 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 251
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 339
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
#line 336
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
#line 404
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 404
  return ((int )tmp);
}
}
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 209 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 399
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 450
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 450 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
#line 453
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
#line 453
  return (tmp);
}
}
#line 457 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 471
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 241 "main.h"
int config_read(void) ;
#line 21 "config.c"
int config_read(void) 
{ FILE *fp ;
  char line[512] ;
  struct stat sb ;
  char *pVar ;
  char *pVal ;
  short founddir ;
  char slash ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___41 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___61 ;
  int tmp___64 ;
  int tmp___65 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___81 ;
  int tmp___84 ;
  int tmp___85 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___91 ;
  int tmp___94 ;
  int tmp___95 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___101 ;
  int tmp___104 ;
  int tmp___105 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___111 ;
  int tmp___114 ;
  int tmp___115 ;
  unsigned short const   **tmp___116 ;
  char *tmp___117 ;

  {
#line 23
  fp = (FILE *)((void *)0);
#line 28
  founddir = (short)0;
#line 32
  slash = (char )'/';
#line 36
  memset((void *)((char *)(& config)), 0, sizeof(config));
#line 37
  pVal = (char *)(program_name);
#line 38
  if ((int )*pVal == 34) {
#line 38
    pVal ++;
  }
#line 42
  tmp = getcwd(config.server_base_dir, sizeof(config.server_base_dir) - 1U);
#line 42
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
#line 42
    return (-1);
  }
#line 43
  strcat((char * __restrict  )(config.server_base_dir), (char const   * __restrict  )"/");
#line 45
  tmp___1 = strrchr((char const   *)(config.server_base_dir), (int )slash);
#line 45
  if ((unsigned int )tmp___1 != (unsigned int )((void *)0)) {
#line 46
    pVal = strrchr((char const   *)(config.server_base_dir), (int )slash);
#line 47
    *pVal = (char )'\000';
#line 48
    chdir((char const   *)(config.server_base_dir));
#line 49
    tmp___0 = strrchr((char const   *)(config.server_base_dir), (int )slash);
#line 49
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 50
      pVal = strrchr((char const   *)(config.server_base_dir), (int )slash);
#line 51
      *pVal = (char )'\000';
#line 52
      founddir = (short)1;
    }
  }
#line 55
  if (! founddir) {
#line 56
    snprintf((char * __restrict  )(config.server_base_dir), sizeof(config.server_base_dir) - 1U,
             (char const   * __restrict  )"%s", "/usr/local/httpd");
  }
#line 58
  snprintf((char * __restrict  )(config.server_bin_dir), sizeof(config.server_bin_dir) - 1U,
           (char const   * __restrict  )"%s/bin", config.server_base_dir);
#line 59
  snprintf((char * __restrict  )(config.server_cgi_dir), sizeof(config.server_cgi_dir) - 1U,
           (char const   * __restrict  )"%s/cgi-bin", config.server_base_dir);
#line 60
  snprintf((char * __restrict  )(config.server_etc_dir), sizeof(config.server_etc_dir) - 1U,
           (char const   * __restrict  )"%s/etc", config.server_base_dir);
#line 61
  snprintf((char * __restrict  )(config.server_htdocs_dir), sizeof(config.server_htdocs_dir) - 1U,
           (char const   * __restrict  )"%s/htdocs", config.server_base_dir);
#line 62
  fixslashes(config.server_base_dir);
#line 63
  fixslashes(config.server_bin_dir);
#line 64
  fixslashes(config.server_cgi_dir);
#line 65
  fixslashes(config.server_etc_dir);
#line 66
  fixslashes(config.server_htdocs_dir);
#line 67
  config.server_loglevel = (short)1;
#line 68
  __builtin_strncpy(config.server_hostname, "any", sizeof(config.server_hostname) - 1U);
#line 69
  config.server_port = (short)80;
#line 70
  config.server_maxconn = (short)50;
#line 71
  config.server_maxidle = (short)120;
#line 74
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 75
    snprintf((char * __restrict  )(config.config_filename), sizeof(config.config_filename) - 1U,
             (char const   * __restrict  )"httpd.cfg");
#line 76
    fp = fopen((char const   * __restrict  )(config.config_filename), (char const   * __restrict  )"r");
  }
#line 78
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 79
    snprintf((char * __restrict  )(config.config_filename), sizeof(config.config_filename) - 1U,
             (char const   * __restrict  )"../etc/httpd.cfg");
#line 80
    fixslashes(config.config_filename);
#line 81
    fp = fopen((char const   * __restrict  )(config.config_filename), (char const   * __restrict  )"r");
  }
#line 83
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 84
    snprintf((char * __restrict  )(config.config_filename), sizeof(config.config_filename) - 1U,
             (char const   * __restrict  )"%s/httpd.cfg", config.server_etc_dir);
#line 85
    fixslashes(config.config_filename);
#line 86
    fp = fopen((char const   * __restrict  )(config.config_filename), (char const   * __restrict  )"r");
  }
#line 89
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 90
    tmp___2 = stat((char const   * __restrict  )(config.server_etc_dir), (struct stat * __restrict  )(& sb));
#line 90
    if (tmp___2 != 0) {
#line 91
      logerror("ERROR: Directory \'%s\' does not exist.  Failed to create configuration file.",
               config.server_etc_dir);
#line 92
      return (-1);
    }
#line 94
    printf((char const   * __restrict  )"Creating configuration file...");
#line 95
    logaccess(1, "Creating configuration file...");
#line 96
    snprintf((char * __restrict  )(config.config_filename), sizeof(config.config_filename) - 1U,
             (char const   * __restrict  )"%s/httpd.cfg", config.server_etc_dir);
#line 97
    fixslashes(config.config_filename);
#line 98
    fp = fopen((char const   * __restrict  )(config.config_filename), (char const   * __restrict  )"w");
#line 99
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 100
      return (-1);
    }
#line 102
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# This file contains system settings for Null httpd.\n\n");
#line 103
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_BASE_DIR = \"%s\"\n",
            config.server_base_dir);
#line 104
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_BIN_DIR  = \"%s\"\n",
            config.server_bin_dir);
#line 105
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_CGI_DIR  = \"%s\"\n",
            config.server_cgi_dir);
#line 106
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_ETC_DIR  = \"%s\"\n",
            config.server_etc_dir);
#line 107
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_HTTP_DIR = \"%s\"\n",
            config.server_htdocs_dir);
#line 108
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_LOGLEVEL = \"%d\"\n",
            config.server_loglevel);
#line 109
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_HOSTNAME = \"%s\"\n",
            config.server_hostname);
#line 110
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_PORT     = \"%d\"\n",
            config.server_port);
#line 111
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_MAXCONN  = \"%d\"\n",
            config.server_maxconn);
#line 112
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"SERVER_MAXIDLE  = \"%d\"\n",
            config.server_maxidle);
#line 113
    fclose(fp);
#line 114
    printf((char const   * __restrict  )"done.\n");
#line 115
    return (0);
  }
#line 118
  while (1) {
#line 118
    tmp___117 = fgets((char * __restrict  )(line), (int )(sizeof(line) - 1U), (FILE * __restrict  )fp);
#line 118
    if (! ((unsigned int )tmp___117 != (unsigned int )((void *)0))) {
#line 118
      break;
    }
#line 119
    while (1) {
#line 119
      tmp___4 = strlen((char const   *)(line));
#line 119
      if (! ((int )line[tmp___4 - 1U] == 10)) {
#line 119
        tmp___5 = strlen((char const   *)(line));
#line 119
        if (! ((int )line[tmp___5 - 1U] == 13)) {
#line 119
          break;
        }
      }
#line 120
      tmp___3 = strlen((char const   *)(line));
#line 120
      line[tmp___3 - 1U] = (char )'\000';
    }
#line 122
    tmp___116 = __ctype_b_loc();
#line 122
    if ((int const   )*(*tmp___116 + (int )line[0]) & 1024) {
#line 123
      pVar = line;
#line 124
      pVal = line;
#line 125
      while (1) {
#line 125
        if ((int )*pVal != 61) {
#line 125
          if (! ((unsigned int )((char *)(& pVal) + 1) != (unsigned int )((char *)0))) {
#line 125
            break;
          }
        } else {
#line 125
          break;
        }
#line 125
        pVal ++;
      }
#line 126
      *pVal = (char )'\000';
#line 127
      pVal ++;
#line 128
      while ((int )*pVar == 32) {
#line 128
        pVar ++;
      }
#line 129
      while (1) {
#line 129
        tmp___7 = strlen((char const   *)pVar);
#line 129
        if (! ((int )*(pVar + (tmp___7 - 1U)) == 32)) {
#line 129
          break;
        }
#line 129
        tmp___6 = strlen((char const   *)pVar);
#line 129
        *(pVar + (tmp___6 - 1U)) = (char )'\000';
      }
#line 130
      while ((int )*pVal == 32) {
#line 130
        pVal ++;
      }
#line 131
      while (1) {
#line 131
        tmp___9 = strlen((char const   *)pVal);
#line 131
        if (! ((int )*(pVal + (tmp___9 - 1U)) == 32)) {
#line 131
          break;
        }
#line 131
        tmp___8 = strlen((char const   *)pVal);
#line 131
        *(pVal + (tmp___8 - 1U)) = (char )'\000';
      }
#line 132
      while ((int )*pVal == 34) {
#line 132
        pVal ++;
      }
#line 133
      while (1) {
#line 133
        tmp___11 = strlen((char const   *)pVal);
#line 133
        if (! ((int )*(pVal + (tmp___11 - 1U)) == 34)) {
#line 133
          break;
        }
#line 133
        tmp___10 = strlen((char const   *)pVal);
#line 133
        *(pVal + (tmp___10 - 1U)) = (char )'\000';
      }
#line 134
      if (0) {
#line 134
        __s1_len___8 = strlen((char const   *)pVar);
#line 134
        __s2_len___8 = strlen("SERVER_BASE_DIR");
#line 134
        if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
          goto _L___18;
        } else {
#line 134
          if (__s1_len___8 >= 4U) {
            _L___18: /* CIL Label */ 
#line 134
            if (! ((unsigned int )((void const   *)("SERVER_BASE_DIR" + 1)) - (unsigned int )((void const   *)"SERVER_BASE_DIR") == 1U)) {
#line 134
              tmp___115 = 1;
            } else {
#line 134
              if (__s2_len___8 >= 4U) {
#line 134
                tmp___115 = 1;
              } else {
#line 134
                tmp___115 = 0;
              }
            }
          } else {
#line 134
            tmp___115 = 0;
          }
        }
#line 134
        if (tmp___115) {
#line 134
          tmp___111 = __builtin_strcmp((char const   *)pVar, "SERVER_BASE_DIR");
        } else {
#line 134
          tmp___114 = __builtin_strcmp((char const   *)pVar, "SERVER_BASE_DIR");
#line 134
          tmp___111 = tmp___114;
        }
      } else {
#line 134
        tmp___114 = __builtin_strcmp((char const   *)pVar, "SERVER_BASE_DIR");
#line 134
        tmp___111 = tmp___114;
      }
#line 134
      if (tmp___111 == 0) {
#line 135
        __builtin_strncpy(config.server_base_dir, (char const   *)pVal, sizeof(config.server_base_dir) - 1U);
      } else {
#line 136
        if (0) {
#line 136
          __s1_len___7 = strlen((char const   *)pVar);
#line 136
          __s2_len___7 = strlen("SERVER_BIN_DIR");
#line 136
          if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
            goto _L___16;
          } else {
#line 136
            if (__s1_len___7 >= 4U) {
              _L___16: /* CIL Label */ 
#line 136
              if (! ((unsigned int )((void const   *)("SERVER_BIN_DIR" + 1)) - (unsigned int )((void const   *)"SERVER_BIN_DIR") == 1U)) {
#line 136
                tmp___105 = 1;
              } else {
#line 136
                if (__s2_len___7 >= 4U) {
#line 136
                  tmp___105 = 1;
                } else {
#line 136
                  tmp___105 = 0;
                }
              }
            } else {
#line 136
              tmp___105 = 0;
            }
          }
#line 136
          if (tmp___105) {
#line 136
            tmp___101 = __builtin_strcmp((char const   *)pVar, "SERVER_BIN_DIR");
          } else {
#line 136
            tmp___104 = __builtin_strcmp((char const   *)pVar, "SERVER_BIN_DIR");
#line 136
            tmp___101 = tmp___104;
          }
        } else {
#line 136
          tmp___104 = __builtin_strcmp((char const   *)pVar, "SERVER_BIN_DIR");
#line 136
          tmp___101 = tmp___104;
        }
#line 136
        if (tmp___101 == 0) {
#line 137
          __builtin_strncpy(config.server_bin_dir, (char const   *)pVal, sizeof(config.server_bin_dir) - 1U);
        } else {
#line 138
          if (0) {
#line 138
            __s1_len___6 = strlen((char const   *)pVar);
#line 138
            __s2_len___6 = strlen("SERVER_CGI_DIR");
#line 138
            if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
              goto _L___14;
            } else {
#line 138
              if (__s1_len___6 >= 4U) {
                _L___14: /* CIL Label */ 
#line 138
                if (! ((unsigned int )((void const   *)("SERVER_CGI_DIR" + 1)) - (unsigned int )((void const   *)"SERVER_CGI_DIR") == 1U)) {
#line 138
                  tmp___95 = 1;
                } else {
#line 138
                  if (__s2_len___6 >= 4U) {
#line 138
                    tmp___95 = 1;
                  } else {
#line 138
                    tmp___95 = 0;
                  }
                }
              } else {
#line 138
                tmp___95 = 0;
              }
            }
#line 138
            if (tmp___95) {
#line 138
              tmp___91 = __builtin_strcmp((char const   *)pVar, "SERVER_CGI_DIR");
            } else {
#line 138
              tmp___94 = __builtin_strcmp((char const   *)pVar, "SERVER_CGI_DIR");
#line 138
              tmp___91 = tmp___94;
            }
          } else {
#line 138
            tmp___94 = __builtin_strcmp((char const   *)pVar, "SERVER_CGI_DIR");
#line 138
            tmp___91 = tmp___94;
          }
#line 138
          if (tmp___91 == 0) {
#line 139
            __builtin_strncpy(config.server_cgi_dir, (char const   *)pVal, sizeof(config.server_cgi_dir) - 1U);
          } else {
#line 140
            if (0) {
#line 140
              __s1_len___5 = strlen((char const   *)pVar);
#line 140
              __s2_len___5 = strlen("SERVER_ETC_DIR");
#line 140
              if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                goto _L___12;
              } else {
#line 140
                if (__s1_len___5 >= 4U) {
                  _L___12: /* CIL Label */ 
#line 140
                  if (! ((unsigned int )((void const   *)("SERVER_ETC_DIR" + 1)) - (unsigned int )((void const   *)"SERVER_ETC_DIR") == 1U)) {
#line 140
                    tmp___85 = 1;
                  } else {
#line 140
                    if (__s2_len___5 >= 4U) {
#line 140
                      tmp___85 = 1;
                    } else {
#line 140
                      tmp___85 = 0;
                    }
                  }
                } else {
#line 140
                  tmp___85 = 0;
                }
              }
#line 140
              if (tmp___85) {
#line 140
                tmp___81 = __builtin_strcmp((char const   *)pVar, "SERVER_ETC_DIR");
              } else {
#line 140
                tmp___84 = __builtin_strcmp((char const   *)pVar, "SERVER_ETC_DIR");
#line 140
                tmp___81 = tmp___84;
              }
            } else {
#line 140
              tmp___84 = __builtin_strcmp((char const   *)pVar, "SERVER_ETC_DIR");
#line 140
              tmp___81 = tmp___84;
            }
#line 140
            if (tmp___81 == 0) {
#line 141
              __builtin_strncpy(config.server_etc_dir, (char const   *)pVal, sizeof(config.server_etc_dir) - 1U);
            } else {
#line 142
              if (0) {
#line 142
                __s1_len___4 = strlen((char const   *)pVar);
#line 142
                __s2_len___4 = strlen("SERVER_HTTP_DIR");
#line 142
                if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                  goto _L___10;
                } else {
#line 142
                  if (__s1_len___4 >= 4U) {
                    _L___10: /* CIL Label */ 
#line 142
                    if (! ((unsigned int )((void const   *)("SERVER_HTTP_DIR" + 1)) - (unsigned int )((void const   *)"SERVER_HTTP_DIR") == 1U)) {
#line 142
                      tmp___75 = 1;
                    } else {
#line 142
                      if (__s2_len___4 >= 4U) {
#line 142
                        tmp___75 = 1;
                      } else {
#line 142
                        tmp___75 = 0;
                      }
                    }
                  } else {
#line 142
                    tmp___75 = 0;
                  }
                }
#line 142
                if (tmp___75) {
#line 142
                  tmp___71 = __builtin_strcmp((char const   *)pVar, "SERVER_HTTP_DIR");
                } else {
#line 142
                  tmp___74 = __builtin_strcmp((char const   *)pVar, "SERVER_HTTP_DIR");
#line 142
                  tmp___71 = tmp___74;
                }
              } else {
#line 142
                tmp___74 = __builtin_strcmp((char const   *)pVar, "SERVER_HTTP_DIR");
#line 142
                tmp___71 = tmp___74;
              }
#line 142
              if (tmp___71 == 0) {
#line 143
                __builtin_strncpy(config.server_htdocs_dir, (char const   *)pVal,
                                  sizeof(config.server_htdocs_dir) - 1U);
              } else {
#line 144
                if (0) {
#line 144
                  __s1_len___3 = strlen((char const   *)pVar);
#line 144
                  __s2_len___3 = strlen("SERVER_LOGLEVEL");
#line 144
                  if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                    goto _L___8;
                  } else {
#line 144
                    if (__s1_len___3 >= 4U) {
                      _L___8: /* CIL Label */ 
#line 144
                      if (! ((unsigned int )((void const   *)("SERVER_LOGLEVEL" + 1)) - (unsigned int )((void const   *)"SERVER_LOGLEVEL") == 1U)) {
#line 144
                        tmp___65 = 1;
                      } else {
#line 144
                        if (__s2_len___3 >= 4U) {
#line 144
                          tmp___65 = 1;
                        } else {
#line 144
                          tmp___65 = 0;
                        }
                      }
                    } else {
#line 144
                      tmp___65 = 0;
                    }
                  }
#line 144
                  if (tmp___65) {
#line 144
                    tmp___61 = __builtin_strcmp((char const   *)pVar, "SERVER_LOGLEVEL");
                  } else {
#line 144
                    tmp___64 = __builtin_strcmp((char const   *)pVar, "SERVER_LOGLEVEL");
#line 144
                    tmp___61 = tmp___64;
                  }
                } else {
#line 144
                  tmp___64 = __builtin_strcmp((char const   *)pVar, "SERVER_LOGLEVEL");
#line 144
                  tmp___61 = tmp___64;
                }
#line 144
                if (tmp___61 == 0) {
#line 145
                  tmp___12 = atoi((char const   *)pVal);
#line 145
                  config.server_loglevel = (short )tmp___12;
                } else {
#line 146
                  if (0) {
#line 146
                    __s1_len___2 = strlen((char const   *)pVar);
#line 146
                    __s2_len___2 = strlen("SERVER_HOSTNAME");
#line 146
                    if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                      goto _L___6;
                    } else {
#line 146
                      if (__s1_len___2 >= 4U) {
                        _L___6: /* CIL Label */ 
#line 146
                        if (! ((unsigned int )((void const   *)("SERVER_HOSTNAME" + 1)) - (unsigned int )((void const   *)"SERVER_HOSTNAME") == 1U)) {
#line 146
                          tmp___55 = 1;
                        } else {
#line 146
                          if (__s2_len___2 >= 4U) {
#line 146
                            tmp___55 = 1;
                          } else {
#line 146
                            tmp___55 = 0;
                          }
                        }
                      } else {
#line 146
                        tmp___55 = 0;
                      }
                    }
#line 146
                    if (tmp___55) {
#line 146
                      tmp___51 = __builtin_strcmp((char const   *)pVar, "SERVER_HOSTNAME");
                    } else {
#line 146
                      tmp___54 = __builtin_strcmp((char const   *)pVar, "SERVER_HOSTNAME");
#line 146
                      tmp___51 = tmp___54;
                    }
                  } else {
#line 146
                    tmp___54 = __builtin_strcmp((char const   *)pVar, "SERVER_HOSTNAME");
#line 146
                    tmp___51 = tmp___54;
                  }
#line 146
                  if (tmp___51 == 0) {
#line 147
                    __builtin_strncpy(config.server_hostname, (char const   *)pVal,
                                      sizeof(config.server_hostname) - 1U);
                  } else {
#line 148
                    if (0) {
#line 148
                      __s1_len___1 = strlen((char const   *)pVar);
#line 148
                      __s2_len___1 = strlen("SERVER_MAXCONN");
#line 148
                      if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                        goto _L___4;
                      } else {
#line 148
                        if (__s1_len___1 >= 4U) {
                          _L___4: /* CIL Label */ 
#line 148
                          if (! ((unsigned int )((void const   *)("SERVER_MAXCONN" + 1)) - (unsigned int )((void const   *)"SERVER_MAXCONN") == 1U)) {
#line 148
                            tmp___45 = 1;
                          } else {
#line 148
                            if (__s2_len___1 >= 4U) {
#line 148
                              tmp___45 = 1;
                            } else {
#line 148
                              tmp___45 = 0;
                            }
                          }
                        } else {
#line 148
                          tmp___45 = 0;
                        }
                      }
#line 148
                      if (tmp___45) {
#line 148
                        tmp___41 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXCONN");
                      } else {
#line 148
                        tmp___44 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXCONN");
#line 148
                        tmp___41 = tmp___44;
                      }
                    } else {
#line 148
                      tmp___44 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXCONN");
#line 148
                      tmp___41 = tmp___44;
                    }
#line 148
                    if (tmp___41 == 0) {
#line 149
                      tmp___13 = atoi((char const   *)pVal);
#line 149
                      config.server_maxconn = (short )tmp___13;
                    } else {
#line 150
                      if (0) {
#line 150
                        __s1_len___0 = strlen((char const   *)pVar);
#line 150
                        __s2_len___0 = strlen("SERVER_PORT");
#line 150
                        if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                          goto _L___2;
                        } else {
#line 150
                          if (__s1_len___0 >= 4U) {
                            _L___2: /* CIL Label */ 
#line 150
                            if (! ((unsigned int )((void const   *)("SERVER_PORT" + 1)) - (unsigned int )((void const   *)"SERVER_PORT") == 1U)) {
#line 150
                              tmp___35 = 1;
                            } else {
#line 150
                              if (__s2_len___0 >= 4U) {
#line 150
                                tmp___35 = 1;
                              } else {
#line 150
                                tmp___35 = 0;
                              }
                            }
                          } else {
#line 150
                            tmp___35 = 0;
                          }
                        }
#line 150
                        if (tmp___35) {
#line 150
                          tmp___31 = __builtin_strcmp((char const   *)pVar, "SERVER_PORT");
                        } else {
#line 150
                          tmp___34 = __builtin_strcmp((char const   *)pVar, "SERVER_PORT");
#line 150
                          tmp___31 = tmp___34;
                        }
                      } else {
#line 150
                        tmp___34 = __builtin_strcmp((char const   *)pVar, "SERVER_PORT");
#line 150
                        tmp___31 = tmp___34;
                      }
#line 150
                      if (tmp___31 == 0) {
#line 151
                        tmp___14 = atoi((char const   *)pVal);
#line 151
                        config.server_port = (short )tmp___14;
                      } else {
#line 152
                        if (0) {
#line 152
                          __s1_len = strlen((char const   *)pVar);
#line 152
                          __s2_len = strlen("SERVER_MAXIDLE");
#line 152
                          if (! ((unsigned int )((void const   *)(pVar + 1)) - (unsigned int )((void const   *)pVar) == 1U)) {
                            goto _L___0;
                          } else {
#line 152
                            if (__s1_len >= 4U) {
                              _L___0: /* CIL Label */ 
#line 152
                              if (! ((unsigned int )((void const   *)("SERVER_MAXIDLE" + 1)) - (unsigned int )((void const   *)"SERVER_MAXIDLE") == 1U)) {
#line 152
                                tmp___25 = 1;
                              } else {
#line 152
                                if (__s2_len >= 4U) {
#line 152
                                  tmp___25 = 1;
                                } else {
#line 152
                                  tmp___25 = 0;
                                }
                              }
                            } else {
#line 152
                              tmp___25 = 0;
                            }
                          }
#line 152
                          if (tmp___25) {
#line 152
                            tmp___21 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXIDLE");
                          } else {
#line 152
                            tmp___24 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXIDLE");
#line 152
                            tmp___21 = tmp___24;
                          }
                        } else {
#line 152
                          tmp___24 = __builtin_strcmp((char const   *)pVar, "SERVER_MAXIDLE");
#line 152
                          tmp___21 = tmp___24;
                        }
#line 152
                        if (tmp___21 == 0) {
#line 153
                          tmp___15 = atoi((char const   *)pVal);
#line 153
                          config.server_maxidle = (short )tmp___15;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 155
      *pVal = (char )'\000';
#line 156
      *pVar = (char )'\000';
    }
  }
#line 159
  fclose(fp);
#line 160
  if ((int )config.server_maxconn < 1) {
#line 160
    config.server_maxconn = (short)1;
  }
#line 161
  if ((int )config.server_maxconn > 1000) {
#line 161
    config.server_maxconn = (short)1000;
  }
#line 162
  return (0);
}
}
#line 1 "files.o"
#pragma merger(0,"/tmp/cil-D1XTBXFk.i","-Wall,-O2,-s")
#line 451 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 194 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 200
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 236
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 209 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 243 "main.h"
int dirlist(int sid ) ;
#line 244
int sendfile(int sid , unsigned char *file ) ;
#line 246
void decodeurl(unsigned char *pEncoded ) ;
#line 253
int printhex(char const   *format  , ...) ;
#line 256
char *get_mime_type(char *name ) ;
#line 259
void send_header(int sid , int cacheable , int status , char *title , char *extra_header ,
                 char *mime_type , int length , time_t mod ) ;
#line 260
void send_fileheader(int sid , int cacheable , int status , char *title , char *extra_header ,
                     char *mime_type , int length , time_t mod ) ;
#line 21 "files.c"
int sendfile(int sid , unsigned char *file ) 
{ struct stat sb ;
  FILE *fp ;
  char fileblock[2048] ;
  int blocksize ;
  int ich ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 29
  decodeurl(file);
#line 30
  fixslashes((char *)file);
#line 31
  tmp = strstr((char const   *)file, "..");
#line 31
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 31
    return (-1);
  }
#line 32
  tmp___0 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& sb));
#line 32
  if (tmp___0 != 0) {
#line 32
    return (-1);
  }
#line 33
  if (sb.st_mode & 16384U) {
#line 33
    return (-1);
  }
#line 45
  ((conn + sid)->dat)->out_ContentLength = (int )sb.st_size;
#line 46
  tmp___1 = get_mime_type((char *)file);
#line 46
  send_fileheader(sid, 1, 200, (char *)"OK", (char *)"1", tmp___1, (int )sb.st_size,
                  sb.st_mtim.tv_sec);
#line 47
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 48
  if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 48
    return (-1);
  }
#line 49
  blocksize = 0;
#line 50
  while (1) {
#line 50
    ich = _IO_getc(fp);
#line 50
    if (! (ich != -1)) {
#line 50
      break;
    }
#line 51
    if ((unsigned int )blocksize > sizeof(fileblock) - 1U) {
#line 52
      send((int )(conn + sid)->socket, (void const   *)(fileblock), (unsigned int )blocksize,
           0);
#line 53
      blocksize = 0;
    }
#line 55
    fileblock[blocksize] = (char )ich;
#line 56
    blocksize ++;
  }
#line 58
  if (blocksize) {
#line 59
    send((int )(conn + sid)->socket, (void const   *)(fileblock), (unsigned int )blocksize,
         0);
#line 60
    blocksize = 0;
  }
#line 62
  fclose(fp);
#line 63
  ((conn + sid)->dat)->out_headdone = (short)1;
#line 64
  ((conn + sid)->dat)->out_bodydone = (short)1;
#line 65
  ((conn + sid)->dat)->out_flushed = (short)1;
#line 66
  ((conn + sid)->dat)->out_ReplyData[0] = (char )'\000';
#line 67
  flushbuffer(sid);
#line 68
  return (0);
}
}
#line 71 "files.c"
int dirlist(int sid ) 
{ struct dirent *dentry ;
  DIR *handle ;
  char file[1024] ;
  char index___0[1024] ;
  char showfile[1024] ;
  struct stat sb ;
  char *directory ;
  char timebuf[100] ;
  time_t t ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  struct tm *tmp___32 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  struct tm *tmp___73 ;

  {
#line 87
  if (0) {
#line 87
    if (0) {
#line 87
      __s1_len___0 = strlen((char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 87
      __s2_len___0 = strlen("/");
#line 87
      if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI)) == 1U)) {
        goto _L___2;
      } else {
#line 87
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 87
          if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 87
            tmp___22 = 1;
          } else {
#line 87
            if (__s2_len___0 >= 4U) {
#line 87
              tmp___22 = 1;
            } else {
#line 87
              tmp___22 = 0;
            }
          }
        } else {
#line 87
          tmp___22 = 0;
        }
      }
#line 87
      if (tmp___22) {
#line 87
        tmp___18 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/");
      } else {
#line 87
        tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/");
#line 87
        tmp___18 = tmp___21;
      }
    } else {
#line 87
      tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                  "/");
#line 87
      tmp___18 = tmp___21;
    }
#line 87
    tmp___12 = tmp___18;
  } else {
#line 87
    tmp___12 = strncmp((char const   *)(((conn + sid)->dat)->in_RequestURI), "/",
                       1U);
  }
#line 87
  if (tmp___12 != 0) {
#line 88
    return (-1);
  }
#line 90
  directory = ((conn + sid)->dat)->in_RequestURI + 1;
#line 91
  snprintf((char * __restrict  )(file), sizeof(file) - 1U, (char const   * __restrict  )"%s/%s",
           config.server_htdocs_dir, directory);
#line 92
  decodeurl((unsigned char *)(file));
#line 93
  fixslashes(file);
#line 94
  while (1) {
#line 94
    tmp___26 = strlen((char const   *)(file));
#line 94
    if (! ((int )file[tmp___26 - 1U] == 92)) {
#line 94
      tmp___27 = strlen((char const   *)(file));
#line 94
      if (! ((int )file[tmp___27 - 1U] == 47)) {
#line 94
        break;
      }
    }
#line 94
    tmp___25 = strlen((char const   *)(file));
#line 94
    file[tmp___25 - 1U] = (char )'\000';
  }
#line 95
  tmp___28 = strstr((char const   *)(file), "..");
#line 95
  if ((unsigned int )tmp___28 != (unsigned int )((void *)0)) {
#line 95
    return (-1);
  }
#line 96
  snprintf((char * __restrict  )(index___0), sizeof(index___0) - 1U, (char const   * __restrict  )"%s/%s/index.html",
           config.server_htdocs_dir, directory);
#line 97
  decodeurl((unsigned char *)(index___0));
#line 98
  fixslashes(index___0);
#line 99
  tmp___29 = stat((char const   * __restrict  )(index___0), (struct stat * __restrict  )(& sb));
#line 99
  if (tmp___29 == 0) {
#line 100
    sendfile(sid, (unsigned char *)(index___0));
#line 101
    return (0);
  }
#line 103
  tmp___30 = stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& sb));
#line 103
  if (tmp___30 != 0) {
#line 103
    return (-1);
  }
#line 104
  if (! (sb.st_mode & 16384U)) {
#line 104
    tmp___31 = sendfile(sid, (unsigned char *)(file));
#line 104
    return (tmp___31);
  }
#line 105
  t = time((time_t *)0);
#line 106
  tmp___32 = localtime((time_t const   *)(& t));
#line 106
  strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%b %d %H:%M:%S",
           (struct tm  const  * __restrict  )tmp___32);
#line 107
  send_header(sid, 0, 200, (char *)"OK", (char *)"1", (char *)"text/html", -1, -1L);
#line 108
  prints("<CENTER>\n<TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0 WIDTH=90%%>\n");
#line 109
  prints("<TR BGCOLOR=#00A5D0><TH COLSPAN=4>Index of %s</TH></TR>\n", ((conn + sid)->dat)->in_RequestURI);
#line 110
  prints("<TR BGCOLOR=#E0E0E0>");
#line 111
  prints("<TH width=20%%>Filename</TH><TH width=10%%>Size</TH>");
#line 112
  prints("<TH width=10%%>Date</TH><TH width=60%%>Description</TH></TR>\n");
#line 113
  handle = opendir((char const   *)(file));
#line 114
  while (1) {
#line 114
    dentry = readdir(handle);
#line 114
    if (! ((unsigned int )dentry != (unsigned int )((void *)0))) {
#line 114
      break;
    }
#line 115
    snprintf((char * __restrict  )(file), sizeof(file) - 1U, (char const   * __restrict  )"%s/%s%s",
             config.server_htdocs_dir, directory, dentry->d_name);
#line 116
    fixslashes(file);
#line 117
    stat((char const   * __restrict  )(file), (struct stat * __restrict  )(& sb));
#line 118
    if (0) {
#line 118
      __s1_len___1 = strlen(".");
#line 118
      __s2_len___1 = strlen((char const   *)(dentry->d_name));
#line 118
      if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
        goto _L___4;
      } else {
#line 118
        if (__s1_len___1 >= 4U) {
          _L___4: /* CIL Label */ 
#line 118
          if (! ((unsigned int )((void const   *)(dentry->d_name + 1)) - (unsigned int )((void const   *)(dentry->d_name)) == 1U)) {
#line 118
            tmp___42 = 1;
          } else {
#line 118
            if (__s2_len___1 >= 4U) {
#line 118
              tmp___42 = 1;
            } else {
#line 118
              tmp___42 = 0;
            }
          }
        } else {
#line 118
          tmp___42 = 0;
        }
      }
#line 118
      if (tmp___42) {
#line 118
        tmp___38 = __builtin_strcmp(".", (char const   *)(dentry->d_name));
      } else {
#line 118
        tmp___41 = __builtin_strcmp(".", (char const   *)(dentry->d_name));
#line 118
        tmp___38 = tmp___41;
      }
    } else {
#line 118
      tmp___41 = __builtin_strcmp(".", (char const   *)(dentry->d_name));
#line 118
      tmp___38 = tmp___41;
    }
#line 118
    if (tmp___38 == 0) {
#line 118
      continue;
    }
#line 119
    if (0) {
#line 119
      __s1_len___2 = strlen("..");
#line 119
      __s2_len___2 = strlen((char const   *)(dentry->d_name));
#line 119
      if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
        goto _L___6;
      } else {
#line 119
        if (__s1_len___2 >= 4U) {
          _L___6: /* CIL Label */ 
#line 119
          if (! ((unsigned int )((void const   *)(dentry->d_name + 1)) - (unsigned int )((void const   *)(dentry->d_name)) == 1U)) {
#line 119
            tmp___52 = 1;
          } else {
#line 119
            if (__s2_len___2 >= 4U) {
#line 119
              tmp___52 = 1;
            } else {
#line 119
              tmp___52 = 0;
            }
          }
        } else {
#line 119
          tmp___52 = 0;
        }
      }
#line 119
      if (tmp___52) {
#line 119
        tmp___48 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
      } else {
#line 119
        tmp___51 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
#line 119
        tmp___48 = tmp___51;
      }
    } else {
#line 119
      tmp___51 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
#line 119
      tmp___48 = tmp___51;
    }
#line 119
    if (tmp___48 == 0) {
#line 119
      if (0) {
#line 119
        __s1_len___3 = strlen("/files/");
#line 119
        __s2_len___3 = strlen((char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 119
        if (! ((unsigned int )((void const   *)("/files/" + 1)) - (unsigned int )((void const   *)"/files/") == 1U)) {
          goto _L___8;
        } else {
#line 119
          if (__s1_len___3 >= 4U) {
            _L___8: /* CIL Label */ 
#line 119
            if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI)) == 1U)) {
#line 119
              tmp___62 = 1;
            } else {
#line 119
              if (__s2_len___3 >= 4U) {
#line 119
                tmp___62 = 1;
              } else {
#line 119
                tmp___62 = 0;
              }
            }
          } else {
#line 119
            tmp___62 = 0;
          }
        }
#line 119
        if (tmp___62) {
#line 119
          tmp___58 = __builtin_strcmp("/files/", (char const   *)(((conn + sid)->dat)->in_RequestURI));
        } else {
#line 119
          tmp___61 = __builtin_strcmp("/files/", (char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 119
          tmp___58 = tmp___61;
        }
      } else {
#line 119
        tmp___61 = __builtin_strcmp("/files/", (char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 119
        tmp___58 = tmp___61;
      }
#line 119
      if (tmp___58 == 0) {
#line 119
        continue;
      }
    }
#line 120
    if (0) {
#line 120
      __s1_len___4 = strlen("..");
#line 120
      __s2_len___4 = strlen((char const   *)(dentry->d_name));
#line 120
      if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
        goto _L___10;
      } else {
#line 120
        if (__s1_len___4 >= 4U) {
          _L___10: /* CIL Label */ 
#line 120
          if (! ((unsigned int )((void const   *)(dentry->d_name + 1)) - (unsigned int )((void const   *)(dentry->d_name)) == 1U)) {
#line 120
            tmp___72 = 1;
          } else {
#line 120
            if (__s2_len___4 >= 4U) {
#line 120
              tmp___72 = 1;
            } else {
#line 120
              tmp___72 = 0;
            }
          }
        } else {
#line 120
          tmp___72 = 0;
        }
      }
#line 120
      if (tmp___72) {
#line 120
        tmp___68 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
      } else {
#line 120
        tmp___71 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
#line 120
        tmp___68 = tmp___71;
      }
    } else {
#line 120
      tmp___71 = __builtin_strcmp("..", (char const   *)(dentry->d_name));
#line 120
      tmp___68 = tmp___71;
    }
#line 120
    if (tmp___68 == 0) {
#line 121
      prints("<TR BGCOLOR=#F0F0F0><TD COLSPAN=4><IMG SRC=/images/foldero.gif>");
#line 122
      prints("<A HREF=%s/> Parent Directory</A></TD>\n", dentry->d_name);
#line 123
      continue;
    }
#line 125
    tmp___73 = localtime((time_t const   *)(& sb.st_mtim.tv_sec));
#line 125
    strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%b %d %Y %H:%M",
             (struct tm  const  * __restrict  )tmp___73);
#line 126
    memset((void *)(showfile), 0, sizeof(showfile));
#line 127
    snprintf((char * __restrict  )(showfile), sizeof(showfile) - 1U, (char const   * __restrict  )"%s",
             dentry->d_name);
#line 128
    prints("<TR BGCOLOR=#F0F0F0><TD ALIGN=left NOWRAP>");
#line 129
    if (sb.st_mode & 16384U) {
#line 130
      prints("<IMG SRC=/images/folder.gif>&nbsp;<A HREF=");
#line 131
      printhex("%s", showfile);
#line 132
      prints("/>%s/</A></TD>", dentry->d_name);
    } else {
#line 134
      prints("<IMG SRC=/images/default.gif>&nbsp;<A HREF=");
#line 135
      printhex("%s", showfile);
#line 136
      prints(">%s</A></TD>", dentry->d_name);
    }
#line 138
    if (sb.st_size > 1048576L) {
#line 139
      prints("<TD ALIGN=right NOWRAP>%10.1f M</TD>\n", (double )((float )sb.st_size) / 1048576.0);
    } else {
#line 141
      prints("<TD ALIGN=right NOWRAP>%10.1f K</TD>\n", (double )((float )sb.st_size) / 1024.0);
    }
#line 143
    prints("<TD ALIGN=right NOWRAP>%s</TD>\n", timebuf);
#line 144
    prints("<TD ALIGN=left NOWRAP>&nbsp;</TD></TR>\n");
  }
#line 146
  closedir(handle);
#line 147
  prints("</TABLE>\n");
#line 148
  prints("</CENTER>\n");
#line 149
  prints("</BODY></HTML>\n");
#line 150
  return (0);
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "format.o"
#pragma merger(0,"/tmp/cil-PPfwtI3Z.i","-Wall,-O2,-s")
#line 85 "/usr/include/ctype.h"
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 367 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 248 "main.h"
int hex2int(char *pChars ) ;
#line 249
void striprn(char *string ) ;
#line 250
void swapchar(char *string , char oldchar , char newchar ) ;
#line 252
char *strcatf(char *dest , char const   *format  , ...) ;
#line 21 "format.c"
void decodeurl(unsigned char *pEncoded ) 
{ char *pDecoded ;
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 25
  pDecoded = (char *)pEncoded;
#line 26
  while (*pDecoded) {
#line 27
    if ((int )*pDecoded == 43) {
#line 27
      *pDecoded = (char )' ';
    }
#line 28
    pDecoded ++;
  }
#line 30
  pDecoded = (char *)pEncoded;
#line 31
  while (*pEncoded) {
#line 32
    if ((int )*pEncoded == 37) {
#line 33
      pEncoded ++;
#line 34
      tmp___1 = __ctype_b_loc();
#line 34
      if ((int const   )*(*tmp___1 + (int )*(pEncoded + 0)) & 4096) {
#line 34
        tmp___2 = __ctype_b_loc();
#line 34
        if ((int const   )*(*tmp___2 + (int )*(pEncoded + 1)) & 4096) {
#line 35
          tmp = pDecoded;
#line 35
          pDecoded ++;
#line 35
          tmp___0 = hex2int((char *)pEncoded);
#line 35
          *tmp = (char )tmp___0;
#line 36
          pEncoded += 2;
        }
      }
    } else {
#line 39
      tmp___3 = pDecoded;
#line 39
      pDecoded ++;
#line 39
      tmp___4 = pEncoded;
#line 39
      pEncoded ++;
#line 39
      *tmp___3 = (char )*tmp___4;
    }
  }
#line 42
  *pDecoded = (char )'\000';
#line 43
  return;
}
}
#line 45 "format.c"
void fixslashes(char *pOriginal ) 
{ 

  {
#line 50
  swapchar(pOriginal, (char )'\\', (char )'/');
#line 52
  return;
}
}
#line 54 "format.c"
int hex2int(char *pChars ) 
{ int Hi ;
  int Lo ;
  int Result ;

  {
#line 60
  Hi = (int )*(pChars + 0);
#line 61
  if (48 <= Hi) {
#line 61
    if (Hi <= 57) {
#line 62
      Hi -= 48;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 63
    if (97 <= Hi) {
#line 63
      if (Hi <= 102) {
#line 64
        Hi -= 87;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 65
      if (65 <= Hi) {
#line 65
        if (Hi <= 70) {
#line 66
          Hi -= 55;
        }
      }
    }
  }
#line 68
  Lo = (int )*(pChars + 1);
#line 69
  if (48 <= Lo) {
#line 69
    if (Lo <= 57) {
#line 70
      Lo -= 48;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 71
    if (97 <= Lo) {
#line 71
      if (Lo <= 102) {
#line 72
        Lo -= 87;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 73
      if (65 <= Lo) {
#line 73
        if (Lo <= 70) {
#line 74
          Lo -= 55;
        }
      }
    }
  }
#line 76
  Result = Lo + 16 * Hi;
#line 77
  return (Result);
}
}
#line 80 "format.c"
void striprn(char *string ) 
{ size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 82
  while (1) {
#line 82
    tmp___0 = strlen((char const   *)string);
#line 82
    if (! ((int )*(string + (tmp___0 - 1U)) == 13)) {
#line 82
      tmp___1 = strlen((char const   *)string);
#line 82
      if (! ((int )*(string + (tmp___1 - 1U)) == 10)) {
#line 82
        break;
      }
    }
#line 83
    tmp = strlen((char const   *)string);
#line 83
    *(string + (tmp - 1U)) = (char )'\000';
  }
#line 85
  return;
}
}
#line 87 "format.c"
void swapchar(char *string , char oldchar , char newchar ) 
{ 

  {
#line 89
  while (*string) {
#line 90
    if ((int )*string == (int )oldchar) {
#line 90
      *string = newchar;
    }
#line 91
    string ++;
  }
#line 93
  return;
}
}
#line 95 "format.c"
char *strcasestr(char *src , char *query ) 
{ char *pToken ;
  char Buffer[8192] ;
  char Query[64] ;
  int loop ;
  size_t tmp ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int __res___0 ;
  __int32_t const   **tmp___5 ;

  {
#line 102
  tmp = strlen((char const   *)src);
#line 102
  if (tmp == 0U) {
#line 102
    return ((char *)((void *)0));
  }
#line 103
  memset((void *)(Buffer), 0, sizeof(Buffer));
#line 104
  __builtin_strncpy(Buffer, (char const   *)src, sizeof(Buffer) - 1U);
#line 105
  __builtin_strncpy(Query, (char const   *)query, sizeof(Query) - 1U);
#line 106
  loop = 0;
#line 107
  while (Buffer[loop]) {
#line 108
    if (sizeof(Buffer[loop]) > 1U) {
#line 108
      __res = toupper((int )Buffer[loop]);
    } else {
#line 108
      tmp___2 = __ctype_toupper_loc();
#line 108
      __res = (int )*(*tmp___2 + (int )Buffer[loop]);
    }
#line 108
    Buffer[loop] = (char )__res;
#line 109
    loop ++;
  }
#line 111
  loop = 0;
#line 112
  while (Query[loop]) {
#line 113
    if (sizeof(Query[loop]) > 1U) {
#line 113
      __res___0 = toupper((int )Query[loop]);
    } else {
#line 113
      tmp___5 = __ctype_toupper_loc();
#line 113
      __res___0 = (int )*(*tmp___5 + (int )Query[loop]);
    }
#line 113
    Query[loop] = (char )__res___0;
#line 114
    loop ++;
  }
#line 116
  pToken = strstr((char const   *)(Buffer), (char const   *)(Query));
#line 117
  if ((unsigned int )pToken != (unsigned int )((void *)0)) {
#line 118
    return (src + (pToken - (char *)(& Buffer)));
  }
#line 120
  return ((char *)((void *)0));
}
}
#line 123 "format.c"
char *strcatf(char *dest , char const   *format  , ...) 
{ char catbuffer[1024] ;
  va_list ap ;

  {
#line 128
  memset((void *)(catbuffer), 0, sizeof(catbuffer));
#line 129
  __builtin_va_start(ap, format);
#line 130
  vsnprintf((char * __restrict  )(catbuffer), sizeof(catbuffer) - 1U, (char const   * __restrict  )format,
            ap);
#line 131
  __builtin_va_end(ap);
#line 132
  strcat((char * __restrict  )dest, (char const   * __restrict  )(catbuffer));
#line 133
  return (dest);
}
}
#line 136 "format.c"
int printhex(char const   *format  , ...) 
{ char *hex ;
  unsigned char buffer[1024] ;
  int offset ;
  va_list ap ;

  {
#line 138
  hex = (char *)"0123456789ABCDEF";
#line 140
  offset = 0;
#line 143
  __builtin_va_start(ap, format);
#line 144
  vsnprintf((char * __restrict  )(buffer), sizeof(buffer) - 1U, (char const   * __restrict  )format,
            ap);
#line 145
  __builtin_va_end(ap);
#line 146
  while (buffer[offset]) {
#line 147
    if ((int )buffer[offset] > 32) {
#line 147
      if ((int )buffer[offset] < 128) {
#line 147
        if ((int )buffer[offset] != 60) {
#line 147
          if ((int )buffer[offset] != 62) {
#line 148
            prints("%c", buffer[offset]);
          } else {
#line 150
            prints("%%%c%c", *(hex + (unsigned int )buffer[offset] / 16U), *(hex + ((unsigned int )buffer[offset] & 15U)));
          }
        } else {
#line 150
          prints("%%%c%c", *(hex + (unsigned int )buffer[offset] / 16U), *(hex + ((unsigned int )buffer[offset] & 15U)));
        }
      } else {
#line 150
        prints("%%%c%c", *(hex + (unsigned int )buffer[offset] / 16U), *(hex + ((unsigned int )buffer[offset] & 15U)));
      }
    } else {
#line 150
      prints("%%%c%c", *(hex + (unsigned int )buffer[offset] / 16U), *(hex + ((unsigned int )buffer[offset] & 15U)));
    }
#line 152
    offset ++;
  }
#line 154
  return (0);
}
}
#line 1 "http.o"
#pragma merger(0,"/tmp/cil-br1oW10e.i","-Wall,-O2,-s")
#line 119 "/usr/include/ctype.h"
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 413 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 232 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 143 "/usr/include/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 54 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 257 "main.h"
void ReadPOSTData(int sid ) ;
#line 258
int read_header(int sid ) ;
#line 267
int sgets(char *buffer , int max , int fd ) ;
#line 23 "http.c"
void printerror(int sid , int status , char *title , char *text ) 
{ 

  {
#line 25
  send_header(sid, 0, 200, (char *)"OK", (char *)"1", (char *)"text/html", -1, -1L);
#line 26
  prints("<HTML><HEAD><TITLE>%d %s</TITLE></HEAD>\n", status, title);
#line 27
  prints("<BODY BGCOLOR=#F0F0F0 TEXT=#000000 LINK=#0000FF ALINK=#0000FF VLINK=#0000FF>\n");
#line 28
  prints("<H1>%d %s</H1>\n", status, title);
#line 29
  prints("%s\n", text);
#line 30
  prints("<HR>\n<ADDRESS>%s</ADDRESS>\n</BODY></HTML>\n", "Null httpd 0.5.0");
#line 31
  ((conn + sid)->dat)->out_bodydone = (short)1;
#line 32
  flushbuffer(sid);
#line 33
  closeconnect(sid, 1);
#line 34
  return;
}
}
#line 37 "http.c"
char *get_mime_type(char *name ) 
{ char *mime_types[40][2] ;
  char *extension ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
#line 39
  mime_types[0][0] = (char *)".html";
#line 39
  mime_types[0][1] = (char *)"text/html";
#line 39
  mime_types[1][0] = (char *)".htm";
#line 39
  mime_types[1][1] = (char *)"text/html";
#line 39
  mime_types[2][0] = (char *)".shtml";
#line 39
  mime_types[2][1] = (char *)"text/html";
#line 39
  mime_types[3][0] = (char *)".css";
#line 39
  mime_types[3][1] = (char *)"text/css";
#line 39
  mime_types[4][0] = (char *)".txt";
#line 39
  mime_types[4][1] = (char *)"text/plain";
#line 39
  mime_types[5][0] = (char *)".mdb";
#line 39
  mime_types[5][1] = (char *)"application/msaccess";
#line 39
  mime_types[6][0] = (char *)".xls";
#line 39
  mime_types[6][1] = (char *)"application/msexcel";
#line 39
  mime_types[7][0] = (char *)".doc";
#line 39
  mime_types[7][1] = (char *)"application/msword";
#line 39
  mime_types[8][0] = (char *)".exe";
#line 39
  mime_types[8][1] = (char *)"application/octet-stream";
#line 39
  mime_types[9][0] = (char *)".pdf";
#line 39
  mime_types[9][1] = (char *)"application/pdf";
#line 39
  mime_types[10][0] = (char *)".rtf";
#line 39
  mime_types[10][1] = (char *)"application/rtf";
#line 39
  mime_types[11][0] = (char *)".tgz";
#line 39
  mime_types[11][1] = (char *)"application/x-compressed";
#line 39
  mime_types[12][0] = (char *)".gz";
#line 39
  mime_types[12][1] = (char *)"application/x-compressed";
#line 39
  mime_types[13][0] = (char *)".z";
#line 39
  mime_types[13][1] = (char *)"application/x-compress";
#line 39
  mime_types[14][0] = (char *)".swf";
#line 39
  mime_types[14][1] = (char *)"application/x-shockwave-flash";
#line 39
  mime_types[15][0] = (char *)".tar";
#line 39
  mime_types[15][1] = (char *)"application/x-tar";
#line 39
  mime_types[16][0] = (char *)".rar";
#line 39
  mime_types[16][1] = (char *)"application/x-rar-compressed";
#line 39
  mime_types[17][0] = (char *)".zip";
#line 39
  mime_types[17][1] = (char *)"application/x-zip-compressed";
#line 39
  mime_types[18][0] = (char *)".ra";
#line 39
  mime_types[18][1] = (char *)"audio/x-pn-realaudio";
#line 39
  mime_types[19][0] = (char *)".ram";
#line 39
  mime_types[19][1] = (char *)"audio/x-pn-realaudio";
#line 39
  mime_types[20][0] = (char *)".wav";
#line 39
  mime_types[20][1] = (char *)"audio/x-wav";
#line 39
  mime_types[21][0] = (char *)".gif";
#line 39
  mime_types[21][1] = (char *)"image/gif";
#line 39
  mime_types[22][0] = (char *)".jpeg";
#line 39
  mime_types[22][1] = (char *)"image/jpeg";
#line 39
  mime_types[23][0] = (char *)".jpe";
#line 39
  mime_types[23][1] = (char *)"image/jpeg";
#line 39
  mime_types[24][0] = (char *)".jpg";
#line 39
  mime_types[24][1] = (char *)"image/jpeg";
#line 39
  mime_types[25][0] = (char *)".png";
#line 39
  mime_types[25][1] = (char *)"image/png";
#line 39
  mime_types[26][0] = (char *)".avi";
#line 39
  mime_types[26][1] = (char *)"video/avi";
#line 39
  mime_types[27][0] = (char *)".mp3";
#line 39
  mime_types[27][1] = (char *)"video/mpeg";
#line 39
  mime_types[28][0] = (char *)".mpeg";
#line 39
  mime_types[28][1] = (char *)"video/mpeg";
#line 39
  mime_types[29][0] = (char *)".mpg";
#line 39
  mime_types[29][1] = (char *)"video/mpeg";
#line 39
  mime_types[30][0] = (char *)".qt";
#line 39
  mime_types[30][1] = (char *)"video/quicktime";
#line 39
  mime_types[31][0] = (char *)".mov";
#line 39
  mime_types[31][1] = (char *)"video/quicktime";
#line 39
  mime_types[32][0] = (char *)"";
#line 39
  mime_types[32][1] = (char *)"";
#line 39
  mime_types[33][0] = (char *)0;
#line 39
  mime_types[33][1] = (char *)0;
#line 39
  mime_types[34][0] = (char *)0;
#line 39
  mime_types[34][1] = (char *)0;
#line 39
  mime_types[35][0] = (char *)0;
#line 39
  mime_types[35][1] = (char *)0;
#line 39
  mime_types[36][0] = (char *)0;
#line 39
  mime_types[36][1] = (char *)0;
#line 39
  mime_types[37][0] = (char *)0;
#line 39
  mime_types[37][1] = (char *)0;
#line 39
  mime_types[38][0] = (char *)0;
#line 39
  mime_types[38][1] = (char *)0;
#line 39
  mime_types[39][0] = (char *)0;
#line 39
  mime_types[39][1] = (char *)0;
#line 77
  extension = strrchr((char const   *)name, '.');
#line 78
  if ((unsigned int )extension == (unsigned int )((void *)0)) {
#line 79
    return ((char *)"text/plain");
  }
#line 81
  i = 0;
#line 82
  while (1) {
#line 82
    tmp___9 = strlen((char const   *)mime_types[i][0]);
#line 82
    if (! (tmp___9 > 0U)) {
#line 82
      break;
    }
#line 83
    if (0) {
#line 83
      __s1_len = strlen((char const   *)extension);
#line 83
      __s2_len = strlen((char const   *)mime_types[i][0]);
#line 83
      if (! ((unsigned int )((void const   *)(extension + 1)) - (unsigned int )((void const   *)extension) == 1U)) {
        goto _L___0;
      } else {
#line 83
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
#line 83
          if (! ((unsigned int )((void const   *)(mime_types[i][0] + 1)) - (unsigned int )((void const   *)mime_types[i][0]) == 1U)) {
#line 83
            tmp___8 = 1;
          } else {
#line 83
            if (__s2_len >= 4U) {
#line 83
              tmp___8 = 1;
            } else {
#line 83
              tmp___8 = 0;
            }
          }
        } else {
#line 83
          tmp___8 = 0;
        }
      }
#line 83
      if (tmp___8) {
#line 83
        tmp___4 = __builtin_strcmp((char const   *)extension, (char const   *)mime_types[i][0]);
      } else {
#line 83
        tmp___7 = __builtin_strcmp((char const   *)extension, (char const   *)mime_types[i][0]);
#line 83
        tmp___4 = tmp___7;
      }
    } else {
#line 83
      tmp___7 = __builtin_strcmp((char const   *)extension, (char const   *)mime_types[i][0]);
#line 83
      tmp___4 = tmp___7;
    }
#line 83
    if (tmp___4 == 0) {
#line 84
      return (mime_types[i][1]);
    }
#line 86
    i ++;
  }
#line 88
  return ((char *)"application/octet-stream");
}
}
#line 91 "http.c"
void ReadPOSTData(int sid ) 
{ char *pPostData ;
  int rc ;
  int x ;
  void *tmp ;

  {
#line 93
  rc = 0;
#line 94
  x = 0;
#line 96
  if ((unsigned int )(conn + sid)->PostData != (unsigned int )((void *)0)) {
#line 97
    free((void *)(conn + sid)->PostData);
#line 98
    (conn + sid)->PostData = (char *)((void *)0);
  }
#line 100
  tmp = calloc((unsigned int )(((conn + sid)->dat)->in_ContentLength + 1024), sizeof(char ));
#line 100
  (conn + sid)->PostData = (char *)tmp;
#line 101
  if ((unsigned int )(conn + sid)->PostData == (unsigned int )((void *)0)) {
#line 102
    logerror("Memory allocation error while reading POST data.");
#line 103
    closeconnect(sid, 1);
  }
#line 105
  pPostData = (conn + sid)->PostData;
#line 107
  while (1) {
#line 108
    rc = recv((int )(conn + sid)->socket, (void *)pPostData, 1024U, 0);
#line 109
    if (rc == -1) {
#line 110
      closeconnect(sid, 1);
#line 111
      return;
    }
#line 113
    pPostData += rc;
#line 114
    x += rc;
#line 107
    if (! (rc == 1024)) {
#line 107
      if (! (x < ((conn + sid)->dat)->in_ContentLength)) {
#line 107
        break;
      }
    }
  }
#line 116
  *((conn + sid)->PostData + ((conn + sid)->dat)->in_ContentLength) = (char )'\000';
#line 117
  return;
}
}
#line 119 "http.c"
int read_header(int sid ) 
{ char line[2048] ;
  char *pTemp ;
  time_t x ;
  char *tmp ;
  size_t tmp___0 ;
  time_t tmp___1 ;
  size_t tmp___2 ;
  time_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int __res ;
  __int32_t const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  char *tmp___50 ;
  char *tmp___52 ;

  {
#line 125
  tmp = inet_ntoa((conn + sid)->ClientAddr.sin_addr);
#line 125
  __builtin_strncpy(((conn + sid)->dat)->in_RemoteAddr, (char const   *)tmp, sizeof(((conn + sid)->dat)->in_RemoteAddr) - 1U);
#line 126
  x = time((time_t *)0);
#line 127
  while (1) {
#line 128
    memset((void *)(line), 0, sizeof(line));
#line 129
    sgets(line, (int )(sizeof(line) - 1U), (int )(conn + sid)->socket);
#line 130
    striprn(line);
#line 127
    tmp___0 = strlen((char const   *)(line));
#line 127
    if (tmp___0 == 0U) {
#line 127
      tmp___1 = time((time_t *)0L);
#line 127
      if (! (tmp___1 - x < 30L)) {
#line 127
        break;
      }
    } else {
#line 127
      break;
    }
  }
#line 132
  tmp___2 = strlen((char const   *)(line));
#line 132
  if (tmp___2 == 0U) {
#line 132
    tmp___3 = time((time_t *)0L);
#line 132
    if (tmp___3 - x >= 30L) {
#line 136
      closeconnect(sid, 1);
    }
  }
#line 141
  tmp___4 = strlen((char const   *)(line));
#line 141
  if (tmp___4 == 0U) {
#line 142
    printerror(sid, 400, (char *)"Bad Request", (char *)"No Request Found.");
  }
#line 143
  tmp___5 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%[^ ] %[^ ] %[^ ]",
                   ((conn + sid)->dat)->in_RequestMethod, ((conn + sid)->dat)->in_RequestURI,
                   ((conn + sid)->dat)->in_Protocol);
#line 143
  if (tmp___5 != 3) {
#line 144
    printerror(sid, 400, (char *)"Bad Request", (char *)"Can\'t Parse Request.");
  }
#line 145
  pTemp = ((conn + sid)->dat)->in_RequestMethod;
#line 146
  while (*pTemp) {
#line 146
    if (sizeof(*pTemp) > 1U) {
#line 146
      __res = toupper((int )*pTemp);
    } else {
#line 146
      tmp___8 = __ctype_toupper_loc();
#line 146
      __res = (int )*(*tmp___8 + (int )*pTemp);
    }
#line 146
    *pTemp = (char )__res;
#line 146
    pTemp ++;
  }
#line 147
  while (1) {
#line 147
    tmp___18 = strlen((char const   *)(line));
#line 147
    if (! (tmp___18 > 0U)) {
#line 147
      break;
    }
#line 148
    sgets(line, (int )(sizeof(line) - 1U), (int )(conn + sid)->socket);
#line 149
    while (1) {
#line 149
      tmp___10 = strlen((char const   *)(line));
#line 149
      if (! ((int )line[tmp___10 - 1U] == 10)) {
#line 149
        tmp___11 = strlen((char const   *)(line));
#line 149
        if (! ((int )line[tmp___11 - 1U] == 13)) {
#line 149
          break;
        }
      }
#line 149
      tmp___9 = strlen((char const   *)(line));
#line 149
      line[tmp___9 - 1U] = (char )'\000';
    }
#line 150
    tmp___12 = strncasecmp((char const   *)(line), "Connection: ", 12U);
#line 150
    if (tmp___12 == 0) {
#line 151
      __builtin_strncpy(((conn + sid)->dat)->in_Connection, (char const   *)((char *)(& line) + 12),
                        sizeof(((conn + sid)->dat)->in_Connection) - 1U);
    }
#line 152
    tmp___13 = strncasecmp((char const   *)(line), "Content-Length: ", 16U);
#line 152
    if (tmp___13 == 0) {
#line 153
      ((conn + sid)->dat)->in_ContentLength = atoi((char const   *)((char *)(& line) + 16));
    }
#line 154
    tmp___14 = strncasecmp((char const   *)(line), "Cookie: ", 8U);
#line 154
    if (tmp___14 == 0) {
#line 155
      __builtin_strncpy(((conn + sid)->dat)->in_Cookie, (char const   *)((char *)(& line) + 8),
                        sizeof(((conn + sid)->dat)->in_Cookie) - 1U);
    }
#line 156
    tmp___15 = strncasecmp((char const   *)(line), "Host: ", 6U);
#line 156
    if (tmp___15 == 0) {
#line 157
      __builtin_strncpy(((conn + sid)->dat)->in_Host, (char const   *)((char *)(& line) + 6),
                        sizeof(((conn + sid)->dat)->in_Host) - 1U);
    }
#line 158
    tmp___16 = strncasecmp((char const   *)(line), "If-Modified-Since: ", 19U);
#line 158
    if (tmp___16 == 0) {
#line 159
      __builtin_strncpy(((conn + sid)->dat)->in_IfModifiedSince, (char const   *)((char *)(& line) + 19),
                        sizeof(((conn + sid)->dat)->in_IfModifiedSince) - 1U);
    }
#line 160
    tmp___17 = strncasecmp((char const   *)(line), "User-Agent: ", 12U);
#line 160
    if (tmp___17 == 0) {
#line 161
      __builtin_strncpy(((conn + sid)->dat)->in_UserAgent, (char const   *)((char *)(& line) + 12),
                        sizeof(((conn + sid)->dat)->in_UserAgent) - 1U);
    }
  }
#line 163
  if (0) {
#line 163
    __s1_len = strlen((char const   *)(((conn + sid)->dat)->in_RequestMethod));
#line 163
    __s2_len = strlen("GET");
#line 163
    if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod)) == 1U)) {
      goto _L___0;
    } else {
#line 163
      if (__s1_len >= 4U) {
        _L___0: /* CIL Label */ 
#line 163
        if (! ((unsigned int )((void const   *)("GET" + 1)) - (unsigned int )((void const   *)"GET") == 1U)) {
#line 163
          tmp___28 = 1;
        } else {
#line 163
          if (__s2_len >= 4U) {
#line 163
            tmp___28 = 1;
          } else {
#line 163
            tmp___28 = 0;
          }
        }
      } else {
#line 163
        tmp___28 = 0;
      }
    }
#line 163
    if (tmp___28) {
#line 163
      tmp___24 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                  "GET");
    } else {
#line 163
      tmp___27 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                  "GET");
#line 163
      tmp___24 = tmp___27;
    }
  } else {
#line 163
    tmp___27 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                "GET");
#line 163
    tmp___24 = tmp___27;
  }
#line 163
  if (tmp___24 != 0) {
#line 163
    if (0) {
#line 163
      __s1_len___0 = strlen((char const   *)(((conn + sid)->dat)->in_RequestMethod));
#line 163
      __s2_len___0 = strlen("POST");
#line 163
      if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod)) == 1U)) {
        goto _L___2;
      } else {
#line 163
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 163
          if (! ((unsigned int )((void const   *)("POST" + 1)) - (unsigned int )((void const   *)"POST") == 1U)) {
#line 163
            tmp___38 = 1;
          } else {
#line 163
            if (__s2_len___0 >= 4U) {
#line 163
              tmp___38 = 1;
            } else {
#line 163
              tmp___38 = 0;
            }
          }
        } else {
#line 163
          tmp___38 = 0;
        }
      }
#line 163
      if (tmp___38) {
#line 163
        tmp___34 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                    "POST");
      } else {
#line 163
        tmp___37 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                    "POST");
#line 163
        tmp___34 = tmp___37;
      }
    } else {
#line 163
      tmp___37 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                  "POST");
#line 163
      tmp___34 = tmp___37;
    }
#line 163
    if (tmp___34 != 0) {
#line 164
      printerror(sid, 501, (char *)"Not Implemented", (char *)"That method is not implemented.");
#line 165
      closeconnect(sid, 1);
#line 166
      return (-1);
    }
  }
#line 168
  if (0) {
#line 168
    __s1_len___1 = strlen((char const   *)(((conn + sid)->dat)->in_RequestMethod));
#line 168
    __s2_len___1 = strlen("POST");
#line 168
    if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestMethod)) == 1U)) {
      goto _L___4;
    } else {
#line 168
      if (__s1_len___1 >= 4U) {
        _L___4: /* CIL Label */ 
#line 168
        if (! ((unsigned int )((void const   *)("POST" + 1)) - (unsigned int )((void const   *)"POST") == 1U)) {
#line 168
          tmp___48 = 1;
        } else {
#line 168
          if (__s2_len___1 >= 4U) {
#line 168
            tmp___48 = 1;
          } else {
#line 168
            tmp___48 = 0;
          }
        }
      } else {
#line 168
        tmp___48 = 0;
      }
    }
#line 168
    if (tmp___48) {
#line 168
      tmp___44 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                  "POST");
    } else {
#line 168
      tmp___47 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                  "POST");
#line 168
      tmp___44 = tmp___47;
    }
  } else {
#line 168
    tmp___47 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestMethod),
                                "POST");
#line 168
    tmp___44 = tmp___47;
  }
#line 168
  if (tmp___44 == 0) {
#line 169
    if (((conn + sid)->dat)->in_ContentLength < 33554432) {
#line 170
      ReadPOSTData(sid);
    } else {
#line 174
      printerror(sid, 413, (char *)"Bad Request", (char *)"Request entity too large.");
#line 175
      logerror("%s - Large POST (>%d bytes) disallowed", ((conn + sid)->dat)->in_RemoteAddr,
               33554432);
#line 176
      closeconnect(sid, 1);
#line 177
      return (-1);
    }
  }
#line 180
  if ((int )((conn + sid)->dat)->in_RequestURI[0] != 47) {
#line 181
    printerror(sid, 400, (char *)"Bad Request", (char *)"Bad filename.");
  }
#line 183
  tmp___52 = __builtin_strchr(((conn + sid)->dat)->in_RequestURI, '?');
#line 183
  if ((unsigned int )tmp___52 != (unsigned int )((void *)0)) {
#line 184
    tmp___50 = __builtin_strchr(((conn + sid)->dat)->in_RequestURI, '?');
#line 184
    __builtin_strncpy(((conn + sid)->dat)->in_QueryString, (char const   *)(tmp___50 + 1),
                      sizeof(((conn + sid)->dat)->in_QueryString) - 1U);
  }
#line 186
  return (0);
}
}
#line 189 "http.c"
void send_header(int sid , int cacheable , int status , char *title , char *extra_header ,
                 char *mime_type , int length , time_t mod ) 
{ char timebuf[100] ;
  time_t now ;
  struct tm *tmp ;
  struct tm *tmp___0 ;

  {
#line 194
  if (status) {
#line 195
    ((conn + sid)->dat)->out_status = (short )status;
  } else {
#line 197
    ((conn + sid)->dat)->out_status = (short)200;
  }
#line 199
  if (length >= 0) {
#line 200
    ((conn + sid)->dat)->out_ContentLength = length;
  }
#line 202
  if (mod != -1L) {
#line 203
    tmp = gmtime((time_t const   *)(& mod));
#line 203
    strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
             (struct tm  const  * __restrict  )tmp);
#line 204
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_LastModified), sizeof(((conn + sid)->dat)->out_LastModified) - 1U,
             (char const   * __restrict  )"%s", timebuf);
  }
#line 206
  now = time((time_t *)0);
#line 207
  tmp___0 = gmtime((time_t const   *)(& now));
#line 207
  strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
           (struct tm  const  * __restrict  )tmp___0);
#line 208
  snprintf((char * __restrict  )(((conn + sid)->dat)->out_Date), sizeof(((conn + sid)->dat)->out_Date) - 1U,
           (char const   * __restrict  )"%s", timebuf);
#line 209
  if (cacheable) {
#line 210
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_CacheControl), sizeof(((conn + sid)->dat)->out_CacheControl) - 1U,
             (char const   * __restrict  )"public");
#line 211
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Pragma), sizeof(((conn + sid)->dat)->out_Pragma) - 1U,
             (char const   * __restrict  )"public");
  } else {
#line 213
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_CacheControl), sizeof(((conn + sid)->dat)->out_CacheControl) - 1U,
             (char const   * __restrict  )"no-store");
#line 214
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Expires), sizeof(((conn + sid)->dat)->out_Expires) - 1U,
             (char const   * __restrict  )"%s", timebuf);
#line 215
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Pragma), sizeof(((conn + sid)->dat)->out_Pragma) - 1U,
             (char const   * __restrict  )"no-cache");
  }
#line 217
  if ((unsigned int )extra_header != (unsigned int )((char *)0)) {
#line 218
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_ContentType), sizeof(((conn + sid)->dat)->out_ContentType) - 1U,
             (char const   * __restrict  )"%s", mime_type);
  } else {
#line 220
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_ContentType), sizeof(((conn + sid)->dat)->out_ContentType) - 1U,
             (char const   * __restrict  )"text/html");
  }
#line 222
  return;
}
}
#line 224 "http.c"
void send_fileheader(int sid , int cacheable , int status , char *title , char *extra_header ,
                     char *mime_type , int length , time_t mod ) 
{ char timebuf[100] ;
  time_t now ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  struct tm *tmp___2 ;
  struct tm *tmp___3 ;
  time_t tmp___4 ;
  struct tm *tmp___5 ;
  struct tm *tmp___6 ;

  {
#line 229
  if (status) {
#line 230
    ((conn + sid)->dat)->out_status = (short )status;
  } else {
#line 232
    ((conn + sid)->dat)->out_status = (short)200;
  }
#line 234
  tmp = strcasestr(((conn + sid)->dat)->in_Protocol, (char *)"HTTP/1.1");
#line 234
  if ((unsigned int )tmp != (unsigned int )((void *)0)) {
#line 235
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.1");
  } else {
#line 237
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.0");
  }
#line 239
  tmp___0 = strcasecmp((char const   *)(((conn + sid)->dat)->in_Connection), "Keep-Alive");
#line 239
  if (tmp___0 == 0) {
#line 240
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
             (char const   * __restrict  )"Keep-Alive");
  } else {
#line 242
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
             (char const   * __restrict  )"Close");
  }
#line 245
  tmp___1 = strcasestr(((conn + sid)->dat)->in_UserAgent, (char *)"MSIE");
#line 245
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 246
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
             (char const   * __restrict  )"Close");
  }
#line 248
  prints("%s %d OK\r\n", ((conn + sid)->dat)->out_Protocol, ((conn + sid)->dat)->out_status);
#line 249
  prints("Connection: %s\r\n", ((conn + sid)->dat)->out_Connection);
#line 250
  prints("Server: %s\r\n", "Null httpd 0.5.0");
#line 251
  if (length >= 0) {
#line 251
    if (status != 304) {
#line 252
      prints("Content-Length: %d\r\n", length);
    }
  }
#line 254
  now = time((time_t *)0);
#line 255
  tmp___2 = gmtime((time_t const   *)(& now));
#line 255
  strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
           (struct tm  const  * __restrict  )tmp___2);
#line 256
  prints("Date: %s\r\n", timebuf);
#line 257
  if (mod != -1L) {
#line 258
    tmp___3 = gmtime((time_t const   *)(& mod));
#line 258
    strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
             (struct tm  const  * __restrict  )tmp___3);
#line 259
    prints("Last-Modified: %s\r\n", timebuf);
  }
#line 261
  if (cacheable) {
#line 262
    tmp___4 = time((time_t *)0);
#line 262
    now = tmp___4 + 604800L;
#line 263
    tmp___5 = gmtime((time_t const   *)(& now));
#line 263
    strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
             (struct tm  const  * __restrict  )tmp___5);
#line 264
    prints("Expires: %s\r\n", timebuf);
#line 265
    prints("Cache-Control: public\r\n");
#line 266
    prints("Pragma: public\r\n");
  } else {
#line 268
    now = time((time_t *)0);
#line 269
    tmp___6 = gmtime((time_t const   *)(& now));
#line 269
    strftime((char * __restrict  )(timebuf), sizeof(timebuf), (char const   * __restrict  )"%a, %d %b %Y %H:%M:%S GMT",
             (struct tm  const  * __restrict  )tmp___6);
#line 270
    prints("Expires: %s\r\n", timebuf);
#line 271
    prints("Cache-Control: no-store\r\n");
#line 272
    prints("Pragma: no-cache\r\n");
  }
#line 274
  if ((unsigned int )extra_header != (unsigned int )((char *)0)) {
#line 275
    prints("Content-Type: %s\r\n\r\n", mime_type);
  } else {
#line 277
    prints("Content-Type: text/html\r\n\r\n");
  }
#line 279
  ((conn + sid)->dat)->out_headdone = (short)1;
#line 280
  flushbuffer(sid);
#line 281
  return;
}
}
#line 1 "main.o"
#pragma merger(0,"/tmp/cil-lfbqXwbj.i","-Wall,-O2,-s")
#line 237 "main.h"
void dorequest(int sid ) ;
#line 272
void init(void) ;
#line 276
void accept_loop(void *x ) ;
#line 28 "main.c"
void dorequest(int sid ) 
{ unsigned char file[255] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 32
  tmp = read_header(sid);
#line 32
  if (tmp < 0) {
#line 33
    closeconnect(sid, 1);
#line 34
    return;
  }
#line 36
  logaccess(2, "%s - HTTP Request: %s %s", ((conn + sid)->dat)->in_RemoteAddr, ((conn + sid)->dat)->in_RequestMethod,
            ((conn + sid)->dat)->in_RequestURI);
#line 37
  snprintf((char * __restrict  )(file), sizeof(file) - 1U, (char const   * __restrict  )"%s%s",
           config.server_htdocs_dir, ((conn + sid)->dat)->in_RequestURI);
#line 38
  snprintf((char * __restrict  )(((conn + sid)->dat)->out_ContentType), sizeof(((conn + sid)->dat)->out_ContentType) - 1U,
           (char const   * __restrict  )"text/html");
#line 39
  if (0) {
#line 39
    if (0) {
#line 39
      __s1_len___0 = strlen((char const   *)(((conn + sid)->dat)->in_RequestURI));
#line 39
      __s2_len___0 = strlen("/cgi-bin/");
#line 39
      if (! ((unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI + 1)) - (unsigned int )((void const   *)(((conn + sid)->dat)->in_RequestURI)) == 1U)) {
        goto _L___2;
      } else {
#line 39
        if (__s1_len___0 >= 4U) {
          _L___2: /* CIL Label */ 
#line 39
          if (! ((unsigned int )((void const   *)("/cgi-bin/" + 1)) - (unsigned int )((void const   *)"/cgi-bin/") == 1U)) {
#line 39
            tmp___25 = 1;
          } else {
#line 39
            if (__s2_len___0 >= 4U) {
#line 39
              tmp___25 = 1;
            } else {
#line 39
              tmp___25 = 0;
            }
          }
        } else {
#line 39
          tmp___25 = 0;
        }
      }
#line 39
      if (tmp___25) {
#line 39
        tmp___21 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
      } else {
#line 39
        tmp___24 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                    "/cgi-bin/");
#line 39
        tmp___21 = tmp___24;
      }
    } else {
#line 39
      tmp___24 = __builtin_strcmp((char const   *)(((conn + sid)->dat)->in_RequestURI),
                                  "/cgi-bin/");
#line 39
      tmp___21 = tmp___24;
    }
#line 39
    tmp___15 = tmp___21;
  } else {
#line 39
    tmp___15 = strncmp((char const   *)(((conn + sid)->dat)->in_RequestURI), "/cgi-bin/",
                       9U);
  }
#line 39
  if (tmp___15 == 0) {
#line 39
    cgi_main();
  } else {
#line 40
    tmp___1 = sendfile(sid, file);
#line 40
    if (tmp___1 == 0) {
#line 40
      return;
    } else {
#line 41
      tmp___0 = dirlist(sid);
#line 41
      if (tmp___0 == 0) {
#line 41
        return;
      } else {
#line 43
        send_header(sid, 0, 200, (char *)"OK", (char *)"1", (char *)"text/html", -1,
                    -1L);
#line 44
        prints("<BR><CENTER>The file or function \'%s\' could not be found.</CENTER>\n",
               ((conn + sid)->dat)->in_RequestURI);
#line 45
        logerror("%s - Incorrect function call \'%s\'", ((conn + sid)->dat)->in_RemoteAddr,
                 ((conn + sid)->dat)->in_RequestURI);
      }
    }
  }
#line 47
  return;
}
}
#line 79 "main.c"
int main(int argc , char **argv ) 
{ 

  {
#line 81
  snprintf((char * __restrict  )(program_name), sizeof(program_name) - 1U, (char const   * __restrict  )"%s",
           *(argv + 0));
#line 82
  init();
#line 83
  accept_loop((void *)0);
#line 84
  return (0);
}
}
#line 1 "server.o"
#pragma merger(0,"/tmp/cil-BFrCpWHz.i","-Wall,-O2,-s")
#line 85 "/usr/include/fcntl.h"
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 221 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 753
extern void perror(char const   *__s ) ;
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 100 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 199
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 209
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 138 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 222 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 231
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 260
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 264
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 275
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 364
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize )  __attribute__((__nonnull__(1))) ;
#line 716
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 405 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 903
 __attribute__((__nothrow__)) int daemon(int nochdir , int noclose ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 269 "main.h"
void server_shutdown(void) ;
#line 270
int sockinit(void) ;
#line 24 "server.c"
static int ListenSocket  ;
#line 26 "server.c"
void logaccess(int loglevel , char const   *format  , ...) 
{ char logbuffer[1024] ;
  char timebuffer[100] ;
  char file[200] ;
  va_list ap ;
  FILE *fp ;
  struct timeval ttime ;
  struct timezone tzone ;
  struct tm *tmp ;

  {
#line 36
  if (loglevel > (int )config.server_loglevel) {
#line 36
    return;
  }
#line 37
  snprintf((char * __restrict  )(file), sizeof(file) - 1U, (char const   * __restrict  )"%s/access.log",
           config.server_etc_dir);
#line 38
  fixslashes(file);
#line 39
  fp = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"a");
#line 40
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
#line 41
    __builtin_va_start(ap, format);
#line 42
    vsnprintf((char * __restrict  )(logbuffer), sizeof(logbuffer) - 1U, (char const   * __restrict  )format,
              ap);
#line 43
    __builtin_va_end(ap);
#line 44
    gettimeofday((struct timeval * __restrict  )(& ttime), (struct timezone * __restrict  )(& tzone));
#line 45
    tmp = localtime((time_t const   *)(& ttime.tv_sec));
#line 45
    strftime((char * __restrict  )(timebuffer), sizeof(timebuffer), (char const   * __restrict  )"%b %d %H:%M:%S",
             (struct tm  const  * __restrict  )tmp);
#line 46
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s - [%d] %s\n",
            timebuffer, loglevel, logbuffer);
#line 47
    fclose(fp);
  }
#line 49
  return;
}
}
#line 51 "server.c"
void logerror(char const   *format  , ...) 
{ char logbuffer[1024] ;
  char timebuffer[100] ;
  char file[200] ;
  va_list ap ;
  FILE *fp ;
  struct timeval ttime ;
  struct timezone tzone ;
  struct tm *tmp ;

  {
#line 61
  snprintf((char * __restrict  )(file), sizeof(file) - 1U, (char const   * __restrict  )"%s/error.log",
           config.server_etc_dir);
#line 62
  fixslashes(file);
#line 63
  fp = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"a");
#line 64
  if ((unsigned int )fp != (unsigned int )((void *)0)) {
#line 65
    __builtin_va_start(ap, format);
#line 66
    vsnprintf((char * __restrict  )(logbuffer), sizeof(logbuffer) - 1U, (char const   * __restrict  )format,
              ap);
#line 67
    __builtin_va_end(ap);
#line 68
    gettimeofday((struct timeval * __restrict  )(& ttime), (struct timezone * __restrict  )(& tzone));
#line 69
    tmp = localtime((time_t const   *)(& ttime.tv_sec));
#line 69
    strftime((char * __restrict  )(timebuffer), sizeof(timebuffer), (char const   * __restrict  )"%b %d %H:%M:%S",
             (struct tm  const  * __restrict  )tmp);
#line 70
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s - %s\n", timebuffer,
            logbuffer);
#line 71
    fclose(fp);
  }
#line 73
  return;
}
}
#line 75 "server.c"
int getsid(void) 
{ int sid ;
  pthread_t tmp ;

  {
#line 79
  sid = 0;
#line 79
  while (sid < (int )config.server_maxconn) {
#line 80
    tmp = pthread_self();
#line 80
    if ((conn + sid)->id == tmp) {
#line 80
      break;
    }
#line 79
    sid ++;
  }
#line 82
  if (sid < 0) {
#line 83
    return (-1);
  } else {
#line 82
    if (sid >= (int )config.server_maxconn) {
#line 83
      return (-1);
    }
  }
#line 85
  return (sid);
}
}
#line 88 "server.c"
void flushheader(int sid ) 
{ char line[256] ;
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  size_t tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;

  {
#line 92
  if (((conn + sid)->dat)->out_headdone) {
#line 92
    return;
  }
#line 93
  if (! ((conn + sid)->dat)->out_status) {
#line 94
    ((conn + sid)->dat)->out_headdone = (short)1;
#line 95
    return;
  }
#line 100
  if (((conn + sid)->dat)->out_bodydone) {
#line 100
    if (! ((conn + sid)->dat)->out_flushed) {
#line 101
      tmp = strlen((char const   *)(((conn + sid)->dat)->out_ReplyData));
#line 101
      ((conn + sid)->dat)->out_ContentLength = (int )tmp;
    }
  }
#line 103
  tmp___0 = strcasecmp((char const   *)(((conn + sid)->dat)->in_Connection), "Keep-Alive");
#line 103
  if (tmp___0 == 0) {
#line 103
    if (((conn + sid)->dat)->out_bodydone) {
#line 104
      snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
               (char const   * __restrict  )"Keep-Alive");
    } else {
#line 106
      snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
               (char const   * __restrict  )"Close");
    }
  } else {
#line 106
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
             (char const   * __restrict  )"Close");
  }
#line 109
  tmp___1 = strcasestr(((conn + sid)->dat)->in_UserAgent, (char *)"MSIE");
#line 109
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
#line 110
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Connection), sizeof(((conn + sid)->dat)->out_Connection) - 1U,
             (char const   * __restrict  )"Close");
  }
#line 112
  tmp___2 = strcasestr(((conn + sid)->dat)->in_Protocol, (char *)"HTTP/1.1");
#line 112
  if ((unsigned int )tmp___2 != (unsigned int )((void *)0)) {
#line 113
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.1");
  } else {
#line 115
    snprintf((char * __restrict  )(((conn + sid)->dat)->out_Protocol), sizeof(((conn + sid)->dat)->out_Protocol) - 1U,
             (char const   * __restrict  )"HTTP/1.0");
  }
#line 117
  snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"%s %d OK\r\n",
           ((conn + sid)->dat)->out_Protocol, ((conn + sid)->dat)->out_status);
#line 118
  tmp___3 = strlen((char const   *)(line));
#line 118
  send((int )(conn + sid)->socket, (void const   *)(line), tmp___3, 0);
#line 119
  tmp___5 = strlen((char const   *)(((conn + sid)->dat)->out_CacheControl));
#line 119
  if (tmp___5) {
#line 120
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Cache-Control: %s\r\n",
             ((conn + sid)->dat)->out_CacheControl);
#line 121
    tmp___4 = strlen((char const   *)(line));
#line 121
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___4, 0);
  }
#line 123
  tmp___7 = strlen((char const   *)(((conn + sid)->dat)->out_Connection));
#line 123
  if (tmp___7) {
#line 124
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Connection: %s\r\n",
             ((conn + sid)->dat)->out_Connection);
#line 125
    tmp___6 = strlen((char const   *)(line));
#line 125
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___6, 0);
  }
#line 127
  if (((conn + sid)->dat)->out_bodydone) {
#line 128
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Content-Length: %d\r\n",
             ((conn + sid)->dat)->out_ContentLength);
#line 129
    tmp___8 = strlen((char const   *)(line));
#line 129
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___8, 0);
  }
#line 131
  tmp___10 = strlen((char const   *)(((conn + sid)->dat)->out_Date));
#line 131
  if (tmp___10) {
#line 132
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Date: %s\r\n",
             ((conn + sid)->dat)->out_Date);
#line 133
    tmp___9 = strlen((char const   *)(line));
#line 133
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___9, 0);
  }
#line 135
  tmp___12 = strlen((char const   *)(((conn + sid)->dat)->out_Expires));
#line 135
  if (tmp___12) {
#line 136
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Expires: %s\r\n",
             ((conn + sid)->dat)->out_Expires);
#line 137
    tmp___11 = strlen((char const   *)(line));
#line 137
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___11, 0);
  }
#line 139
  tmp___14 = strlen((char const   *)(((conn + sid)->dat)->out_LastModified));
#line 139
  if (tmp___14) {
#line 140
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Last-Modified: %s\r\n",
             ((conn + sid)->dat)->out_LastModified);
#line 141
    tmp___13 = strlen((char const   *)(line));
#line 141
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___13, 0);
  }
#line 143
  tmp___16 = strlen((char const   *)(((conn + sid)->dat)->out_Pragma));
#line 143
  if (tmp___16) {
#line 144
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Pragma: %s\r\n",
             ((conn + sid)->dat)->out_Pragma);
#line 145
    tmp___15 = strlen((char const   *)(line));
#line 145
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___15, 0);
  }
#line 147
  snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Server: %s\r\n",
           "Null httpd 0.5.0");
#line 148
  tmp___17 = strlen((char const   *)(line));
#line 148
  send((int )(conn + sid)->socket, (void const   *)(line), tmp___17, 0);
#line 149
  tmp___20 = strlen((char const   *)(((conn + sid)->dat)->out_ContentType));
#line 149
  if (tmp___20) {
#line 150
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Content-Type: %s\r\n\r\n",
             ((conn + sid)->dat)->out_ContentType);
#line 151
    tmp___18 = strlen((char const   *)(line));
#line 151
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___18, 0);
  } else {
#line 153
    snprintf((char * __restrict  )(line), sizeof(line) - 1U, (char const   * __restrict  )"Content-Type: text/plain\r\n\r\n");
#line 154
    tmp___19 = strlen((char const   *)(line));
#line 154
    send((int )(conn + sid)->socket, (void const   *)(line), tmp___19, 0);
  }
#line 156
  ((conn + sid)->dat)->out_headdone = (short)1;
#line 160
  return;
}
}
#line 163 "server.c"
void flushbuffer(int sid ) 
{ char *pTemp ;
  unsigned int dcount ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 165
  pTemp = ((conn + sid)->dat)->out_ReplyData;
#line 168
  flushheader(sid);
#line 169
  tmp = strlen((char const   *)pTemp);
#line 169
  if (tmp == 0U) {
#line 169
    return;
  }
#line 170
  ((conn + sid)->dat)->out_flushed = (short)1;
#line 171
  while (1) {
#line 171
    tmp___1 = strlen((char const   *)pTemp);
#line 171
    if (! tmp___1) {
#line 171
      break;
    }
#line 172
    dcount = 512U;
#line 173
    tmp___0 = strlen((char const   *)pTemp);
#line 173
    if (tmp___0 < dcount) {
#line 173
      dcount = strlen((char const   *)pTemp);
    }
#line 174
    send((int )(conn + sid)->socket, (void const   *)pTemp, dcount, 0);
#line 175
    pTemp += dcount;
  }
#line 177
  memset((void *)(((conn + sid)->dat)->out_ReplyData), 0, sizeof(((conn + sid)->dat)->out_ReplyData));
#line 178
  return;
}
}
#line 181 "server.c"
int prints(char const   *format  , ...) 
{ unsigned char buffer[2048] ;
  va_list ap ;
  int sid ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 185
  tmp = getsid();
#line 185
  sid = tmp;
#line 187
  if (sid == -1) {
#line 187
    return (-1);
  }
#line 188
  (conn + sid)->atime = time((time_t *)0);
#line 189
  __builtin_va_start(ap, format);
#line 190
  vsnprintf((char * __restrict  )(buffer), sizeof(buffer) - 1U, (char const   * __restrict  )format,
            ap);
#line 191
  __builtin_va_end(ap);
#line 192
  tmp___0 = strlen((char const   *)(((conn + sid)->dat)->out_ReplyData));
#line 192
  if (tmp___0 + sizeof(buffer) > 65534U) {
#line 193
    flushbuffer(sid);
  }
#line 195
  strcat((char * __restrict  )(((conn + sid)->dat)->out_ReplyData), (char const   * __restrict  )(buffer));
#line 196
  tmp___1 = strlen((char const   *)(((conn + sid)->dat)->out_ReplyData));
#line 196
  if (tmp___1 + sizeof(buffer) > 65534U) {
#line 197
    flushbuffer(sid);
  }
#line 199
  return (0);
}
}
#line 202 "server.c"
int sgets(char *buffer , int max , int fd ) 
{ int n ;
  int rc ;
  int sid ;
  int tmp ;

  {
#line 204
  n = 0;
#line 206
  tmp = getsid();
#line 206
  sid = tmp;
#line 208
  if (sid == -1) {
#line 208
    return (-1);
  }
#line 209
  (conn + sid)->atime = time((time_t *)0);
#line 210
  while (n < max) {
#line 211
    rc = recv((int )(conn + sid)->socket, (void *)buffer, 1U, 0);
#line 211
    if (rc < 0) {
#line 212
      ((conn + sid)->dat)->out_headdone = (short)1;
#line 213
      ((conn + sid)->dat)->out_bodydone = (short)1;
#line 214
      ((conn + sid)->dat)->out_flushed = (short)1;
#line 215
      ((conn + sid)->dat)->out_ReplyData[0] = (char )'\000';
#line 216
      closeconnect(sid, 1);
    } else {
#line 217
      if (rc != 1) {
#line 218
        n = - n;
#line 219
        break;
      }
    }
#line 221
    n ++;
#line 222
    if ((int )*buffer == 10) {
#line 223
      buffer ++;
#line 224
      break;
    }
#line 226
    buffer ++;
  }
#line 228
  *buffer = (char)0;
#line 229
  return (n);
}
}
#line 232 "server.c"
int closeconnect(int sid , int exitflag ) 
{ 

  {
#line 239
  flushbuffer(sid);
#line 247
  close((int )(conn + sid)->socket);
#line 249
  if (exitflag) {
#line 250
    logaccess(4, "Closing [%u][%u]", (conn + sid)->id, (conn + sid)->socket);
#line 254
    if ((unsigned int )(conn + sid)->PostData != (unsigned int )((void *)0)) {
#line 254
      free((void *)(conn + sid)->PostData);
    }
#line 255
    if ((unsigned int )(conn + sid)->dat != (unsigned int )((void *)0)) {
#line 255
      free((void *)(conn + sid)->dat);
    }
#line 256
    memset((void *)((char *)(conn + sid)), 0, sizeof(*(conn + sid)));
#line 257
    pthread_exit((void *)0);
  }
#line 259
  return (0);
}
}
#line 263
 __attribute__((__nothrow__)) int daemon(int nochdir , int noclose ) ;
#line 263 "server.c"
int daemon(int nochdir , int noclose ) 
{ int fd ;
  __pid_t tmp ;
  __pid_t tmp___0 ;

  {
#line 267
  tmp = fork();
#line 267
  switch (tmp) {
  case -1: 
#line 268
  return (-1);
  case 0: 
#line 269
  break;
  default: 
#line 270
  _exit(0);
  }
#line 272
  tmp___0 = setsid();
#line 272
  if (tmp___0 == -1) {
#line 272
    return (-1);
  }
#line 273
  if (noclose) {
#line 273
    return (0);
  }
#line 274
  fd = open("/dev/null", 2, 0);
#line 275
  if (fd != -1) {
#line 276
    dup2(fd, 0);
#line 277
    dup2(fd, 1);
#line 278
    dup2(fd, 2);
#line 279
    if (fd > 2) {
#line 279
      close(fd);
    }
  }
#line 281
  return (0);
}
}
#line 285 "server.c"
void server_shutdown(void) 
{ 

  {
#line 287
  logaccess(0, "Stopping %s", "Null httpd 0.5.0");
#line 288
  close(ListenSocket);
#line 289
  fflush(stdout);
#line 290
  exit(0);
}
}
#line 323 "server.c"
void setsigs(void) 
{ sigset_t blockmask ;
  sigset_t emptymask ;
  struct sigaction sa ;

  {
#line 340
  sigemptyset(& emptymask);
#line 341
  sigemptyset(& blockmask);
#line 342
  sigaddset(& blockmask, 17);
#line 343
  sigaddset(& blockmask, 1);
#line 344
  sigaddset(& blockmask, 14);
#line 345
  memset((void *)(& sa), 0, sizeof(sa));
#line 346
  sa.sa_mask = blockmask;
#line 347
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& server_shutdown);
#line 348
  sigaction(2, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 349
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))(& server_shutdown);
#line 350
  sigaction(15, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 351
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 352
  sigaction(17, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 353
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 354
  sigaction(13, (struct sigaction  const  * __restrict  )(& sa), (struct sigaction * __restrict  )((void *)0));
#line 356
  return;
}
}
#line 358 "server.c"
int sockinit(void) 
{ struct hostent *hp ;
  struct sockaddr_in sin ;
  int i ;
  register unsigned int __v ;
  register unsigned int __x ;
  int tmp ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 371
  printf((char const   * __restrict  )"Binding to \'http://%s:%d/\'...", config.server_hostname,
         config.server_port);
#line 372
  fflush(stdout);
#line 374
  ListenSocket = socket(2, 1, 0);
#line 375
  memset((void *)((char *)(& sin)), 0, sizeof(sin));
#line 376
  sin.sin_family = (unsigned short)2;
#line 377
  tmp = strcasecmp("ANY", (char const   *)(config.server_hostname));
#line 377
  if (tmp == 0) {
#line 378
    __x = 0U;
#line 378
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 378
    sin.sin_addr.s_addr = __v;
  } else {
#line 380
    hp = gethostbyname((char const   *)(config.server_hostname));
#line 381
    memmove((void *)((char *)(& sin.sin_addr)), (void const   *)*(hp->h_addr_list + 0),
            (unsigned int )hp->h_length);
  }
#line 383
  __x___0 = (unsigned short )config.server_port;
#line 383
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 383
  sin.sin_port = __v___0;
#line 384
  i = 0;
#line 385
  while (1) {
#line 385
    tmp___0 = bind(ListenSocket, (struct sockaddr  const  *)((struct sockaddr *)(& sin)),
                   sizeof(sin));
#line 385
    if (! (tmp___0 < 0)) {
#line 385
      break;
    }
#line 386
    sleep(5U);
#line 387
    i ++;
#line 388
    if (i > 6) {
#line 389
      logerror("bind() error [%s:%d]", config.server_hostname, config.server_port);
#line 393
      perror("\nBind error");
#line 395
      exit(0);
    }
  }
#line 398
  tmp___1 = listen(ListenSocket, 50);
#line 398
  if (tmp___1 < 0) {
#line 399
    logerror("listen() error");
#line 403
    close(ListenSocket);
#line 405
    exit(0);
  }
#line 408
  printf((char const   * __restrict  )"OK.\r\n");
#line 409
  daemon(0, 0);
#line 411
  setsigs();
#line 412
  return (0);
}
}
#line 447 "server.c"
void init(void) 
{ int tmp ;
  void *tmp___0 ;

  {
#line 449
  printf((char const   * __restrict  )"%s\r\n", "Null httpd 0.5.0");
#line 450
  pthread_mutex_init(& Lock.Crypt, (pthread_mutexattr_t const   *)((void *)0));
#line 451
  pthread_mutex_init(& Lock.Global, (pthread_mutexattr_t const   *)((void *)0));
#line 452
  pthread_mutex_init(& Lock.SQL, (pthread_mutexattr_t const   *)((void *)0));
#line 453
  tmp = config_read();
#line 453
  if (tmp != 0) {
#line 457
    printf((char const   * __restrict  )"\r\nError reading configuration file\r\n");
#line 459
    exit(0);
  }
#line 461
  logaccess(0, "Starting %s", "Null httpd 0.5.0");
#line 462
  tmp___0 = calloc((unsigned int )config.server_maxconn, sizeof(CONNECTION ));
#line 462
  conn = (CONNECTION *)tmp___0;
#line 463
  sockinit();
#line 464
  return;
}
}
#line 503 "server.c"
unsigned int htloop(void *x ) 
{ int sid ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 506
  sid = (int )x;
#line 508
  (conn + sid)->id = pthread_self();
#line 510
  pthread_detach((conn + sid)->id);
#line 512
  logaccess(4, "New client [%u][%u]", (conn + sid)->id, (conn + sid)->socket);
#line 513
  while (1) {
#line 514
    if ((unsigned int )(conn + sid)->PostData != (unsigned int )((void *)0)) {
#line 514
      free((void *)(conn + sid)->PostData);
    }
#line 515
    if ((unsigned int )(conn + sid)->dat != (unsigned int )((void *)0)) {
#line 515
      free((void *)(conn + sid)->dat);
    }
#line 516
    tmp = calloc(1U, sizeof(CONNDATA ));
#line 516
    (conn + sid)->dat = (CONNDATA *)tmp;
#line 517
    ((conn + sid)->dat)->out_ContentLength = -1;
#line 518
    (conn + sid)->atime = time((time_t *)0L);
#line 519
    (conn + sid)->ctime = time((time_t *)0L);
#line 520
    (conn + sid)->PostData = (char *)((void *)0);
#line 521
    dorequest(sid);
#line 523
    prints("\r\n\r\n");
#line 525
    ((conn + sid)->dat)->out_bodydone = (short)1;
#line 526
    flushbuffer(sid);
#line 527
    tmp___0 = strcasestr(((conn + sid)->dat)->out_Connection, (char *)"close");
#line 527
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 527
      break;
    }
  }
#line 529
  closeconnect(sid, 0);
#line 530
  logaccess(4, "Closing [%u][%u]", (conn + sid)->id, (conn + sid)->socket);
#line 534
  if ((unsigned int )(conn + sid)->PostData != (unsigned int )((void *)0)) {
#line 534
    free((void *)(conn + sid)->PostData);
  }
#line 535
  if ((unsigned int )(conn + sid)->dat != (unsigned int )((void *)0)) {
#line 535
    free((void *)(conn + sid)->dat);
  }
#line 536
  memset((void *)((char *)(conn + sid)), 0, sizeof(*(conn + sid)));
#line 537
  pthread_exit((void *)0);
#line 538
  return (0U);
}
}
#line 549 "server.c"
void accept_loop(void *x ) 
{ pthread_attr_t thr_attr ;
  int fromlen ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 555
  tmp = pthread_attr_init(& thr_attr);
#line 555
  if (tmp) {
#line 556
    logerror("pthread_attr_init()");
#line 557
    exit(1);
  }
#line 559
  tmp___0 = pthread_attr_setstacksize(& thr_attr, 65536U);
#line 559
  if (tmp___0) {
#line 560
    logerror("pthread_attr_setstacksize()");
#line 561
    exit(1);
  }
#line 563
  while (1) {
#line 564
    i = 0;
#line 564
    while (1) {
#line 565
      if (i >= (int )config.server_maxconn) {
#line 566
        sleep(1U);
#line 567
        i = 0;
        goto __Cont;
      }
#line 570
      if ((int )(conn + i)->socket == 0) {
#line 570
        break;
      }
      __Cont: /* CIL Label */ 
#line 564
      i ++;
    }
#line 572
    if ((unsigned int )(conn + i)->PostData != (unsigned int )((void *)0)) {
#line 572
      free((void *)(conn + i)->PostData);
    }
#line 573
    if ((unsigned int )(conn + i)->dat != (unsigned int )((void *)0)) {
#line 573
      free((void *)(conn + i)->dat);
    }
#line 574
    memset((void *)((char *)(conn + i)), 0, sizeof(*(conn + i)));
#line 575
    fromlen = (int )sizeof((conn + i)->ClientAddr);
#line 576
    tmp___1 = accept(ListenSocket, (struct sockaddr * __restrict  )((struct sockaddr *)(& (conn + i)->ClientAddr)),
                     (socklen_t * __restrict  )(& fromlen));
#line 576
    (conn + i)->socket = (short )tmp___1;
#line 584
    if (! ((int )(conn + i)->socket < 0)) {
#line 588
      (conn + i)->id = 1UL;
#line 589
      tmp___2 = pthread_create((pthread_t * __restrict  )(& (conn + i)->handle), (pthread_attr_t const   * __restrict  )(& thr_attr),
                               (void *(*)(void * ))(& htloop), (void * __restrict  )((void *)i));
#line 589
      if (tmp___2 == -1) {
#line 590
        logerror("htloop() failed...");
#line 591
        exit(0);
      }
    }
    __Cont___0: /* CIL Label */ ;
  }
#line 595
  return;
}
}
