/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

#line 43 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 105 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 214 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned long size_t;
#line 34 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 35 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 36 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 40 "/usr/include/bits/types.h"
typedef signed char __int8_t;
#line 41 "/usr/include/bits/types.h"
typedef unsigned char __uint8_t;
#line 42 "/usr/include/bits/types.h"
typedef short __int16_t;
#line 43 "/usr/include/bits/types.h"
typedef unsigned short __uint16_t;
#line 44 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 45 "/usr/include/bits/types.h"
typedef unsigned int __uint32_t;
#line 47 "/usr/include/bits/types.h"
typedef long __int64_t;
#line 48 "/usr/include/bits/types.h"
typedef unsigned long __uint64_t;
#line 56 "/usr/include/bits/types.h"
typedef long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long __u_quad_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __dev_t;
#line 138 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 141 "/usr/include/bits/types.h"
typedef unsigned long __ino64_t;
#line 142 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 143 "/usr/include/bits/types.h"
typedef unsigned long __nlink_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef long __off64_t;
#line 146 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 147 "/usr/include/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 147 "/usr/include/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 148 "/usr/include/bits/types.h"
typedef long __clock_t;
#line 149 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 150 "/usr/include/bits/types.h"
typedef unsigned long __rlim64_t;
#line 151 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 152 "/usr/include/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/bits/types.h"
typedef unsigned int __useconds_t;
#line 154 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 156 "/usr/include/bits/types.h"
typedef int __daddr_t;
#line 157 "/usr/include/bits/types.h"
typedef long __swblk_t;
#line 158 "/usr/include/bits/types.h"
typedef int __key_t;
#line 161 "/usr/include/bits/types.h"
typedef int __clockid_t;
#line 164 "/usr/include/bits/types.h"
typedef void *__timer_t;
#line 167 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 172 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 173 "/usr/include/bits/types.h"
typedef long __blkcnt64_t;
#line 176 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 177 "/usr/include/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 180 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 181 "/usr/include/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 183 "/usr/include/bits/types.h"
typedef long __ssize_t;
#line 187 "/usr/include/bits/types.h"
typedef __off64_t __loff_t;
#line 188 "/usr/include/bits/types.h"
typedef __quad_t *__qaddr_t;
#line 189 "/usr/include/bits/types.h"
typedef char *__caddr_t;
#line 192 "/usr/include/bits/types.h"
typedef long __intptr_t;
#line 195 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 62 "/usr/include/stdio.h"
typedef struct _IO_FILE __FILE;
#line 326 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h"
typedef int wchar_t;
#line 355 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/stddef.h"
typedef unsigned int wint_t;
#line 76 "/usr/include/wchar.h"
union __anonunion___value_3 {
   wint_t __wch ;
   char __wchb[4] ;
};
#line 76 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_2 {
   int __count ;
   union __anonunion___value_3 __value ;
};
#line 76 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_2 __mbstate_t;
#line 26 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos_t_4 {
   __off_t __pos ;
   __mbstate_t __state ;
};
#line 26 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos_t_4 _G_fpos_t;
#line 31 "/usr/include/_G_config.h"
struct __anonstruct__G_fpos64_t_5 {
   __off64_t __pos ;
   __mbstate_t __state ;
};
#line 31 "/usr/include/_G_config.h"
typedef struct __anonstruct__G_fpos64_t_5 _G_fpos64_t;
#line 37 "/usr/include/gconv.h"
enum __anonenum_6 {
    __GCONV_OK = 0,
    __GCONV_NOCONV = 1,
    __GCONV_NODB = 2,
    __GCONV_NOMEM = 3,
    __GCONV_EMPTY_INPUT = 4,
    __GCONV_FULL_OUTPUT = 5,
    __GCONV_ILLEGAL_INPUT = 6,
    __GCONV_INCOMPLETE_INPUT = 7,
    __GCONV_ILLEGAL_DESCRIPTOR = 8,
    __GCONV_INTERNAL_ERROR = 9
} ;
#line 55
enum __anonenum_7 {
    __GCONV_IS_LAST = 1,
    __GCONV_IGNORE_ERRORS = 2
} ;
#line 63
struct __gconv_step;
#line 63
struct __gconv_step;
#line 64
struct __gconv_step_data;
#line 64
struct __gconv_step_data;
#line 65
struct __gconv_loaded_object;
#line 65
struct __gconv_loaded_object;
#line 66
struct __gconv_trans_data;
#line 66
struct __gconv_trans_data;
#line 70 "/usr/include/gconv.h"
typedef int (*__gconv_fct)(struct __gconv_step * , struct __gconv_step_data * , unsigned char const   ** ,
                           unsigned char const   * , unsigned char ** , size_t * ,
                           int  , int  );
#line 75 "/usr/include/gconv.h"
typedef wint_t (*__gconv_btowc_fct)(struct __gconv_step * , unsigned char  );
#line 78 "/usr/include/gconv.h"
typedef int (*__gconv_init_fct)(struct __gconv_step * );
#line 79 "/usr/include/gconv.h"
typedef void (*__gconv_end_fct)(struct __gconv_step * );
#line 83 "/usr/include/gconv.h"
typedef int (*__gconv_trans_fct)(struct __gconv_step * , struct __gconv_step_data * ,
                                 void * , unsigned char const   * , unsigned char const   ** ,
                                 unsigned char const   * , unsigned char ** , size_t * );
#line 91 "/usr/include/gconv.h"
typedef int (*__gconv_trans_context_fct)(void * , unsigned char const   * , unsigned char const   * ,
                                         unsigned char * , unsigned char * );
#line 96 "/usr/include/gconv.h"
typedef int (*__gconv_trans_query_fct)(char const   * , char const   *** , size_t * );
#line 100 "/usr/include/gconv.h"
typedef int (*__gconv_trans_init_fct)(void ** , char const   * );
#line 101 "/usr/include/gconv.h"
typedef void (*__gconv_trans_end_fct)(void * );
#line 103 "/usr/include/gconv.h"
struct __gconv_trans_data {
   int (*__trans_fct)(struct __gconv_step * , struct __gconv_step_data * , void * ,
                      unsigned char const   * , unsigned char const   ** , unsigned char const   * ,
                      unsigned char ** , size_t * ) ;
   int (*__trans_context_fct)(void * , unsigned char const   * , unsigned char const   * ,
                              unsigned char * , unsigned char * ) ;
   void (*__trans_end_fct)(void * ) ;
   void *__data ;
   struct __gconv_trans_data *__next ;
};
#line 115 "/usr/include/gconv.h"
struct __gconv_step {
   struct __gconv_loaded_object *__shlib_handle ;
   char const   *__modname ;
   int __counter ;
   char *__from_name ;
   char *__to_name ;
   int (*__fct)(struct __gconv_step * , struct __gconv_step_data * , unsigned char const   ** ,
                unsigned char const   * , unsigned char ** , size_t * , int  , int  ) ;
   wint_t (*__btowc_fct)(struct __gconv_step * , unsigned char  ) ;
   int (*__init_fct)(struct __gconv_step * ) ;
   void (*__end_fct)(struct __gconv_step * ) ;
   int __min_needed_from ;
   int __max_needed_from ;
   int __min_needed_to ;
   int __max_needed_to ;
   int __stateful ;
   void *__data ;
};
#line 145 "/usr/include/gconv.h"
struct __gconv_step_data {
   unsigned char *__outbuf ;
   unsigned char *__outbufend ;
   int __flags ;
   int __invocation_counter ;
   int __internal_use ;
   __mbstate_t *__statep ;
   __mbstate_t __state ;
   struct __gconv_trans_data *__trans ;
};
#line 172 "/usr/include/gconv.h"
struct __gconv_info {
   size_t __nsteps ;
   struct __gconv_step *__steps ;
   struct __gconv_step_data __data[] ;
};
#line 172 "/usr/include/gconv.h"
typedef struct __gconv_info *__gconv_t;
#line 45 "/usr/include/_G_config.h"
struct __anonstruct___combined_9 {
   struct __gconv_info __cd ;
   struct __gconv_step_data __data ;
};
#line 45 "/usr/include/_G_config.h"
union __anonunion__G_iconv_t_8 {
   struct __gconv_info __cd ;
   struct __anonstruct___combined_9 __combined ;
};
#line 45 "/usr/include/_G_config.h"
typedef union __anonunion__G_iconv_t_8 _G_iconv_t;
#line 55 "/usr/include/_G_config.h"
typedef short _G_int16_t;
#line 56 "/usr/include/_G_config.h"
typedef int _G_int32_t;
#line 57 "/usr/include/_G_config.h"
typedef unsigned short _G_uint16_t;
#line 58 "/usr/include/_G_config.h"
typedef unsigned int _G_uint32_t;
#line 167 "/usr/include/libio.h"
struct _IO_jump_t;
#line 167
struct _IO_jump_t;
#line 167
struct _IO_FILE;
#line 177 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 183 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 203
enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3
} ;
#line 268 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 338 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 341
struct _IO_FILE_plus;
#line 341
struct _IO_FILE_plus;
#line 361 "/usr/include/libio.h"
typedef __ssize_t __io_read_fn(void *__cookie , char *__buf , size_t __nbytes );
#line 369 "/usr/include/libio.h"
typedef __ssize_t __io_write_fn(void *__cookie , char const   *__buf , size_t __n );
#line 378 "/usr/include/libio.h"
typedef int __io_seek_fn(void *__cookie , __off64_t *__pos , int __w );
#line 381 "/usr/include/libio.h"
typedef int __io_close_fn(void *__cookie );
#line 386 "/usr/include/libio.h"
typedef __io_read_fn cookie_read_function_t;
#line 387 "/usr/include/libio.h"
typedef __io_write_fn cookie_write_function_t;
#line 388 "/usr/include/libio.h"
typedef __io_seek_fn cookie_seek_function_t;
#line 389 "/usr/include/libio.h"
typedef __io_close_fn cookie_close_function_t;
#line 392 "/usr/include/libio.h"
struct __anonstruct__IO_cookie_io_functions_t_10 {
   __io_read_fn *read ;
   __io_write_fn *write ;
   __io_seek_fn *seek ;
   __io_close_fn *close ;
};
#line 392 "/usr/include/libio.h"
typedef struct __anonstruct__IO_cookie_io_functions_t_10 _IO_cookie_io_functions_t;
#line 399 "/usr/include/libio.h"
typedef _IO_cookie_io_functions_t cookie_io_functions_t;
#line 401
struct _IO_cookie_file;
#line 401
struct _IO_cookie_file;
#line 90 "/usr/include/stdio.h"
typedef _G_fpos64_t fpos_t;
#line 94 "/usr/include/stdio.h"
typedef _G_fpos64_t fpos64_t;
#line 797
struct obstack;
#line 797
struct obstack;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_11 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_12 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_11 __wait_terminated ;
   struct __anonstruct___wait_stopped_12 __wait_stopped ;
};
#line 68 "/usr/include/stdlib.h"
union __anonunion___WAIT_STATUS_13 {
   union wait *__uptr ;
   int *__iptr ;
};
#line 68 "/usr/include/stdlib.h"
typedef union __anonunion___WAIT_STATUS_13  __attribute__((__transparent_union__)) __WAIT_STATUS;
#line 98 "/usr/include/stdlib.h"
struct __anonstruct_div_t_14 {
   int quot ;
   int rem ;
};
#line 98 "/usr/include/stdlib.h"
typedef struct __anonstruct_div_t_14 div_t;
#line 106 "/usr/include/stdlib.h"
struct __anonstruct_ldiv_t_15 {
   long quot ;
   long rem ;
};
#line 106 "/usr/include/stdlib.h"
typedef struct __anonstruct_ldiv_t_15 ldiv_t;
#line 118 "/usr/include/stdlib.h"
struct __anonstruct_lldiv_t_16 {
   long long quot ;
   long long rem ;
};
#line 118 "/usr/include/stdlib.h"
typedef struct __anonstruct_lldiv_t_16 lldiv_t;
#line 28 "/usr/include/xlocale.h"
struct locale_data;
#line 28 "/usr/include/xlocale.h"
struct __locale_struct {
   struct locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 28 "/usr/include/xlocale.h"
typedef struct __locale_struct *__locale_t;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 39 "/usr/include/sys/types.h"
typedef __quad_t quad_t;
#line 40 "/usr/include/sys/types.h"
typedef __u_quad_t u_quad_t;
#line 41 "/usr/include/sys/types.h"
typedef __fsid_t fsid_t;
#line 46 "/usr/include/sys/types.h"
typedef __loff_t loff_t;
#line 52 "/usr/include/sys/types.h"
typedef __ino64_t ino_t;
#line 57 "/usr/include/sys/types.h"
typedef __ino64_t ino64_t;
#line 62 "/usr/include/sys/types.h"
typedef __dev_t dev_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 77 "/usr/include/sys/types.h"
typedef __nlink_t nlink_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 90 "/usr/include/sys/types.h"
typedef __off64_t off_t;
#line 95 "/usr/include/sys/types.h"
typedef __off64_t off64_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 105 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 116 "/usr/include/sys/types.h"
typedef __daddr_t daddr_t;
#line 117 "/usr/include/sys/types.h"
typedef __caddr_t caddr_t;
#line 123 "/usr/include/sys/types.h"
typedef __key_t key_t;
#line 61 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 93 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 105 "/usr/include/time.h"
typedef __timer_t timer_t;
#line 137 "/usr/include/sys/types.h"
typedef __useconds_t useconds_t;
#line 141 "/usr/include/sys/types.h"
typedef __suseconds_t suseconds_t;
#line 151 "/usr/include/sys/types.h"
typedef unsigned long ulong;
#line 152 "/usr/include/sys/types.h"
typedef unsigned short ushort;
#line 153 "/usr/include/sys/types.h"
typedef unsigned int uint;
#line 195 "/usr/include/sys/types.h"
typedef char int8_t;
#line 196 "/usr/include/sys/types.h"
typedef short int16_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 198 "/usr/include/sys/types.h"
typedef long long int64_t;
#line 201 "/usr/include/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 204 "/usr/include/sys/types.h"
typedef unsigned long long u_int64_t;
#line 206 "/usr/include/sys/types.h"
typedef int register_t;
#line 23 "/usr/include/bits/sigset.h"
typedef int __sig_atomic_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_17 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_17 __sigset_t;
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_18 {
   __fd_mask fds_bits[1024UL / (8UL * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_18 fd_set;
#line 85 "/usr/include/sys/select.h"
typedef __fd_mask fd_mask;
#line 228 "/usr/include/sys/types.h"
typedef __blksize_t blksize_t;
#line 248 "/usr/include/sys/types.h"
typedef __blkcnt64_t blkcnt_t;
#line 252 "/usr/include/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt_t;
#line 256 "/usr/include/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt_t;
#line 262 "/usr/include/sys/types.h"
typedef __blkcnt64_t blkcnt64_t;
#line 263 "/usr/include/sys/types.h"
typedef __fsblkcnt64_t fsblkcnt64_t;
#line 264 "/usr/include/sys/types.h"
typedef __fsfilcnt64_t fsfilcnt64_t;
#line 50 "/usr/include/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 53 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_attr_t_19 {
   char __size[56] ;
   long __align ;
};
#line 53 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_attr_t_19 pthread_attr_t;
#line 61 "/usr/include/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 61 "/usr/include/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 76 "/usr/include/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_20 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 76 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_20 pthread_mutex_t;
#line 106 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_21 {
   char __size[4] ;
   int __align ;
};
#line 106 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_21 pthread_mutexattr_t;
#line 115 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_23 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 115 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_22 {
   struct __anonstruct___data_23 __data ;
   char __size[48] ;
   long long __align ;
};
#line 115 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_22 pthread_cond_t;
#line 132 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_24 {
   char __size[4] ;
   int __align ;
};
#line 132 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_24 pthread_condattr_t;
#line 140 "/usr/include/bits/pthreadtypes.h"
typedef unsigned int pthread_key_t;
#line 144 "/usr/include/bits/pthreadtypes.h"
typedef int pthread_once_t;
#line 150 "/usr/include/bits/pthreadtypes.h"
struct __anonstruct___data_26 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   int __writer ;
   int __pad1 ;
   unsigned long __pad2 ;
   unsigned long __pad3 ;
   unsigned int __flags ;
};
#line 150 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlock_t_25 {
   struct __anonstruct___data_26 __data ;
   char __size[56] ;
   long __align ;
};
#line 150 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlock_t_25 pthread_rwlock_t;
#line 188 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_rwlockattr_t_27 {
   char __size[8] ;
   long __align ;
};
#line 188 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_rwlockattr_t_27 pthread_rwlockattr_t;
#line 198 "/usr/include/bits/pthreadtypes.h"
typedef int volatile   pthread_spinlock_t;
#line 203 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_barrier_t_28 {
   char __size[32] ;
   long __align ;
};
#line 203 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrier_t_28 pthread_barrier_t;
#line 209 "/usr/include/bits/pthreadtypes.h"
union __anonunion_pthread_barrierattr_t_29 {
   char __size[4] ;
   int __align ;
};
#line 209 "/usr/include/bits/pthreadtypes.h"
typedef union __anonunion_pthread_barrierattr_t_29 pthread_barrierattr_t;
#line 467 "/usr/include/stdlib.h"
struct random_data {
   int32_t *fptr ;
   int32_t *rptr ;
   int32_t *state ;
   int rand_type ;
   int rand_deg ;
   int rand_sep ;
   int32_t *end_ptr ;
};
#line 536 "/usr/include/stdlib.h"
struct drand48_data {
   unsigned short __x[3] ;
   unsigned short __old_x[3] ;
   unsigned short __c ;
   unsigned short __init ;
   unsigned long long __a ;
};
#line 764 "/usr/include/stdlib.h"
typedef int (*__compar_fn_t)(void const   * , void const   * );
#line 767 "/usr/include/stdlib.h"
typedef int (*comparison_fn_t)(void const   * , void const   * );
#line 238 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 26 "/usr/include/bits/confname.h"
enum __anonenum_30 {
    _PC_LINK_MAX = 0,
    _PC_MAX_CANON = 1,
    _PC_MAX_INPUT = 2,
    _PC_NAME_MAX = 3,
    _PC_PATH_MAX = 4,
    _PC_PIPE_BUF = 5,
    _PC_CHOWN_RESTRICTED = 6,
    _PC_NO_TRUNC = 7,
    _PC_VDISABLE = 8,
    _PC_SYNC_IO = 9,
    _PC_ASYNC_IO = 10,
    _PC_PRIO_IO = 11,
    _PC_SOCK_MAXBUF = 12,
    _PC_FILESIZEBITS = 13,
    _PC_REC_INCR_XFER_SIZE = 14,
    _PC_REC_MAX_XFER_SIZE = 15,
    _PC_REC_MIN_XFER_SIZE = 16,
    _PC_REC_XFER_ALIGN = 17,
    _PC_ALLOC_SIZE_MIN = 18,
    _PC_SYMLINK_MAX = 19,
    _PC_2_SYMLINKS = 20
} ;
#line 73
enum __anonenum_31 {
    _SC_ARG_MAX = 0,
    _SC_CHILD_MAX = 1,
    _SC_CLK_TCK = 2,
    _SC_NGROUPS_MAX = 3,
    _SC_OPEN_MAX = 4,
    _SC_STREAM_MAX = 5,
    _SC_TZNAME_MAX = 6,
    _SC_JOB_CONTROL = 7,
    _SC_SAVED_IDS = 8,
    _SC_REALTIME_SIGNALS = 9,
    _SC_PRIORITY_SCHEDULING = 10,
    _SC_TIMERS = 11,
    _SC_ASYNCHRONOUS_IO = 12,
    _SC_PRIORITIZED_IO = 13,
    _SC_SYNCHRONIZED_IO = 14,
    _SC_FSYNC = 15,
    _SC_MAPPED_FILES = 16,
    _SC_MEMLOCK = 17,
    _SC_MEMLOCK_RANGE = 18,
    _SC_MEMORY_PROTECTION = 19,
    _SC_MESSAGE_PASSING = 20,
    _SC_SEMAPHORES = 21,
    _SC_SHARED_MEMORY_OBJECTS = 22,
    _SC_AIO_LISTIO_MAX = 23,
    _SC_AIO_MAX = 24,
    _SC_AIO_PRIO_DELTA_MAX = 25,
    _SC_DELAYTIMER_MAX = 26,
    _SC_MQ_OPEN_MAX = 27,
    _SC_MQ_PRIO_MAX = 28,
    _SC_VERSION = 29,
    _SC_PAGESIZE = 30,
    _SC_RTSIG_MAX = 31,
    _SC_SEM_NSEMS_MAX = 32,
    _SC_SEM_VALUE_MAX = 33,
    _SC_SIGQUEUE_MAX = 34,
    _SC_TIMER_MAX = 35,
    _SC_BC_BASE_MAX = 36,
    _SC_BC_DIM_MAX = 37,
    _SC_BC_SCALE_MAX = 38,
    _SC_BC_STRING_MAX = 39,
    _SC_COLL_WEIGHTS_MAX = 40,
    _SC_EQUIV_CLASS_MAX = 41,
    _SC_EXPR_NEST_MAX = 42,
    _SC_LINE_MAX = 43,
    _SC_RE_DUP_MAX = 44,
    _SC_CHARCLASS_NAME_MAX = 45,
    _SC_2_VERSION = 46,
    _SC_2_C_BIND = 47,
    _SC_2_C_DEV = 48,
    _SC_2_FORT_DEV = 49,
    _SC_2_FORT_RUN = 50,
    _SC_2_SW_DEV = 51,
    _SC_2_LOCALEDEF = 52,
    _SC_PII = 53,
    _SC_PII_XTI = 54,
    _SC_PII_SOCKET = 55,
    _SC_PII_INTERNET = 56,
    _SC_PII_OSI = 57,
    _SC_POLL = 58,
    _SC_SELECT = 59,
    _SC_UIO_MAXIOV = 60,
    _SC_IOV_MAX = 60,
    _SC_PII_INTERNET_STREAM = 61,
    _SC_PII_INTERNET_DGRAM = 62,
    _SC_PII_OSI_COTS = 63,
    _SC_PII_OSI_CLTS = 64,
    _SC_PII_OSI_M = 65,
    _SC_T_IOV_MAX = 66,
    _SC_THREADS = 67,
    _SC_THREAD_SAFE_FUNCTIONS = 68,
    _SC_GETGR_R_SIZE_MAX = 69,
    _SC_GETPW_R_SIZE_MAX = 70,
    _SC_LOGIN_NAME_MAX = 71,
    _SC_TTY_NAME_MAX = 72,
    _SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
    _SC_THREAD_KEYS_MAX = 74,
    _SC_THREAD_STACK_MIN = 75,
    _SC_THREAD_THREADS_MAX = 76,
    _SC_THREAD_ATTR_STACKADDR = 77,
    _SC_THREAD_ATTR_STACKSIZE = 78,
    _SC_THREAD_PRIORITY_SCHEDULING = 79,
    _SC_THREAD_PRIO_INHERIT = 80,
    _SC_THREAD_PRIO_PROTECT = 81,
    _SC_THREAD_PROCESS_SHARED = 82,
    _SC_NPROCESSORS_CONF = 83,
    _SC_NPROCESSORS_ONLN = 84,
    _SC_PHYS_PAGES = 85,
    _SC_AVPHYS_PAGES = 86,
    _SC_ATEXIT_MAX = 87,
    _SC_PASS_MAX = 88,
    _SC_XOPEN_VERSION = 89,
    _SC_XOPEN_XCU_VERSION = 90,
    _SC_XOPEN_UNIX = 91,
    _SC_XOPEN_CRYPT = 92,
    _SC_XOPEN_ENH_I18N = 93,
    _SC_XOPEN_SHM = 94,
    _SC_2_CHAR_TERM = 95,
    _SC_2_C_VERSION = 96,
    _SC_2_UPE = 97,
    _SC_XOPEN_XPG2 = 98,
    _SC_XOPEN_XPG3 = 99,
    _SC_XOPEN_XPG4 = 100,
    _SC_CHAR_BIT = 101,
    _SC_CHAR_MAX = 102,
    _SC_CHAR_MIN = 103,
    _SC_INT_MAX = 104,
    _SC_INT_MIN = 105,
    _SC_LONG_BIT = 106,
    _SC_WORD_BIT = 107,
    _SC_MB_LEN_MAX = 108,
    _SC_NZERO = 109,
    _SC_SSIZE_MAX = 110,
    _SC_SCHAR_MAX = 111,
    _SC_SCHAR_MIN = 112,
    _SC_SHRT_MAX = 113,
    _SC_SHRT_MIN = 114,
    _SC_UCHAR_MAX = 115,
    _SC_UINT_MAX = 116,
    _SC_ULONG_MAX = 117,
    _SC_USHRT_MAX = 118,
    _SC_NL_ARGMAX = 119,
    _SC_NL_LANGMAX = 120,
    _SC_NL_MSGMAX = 121,
    _SC_NL_NMAX = 122,
    _SC_NL_SETMAX = 123,
    _SC_NL_TEXTMAX = 124,
    _SC_XBS5_ILP32_OFF32 = 125,
    _SC_XBS5_ILP32_OFFBIG = 126,
    _SC_XBS5_LP64_OFF64 = 127,
    _SC_XBS5_LPBIG_OFFBIG = 128,
    _SC_XOPEN_LEGACY = 129,
    _SC_XOPEN_REALTIME = 130,
    _SC_XOPEN_REALTIME_THREADS = 131,
    _SC_ADVISORY_INFO = 132,
    _SC_BARRIERS = 133,
    _SC_BASE = 134,
    _SC_C_LANG_SUPPORT = 135,
    _SC_C_LANG_SUPPORT_R = 136,
    _SC_CLOCK_SELECTION = 137,
    _SC_CPUTIME = 138,
    _SC_THREAD_CPUTIME = 139,
    _SC_DEVICE_IO = 140,
    _SC_DEVICE_SPECIFIC = 141,
    _SC_DEVICE_SPECIFIC_R = 142,
    _SC_FD_MGMT = 143,
    _SC_FIFO = 144,
    _SC_PIPE = 145,
    _SC_FILE_ATTRIBUTES = 146,
    _SC_FILE_LOCKING = 147,
    _SC_FILE_SYSTEM = 148,
    _SC_MONOTONIC_CLOCK = 149,
    _SC_MULTI_PROCESS = 150,
    _SC_SINGLE_PROCESS = 151,
    _SC_NETWORKING = 152,
    _SC_READER_WRITER_LOCKS = 153,
    _SC_SPIN_LOCKS = 154,
    _SC_REGEXP = 155,
    _SC_REGEX_VERSION = 156,
    _SC_SHELL = 157,
    _SC_SIGNALS = 158,
    _SC_SPAWN = 159,
    _SC_SPORADIC_SERVER = 160,
    _SC_THREAD_SPORADIC_SERVER = 161,
    _SC_SYSTEM_DATABASE = 162,
    _SC_SYSTEM_DATABASE_R = 163,
    _SC_TIMEOUTS = 164,
    _SC_TYPED_MEMORY_OBJECTS = 165,
    _SC_USER_GROUPS = 166,
    _SC_USER_GROUPS_R = 167,
    _SC_2_PBS = 168,
    _SC_2_PBS_ACCOUNTING = 169,
    _SC_2_PBS_LOCATE = 170,
    _SC_2_PBS_MESSAGE = 171,
    _SC_2_PBS_TRACK = 172,
    _SC_SYMLOOP_MAX = 173,
    _SC_STREAMS = 174,
    _SC_2_PBS_CHECKPOINT = 175,
    _SC_V6_ILP32_OFF32 = 176,
    _SC_V6_ILP32_OFFBIG = 177,
    _SC_V6_LP64_OFF64 = 178,
    _SC_V6_LPBIG_OFFBIG = 179,
    _SC_HOST_NAME_MAX = 180,
    _SC_TRACE = 181,
    _SC_TRACE_EVENT_FILTER = 182,
    _SC_TRACE_INHERIT = 183,
    _SC_TRACE_LOG = 184,
    _SC_LEVEL1_ICACHE_SIZE = 185,
    _SC_LEVEL1_ICACHE_ASSOC = 186,
    _SC_LEVEL1_ICACHE_LINESIZE = 187,
    _SC_LEVEL1_DCACHE_SIZE = 188,
    _SC_LEVEL1_DCACHE_ASSOC = 189,
    _SC_LEVEL1_DCACHE_LINESIZE = 190,
    _SC_LEVEL2_CACHE_SIZE = 191,
    _SC_LEVEL2_CACHE_ASSOC = 192,
    _SC_LEVEL2_CACHE_LINESIZE = 193,
    _SC_LEVEL3_CACHE_SIZE = 194,
    _SC_LEVEL3_CACHE_ASSOC = 195,
    _SC_LEVEL3_CACHE_LINESIZE = 196,
    _SC_LEVEL4_CACHE_SIZE = 197,
    _SC_LEVEL4_CACHE_ASSOC = 198,
    _SC_LEVEL4_CACHE_LINESIZE = 199,
    _SC_IPV6 = 235,
    _SC_RAW_SOCKETS = 236
} ;
#line 506
enum __anonenum_32 {
    _CS_PATH = 0,
    _CS_V6_WIDTH_RESTRICTED_ENVS = 1,
    _CS_GNU_LIBC_VERSION = 2,
    _CS_GNU_LIBPTHREAD_VERSION = 3,
    _CS_LFS_CFLAGS = 1000,
    _CS_LFS_LDFLAGS = 1001,
    _CS_LFS_LIBS = 1002,
    _CS_LFS_LINTFLAGS = 1003,
    _CS_LFS64_CFLAGS = 1004,
    _CS_LFS64_LDFLAGS = 1005,
    _CS_LFS64_LIBS = 1006,
    _CS_LFS64_LINTFLAGS = 1007,
    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
    _CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
    _CS_XBS5_ILP32_OFF32_LIBS = 1102,
    _CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
    _CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
    _CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
    _CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
    _CS_XBS5_LP64_OFF64_CFLAGS = 1108,
    _CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
    _CS_XBS5_LP64_OFF64_LIBS = 1110,
    _CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
    _CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
    _CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
    _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
    _CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
    _CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
    _CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
    _CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
    _CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
} ;
#line 48 "/usr/include/ctype.h"
enum __anonenum_33 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8
} ;
#line 27 "/usr/include/bits/locale.h"
enum __anonenum_34 {
    __LC_CTYPE = 0,
    __LC_NUMERIC = 1,
    __LC_TIME = 2,
    __LC_COLLATE = 3,
    __LC_MONETARY = 4,
    __LC_MESSAGES = 5,
    __LC_ALL = 6,
    __LC_PAPER = 7,
    __LC_NAME = 8,
    __LC_ADDRESS = 9,
    __LC_TELEPHONE = 10,
    __LC_MEASUREMENT = 11,
    __LC_IDENTIFICATION = 12
} ;
#line 52 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 148 "/usr/include/locale.h"
typedef __locale_t locale_t;
#line 69 "/usr/include/errno.h"
typedef int error_t;
#line 44 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 155 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 170 "/usr/include/bits/fcntl.h"
struct flock64 {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 43 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 116 "/usr/include/bits/stat.h"
struct stat64 {
   __dev_t st_dev ;
   __ino64_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
#line 31 "/usr/include/bits/mathdef.h"
typedef float float_t;
#line 32 "/usr/include/bits/mathdef.h"
typedef double double_t;
#line 198 "/usr/include/math.h"
enum __anonenum_35 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4
} ;
#line 284
enum __anonenum__LIB_VERSION_TYPE_36 {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3
} ;
#line 284 "/usr/include/math.h"
typedef enum __anonenum__LIB_VERSION_TYPE_36 _LIB_VERSION_TYPE;
#line 309 "/usr/include/math.h"
struct exception {
   int type ;
   char *name ;
   double arg1 ;
   double arg2 ;
   double retval ;
};
#line 38 "/usr/include/bits/mathinline.h"
union __anonunion___u_37 {
   float __f ;
   int __i ;
};
#line 44 "/usr/include/bits/mathinline.h"
union __anonunion___u_38 {
   double __d ;
   int __i[2] ;
};
#line 50 "/usr/include/bits/mathinline.h"
union __anonunion___u_39 {
   long double __l ;
   int __i[3] ;
};
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 162 "/usr/include/time.h"
struct itimerspec {
   struct timespec it_interval ;
   struct timespec it_value ;
};
#line 169
struct sigevent;
#line 169
struct sigevent;
#line 41 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 196 "/usr/include/signal.h"
typedef void (*sighandler_t)(int  );
#line 201 "/usr/include/signal.h"
typedef void (*sig_t)(int  );
#line 33 "/usr/include/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 33 "/usr/include/bits/siginfo.h"
typedef union sigval sigval_t;
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__kill_41 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__timer_42 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__rt_43 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigchld_44 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigfault_45 {
   void *si_addr ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigpoll_46 {
   long si_band ;
   int si_fd ;
};
#line 51 "/usr/include/bits/siginfo.h"
union __anonunion__sifields_40 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_41 _kill ;
   struct __anonstruct__timer_42 _timer ;
   struct __anonstruct__rt_43 _rt ;
   struct __anonstruct__sigchld_44 _sigchld ;
   struct __anonstruct__sigfault_45 _sigfault ;
   struct __anonstruct__sigpoll_46 _sigpoll ;
};
#line 51 "/usr/include/bits/siginfo.h"
struct siginfo {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_40 _sifields ;
};
#line 51 "/usr/include/bits/siginfo.h"
typedef struct siginfo siginfo_t;
#line 129
enum __anonenum_47 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128
} ;
#line 153
enum __anonenum_48 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8
} ;
#line 174
enum __anonenum_49 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8
} ;
#line 195
enum __anonenum_50 {
    SEGV_MAPERR = 1,
    SEGV_ACCERR = 2
} ;
#line 204
enum __anonenum_51 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3
} ;
#line 215
enum __anonenum_52 {
    TRAP_BRKPT = 1,
    TRAP_TRACE = 2
} ;
#line 224
enum __anonenum_53 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6
} ;
#line 241
enum __anonenum_54 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6
} ;
#line 273 "/usr/include/bits/siginfo.h"
struct __anonstruct__sigev_thread_56 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
#line 273 "/usr/include/bits/siginfo.h"
union __anonunion__sigev_un_55 {
   int _pad[64UL / sizeof(int ) - 4UL] ;
   __pid_t _tid ;
   struct __anonstruct__sigev_thread_56 _sigev_thread ;
};
#line 273 "/usr/include/bits/siginfo.h"
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion__sigev_un_55 _sigev_un ;
};
#line 273 "/usr/include/bits/siginfo.h"
typedef struct sigevent sigevent_t;
#line 300
enum __anonenum_57 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4
} ;
#line 25 "/usr/include/bits/sigaction.h"
union __anonunion___sigaction_handler_58 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 25 "/usr/include/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_58 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 308 "/usr/include/signal.h"
struct sigvec {
   void (*sv_handler)(int  ) ;
   int sv_mask ;
   int sv_flags ;
};
#line 28 "/usr/include/bits/sigcontext.h"
struct _fpreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
};
#line 34 "/usr/include/bits/sigcontext.h"
struct _fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 41 "/usr/include/bits/sigcontext.h"
struct _xmmreg {
   __uint32_t element[4] ;
};
#line 109 "/usr/include/bits/sigcontext.h"
struct _fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _fpxreg _st[8] ;
   struct _xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 125 "/usr/include/bits/sigcontext.h"
struct sigcontext {
   unsigned long r8 ;
   unsigned long r9 ;
   unsigned long r10 ;
   unsigned long r11 ;
   unsigned long r12 ;
   unsigned long r13 ;
   unsigned long r14 ;
   unsigned long r15 ;
   unsigned long rdi ;
   unsigned long rsi ;
   unsigned long rbp ;
   unsigned long rbx ;
   unsigned long rdx ;
   unsigned long rax ;
   unsigned long rcx ;
   unsigned long rsp ;
   unsigned long rip ;
   unsigned long eflags ;
   unsigned short cs ;
   unsigned short gs ;
   unsigned short fs ;
   unsigned short __pad0 ;
   unsigned long err ;
   unsigned long trapno ;
   unsigned long oldmask ;
   unsigned long cr2 ;
   struct _fpstate *fpstate ;
   unsigned long __reserved1[8] ;
};
#line 26 "/usr/include/bits/sigstack.h"
struct sigstack {
   void *ss_sp ;
   int ss_onstack ;
};
#line 34
enum __anonenum_59 {
    SS_ONSTACK = 1,
    SS_DISABLE = 2
} ;
#line 50 "/usr/include/bits/sigstack.h"
struct sigaltstack {
   void *ss_sp ;
   int ss_flags ;
   size_t ss_size ;
};
#line 50 "/usr/include/bits/sigstack.h"
typedef struct sigaltstack stack_t;
#line 33 "/usr/include/sys/ucontext.h"
typedef long greg_t;
#line 39 "/usr/include/sys/ucontext.h"
typedef greg_t gregset_t[23];
#line 43
enum __anonenum_60 {
    REG_R8 = 0,
    REG_R9 = 1,
    REG_R10 = 2,
    REG_R11 = 3,
    REG_R12 = 4,
    REG_R13 = 5,
    REG_R14 = 6,
    REG_R15 = 7,
    REG_RDI = 8,
    REG_RSI = 9,
    REG_RBP = 10,
    REG_RBX = 11,
    REG_RDX = 12,
    REG_RAX = 13,
    REG_RCX = 14,
    REG_RSP = 15,
    REG_RIP = 16,
    REG_EFL = 17,
    REG_CSGSFS = 18,
    REG_ERR = 19,
    REG_TRAPNO = 20,
    REG_OLDMASK = 21,
    REG_CR2 = 22
} ;
#line 94 "/usr/include/sys/ucontext.h"
struct _libc_fpxreg {
   unsigned short significand[4] ;
   unsigned short exponent ;
   unsigned short padding[3] ;
};
#line 101 "/usr/include/sys/ucontext.h"
struct _libc_xmmreg {
   __uint32_t element[4] ;
};
#line 106 "/usr/include/sys/ucontext.h"
struct _libc_fpstate {
   __uint16_t cwd ;
   __uint16_t swd ;
   __uint16_t ftw ;
   __uint16_t fop ;
   __uint64_t rip ;
   __uint64_t rdp ;
   __uint32_t mxcsr ;
   __uint32_t mxcr_mask ;
   struct _libc_fpxreg _st[8] ;
   struct _libc_xmmreg _xmm[16] ;
   __uint32_t padding[24] ;
};
#line 123 "/usr/include/sys/ucontext.h"
typedef struct _libc_fpstate *fpregset_t;
#line 126 "/usr/include/sys/ucontext.h"
struct __anonstruct_mcontext_t_61 {
   gregset_t gregs ;
   fpregset_t fpregs ;
   unsigned long __reserved1[8] ;
};
#line 126 "/usr/include/sys/ucontext.h"
typedef struct __anonstruct_mcontext_t_61 mcontext_t;
#line 135 "/usr/include/sys/ucontext.h"
struct ucontext {
   unsigned long uc_flags ;
   struct ucontext *uc_link ;
   stack_t uc_stack ;
   mcontext_t uc_mcontext ;
   __sigset_t uc_sigmask ;
   struct _libc_fpstate __fpregs_mem ;
};
#line 135 "/usr/include/sys/ucontext.h"
typedef struct ucontext ucontext_t;
#line 65 "/usr/include/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 89 "/usr/include/bits/sched.h"
struct __sched_param {
   int __sched_priority ;
};
#line 104 "/usr/include/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 111 "/usr/include/bits/sched.h"
struct __anonstruct_cpu_set_t_62 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 111 "/usr/include/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_62 cpu_set_t;
#line 32 "/usr/include/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/pthread.h"
enum __anonenum_63 {
    PTHREAD_CREATE_JOINABLE = 0,
    PTHREAD_CREATE_DETACHED = 1
} ;
#line 44
enum __anonenum_64 {
    PTHREAD_MUTEX_TIMED_NP = 0,
    PTHREAD_MUTEX_RECURSIVE_NP = 1,
    PTHREAD_MUTEX_ERRORCHECK_NP = 2,
    PTHREAD_MUTEX_ADAPTIVE_NP = 3,
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,
    PTHREAD_MUTEX_DEFAULT = 0,
    PTHREAD_MUTEX_FAST_NP = 0
} ;
#line 66
enum __anonenum_65 {
    PTHREAD_MUTEX_STALLED_NP = 0,
    PTHREAD_MUTEX_ROBUST_NP = 1
} ;
#line 76
enum __anonenum_66 {
    PTHREAD_PRIO_NONE = 0,
    PTHREAD_PRIO_INHERIT = 1,
    PTHREAD_PRIO_PROTECT = 2
} ;
#line 113
enum __anonenum_67 {
    PTHREAD_RWLOCK_PREFER_READER_NP = 0,
    PTHREAD_RWLOCK_PREFER_WRITER_NP = 1,
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP = 2,
    PTHREAD_RWLOCK_DEFAULT_NP = 0
} ;
#line 143
enum __anonenum_68 {
    PTHREAD_INHERIT_SCHED = 0,
    PTHREAD_EXPLICIT_SCHED = 1
} ;
#line 153
enum __anonenum_69 {
    PTHREAD_SCOPE_SYSTEM = 0,
    PTHREAD_SCOPE_PROCESS = 1
} ;
#line 163
enum __anonenum_70 {
    PTHREAD_PROCESS_PRIVATE = 0,
    PTHREAD_PROCESS_SHARED = 1
} ;
#line 178 "/usr/include/pthread.h"
struct _pthread_cleanup_buffer {
   void (*__routine)(void * ) ;
   void *__arg ;
   int __canceltype ;
   struct _pthread_cleanup_buffer *__prev ;
};
#line 187
enum __anonenum_71 {
    PTHREAD_CANCEL_ENABLE = 0,
    PTHREAD_CANCEL_DISABLE = 1
} ;
#line 194
enum __anonenum_72 {
    PTHREAD_CANCEL_DEFERRED = 0,
    PTHREAD_CANCEL_ASYNCHRONOUS = 1
} ;
#line 491 "/usr/include/pthread.h"
struct __anonstruct___cancel_jmp_buf_74 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
#line 491 "/usr/include/pthread.h"
struct __anonstruct___pthread_unwind_buf_t_73 {
   struct __anonstruct___cancel_jmp_buf_74 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
#line 491 "/usr/include/pthread.h"
typedef struct __anonstruct___pthread_unwind_buf_t_73  __attribute__((__aligned__)) __pthread_unwind_buf_t;
#line 508 "/usr/include/pthread.h"
struct __pthread_cleanup_frame {
   void (*__cancel_routine)(void * ) ;
   void *__cancel_arg ;
   int __do_it ;
   int __cancel_type ;
};
#line 708
struct __jmp_buf_tag;
#line 708
struct __jmp_buf_tag;
#line 37 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/omp.h"
struct __anonstruct_omp_lock_t_75 {
   unsigned char _x[4]  __attribute__((__aligned__(4))) ;
};
#line 37 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/omp.h"
typedef struct __anonstruct_omp_lock_t_75 omp_lock_t;
#line 43 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/omp.h"
struct __anonstruct_omp_nest_lock_t_76 {
   unsigned char _x[8]  __attribute__((__aligned__(4))) ;
};
#line 43 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/omp.h"
typedef struct __anonstruct_omp_nest_lock_t_76 omp_nest_lock_t;
#line 32 "/usr/include/sys/timeb.h"
struct timeb {
   time_t time ;
   unsigned short millitm ;
   short timezone ;
   short dstflag ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 38 "/usr/include/bits/dirent.h"
struct dirent64 {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 98 "/usr/include/dirent.h"
enum __anonenum_77 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14
} ;
#line 128
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 33 "/usr/include/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_NLIMITS = 15,
    __RLIM_NLIMITS = 15
} ;
#line 129 "/usr/include/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 132 "/usr/include/bits/resource.h"
typedef __rlim64_t rlim64_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 144 "/usr/include/bits/resource.h"
struct rlimit64 {
   rlim64_t rlim_cur ;
   rlim64_t rlim_max ;
};
#line 154
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
#line 169 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 217
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 39 "/usr/include/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 40 "/usr/include/sys/resource.h"
typedef enum __rusage_who __rusage_who_t;
#line 41 "/usr/include/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 102 "/usr/include/sys/wait.h"
enum __anonenum_idtype_t_78 {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2
} ;
#line 102 "/usr/include/sys/wait.h"
typedef enum __anonenum_idtype_t_78 idtype_t;
#line 162
struct rusage;
#line 176
struct rusage;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 61 "./magick/magick-type.h"
typedef double MagickRealType;
#line 67 "./magick/magick-type.h"
typedef unsigned short Quantum;
#line 113 "./magick/magick-type.h"
typedef unsigned int MagickStatusType;
#line 116 "./magick/magick-type.h"
typedef long long MagickOffsetType;
#line 117 "./magick/magick-type.h"
typedef unsigned long long MagickSizeType;
#line 133 "./magick/magick-type.h"
typedef MagickSizeType QuantumAny;
#line 140
enum __anonenum_ChannelType_79 {
    UndefinedChannel = 0,
    RedChannel = 1,
    GrayChannel = 1,
    CyanChannel = 1,
    GreenChannel = 2,
    MagentaChannel = 2,
    BlueChannel = 4,
    YellowChannel = 4,
    AlphaChannel = 8,
    OpacityChannel = 8,
    MatteChannel = 8,
    BlackChannel = 32,
    IndexChannel = 32,
    TrueAlphaChannel = 64,
    RGBChannels = 128,
    AllChannels = 63,
    DefaultChannels = 55
} ;
#line 140 "./magick/magick-type.h"
typedef enum __anonenum_ChannelType_79 ChannelType;
#line 162
enum __anonenum_ClassType_80 {
    UndefinedClass = 0,
    DirectClass = 1,
    PseudoClass = 2
} ;
#line 162 "./magick/magick-type.h"
typedef enum __anonenum_ClassType_80 ClassType;
#line 169
enum __anonenum_MagickBooleanType_81 {
    MagickFalse = 0,
    MagickTrue = 1
} ;
#line 169 "./magick/magick-type.h"
typedef enum __anonenum_MagickBooleanType_81 MagickBooleanType;
#line 175
struct _BlobInfo;
#line 175 "./magick/magick-type.h"
typedef struct _BlobInfo BlobInfo;
#line 177
struct _ExceptionInfo;
#line 177 "./magick/magick-type.h"
typedef struct _ExceptionInfo ExceptionInfo;
#line 179
struct _Image;
#line 179 "./magick/magick-type.h"
typedef struct _Image Image;
#line 181
struct _ImageInfo;
#line 181 "./magick/magick-type.h"
typedef struct _ImageInfo ImageInfo;
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 93
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 109 "/usr/include/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 120 "/usr/include/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 35 "/usr/include/sys/times.h"
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
#line 25 "./magick/geometry.h"
enum __anonenum_GeometryFlags_82 {
    NoValue = 0,
    XValue = 1,
    XiValue = 1,
    YValue = 2,
    PsiValue = 2,
    WidthValue = 4,
    RhoValue = 4,
    HeightValue = 8,
    SigmaValue = 8,
    ChiValue = 16,
    XiNegative = 32,
    XNegative = 32,
    PsiNegative = 64,
    YNegative = 64,
    ChiNegative = 128,
    PercentValue = 4096,
    AspectValue = 8192,
    LessValue = 16384,
    GreaterValue = 32768,
    MinimumValue = 65536,
    AreaValue = 131072,
    DecimalValue = 262144,
    AllValues = 2147483647
} ;
#line 25 "./magick/geometry.h"
typedef enum __anonenum_GeometryFlags_82 GeometryFlags;
#line 74
enum __anonenum_GravityType_83 {
    UndefinedGravity = 0,
    ForgetGravity = 0,
    NorthWestGravity = 1,
    NorthGravity = 2,
    NorthEastGravity = 3,
    WestGravity = 4,
    CenterGravity = 5,
    EastGravity = 6,
    SouthWestGravity = 7,
    SouthGravity = 8,
    SouthEastGravity = 9,
    StaticGravity = 10
} ;
#line 74 "./magick/geometry.h"
typedef enum __anonenum_GravityType_83 GravityType;
#line 90 "./magick/geometry.h"
struct _AffineMatrix {
   double sx ;
   double rx ;
   double ry ;
   double sy ;
   double tx ;
   double ty ;
};
#line 90 "./magick/geometry.h"
typedef struct _AffineMatrix AffineMatrix;
#line 101 "./magick/geometry.h"
struct _GeometryInfo {
   double rho ;
   double sigma ;
   double xi ;
   double psi ;
   double chi ;
};
#line 101 "./magick/geometry.h"
typedef struct _GeometryInfo GeometryInfo;
#line 111 "./magick/geometry.h"
struct _RectangleInfo {
   unsigned long width ;
   unsigned long height ;
   long x ;
   long y ;
};
#line 111 "./magick/geometry.h"
typedef struct _RectangleInfo RectangleInfo;
#line 25 "./magick/colorspace.h"
enum __anonenum_ColorspaceType_84 {
    UndefinedColorspace = 0,
    RGBColorspace = 1,
    GRAYColorspace = 2,
    TransparentColorspace = 3,
    OHTAColorspace = 4,
    LabColorspace = 5,
    XYZColorspace = 6,
    YCbCrColorspace = 7,
    YCCColorspace = 8,
    YIQColorspace = 9,
    YPbPrColorspace = 10,
    YUVColorspace = 11,
    CMYKColorspace = 12,
    sRGBColorspace = 13,
    HSBColorspace = 14,
    HSLColorspace = 15,
    HWBColorspace = 16,
    Rec601LumaColorspace = 17,
    Rec601YCbCrColorspace = 18,
    Rec709LumaColorspace = 19,
    Rec709YCbCrColorspace = 20,
    LogColorspace = 21,
    CMYColorspace = 22
} ;
#line 25 "./magick/colorspace.h"
typedef enum __anonenum_ColorspaceType_84 ColorspaceType;
#line 25 "./magick/constitute.h"
enum __anonenum_StorageType_85 {
    UndefinedPixel = 0,
    CharPixel = 1,
    DoublePixel = 2,
    FloatPixel = 3,
    IntegerPixel = 4,
    LongPixel = 5,
    QuantumPixel = 6,
    ShortPixel = 7
} ;
#line 25 "./magick/constitute.h"
typedef enum __anonenum_StorageType_85 StorageType;
#line 28 "./magick/pixel.h"
struct _LongPixelPacket {
   unsigned long red ;
   unsigned long green ;
   unsigned long blue ;
   unsigned long opacity ;
   unsigned long index ;
};
#line 28 "./magick/pixel.h"
typedef struct _LongPixelPacket LongPixelPacket;
#line 38 "./magick/pixel.h"
struct _MagickPixelPacket {
   ClassType storage_class ;
   ColorspaceType colorspace ;
   MagickBooleanType matte ;
   double fuzz ;
   unsigned long depth ;
   MagickRealType red ;
   MagickRealType green ;
   MagickRealType blue ;
   MagickRealType opacity ;
   MagickRealType index ;
};
#line 38 "./magick/pixel.h"
typedef struct _MagickPixelPacket MagickPixelPacket;
#line 63 "./magick/pixel.h"
typedef Quantum IndexPacket;
#line 65 "./magick/pixel.h"
struct _PixelPacket {
   Quantum blue ;
   Quantum green ;
   Quantum red ;
   Quantum opacity ;
};
#line 65 "./magick/pixel.h"
typedef struct _PixelPacket PixelPacket;
#line 25 "./magick/semaphore.h"
struct SemaphoreInfo;
#line 25 "./magick/semaphore.h"
typedef struct SemaphoreInfo SemaphoreInfo;
#line 28 "./magick/exception.h"
enum __anonenum_ExceptionType_86 {
    UndefinedException = 0,
    WarningException = 300,
    ResourceLimitWarning = 300,
    TypeWarning = 305,
    OptionWarning = 310,
    DelegateWarning = 315,
    MissingDelegateWarning = 320,
    CorruptImageWarning = 325,
    FileOpenWarning = 330,
    BlobWarning = 335,
    StreamWarning = 340,
    CacheWarning = 345,
    CoderWarning = 350,
    ModuleWarning = 355,
    DrawWarning = 360,
    ImageWarning = 365,
    WandWarning = 370,
    RandomWarning = 375,
    XServerWarning = 380,
    MonitorWarning = 385,
    RegistryWarning = 390,
    ConfigureWarning = 395,
    PolicyWarning = 399,
    ErrorException = 400,
    ResourceLimitError = 400,
    TypeError = 405,
    OptionError = 410,
    DelegateError = 415,
    MissingDelegateError = 420,
    CorruptImageError = 425,
    FileOpenError = 430,
    BlobError = 435,
    StreamError = 440,
    CacheError = 445,
    CoderError = 450,
    ModuleError = 455,
    DrawError = 460,
    ImageError = 465,
    WandError = 470,
    RandomError = 475,
    XServerError = 480,
    MonitorError = 485,
    RegistryError = 490,
    ConfigureError = 495,
    PolicyError = 499,
    FatalErrorException = 700,
    ResourceLimitFatalError = 700,
    TypeFatalError = 705,
    OptionFatalError = 710,
    DelegateFatalError = 715,
    MissingDelegateFatalError = 720,
    CorruptImageFatalError = 725,
    FileOpenFatalError = 730,
    BlobFatalError = 735,
    StreamFatalError = 740,
    CacheFatalError = 745,
    CoderFatalError = 750,
    ModuleFatalError = 755,
    DrawFatalError = 760,
    ImageFatalError = 765,
    WandFatalError = 770,
    RandomFatalError = 775,
    XServerFatalError = 780,
    MonitorFatalError = 785,
    RegistryFatalError = 790,
    ConfigureFatalError = 795,
    PolicyFatalError = 799
} ;
#line 28 "./magick/exception.h"
typedef enum __anonenum_ExceptionType_86 ExceptionType;
#line 99 "./magick/exception.h"
struct _ExceptionInfo {
   ExceptionType severity ;
   int error_number ;
   char *reason ;
   char *description ;
   void *exceptions ;
   MagickBooleanType relinquish ;
   SemaphoreInfo *semaphore ;
   unsigned long signature ;
};
#line 124 "./magick/exception.h"
typedef void (*ErrorHandler)(ExceptionType  , char const   * , char const   * );
#line 127 "./magick/exception.h"
typedef void (*FatalErrorHandler)(ExceptionType  , char const   * , char const   * );
#line 130 "./magick/exception.h"
typedef void (*WarningHandler)(ExceptionType  , char const   * , char const   * );
#line 28 "./magick/color.h"
enum __anonenum_ComplianceType_87 {
    UndefinedCompliance = 0,
    NoCompliance = 0,
    SVGCompliance = 1,
    X11Compliance = 2,
    XPMCompliance = 4,
    AllCompliance = 2147483647
} ;
#line 28 "./magick/color.h"
typedef enum __anonenum_ComplianceType_87 ComplianceType;
#line 38 "./magick/color.h"
struct _ColorInfo {
   char *path ;
   char *name ;
   ComplianceType compliance ;
   MagickPixelPacket color ;
   MagickBooleanType stealth ;
   struct _ColorInfo *previous ;
   struct _ColorInfo *next ;
   unsigned long signature ;
};
#line 38 "./magick/color.h"
typedef struct _ColorInfo ColorInfo;
#line 61 "./magick/color.h"
struct _ColorPacket {
   PixelPacket pixel ;
   IndexPacket index ;
   MagickSizeType count ;
};
#line 61 "./magick/color.h"
typedef struct _ColorPacket ColorPacket;
#line 73 "./magick/color.h"
struct _ErrorInfo {
   double mean_error_per_pixel ;
   double normalized_mean_error ;
   double normalized_maximum_error ;
};
#line 73 "./magick/color.h"
typedef struct _ErrorInfo ErrorInfo;
#line 30 "./magick/image.h"
enum __anonenum_AlphaChannelType_88 {
    UndefinedAlphaChannel = 0,
    ActivateAlphaChannel = 1,
    BackgroundAlphaChannel = 2,
    CopyAlphaChannel = 3,
    DeactivateAlphaChannel = 4,
    ExtractAlphaChannel = 5,
    OpaqueAlphaChannel = 6,
    ResetAlphaChannel = 7,
    SetAlphaChannel = 8,
    ShapeAlphaChannel = 9,
    TransparentAlphaChannel = 10
} ;
#line 30 "./magick/image.h"
typedef enum __anonenum_AlphaChannelType_88 AlphaChannelType;
#line 45
enum __anonenum_ImageType_89 {
    UndefinedType = 0,
    BilevelType = 1,
    GrayscaleType = 2,
    GrayscaleMatteType = 3,
    PaletteType = 4,
    PaletteMatteType = 5,
    TrueColorType = 6,
    TrueColorMatteType = 7,
    ColorSeparationType = 8,
    ColorSeparationMatteType = 9,
    OptimizeType = 10,
    PaletteBilevelMatteType = 11
} ;
#line 45 "./magick/image.h"
typedef enum __anonenum_ImageType_89 ImageType;
#line 61
enum __anonenum_InterlaceType_90 {
    UndefinedInterlace = 0,
    NoInterlace = 1,
    LineInterlace = 2,
    PlaneInterlace = 3,
    PartitionInterlace = 4,
    GIFInterlace = 5,
    JPEGInterlace = 6,
    PNGInterlace = 7
} ;
#line 61 "./magick/image.h"
typedef enum __anonenum_InterlaceType_90 InterlaceType;
#line 73
enum __anonenum_OrientationType_91 {
    UndefinedOrientation = 0,
    TopLeftOrientation = 1,
    TopRightOrientation = 2,
    BottomRightOrientation = 3,
    BottomLeftOrientation = 4,
    LeftTopOrientation = 5,
    RightTopOrientation = 6,
    RightBottomOrientation = 7,
    LeftBottomOrientation = 8
} ;
#line 73 "./magick/image.h"
typedef enum __anonenum_OrientationType_91 OrientationType;
#line 86
enum __anonenum_ResolutionType_92 {
    UndefinedResolution = 0,
    PixelsPerInchResolution = 1,
    PixelsPerCentimeterResolution = 2
} ;
#line 86 "./magick/image.h"
typedef enum __anonenum_ResolutionType_92 ResolutionType;
#line 93 "./magick/image.h"
struct _PrimaryInfo {
   double x ;
   double y ;
   double z ;
};
#line 93 "./magick/image.h"
typedef struct _PrimaryInfo PrimaryInfo;
#line 101 "./magick/image.h"
struct _SegmentInfo {
   double x1 ;
   double y1 ;
   double x2 ;
   double y2 ;
};
#line 101 "./magick/image.h"
typedef struct _SegmentInfo SegmentInfo;
#line 110
enum __anonenum_TransmitType_93 {
    UndefinedTransmitType = 0,
    FileTransmitType = 1,
    BlobTransmitType = 2,
    StreamTransmitType = 3,
    ImageTransmitType = 4
} ;
#line 110 "./magick/image.h"
typedef enum __anonenum_TransmitType_93 TransmitType;
#line 119 "./magick/image.h"
struct _ChromaticityInfo {
   PrimaryInfo red_primary ;
   PrimaryInfo green_primary ;
   PrimaryInfo blue_primary ;
   PrimaryInfo white_point ;
};
#line 119 "./magick/image.h"
typedef struct _ChromaticityInfo ChromaticityInfo;
#line 25 "./magick/stream.h"
typedef size_t (*StreamHandler)(Image const   * , void const   * , size_t  );
#line 30 "./magick/blob.h"
enum __anonenum_MapMode_94 {
    ReadMode = 0,
    WriteMode = 1,
    IOMode = 2
} ;
#line 30 "./magick/blob.h"
typedef enum __anonenum_MapMode_94 MapMode;
#line 27 "./magick/cache-view.h"
enum __anonenum_VirtualPixelMethod_95 {
    UndefinedVirtualPixelMethod = 0,
    BackgroundVirtualPixelMethod = 1,
    ConstantVirtualPixelMethod = 2,
    DitherVirtualPixelMethod = 3,
    EdgeVirtualPixelMethod = 4,
    MirrorVirtualPixelMethod = 5,
    RandomVirtualPixelMethod = 6,
    TileVirtualPixelMethod = 7,
    TransparentVirtualPixelMethod = 8,
    MaskVirtualPixelMethod = 9,
    BlackVirtualPixelMethod = 10,
    GrayVirtualPixelMethod = 11,
    WhiteVirtualPixelMethod = 12,
    HorizontalTileVirtualPixelMethod = 13,
    VerticalTileVirtualPixelMethod = 14,
    HorizontalTileEdgeVirtualPixelMethod = 15,
    VerticalTileEdgeVirtualPixelMethod = 16,
    CheckerTileVirtualPixelMethod = 17
} ;
#line 27 "./magick/cache-view.h"
typedef enum __anonenum_VirtualPixelMethod_95 VirtualPixelMethod;
#line 49
struct _ViewInfo;
#line 49 "./magick/cache-view.h"
typedef struct _ViewInfo ViewInfo;
#line 25 "./magick/composite.h"
enum __anonenum_CompositeOperator_96 {
    UndefinedCompositeOp = 0,
    NoCompositeOp = 1,
    AddCompositeOp = 2,
    AtopCompositeOp = 3,
    BlendCompositeOp = 4,
    BumpmapCompositeOp = 5,
    ChangeMaskCompositeOp = 6,
    ClearCompositeOp = 7,
    ColorBurnCompositeOp = 8,
    ColorDodgeCompositeOp = 9,
    ColorizeCompositeOp = 10,
    CopyBlackCompositeOp = 11,
    CopyBlueCompositeOp = 12,
    CopyCompositeOp = 13,
    CopyCyanCompositeOp = 14,
    CopyGreenCompositeOp = 15,
    CopyMagentaCompositeOp = 16,
    CopyOpacityCompositeOp = 17,
    CopyRedCompositeOp = 18,
    CopyYellowCompositeOp = 19,
    DarkenCompositeOp = 20,
    DstAtopCompositeOp = 21,
    DstCompositeOp = 22,
    DstInCompositeOp = 23,
    DstOutCompositeOp = 24,
    DstOverCompositeOp = 25,
    DifferenceCompositeOp = 26,
    DisplaceCompositeOp = 27,
    DissolveCompositeOp = 28,
    ExclusionCompositeOp = 29,
    HardLightCompositeOp = 30,
    HueCompositeOp = 31,
    InCompositeOp = 32,
    LightenCompositeOp = 33,
    LinearLightCompositeOp = 34,
    LuminizeCompositeOp = 35,
    MinusCompositeOp = 36,
    ModulateCompositeOp = 37,
    MultiplyCompositeOp = 38,
    OutCompositeOp = 39,
    OverCompositeOp = 40,
    OverlayCompositeOp = 41,
    PlusCompositeOp = 42,
    ReplaceCompositeOp = 43,
    SaturateCompositeOp = 44,
    ScreenCompositeOp = 45,
    SoftLightCompositeOp = 46,
    SrcAtopCompositeOp = 47,
    SrcCompositeOp = 48,
    SrcInCompositeOp = 49,
    SrcOutCompositeOp = 50,
    SrcOverCompositeOp = 51,
    SubtractCompositeOp = 52,
    ThresholdCompositeOp = 53,
    XorCompositeOp = 54,
    DivideCompositeOp = 55
} ;
#line 25 "./magick/composite.h"
typedef enum __anonenum_CompositeOperator_96 CompositeOperator;
#line 25 "./magick/compress.h"
enum __anonenum_CompressionType_97 {
    UndefinedCompression = 0,
    NoCompression = 1,
    BZipCompression = 2,
    DXT1Compression = 3,
    DXT3Compression = 4,
    DXT5Compression = 5,
    FaxCompression = 6,
    Group4Compression = 7,
    JPEGCompression = 8,
    JPEG2000Compression = 9,
    LosslessJPEGCompression = 10,
    LZWCompression = 11,
    RLECompression = 12,
    ZipCompression = 13
} ;
#line 25 "./magick/compress.h"
typedef enum __anonenum_CompressionType_97 CompressionType;
#line 43
struct _Ascii85Info;
#line 43 "./magick/compress.h"
typedef struct _Ascii85Info Ascii85Info;
#line 25 "./magick/effect.h"
enum __anonenum_PreviewType_98 {
    UndefinedPreview = 0,
    RotatePreview = 1,
    ShearPreview = 2,
    RollPreview = 3,
    HuePreview = 4,
    SaturationPreview = 5,
    BrightnessPreview = 6,
    GammaPreview = 7,
    SpiffPreview = 8,
    DullPreview = 9,
    GrayscalePreview = 10,
    QuantizePreview = 11,
    DespecklePreview = 12,
    ReduceNoisePreview = 13,
    AddNoisePreview = 14,
    SharpenPreview = 15,
    BlurPreview = 16,
    ThresholdPreview = 17,
    EdgeDetectPreview = 18,
    SpreadPreview = 19,
    SolarizePreview = 20,
    ShadePreview = 21,
    RaisePreview = 22,
    SegmentPreview = 23,
    SwirlPreview = 24,
    ImplodePreview = 25,
    WavePreview = 26,
    OilPaintPreview = 27,
    CharcoalDrawingPreview = 28,
    JPEGPreview = 29
} ;
#line 25 "./magick/effect.h"
typedef enum __anonenum_PreviewType_98 PreviewType;
#line 25 "./magick/layer.h"
enum __anonenum_DisposeType_99 {
    UnrecognizedDispose = 0,
    UndefinedDispose = 0,
    NoneDispose = 1,
    BackgroundDispose = 2,
    PreviousDispose = 3
} ;
#line 25 "./magick/layer.h"
typedef enum __anonenum_DisposeType_99 DisposeType;
#line 34
enum __anonenum_ImageLayerMethod_100 {
    UndefinedLayer = 0,
    CoalesceLayer = 1,
    CompareAnyLayer = 2,
    CompareClearLayer = 3,
    CompareOverlayLayer = 4,
    DisposeLayer = 5,
    OptimizeLayer = 6,
    OptimizeImageLayer = 7,
    OptimizePlusLayer = 8,
    OptimizeTransLayer = 9,
    RemoveDupsLayer = 10,
    RemoveZeroLayer = 11,
    CompositeLayer = 12,
    MergeLayer = 13,
    FlattenLayer = 14,
    MosaicLayer = 15,
    TrimBoundsLayer = 16
} ;
#line 34 "./magick/layer.h"
typedef enum __anonenum_ImageLayerMethod_100 ImageLayerMethod;
#line 25 "./magick/monitor.h"
typedef MagickBooleanType (*MagickProgressMonitor)(char const   * , MagickOffsetType  ,
                                                   MagickSizeType  , void * );
#line 29 "./magick/string_.h"
struct _StringInfo {
   char path[4096] ;
   unsigned char *datum ;
   size_t length ;
   unsigned long signature ;
};
#line 29 "./magick/string_.h"
typedef struct _StringInfo StringInfo;
#line 27 "./magick/profile.h"
struct _ProfileInfo {
   char *name ;
   size_t length ;
   unsigned char *info ;
   unsigned long signature ;
};
#line 27 "./magick/profile.h"
typedef struct _ProfileInfo ProfileInfo;
#line 42
enum __anonenum_RenderingIntent_101 {
    UndefinedIntent = 0,
    SaturationIntent = 1,
    PerceptualIntent = 2,
    AbsoluteIntent = 3,
    RelativeIntent = 4
} ;
#line 42 "./magick/profile.h"
typedef enum __anonenum_RenderingIntent_101 RenderingIntent;
#line 27 "./magick/quantum.h"
enum __anonenum_EndianType_102 {
    UndefinedEndian = 0,
    LSBEndian = 1,
    MSBEndian = 2
} ;
#line 27 "./magick/quantum.h"
typedef enum __anonenum_EndianType_102 EndianType;
#line 34
enum __anonenum_QuantumAlphaType_103 {
    UndefinedQuantumAlpha = 0,
    AssociatedQuantumAlpha = 1,
    DisassociatedQuantumAlpha = 2
} ;
#line 34 "./magick/quantum.h"
typedef enum __anonenum_QuantumAlphaType_103 QuantumAlphaType;
#line 41
enum __anonenum_QuantumFormatType_104 {
    UndefinedQuantumFormat = 0,
    FloatingPointQuantumFormat = 1,
    SignedQuantumFormat = 2,
    UnsignedQuantumFormat = 3
} ;
#line 41 "./magick/quantum.h"
typedef enum __anonenum_QuantumFormatType_104 QuantumFormatType;
#line 49
enum __anonenum_QuantumType_105 {
    UndefinedQuantum = 0,
    AlphaQuantum = 1,
    BlackQuantum = 2,
    BlueQuantum = 3,
    CMYKAQuantum = 4,
    CMYKQuantum = 5,
    CyanQuantum = 6,
    GrayAlphaQuantum = 7,
    GrayQuantum = 8,
    GreenQuantum = 9,
    IndexAlphaQuantum = 10,
    IndexQuantum = 11,
    MagentaQuantum = 12,
    OpacityQuantum = 13,
    RedQuantum = 14,
    RGBAQuantum = 15,
    RGBOQuantum = 16,
    RGBQuantum = 17,
    YellowQuantum = 18,
    GrayPadQuantum = 19,
    RGBPadQuantum = 20,
    CbYCrYQuantum = 21
} ;
#line 49 "./magick/quantum.h"
typedef enum __anonenum_QuantumType_105 QuantumType;
#line 75
struct _QuantumInfo;
#line 75 "./magick/quantum.h"
typedef struct _QuantumInfo QuantumInfo;
#line 27 "./magick/resample.h"
enum __anonenum_FilterTypes_106 {
    UndefinedFilter = 0,
    PointFilter = 1,
    BoxFilter = 2,
    TriangleFilter = 3,
    HermiteFilter = 4,
    HanningFilter = 5,
    HammingFilter = 6,
    BlackmanFilter = 7,
    GaussianFilter = 8,
    QuadraticFilter = 9,
    CubicFilter = 10,
    CatromFilter = 11,
    MitchellFilter = 12,
    LanczosFilter = 13,
    BesselFilter = 14,
    SincFilter = 15,
    KaiserFilter = 16,
    WelshFilter = 17,
    ParzenFilter = 18,
    LagrangeFilter = 19,
    BohmanFilter = 20,
    BartlettFilter = 21,
    SentinelFilter = 22
} ;
#line 27 "./magick/resample.h"
typedef enum __anonenum_FilterTypes_106 FilterTypes;
#line 54
enum __anonenum_InterpolatePixelMethod_107 {
    UndefinedInterpolatePixel = 0,
    AverageInterpolatePixel = 1,
    BicubicInterpolatePixel = 2,
    BilinearInterpolatePixel = 3,
    FilterInterpolatePixel = 4,
    IntegerInterpolatePixel = 5,
    MeshInterpolatePixel = 6,
    NearestNeighborInterpolatePixel = 7,
    SplineInterpolatePixel = 8
} ;
#line 54 "./magick/resample.h"
typedef enum __anonenum_InterpolatePixelMethod_107 InterpolatePixelMethod;
#line 67
struct _ResampleFilter;
#line 67 "./magick/resample.h"
typedef struct _ResampleFilter ResampleFilter;
#line 25 "./magick/timer.h"
enum __anonenum_TimerState_108 {
    UndefinedTimerState = 0,
    StoppedTimerState = 1,
    RunningTimerState = 2
} ;
#line 25 "./magick/timer.h"
typedef enum __anonenum_TimerState_108 TimerState;
#line 32 "./magick/timer.h"
struct _Timer {
   double start ;
   double stop ;
   double total ;
};
#line 32 "./magick/timer.h"
typedef struct _Timer Timer;
#line 40 "./magick/timer.h"
struct _TimerInfo {
   Timer user ;
   Timer elapsed ;
   TimerState state ;
   unsigned long signature ;
};
#line 40 "./magick/timer.h"
typedef struct _TimerInfo TimerInfo;
#line 147 "./magick/image.h"
struct _Image {
   ClassType storage_class ;
   ColorspaceType colorspace ;
   CompressionType compression ;
   unsigned long quality ;
   OrientationType orientation ;
   MagickBooleanType taint ;
   MagickBooleanType matte ;
   unsigned long columns ;
   unsigned long rows ;
   unsigned long depth ;
   unsigned long colors ;
   PixelPacket *colormap ;
   PixelPacket background_color ;
   PixelPacket border_color ;
   PixelPacket matte_color ;
   double gamma ;
   ChromaticityInfo chromaticity ;
   RenderingIntent rendering_intent ;
   void *profiles ;
   ResolutionType units ;
   char *montage ;
   char *directory ;
   char *geometry ;
   long offset ;
   double x_resolution ;
   double y_resolution ;
   RectangleInfo page ;
   RectangleInfo extract_info ;
   RectangleInfo tile_info ;
   double bias ;
   double blur ;
   double fuzz ;
   FilterTypes filter ;
   InterlaceType interlace ;
   EndianType endian ;
   GravityType gravity ;
   CompositeOperator compose ;
   DisposeType dispose ;
   struct _Image *clip_mask ;
   unsigned long scene ;
   unsigned long delay ;
   long ticks_per_second ;
   unsigned long iterations ;
   unsigned long total_colors ;
   long start_loop ;
   ErrorInfo error ;
   TimerInfo timer ;
   MagickBooleanType (*progress_monitor)(char const   * , MagickOffsetType  , MagickSizeType  ,
                                         void * ) ;
   void *client_data ;
   void *cache ;
   void *attributes ;
   Ascii85Info *ascii85 ;
   BlobInfo *blob ;
   char filename[4096] ;
   char magick_filename[4096] ;
   char magick[4096] ;
   unsigned long magick_columns ;
   unsigned long magick_rows ;
   ExceptionInfo exception ;
   MagickBooleanType debug ;
   long volatile   reference_count ;
   SemaphoreInfo *semaphore ;
   ProfileInfo color_profile ;
   ProfileInfo iptc_profile ;
   ProfileInfo *generic_profile ;
   unsigned long generic_profiles ;
   unsigned long signature ;
   struct _Image *previous ;
   struct _Image *list ;
   struct _Image *next ;
   InterpolatePixelMethod interpolate ;
   MagickBooleanType black_point_compensation ;
   PixelPacket transparent_color ;
   struct _Image *mask ;
   RectangleInfo tile_offset ;
   void *properties ;
   void *artifacts ;
   ImageType type ;
   MagickBooleanType dither ;
};
#line 335 "./magick/image.h"
struct _ImageInfo {
   CompressionType compression ;
   OrientationType orientation ;
   MagickBooleanType temporary ;
   MagickBooleanType adjoin ;
   MagickBooleanType affirm ;
   MagickBooleanType antialias ;
   char *size ;
   char *extract ;
   char *page ;
   char *scenes ;
   unsigned long scene ;
   unsigned long number_scenes ;
   unsigned long depth ;
   InterlaceType interlace ;
   EndianType endian ;
   ResolutionType units ;
   unsigned long quality ;
   char *sampling_factor ;
   char *server_name ;
   char *font ;
   char *texture ;
   char *density ;
   double pointsize ;
   double fuzz ;
   PixelPacket background_color ;
   PixelPacket border_color ;
   PixelPacket matte_color ;
   MagickBooleanType dither ;
   MagickBooleanType monochrome ;
   unsigned long colors ;
   ColorspaceType colorspace ;
   ImageType type ;
   PreviewType preview_type ;
   long group ;
   MagickBooleanType ping ;
   MagickBooleanType verbose ;
   char *view ;
   char *authenticate ;
   ChannelType channel ;
   Image *attributes ;
   void *options ;
   MagickBooleanType (*progress_monitor)(char const   * , MagickOffsetType  , MagickSizeType  ,
                                         void * ) ;
   void *client_data ;
   void *cache ;
   size_t (*stream)(Image const   * , void const   * , size_t  ) ;
   FILE *file ;
   void *blob ;
   size_t length ;
   char magick[4096] ;
   char unique[4096] ;
   char zero[4096] ;
   char filename[4096] ;
   MagickBooleanType debug ;
   char *tile ;
   unsigned long subimage ;
   unsigned long subrange ;
   PixelPacket pen ;
   unsigned long signature ;
   VirtualPixelMethod virtual_pixel_method ;
   PixelPacket transparent_color ;
   void *profile ;
   MagickBooleanType synchronize ;
};
#line 25 "./magick/type.h"
enum __anonenum_StretchType_109 {
    UndefinedStretch = 0,
    NormalStretch = 1,
    UltraCondensedStretch = 2,
    ExtraCondensedStretch = 3,
    CondensedStretch = 4,
    SemiCondensedStretch = 5,
    SemiExpandedStretch = 6,
    ExpandedStretch = 7,
    ExtraExpandedStretch = 8,
    UltraExpandedStretch = 9,
    AnyStretch = 10
} ;
#line 25 "./magick/type.h"
typedef enum __anonenum_StretchType_109 StretchType;
#line 40
enum __anonenum_StyleType_110 {
    UndefinedStyle = 0,
    NormalStyle = 1,
    ItalicStyle = 2,
    ObliqueStyle = 3,
    AnyStyle = 4
} ;
#line 40 "./magick/type.h"
typedef enum __anonenum_StyleType_110 StyleType;
#line 49 "./magick/type.h"
struct _TypeInfo {
   unsigned long face ;
   char *path ;
   char *name ;
   char *description ;
   char *family ;
   StyleType style ;
   StretchType stretch ;
   unsigned long weight ;
   char *encoding ;
   char *foundry ;
   char *format ;
   char *metrics ;
   char *glyphs ;
   MagickBooleanType stealth ;
   struct _TypeInfo *previous ;
   struct _TypeInfo *next ;
   unsigned long signature ;
};
#line 49 "./magick/type.h"
typedef struct _TypeInfo TypeInfo;
#line 30 "./magick/draw.h"
enum __anonenum_AlignType_111 {
    UndefinedAlign = 0,
    LeftAlign = 1,
    CenterAlign = 2,
    RightAlign = 3
} ;
#line 30 "./magick/draw.h"
typedef enum __anonenum_AlignType_111 AlignType;
#line 38
enum __anonenum_ClipPathUnits_112 {
    UndefinedPathUnits = 0,
    UserSpace = 1,
    UserSpaceOnUse = 2,
    ObjectBoundingBox = 3
} ;
#line 38 "./magick/draw.h"
typedef enum __anonenum_ClipPathUnits_112 ClipPathUnits;
#line 46
enum __anonenum_DecorationType_113 {
    UndefinedDecoration = 0,
    NoDecoration = 1,
    UnderlineDecoration = 2,
    OverlineDecoration = 3,
    LineThroughDecoration = 4
} ;
#line 46 "./magick/draw.h"
typedef enum __anonenum_DecorationType_113 DecorationType;
#line 55
enum __anonenum_FillRule_114 {
    UndefinedRule = 0,
    EvenOddRule = 1,
    NonZeroRule = 2
} ;
#line 55 "./magick/draw.h"
typedef enum __anonenum_FillRule_114 FillRule;
#line 63
enum __anonenum_GradientType_115 {
    UndefinedGradient = 0,
    LinearGradient = 1,
    RadialGradient = 2
} ;
#line 63 "./magick/draw.h"
typedef enum __anonenum_GradientType_115 GradientType;
#line 70
enum __anonenum_LineCap_116 {
    UndefinedCap = 0,
    ButtCap = 1,
    RoundCap = 2,
    SquareCap = 3
} ;
#line 70 "./magick/draw.h"
typedef enum __anonenum_LineCap_116 LineCap;
#line 78
enum __anonenum_LineJoin_117 {
    UndefinedJoin = 0,
    MiterJoin = 1,
    RoundJoin = 2,
    BevelJoin = 3
} ;
#line 78 "./magick/draw.h"
typedef enum __anonenum_LineJoin_117 LineJoin;
#line 86
enum __anonenum_PaintMethod_118 {
    UndefinedMethod = 0,
    PointMethod = 1,
    ReplaceMethod = 2,
    FloodfillMethod = 3,
    FillToBorderMethod = 4,
    ResetMethod = 5
} ;
#line 86 "./magick/draw.h"
typedef enum __anonenum_PaintMethod_118 PaintMethod;
#line 96
enum __anonenum_PrimitiveType_119 {
    UndefinedPrimitive = 0,
    PointPrimitive = 1,
    LinePrimitive = 2,
    RectanglePrimitive = 3,
    RoundRectanglePrimitive = 4,
    ArcPrimitive = 5,
    EllipsePrimitive = 6,
    CirclePrimitive = 7,
    PolylinePrimitive = 8,
    PolygonPrimitive = 9,
    BezierPrimitive = 10,
    ColorPrimitive = 11,
    MattePrimitive = 12,
    TextPrimitive = 13,
    ImagePrimitive = 14,
    PathPrimitive = 15
} ;
#line 96 "./magick/draw.h"
typedef enum __anonenum_PrimitiveType_119 PrimitiveType;
#line 116
enum __anonenum_ReferenceType_120 {
    UndefinedReference = 0,
    GradientReference = 1
} ;
#line 116 "./magick/draw.h"
typedef enum __anonenum_ReferenceType_120 ReferenceType;
#line 122
enum __anonenum_SpreadMethod_121 {
    UndefinedSpread = 0,
    PadSpread = 1,
    ReflectSpread = 2,
    RepeatSpread = 3
} ;
#line 122 "./magick/draw.h"
typedef enum __anonenum_SpreadMethod_121 SpreadMethod;
#line 130 "./magick/draw.h"
struct _PointInfo {
   double x ;
   double y ;
};
#line 130 "./magick/draw.h"
typedef struct _PointInfo PointInfo;
#line 137 "./magick/draw.h"
struct _StopInfo {
   MagickPixelPacket color ;
   MagickRealType offset ;
};
#line 137 "./magick/draw.h"
typedef struct _StopInfo StopInfo;
#line 146 "./magick/draw.h"
struct _GradientInfo {
   GradientType type ;
   RectangleInfo bounding_box ;
   SegmentInfo gradient_vector ;
   StopInfo *stops ;
   unsigned long number_stops ;
   SpreadMethod spread ;
   MagickBooleanType debug ;
   unsigned long signature ;
   PointInfo center ;
   MagickRealType radius ;
};
#line 146 "./magick/draw.h"
typedef struct _GradientInfo GradientInfo;
#line 179 "./magick/draw.h"
struct _ElementReference {
   char *id ;
   ReferenceType type ;
   GradientInfo gradient ;
   unsigned long signature ;
   struct _ElementReference *previous ;
   struct _ElementReference *next ;
};
#line 179 "./magick/draw.h"
typedef struct _ElementReference ElementReference;
#line 198 "./magick/draw.h"
struct _DrawInfo {
   char *primitive ;
   char *geometry ;
   RectangleInfo viewbox ;
   AffineMatrix affine ;
   GravityType gravity ;
   PixelPacket fill ;
   PixelPacket stroke ;
   double stroke_width ;
   GradientInfo gradient ;
   Image *fill_pattern ;
   Image *tile ;
   Image *stroke_pattern ;
   MagickBooleanType stroke_antialias ;
   MagickBooleanType text_antialias ;
   FillRule fill_rule ;
   LineCap linecap ;
   LineJoin linejoin ;
   unsigned long miterlimit ;
   double dash_offset ;
   DecorationType decorate ;
   CompositeOperator compose ;
   char *text ;
   unsigned long face ;
   char *font ;
   char *metrics ;
   char *family ;
   StyleType style ;
   StretchType stretch ;
   unsigned long weight ;
   char *encoding ;
   double pointsize ;
   char *density ;
   AlignType align ;
   PixelPacket undercolor ;
   PixelPacket border_color ;
   char *server_name ;
   double *dash_pattern ;
   char *clip_mask ;
   SegmentInfo bounds ;
   ClipPathUnits clip_units ;
   Quantum opacity ;
   MagickBooleanType render ;
   ElementReference element_reference ;
   MagickBooleanType debug ;
   unsigned long signature ;
   double kerning ;
   double interword_spacing ;
};
#line 198 "./magick/draw.h"
typedef struct _DrawInfo DrawInfo;
#line 324 "./magick/draw.h"
struct _PrimitiveInfo {
   PointInfo point ;
   unsigned long coordinates ;
   PrimitiveType primitive ;
   PaintMethod method ;
   char *text ;
};
#line 324 "./magick/draw.h"
typedef struct _PrimitiveInfo PrimitiveInfo;
#line 342 "./magick/draw.h"
struct _TypeMetric {
   PointInfo pixels_per_em ;
   double ascent ;
   double descent ;
   double width ;
   double height ;
   double max_advance ;
   double underline_position ;
   double underline_thickness ;
   SegmentInfo bounds ;
   PointInfo origin ;
};
#line 342 "./magick/draw.h"
typedef struct _TypeMetric TypeMetric;
#line 34 "./magick/log.h"
enum __anonenum_LogEventType_122 {
    UndefinedEvents = 0,
    NoEvents = 0,
    TraceEvent = 1,
    AnnotateEvent = 2,
    BlobEvent = 4,
    CacheEvent = 8,
    CoderEvent = 16,
    ConfigureEvent = 32,
    DeprecateEvent = 64,
    DrawEvent = 128,
    ExceptionEvent = 256,
    LocaleEvent = 512,
    ModuleEvent = 1024,
    PolicyEvent = 2048,
    ResourceEvent = 4096,
    TransformEvent = 8192,
    UserEvent = 16384,
    WandEvent = 32768,
    X11Event = 65536,
    AllEvents = 2147483647
} ;
#line 34 "./magick/log.h"
typedef enum __anonenum_LogEventType_122 LogEventType;
#line 58
struct _LogInfo;
#line 58 "./magick/log.h"
typedef struct _LogInfo LogInfo;
#line 25 "./magick/decorate.h"
struct _FrameInfo {
   unsigned long width ;
   unsigned long height ;
   long x ;
   long y ;
   long inner_bevel ;
   long outer_bevel ;
};
#line 25 "./magick/decorate.h"
typedef struct _FrameInfo FrameInfo;
#line 27 "./magick/fx.h"
enum __anonenum_MagickEvaluateOperator_123 {
    UndefinedEvaluateOperator = 0,
    AddEvaluateOperator = 1,
    AndEvaluateOperator = 2,
    DivideEvaluateOperator = 3,
    LeftShiftEvaluateOperator = 4,
    MaxEvaluateOperator = 5,
    MinEvaluateOperator = 6,
    MultiplyEvaluateOperator = 7,
    OrEvaluateOperator = 8,
    RightShiftEvaluateOperator = 9,
    SetEvaluateOperator = 10,
    SubtractEvaluateOperator = 11,
    XorEvaluateOperator = 12,
    PowEvaluateOperator = 13,
    LogEvaluateOperator = 14,
    ThresholdEvaluateOperator = 15,
    ThresholdBlackEvaluateOperator = 16,
    ThresholdWhiteEvaluateOperator = 17,
    GaussianNoiseEvaluateOperator = 18,
    ImpulseNoiseEvaluateOperator = 19,
    LaplacianNoiseEvaluateOperator = 20,
    MultiplicativeNoiseEvaluateOperator = 21,
    PoissonNoiseEvaluateOperator = 22,
    UniformNoiseEvaluateOperator = 23,
    CosineEvaluateOperator = 24,
    SineEvaluateOperator = 25,
    AddModulusEvaluateOperator = 26
} ;
#line 27 "./magick/fx.h"
typedef enum __anonenum_MagickEvaluateOperator_123 MagickEvaluateOperator;
#line 58
enum __anonenum_MagickFunction_124 {
    UndefinedFunction = 0,
    PolynomialFunction = 1,
    SinusoidFunction = 2,
    ArcsinFunction = 3,
    ArctanFunction = 4
} ;
#line 58 "./magick/fx.h"
typedef enum __anonenum_MagickFunction_124 MagickFunction;
#line 67
enum __anonenum_NoiseType_125 {
    UndefinedNoise = 0,
    UniformNoise = 1,
    GaussianNoise = 2,
    MultiplicativeGaussianNoise = 3,
    ImpulseNoise = 4,
    LaplacianNoise = 5,
    PoissonNoise = 6,
    RandomNoise = 7
} ;
#line 67 "./magick/fx.h"
typedef enum __anonenum_NoiseType_125 NoiseType;
#line 25 "./magick/fx-private.h"
struct _FxInfo;
#line 25 "./magick/fx-private.h"
typedef struct _FxInfo FxInfo;
#line 25 "./magick/memory_.h"
typedef void *(*AcquireMemoryHandler)(size_t  );
#line 25 "./magick/memory_.h"
typedef void (*DestroyMemoryHandler)(void * );
#line 25 "./magick/memory_.h"
typedef void *(*ResizeMemoryHandler)(void * , size_t  );
#line 25 "./magick/option.h"
enum __anonenum_MagickOption_126 {
    MagickUndefinedOptions = -1,
    MagickAlignOptions = 0,
    MagickAlphaOptions = 1,
    MagickBooleanOptions = 2,
    MagickChannelOptions = 3,
    MagickClassOptions = 4,
    MagickClipPathOptions = 5,
    MagickCoderOptions = 6,
    MagickColorOptions = 7,
    MagickColorspaceOptions = 8,
    MagickCommandOptions = 9,
    MagickComposeOptions = 10,
    MagickCompressOptions = 11,
    MagickConfigureOptions = 12,
    MagickDataTypeOptions = 13,
    MagickDebugOptions = 14,
    MagickDecorateOptions = 15,
    MagickDelegateOptions = 16,
    MagickDisposeOptions = 17,
    MagickDistortOptions = 18,
    MagickDitherOptions = 19,
    MagickEndianOptions = 20,
    MagickEvaluateOptions = 21,
    MagickFillRuleOptions = 22,
    MagickFilterOptions = 23,
    MagickFontOptions = 24,
    MagickFontsOptions = 25,
    MagickFormatOptions = 26,
    MagickFunctionOptions = 27,
    MagickGravityOptions = 28,
    MagickImageListOptions = 29,
    MagickIntentOptions = 30,
    MagickInterlaceOptions = 31,
    MagickInterpolateOptions = 32,
    MagickLayerOptions = 33,
    MagickLineCapOptions = 34,
    MagickLineJoinOptions = 35,
    MagickListOptions = 36,
    MagickLocaleOptions = 37,
    MagickLogEventOptions = 38,
    MagickLogOptions = 39,
    MagickMagicOptions = 40,
    MagickMethodOptions = 41,
    MagickMetricOptions = 42,
    MagickMimeOptions = 43,
    MagickModeOptions = 44,
    MagickModuleOptions = 45,
    MagickNoiseOptions = 46,
    MagickOrientationOptions = 47,
    MagickPolicyOptions = 48,
    MagickPolicyDomainOptions = 49,
    MagickPolicyRightsOptions = 50,
    MagickPreviewOptions = 51,
    MagickPrimitiveOptions = 52,
    MagickQuantumFormatOptions = 53,
    MagickResolutionOptions = 54,
    MagickResourceOptions = 55,
    MagickSparseColorOptions = 56,
    MagickStorageOptions = 57,
    MagickStretchOptions = 58,
    MagickStyleOptions = 59,
    MagickThresholdOptions = 60,
    MagickTypeOptions = 61,
    MagickVirtualPixelOptions = 62
} ;
#line 25 "./magick/option.h"
typedef enum __anonenum_MagickOption_126 MagickOption;
#line 93 "./magick/option.h"
struct _OptionInfo {
   char const   *mnemonic ;
   long type ;
   MagickBooleanType stealth ;
};
#line 93 "./magick/option.h"
typedef struct _OptionInfo OptionInfo;
#line 27 "./magick/quantum-private.h"
struct _QuantumState {
   EndianType endian ;
   double minimum ;
   double scale ;
   double inverse_scale ;
   unsigned long pixel ;
   unsigned long bits ;
   unsigned long const   *mask ;
};
#line 27 "./magick/quantum-private.h"
typedef struct _QuantumState QuantumState;
#line 45 "./magick/quantum-private.h"
struct _QuantumInfo {
   unsigned long depth ;
   unsigned long quantum ;
   QuantumFormatType format ;
   double minimum ;
   double maximum ;
   double scale ;
   size_t pad ;
   MagickBooleanType min_is_white ;
   MagickBooleanType pack ;
   QuantumAlphaType alpha_type ;
   unsigned long number_threads ;
   unsigned char **pixels ;
   size_t extent ;
   SemaphoreInfo *semaphore ;
   unsigned long signature ;
};
#line 30 "./magick/random_.h"
struct _RandomInfo;
#line 30 "./magick/random_.h"
typedef struct _RandomInfo RandomInfo;
#line 25 "./magick/splay-tree.h"
struct _SplayTreeInfo;
#line 25 "./magick/splay-tree.h"
typedef struct _SplayTreeInfo SplayTreeInfo;
#line 25 "./magick/statistic.h"
struct _ChannelStatistics {
   unsigned long depth ;
   double minima ;
   double maxima ;
   double mean ;
   double standard_deviation ;
   double kurtosis ;
   double skewness ;
};
#line 25 "./magick/statistic.h"
typedef struct _ChannelStatistics ChannelStatistics;
#line 25 "./magick/utility.h"
enum __anonenum_PathType_127 {
    UndefinedPath = 0,
    MagickPath = 1,
    RootPath = 2,
    HeadPath = 3,
    TailPath = 4,
    BasePath = 5,
    ExtensionPath = 6,
    SubimagePath = 7,
    CanonicalPath = 8
} ;
#line 25 "./magick/utility.h"
typedef enum __anonenum_PathType_127 PathType;
#line 96 "magick/fx.c"
struct _FxInfo {
   Image const   *images ;
   MagickBooleanType matte ;
   char *expression ;
   FILE *file ;
   SplayTreeInfo *colors ;
   SplayTreeInfo *symbols ;
   ResampleFilter **resample_filter ;
   ExceptionInfo *exception ;
};
#line 2420
enum __anonenum_FxPrecedence_128 {
    UndefinedPrecedence = 0,
    NullPrecedence = 1,
    BitwiseComplementPrecedence = 2,
    ExponentPrecedence = 3,
    MultiplyPrecedence = 4,
    AdditionPrecedence = 5,
    ShiftPrecedence = 6,
    RelationalPrecedence = 7,
    EquivalencyPrecedence = 8,
    BitwiseAndPrecedence = 9,
    BitwiseOrPrecedence = 10,
    LogicalAndPrecedence = 11,
    LogicalOrPrecedence = 12,
    TernaryPrecedence = 13,
    AssignmentPrecedence = 14,
    CommaPrecedence = 15,
    SeparatorPrecedence = 16
} ;
#line 2420 "magick/fx.c"
typedef enum __anonenum_FxPrecedence_128 FxPrecedence;
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 343 "/usr/include/libio.h"
extern struct _IO_FILE_plus _IO_2_1_stdin_ ;
#line 344
extern struct _IO_FILE_plus _IO_2_1_stdout_ ;
#line 345
extern struct _IO_FILE_plus _IO_2_1_stderr_ ;
#line 404
extern void _IO_cookie_init(struct _IO_cookie_file *__cfile , int __read_write , void *__cookie ,
                            _IO_cookie_io_functions_t __fns ) ;
#line 413
extern int __underflow(_IO_FILE * ) ;
#line 414
extern int __uflow(_IO_FILE * ) ;
#line 415
extern int __overflow(_IO_FILE * , int  ) ;
#line 416
extern wint_t __wunderflow(_IO_FILE * ) ;
#line 417
extern wint_t __wuflow(_IO_FILE * ) ;
#line 418
extern wint_t __woverflow(_IO_FILE * , wint_t  ) ;
#line 451
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 452
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 453
extern  __attribute__((__nothrow__)) int _IO_feof(_IO_FILE *__fp ) ;
#line 454
extern  __attribute__((__nothrow__)) int _IO_ferror(_IO_FILE *__fp ) ;
#line 456
extern int _IO_peekc_locked(_IO_FILE *__fp ) ;
#line 462
extern  __attribute__((__nothrow__)) void _IO_flockfile(_IO_FILE * ) ;
#line 463
extern  __attribute__((__nothrow__)) void _IO_funlockfile(_IO_FILE * ) ;
#line 464
extern  __attribute__((__nothrow__)) int _IO_ftrylockfile(_IO_FILE * ) ;
#line 481
extern int _IO_vfscanf(_IO_FILE * __restrict   , char const   * __restrict   , __gnuc_va_list  ,
                       int * __restrict   ) ;
#line 483
extern int _IO_vfprintf(_IO_FILE * __restrict   , char const   * __restrict   , __gnuc_va_list  ) ;
#line 485
extern __ssize_t _IO_padn(_IO_FILE * , int  , __ssize_t  ) ;
#line 486
extern size_t _IO_sgetn(_IO_FILE * , void * , size_t  ) ;
#line 488
extern __off64_t _IO_seekoff(_IO_FILE * , __off64_t  , int  , int  ) ;
#line 489
extern __off64_t _IO_seekpos(_IO_FILE * , __off64_t  , int  ) ;
#line 491
extern  __attribute__((__nothrow__)) void _IO_free_backup_area(_IO_FILE * ) ;
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 143
extern struct _IO_FILE *stdout ;
#line 144
extern struct _IO_FILE *stderr ;
#line 154
extern  __attribute__((__nothrow__)) int remove(char const   *__filename ) ;
#line 156
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 161
extern  __attribute__((__nothrow__)) int renameat(int __oldfd , char const   *__old ,
                                                  int __newfd , char const   *__new ) ;
#line 174
extern FILE *tmpfile(void)  __asm__("tmpfile64")  ;
#line 181
extern FILE *tmpfile64(void) ;
#line 185
extern  __attribute__((__nothrow__)) char *tmpnam(char *__s ) ;
#line 191
extern  __attribute__((__nothrow__)) char *tmpnam_r(char *__s ) ;
#line 203
extern  __attribute__((__nothrow__)) char *tempnam(char const   *__dir , char const   *__pfx )  __attribute__((__malloc__)) ;
#line 213
extern int fclose(FILE *__stream ) ;
#line 218
extern int fflush(FILE *__stream ) ;
#line 228
extern int fflush_unlocked(FILE *__stream ) ;
#line 238
extern int fcloseall(void) ;
#line 259
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 261
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream )  __asm__("freopen64")  ;
#line 271
extern FILE *fopen64(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 273
extern FILE *freopen64(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                       FILE * __restrict  __stream ) ;
#line 280
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 286
extern  __attribute__((__nothrow__)) FILE *fopencookie(void * __restrict  __magic_cookie ,
                                                       char const   * __restrict  __modes ,
                                                       _IO_cookie_io_functions_t __io_funcs ) ;
#line 291
extern  __attribute__((__nothrow__)) FILE *fmemopen(void *__s , size_t __len , char const   *__modes ) ;
#line 296
extern  __attribute__((__nothrow__)) FILE *open_memstream(char **__bufloc , size_t *__sizeloc ) ;
#line 303
extern  __attribute__((__nothrow__)) void setbuf(FILE * __restrict  __stream , char * __restrict  __buf ) ;
#line 307
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 314
extern  __attribute__((__nothrow__)) void setbuffer(FILE * __restrict  __stream ,
                                                    char * __restrict  __buf , size_t __size ) ;
#line 318
extern  __attribute__((__nothrow__)) void setlinebuf(FILE *__stream ) ;
#line 327
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 333
extern int printf(char const   * __restrict  __format  , ...) ;
#line 335
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 342
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 348
__inline static int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
#line 350
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 357
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 361
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 370
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 373
extern  __attribute__((__nothrow__)) int ( /* format attribute */  __asprintf)(char ** __restrict  __ptr ,
                                                                               char const   * __restrict  __fmt 
                                                                               , ...) ;
#line 376
extern  __attribute__((__nothrow__)) int ( /* format attribute */  asprintf)(char ** __restrict  __ptr ,
                                                                             char const   * __restrict  __fmt 
                                                                             , ...) ;
#line 386
extern int ( /* format attribute */  vdprintf)(int __fd , char const   * __restrict  __fmt ,
                                               __gnuc_va_list __arg ) ;
#line 389
extern int ( /* format attribute */  dprintf)(int __fd , char const   * __restrict  __fmt 
                                              , ...) ;
#line 399
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 405
extern int scanf(char const   * __restrict  __format  , ...) ;
#line 407
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 417
extern int ( /* format attribute */  vfscanf)(FILE * __restrict  __s , char const   * __restrict  __format ,
                                              __gnuc_va_list __arg ) ;
#line 425
extern int ( /* format attribute */  vscanf)(char const   * __restrict  __format ,
                                             __gnuc_va_list __arg ) ;
#line 429
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsscanf)(char const   * __restrict  __s ,
                                                                            char const   * __restrict  __format ,
                                                                            __gnuc_va_list __arg ) ;
#line 441
extern int fgetc(FILE *__stream ) ;
#line 442
extern int getc(FILE *__stream ) ;
#line 448
__inline static int getchar(void) ;
#line 460
__inline static int getc_unlocked(FILE *__fp ) ;
#line 461
__inline static int getchar_unlocked(void) ;
#line 471
__inline static int fgetc_unlocked(FILE *__fp ) ;
#line 483
extern int fputc(int __c , FILE *__stream ) ;
#line 484
extern int putc(int __c , FILE *__stream ) ;
#line 490
__inline static int putchar(int __c ) ;
#line 504
__inline static int fputc_unlocked(int __c , FILE *__stream ) ;
#line 512
__inline static int putc_unlocked(int __c , FILE *__stream ) ;
#line 513
__inline static int putchar_unlocked(int __c ) ;
#line 517
extern int getw(FILE *__stream ) ;
#line 520
extern int putw(int __w , FILE *__stream ) ;
#line 529
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 537
extern char *gets(char *__s ) ;
#line 550
extern char *fgets_unlocked(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 566
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 569
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 579
__inline static __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) ;
#line 590
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 596
extern int puts(char const   *__s ) ;
#line 603
extern int ungetc(int __c , FILE *__stream ) ;
#line 610
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 616
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 627
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 638
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 640
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 650
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 655
extern long ftell(FILE *__stream ) ;
#line 660
extern void rewind(FILE *__stream ) ;
#line 682
extern int fseeko(FILE *__stream , __off64_t __off , int __whence )  __asm__("fseeko64")  ;
#line 685
extern __off64_t ftello(FILE *__stream )  __asm__("ftello64")  ;
#line 707
extern int fgetpos(FILE * __restrict  __stream , fpos_t * __restrict  __pos )  __asm__("fgetpos64")  ;
#line 709
extern int fsetpos(FILE *__stream , fpos_t const   *__pos )  __asm__("fsetpos64")  ;
#line 719
extern int fseeko64(FILE *__stream , __off64_t __off , int __whence ) ;
#line 720
extern __off64_t ftello64(FILE *__stream ) ;
#line 721
extern int fgetpos64(FILE * __restrict  __stream , fpos64_t * __restrict  __pos ) ;
#line 722
extern int fsetpos64(FILE *__stream , fpos64_t const   *__pos ) ;
#line 727
extern  __attribute__((__nothrow__)) void clearerr(FILE *__stream ) ;
#line 729
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 731
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 736
extern  __attribute__((__nothrow__)) void clearerr_unlocked(FILE *__stream ) ;
#line 737
__inline static  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
#line 738
__inline static  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 747
extern void perror(char const   *__s ) ;
#line 27 "/usr/include/bits/sys_errlist.h"
extern int sys_nerr ;
#line 28
extern char const   * const  sys_errlist[] ;
#line 31
extern int _sys_nerr ;
#line 32
extern char const   * const  _sys_errlist[] ;
#line 759 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 764
extern  __attribute__((__nothrow__)) int fileno_unlocked(FILE *__stream ) ;
#line 774
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 780
extern int pclose(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) char *ctermid(char *__s ) ;
#line 792
extern char *cuserid(char *__s ) ;
#line 800
extern  __attribute__((__nothrow__)) int ( /* format attribute */  obstack_printf)(struct obstack * __restrict  __obstack ,
                                                                                   char const   * __restrict  __format 
                                                                                   , ...) ;
#line 803
extern  __attribute__((__nothrow__)) int ( /* format attribute */  obstack_vprintf)(struct obstack * __restrict  __obstack ,
                                                                                    char const   * __restrict  __format ,
                                                                                    __gnuc_va_list __args ) ;
#line 814
extern  __attribute__((__nothrow__)) void flockfile(FILE *__stream ) ;
#line 818
extern  __attribute__((__nothrow__)) int ftrylockfile(FILE *__stream ) ;
#line 821
extern  __attribute__((__nothrow__)) void funlockfile(FILE *__stream ) ;
#line 33 "/usr/include/bits/stdio.h"
__inline static int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ int tmp ;

  {
  {
#line 36
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 36
  return (tmp);
}
}
#line 40 "/usr/include/bits/stdio.h"
__inline static int getchar(void) 
{ int tmp ;

  {
  {
#line 43
  tmp = _IO_getc(stdin);
  }
#line 43
  return (tmp);
}
}
#line 49 "/usr/include/bits/stdio.h"
__inline static int fgetc_unlocked(FILE *__fp ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 52
  tmp___4 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 52
  if (tmp___4) {
    {
#line 52
    tmp___2 = __uflow(__fp);
    }
  } else {
#line 52
    tmp___3 = __fp->_IO_read_ptr;
#line 52
    (__fp->_IO_read_ptr) ++;
#line 52
    tmp___2 = (int )*((unsigned char *)tmp___3);
  }
#line 52
  return (tmp___2);
}
}
#line 59 "/usr/include/bits/stdio.h"
__inline static int getc_unlocked(FILE *__fp ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 62
  tmp___4 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 62
  if (tmp___4) {
    {
#line 62
    tmp___2 = __uflow(__fp);
    }
  } else {
#line 62
    tmp___3 = __fp->_IO_read_ptr;
#line 62
    (__fp->_IO_read_ptr) ++;
#line 62
    tmp___2 = (int )*((unsigned char *)tmp___3);
  }
#line 62
  return (tmp___2);
}
}
#line 66 "/usr/include/bits/stdio.h"
__inline static int getchar_unlocked(void) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 69
  tmp___4 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 69
  if (tmp___4) {
    {
#line 69
    tmp___2 = __uflow(stdin);
    }
  } else {
#line 69
    tmp___3 = stdin->_IO_read_ptr;
#line 69
    (stdin->_IO_read_ptr) ++;
#line 69
    tmp___2 = (int )*((unsigned char *)tmp___3);
  }
#line 69
  return (tmp___2);
}
}
#line 75 "/usr/include/bits/stdio.h"
__inline static int putchar(int __c ) 
{ int tmp ;

  {
  {
#line 78
  tmp = _IO_putc(__c, stdout);
  }
#line 78
  return (tmp);
}
}
#line 84 "/usr/include/bits/stdio.h"
__inline static int fputc_unlocked(int __c , FILE *__stream ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 87
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 87
  if (tmp___4) {
    {
#line 87
    tmp___2 = __overflow(__stream, (int )((unsigned char )__c));
    }
  } else {
#line 87
    tmp___3 = __stream->_IO_write_ptr;
#line 87
    (__stream->_IO_write_ptr) ++;
#line 87
    *tmp___3 = (char )__c;
#line 87
    tmp___2 = (int )((unsigned char )*tmp___3);
  }
#line 87
  return (tmp___2);
}
}
#line 94 "/usr/include/bits/stdio.h"
__inline static int putc_unlocked(int __c , FILE *__stream ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 97
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 97
  if (tmp___4) {
    {
#line 97
    tmp___2 = __overflow(__stream, (int )((unsigned char )__c));
    }
  } else {
#line 97
    tmp___3 = __stream->_IO_write_ptr;
#line 97
    (__stream->_IO_write_ptr) ++;
#line 97
    *tmp___3 = (char )__c;
#line 97
    tmp___2 = (int )((unsigned char )*tmp___3);
  }
#line 97
  return (tmp___2);
}
}
#line 101 "/usr/include/bits/stdio.h"
__inline static int putchar_unlocked(int __c ) 
{ long tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  long tmp___4 ;

  {
  {
#line 104
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 104
  if (tmp___4) {
    {
#line 104
    tmp___2 = __overflow(stdout, (int )((unsigned char )__c));
    }
  } else {
#line 104
    tmp___3 = stdout->_IO_write_ptr;
#line 104
    (stdout->_IO_write_ptr) ++;
#line 104
    *tmp___3 = (char )__c;
#line 104
    tmp___2 = (int )((unsigned char )*tmp___3);
  }
#line 104
  return (tmp___2);
}
}
#line 111 "/usr/include/bits/stdio.h"
__inline static __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ __ssize_t tmp ;

  {
  {
#line 114
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 114
  return (tmp);
}
}
#line 121
__inline static  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
#line 121 "/usr/include/bits/stdio.h"
__inline static int feof_unlocked(FILE *__stream ) 
{ 

  {
#line 124
  return ((__stream->_flags & 16) != 0);
}
}
#line 128
__inline static  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
#line 128 "/usr/include/bits/stdio.h"
__inline static int ferror_unlocked(FILE *__stream ) 
{ 

  {
#line 131
  return ((__stream->_flags & 32) != 0);
}
}
#line 140 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t __ctype_get_mb_cur_max(void) ;
#line 145
__inline static  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 148
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 151
__inline static  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 158
__inline static  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 165
__inline static  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 173
__inline static  __attribute__((__nothrow__)) float strtof(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 176
__inline static  __attribute__((__nothrow__)) long double strtold(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 184
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 188
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 196
__inline static  __attribute__((__nothrow__)) long long strtoq(char const   * __restrict  __nptr ,
                                                               char ** __restrict  __endptr ,
                                                               int __base )  __attribute__((__nonnull__(1))) ;
#line 201
__inline static  __attribute__((__nothrow__)) unsigned long long strtouq(char const   * __restrict  __nptr ,
                                                                         char ** __restrict  __endptr ,
                                                                         int __base )  __attribute__((__nonnull__(1))) ;
#line 210
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 215
__inline static  __attribute__((__nothrow__)) unsigned long long strtoull(char const   * __restrict  __nptr ,
                                                                          char ** __restrict  __endptr ,
                                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 240
extern  __attribute__((__nothrow__)) long strtol_l(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr ,
                                                   int __base , __locale_t __loc )  __attribute__((__nonnull__(1,4))) ;
#line 244
extern  __attribute__((__nothrow__)) unsigned long strtoul_l(char const   * __restrict  __nptr ,
                                                             char ** __restrict  __endptr ,
                                                             int __base , __locale_t __loc )  __attribute__((__nonnull__(1,4))) ;
#line 250
extern  __attribute__((__nothrow__)) long long strtoll_l(char const   * __restrict  __nptr ,
                                                         char ** __restrict  __endptr ,
                                                         int __base , __locale_t __loc )  __attribute__((__nonnull__(1,4))) ;
#line 256
extern  __attribute__((__nothrow__)) unsigned long long strtoull_l(char const   * __restrict  __nptr ,
                                                                   char ** __restrict  __endptr ,
                                                                   int __base , __locale_t __loc )  __attribute__((__nonnull__(1,4))) ;
#line 261
extern  __attribute__((__nothrow__)) double strtod_l(char const   * __restrict  __nptr ,
                                                     char ** __restrict  __endptr ,
                                                     __locale_t __loc )  __attribute__((__nonnull__(1,3))) ;
#line 265
extern  __attribute__((__nothrow__)) float strtof_l(char const   * __restrict  __nptr ,
                                                    char ** __restrict  __endptr ,
                                                    __locale_t __loc )  __attribute__((__nonnull__(1,3))) ;
#line 269
extern  __attribute__((__nothrow__)) long double strtold_l(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           __locale_t __loc )  __attribute__((__nonnull__(1,3))) ;
#line 279
extern  __attribute__((__nothrow__)) double __strtod_internal(char const   * __restrict  __nptr ,
                                                              char ** __restrict  __endptr ,
                                                              int __group )  __attribute__((__nonnull__(1))) ;
#line 282
extern  __attribute__((__nothrow__)) float __strtof_internal(char const   * __restrict  __nptr ,
                                                             char ** __restrict  __endptr ,
                                                             int __group )  __attribute__((__nonnull__(1))) ;
#line 285
extern  __attribute__((__nothrow__)) long double __strtold_internal(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __group )  __attribute__((__nonnull__(1))) ;
#line 290
extern  __attribute__((__nothrow__)) long __strtol_internal(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr ,
                                                            int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 297
extern  __attribute__((__nothrow__)) unsigned long __strtoul_internal(char const   * __restrict  __nptr ,
                                                                      char ** __restrict  __endptr ,
                                                                      int __base ,
                                                                      int __group )  __attribute__((__nonnull__(1))) ;
#line 306
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
#line 314
extern  __attribute__((__nothrow__)) unsigned long long __strtoull_internal(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            int __base ,
                                                                            int __group )  __attribute__((__nonnull__(1))) ;
#line 327
__inline static  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                            char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 327 "/usr/include/stdlib.h"
__inline static double strtod(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ double tmp ;

  {
  {
#line 330
  tmp = __strtod_internal(__nptr, __endptr, 0);
  }
#line 330
  return (tmp);
}
}
#line 332
__inline static  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                          char ** __restrict  __endptr ,
                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 332 "/usr/include/stdlib.h"
__inline static long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                            int __base ) 
{ long tmp ;

  {
  {
#line 336
  tmp = __strtol_internal(__nptr, __endptr, __base, 0);
  }
#line 336
  return (tmp);
}
}
#line 338
__inline static  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                                    char ** __restrict  __endptr ,
                                                                    int __base )  __attribute__((__nonnull__(1))) ;
#line 338 "/usr/include/stdlib.h"
__inline static unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                      int __base ) 
{ unsigned long tmp ;

  {
  {
#line 342
  tmp = __strtoul_internal(__nptr, __endptr, __base, 0);
  }
#line 342
  return (tmp);
}
}
#line 348
__inline static  __attribute__((__nothrow__)) float strtof(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 348 "/usr/include/stdlib.h"
__inline static float strtof(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ float tmp ;

  {
  {
#line 351
  tmp = __strtof_internal(__nptr, __endptr, 0);
  }
#line 351
  return (tmp);
}
}
#line 354
__inline static  __attribute__((__nothrow__)) long double strtold(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 354 "/usr/include/stdlib.h"
__inline static long double strtold(char const   * __restrict  __nptr , char ** __restrict  __endptr ) 
{ long double tmp ;

  {
  {
#line 357
  tmp = __strtold_internal(__nptr, __endptr, 0);
  }
#line 357
  return (tmp);
}
}
#line 364
__inline static  __attribute__((__nothrow__)) long long strtoq(char const   * __restrict  __nptr ,
                                                               char ** __restrict  __endptr ,
                                                               int __base )  __attribute__((__nonnull__(1))) ;
#line 364 "/usr/include/stdlib.h"
__inline static long long strtoq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                 int __base ) 
{ long long tmp ;

  {
  {
#line 368
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
  }
#line 368
  return (tmp);
}
}
#line 370
__inline static  __attribute__((__nothrow__)) unsigned long long strtouq(char const   * __restrict  __nptr ,
                                                                         char ** __restrict  __endptr ,
                                                                         int __base )  __attribute__((__nonnull__(1))) ;
#line 370 "/usr/include/stdlib.h"
__inline static unsigned long long strtouq(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                           int __base ) 
{ unsigned long long tmp ;

  {
  {
#line 374
  tmp = __strtoull_internal(__nptr, __endptr, __base, 0);
  }
#line 374
  return (tmp);
}
}
#line 380
__inline static  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                                char ** __restrict  __endptr ,
                                                                int __base )  __attribute__((__nonnull__(1))) ;
#line 380 "/usr/include/stdlib.h"
__inline static long long strtoll(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                  int __base ) 
{ long long tmp ;

  {
  {
#line 384
  tmp = __strtoll_internal(__nptr, __endptr, __base, 0);
  }
#line 384
  return (tmp);
}
}
#line 386
__inline static  __attribute__((__nothrow__)) unsigned long long strtoull(char const   * __restrict  __nptr ,
                                                                          char ** __restrict  __endptr ,
                                                                          int __base )  __attribute__((__nonnull__(1))) ;
#line 386 "/usr/include/stdlib.h"
__inline static unsigned long long strtoull(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                                            int __base ) 
{ unsigned long long tmp ;

  {
  {
#line 390
  tmp = __strtoull_internal(__nptr, __endptr, __base, 0);
  }
#line 390
  return (tmp);
}
}
#line 396
__inline static  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 396 "/usr/include/stdlib.h"
__inline static double atof(char const   *__nptr ) 
{ double tmp ;

  {
  {
#line 399
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 399
  return (tmp);
}
}
#line 401
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 401 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  {
#line 404
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 404
  return ((int )tmp);
}
}
#line 406
__inline static  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 406 "/usr/include/stdlib.h"
__inline static long atol(char const   *__nptr ) 
{ long tmp ;

  {
  {
#line 409
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 409
  return (tmp);
}
}
#line 415
__inline static  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 415 "/usr/include/stdlib.h"
__inline static long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
  {
#line 418
  tmp = strtoll((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
                10);
  }
#line 418
  return (tmp);
}
}
#line 429
extern  __attribute__((__nothrow__)) char *l64a(long __n ) ;
#line 432
extern  __attribute__((__nothrow__)) long a64l(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 121
extern int pselect(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                   fd_set * __restrict  __exceptfds , struct timespec  const  * __restrict  __timeout ,
                   __sigset_t const   * __restrict  __sigmask ) ;
#line 30 "/usr/include/sys/sysmacros.h"
__inline static  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 33
__inline static  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 36
__inline static  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 41
__inline static  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
#line 41 "/usr/include/sys/sysmacros.h"
__inline static unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 

  {
#line 44
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 47
__inline static  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
#line 47 "/usr/include/sys/sysmacros.h"
__inline static unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 

  {
#line 50
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 53
__inline static  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
#line 53 "/usr/include/sys/sysmacros.h"
__inline static unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
#line 56
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 445 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long random(void) ;
#line 448
extern  __attribute__((__nothrow__)) void srandom(unsigned int __seed ) ;
#line 454
extern  __attribute__((__nothrow__)) char *initstate(unsigned int __seed , char *__statebuf ,
                                                     size_t __statelen )  __attribute__((__nonnull__(2))) ;
#line 459
extern  __attribute__((__nothrow__)) char *setstate(char *__statebuf )  __attribute__((__nonnull__(1))) ;
#line 478
extern  __attribute__((__nothrow__)) int random_r(struct random_data * __restrict  __buf ,
                                                  int32_t * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 481
extern  __attribute__((__nothrow__)) int srandom_r(unsigned int __seed , struct random_data *__buf )  __attribute__((__nonnull__(2))) ;
#line 484
extern  __attribute__((__nothrow__)) int initstate_r(unsigned int __seed , char * __restrict  __statebuf ,
                                                     size_t __statelen , struct random_data * __restrict  __buf )  __attribute__((__nonnull__(2,4))) ;
#line 489
extern  __attribute__((__nothrow__)) int setstate_r(char * __restrict  __statebuf ,
                                                    struct random_data * __restrict  __buf )  __attribute__((__nonnull__(1,2))) ;
#line 498
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 500
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 505
extern  __attribute__((__nothrow__)) int rand_r(unsigned int *__seed ) ;
#line 513
extern  __attribute__((__nothrow__)) double drand48(void) ;
#line 514
extern  __attribute__((__nothrow__)) double erand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
#line 517
extern  __attribute__((__nothrow__)) long lrand48(void) ;
#line 518
extern  __attribute__((__nothrow__)) long nrand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
#line 522
extern  __attribute__((__nothrow__)) long mrand48(void) ;
#line 523
extern  __attribute__((__nothrow__)) long jrand48(unsigned short *__xsubi )  __attribute__((__nonnull__(1))) ;
#line 527
extern  __attribute__((__nothrow__)) void srand48(long __seedval ) ;
#line 528
extern  __attribute__((__nothrow__)) unsigned short *seed48(unsigned short *__seed16v )  __attribute__((__nonnull__(1))) ;
#line 530
extern  __attribute__((__nothrow__)) void lcong48(unsigned short *__param )  __attribute__((__nonnull__(1))) ;
#line 546
extern  __attribute__((__nothrow__)) int drand48_r(struct drand48_data * __restrict  __buffer ,
                                                   double * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 548
extern  __attribute__((__nothrow__)) int erand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer ,
                                                   double * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 553
extern  __attribute__((__nothrow__)) int lrand48_r(struct drand48_data * __restrict  __buffer ,
                                                   long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 556
extern  __attribute__((__nothrow__)) int nrand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer ,
                                                   long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 562
extern  __attribute__((__nothrow__)) int mrand48_r(struct drand48_data * __restrict  __buffer ,
                                                   long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 565
extern  __attribute__((__nothrow__)) int jrand48_r(unsigned short *__xsubi , struct drand48_data * __restrict  __buffer ,
                                                   long * __restrict  __result )  __attribute__((__nonnull__(1,2))) ;
#line 571
extern  __attribute__((__nothrow__)) int srand48_r(long __seedval , struct drand48_data *__buffer )  __attribute__((__nonnull__(2))) ;
#line 574
extern  __attribute__((__nothrow__)) int seed48_r(unsigned short *__seed16v , struct drand48_data *__buffer )  __attribute__((__nonnull__(1,2))) ;
#line 577
extern  __attribute__((__nothrow__)) int lcong48_r(unsigned short *__param , struct drand48_data *__buffer )  __attribute__((__nonnull__(1,2))) ;
#line 589
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 591
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 600
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__,
__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 608
extern  __attribute__((__nothrow__)) void cfree(void *__ptr ) ;
#line 33 "/usr/include/alloca.h"
extern  __attribute__((__nothrow__)) void *alloca(size_t __size ) ;
#line 617 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *valloc(size_t __size )  __attribute__((__malloc__)) ;
#line 622
extern  __attribute__((__nothrow__)) int posix_memalign(void **__memptr , size_t __alignment ,
                                                        size_t __size )  __attribute__((__nonnull__(1))) ;
#line 628
extern  __attribute__((__nothrow__, __noreturn__)) void abort(void) ;
#line 632
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
#line 638
extern  __attribute__((__nothrow__)) int on_exit(void (*__func)(int __status , void *__arg ) ,
                                                 void *__arg )  __attribute__((__nonnull__(1))) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 653
extern  __attribute__((__nothrow__, __noreturn__)) void _Exit(int __status ) ;
#line 660
extern  __attribute__((__nothrow__)) char *getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 665
extern  __attribute__((__nothrow__)) char *__secure_getenv(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 672
extern  __attribute__((__nothrow__)) int putenv(char *__string )  __attribute__((__nonnull__(1))) ;
#line 678
extern  __attribute__((__nothrow__)) int setenv(char const   *__name , char const   *__value ,
                                                int __replace )  __attribute__((__nonnull__(2))) ;
#line 682
extern  __attribute__((__nothrow__)) int unsetenv(char const   *__name ) ;
#line 689
extern  __attribute__((__nothrow__)) int clearenv(void) ;
#line 698
extern  __attribute__((__nothrow__)) char *mktemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 712
extern int mkstemp(char *__template )  __asm__("mkstemp64") __attribute__((__nonnull__(1))) ;
#line 719
extern int mkstemp64(char *__template )  __attribute__((__nonnull__(1))) ;
#line 729
extern  __attribute__((__nothrow__)) char *mkdtemp(char *__template )  __attribute__((__nonnull__(1))) ;
#line 738
extern int system(char const   *__command ) ;
#line 746
extern  __attribute__((__nothrow__)) char *canonicalize_file_name(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 756
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
#line 774
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                     size_t __size , int (*__compar)(void const   * , void const   * ) )  __attribute__((__nonnull__(1,2,5))) ;
#line 780
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
#line 785
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
#line 786
extern  __attribute__((__nothrow__)) long labs(long __x )  __attribute__((__const__)) ;
#line 790
extern  __attribute__((__nothrow__)) long long llabs(long long __x )  __attribute__((__const__)) ;
#line 799
extern  __attribute__((__nothrow__)) div_t div(int __numer , int __denom )  __attribute__((__const__)) ;
#line 801
extern  __attribute__((__nothrow__)) ldiv_t ldiv(long __numer , long __denom )  __attribute__((__const__)) ;
#line 807
extern  __attribute__((__nothrow__)) lldiv_t lldiv(long long __numer , long long __denom )  __attribute__((__const__)) ;
#line 821
extern  __attribute__((__nothrow__)) char *ecvt(double __value , int __ndigit , int * __restrict  __decpt ,
                                                int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
#line 827
extern  __attribute__((__nothrow__)) char *fcvt(double __value , int __ndigit , int * __restrict  __decpt ,
                                                int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
#line 833
extern  __attribute__((__nothrow__)) char *gcvt(double __value , int __ndigit , char *__buf )  __attribute__((__nonnull__(3))) ;
#line 839
extern  __attribute__((__nothrow__)) char *qecvt(long double __value , int __ndigit ,
                                                 int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
#line 842
extern  __attribute__((__nothrow__)) char *qfcvt(long double __value , int __ndigit ,
                                                 int * __restrict  __decpt , int * __restrict  __sign )  __attribute__((__nonnull__(3,4))) ;
#line 845
extern  __attribute__((__nothrow__)) char *qgcvt(long double __value , int __ndigit ,
                                                 char *__buf )  __attribute__((__nonnull__(3))) ;
#line 851
extern  __attribute__((__nothrow__)) int ecvt_r(double __value , int __ndigit , int * __restrict  __decpt ,
                                                int * __restrict  __sign , char * __restrict  __buf ,
                                                size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
#line 854
extern  __attribute__((__nothrow__)) int fcvt_r(double __value , int __ndigit , int * __restrict  __decpt ,
                                                int * __restrict  __sign , char * __restrict  __buf ,
                                                size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
#line 858
extern  __attribute__((__nothrow__)) int qecvt_r(long double __value , int __ndigit ,
                                                 int * __restrict  __decpt , int * __restrict  __sign ,
                                                 char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
#line 862
extern  __attribute__((__nothrow__)) int qfcvt_r(long double __value , int __ndigit ,
                                                 int * __restrict  __decpt , int * __restrict  __sign ,
                                                 char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(3,4,5))) ;
#line 873
extern  __attribute__((__nothrow__)) int mblen(char const   *__s , size_t __n ) ;
#line 876
extern  __attribute__((__nothrow__)) int mbtowc(wchar_t * __restrict  __pwc , char const   * __restrict  __s ,
                                                size_t __n ) ;
#line 880
extern  __attribute__((__nothrow__)) int wctomb(char *__s , wchar_t __wchar ) ;
#line 884
extern  __attribute__((__nothrow__)) size_t mbstowcs(wchar_t * __restrict  __pwcs ,
                                                     char const   * __restrict  __s ,
                                                     size_t __n ) ;
#line 887
extern  __attribute__((__nothrow__)) size_t wcstombs(char * __restrict  __s , wchar_t const   * __restrict  __pwcs ,
                                                     size_t __n ) ;
#line 898
extern  __attribute__((__nothrow__)) int rpmatch(char const   *__response )  __attribute__((__nonnull__(1))) ;
#line 909
extern  __attribute__((__nothrow__)) int getsubopt(char ** __restrict  __optionp ,
                                                   char * const  * __restrict  __tokens ,
                                                   char ** __restrict  __valuep )  __attribute__((__nonnull__(1,2,3))) ;
#line 918
extern  __attribute__((__nothrow__)) void setkey(char const   *__key )  __attribute__((__nonnull__(1))) ;
#line 926
extern int posix_openpt(int __oflag ) ;
#line 934
extern  __attribute__((__nothrow__)) int grantpt(int __fd ) ;
#line 938
extern  __attribute__((__nothrow__)) int unlockpt(int __fd ) ;
#line 943
extern  __attribute__((__nothrow__)) char *ptsname(int __fd ) ;
#line 950
extern  __attribute__((__nothrow__)) int ptsname_r(int __fd , char *__buf , size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 954
extern int getpt(void) ;
#line 961
extern  __attribute__((__nothrow__)) int getloadavg(double *__loadavg , int __nelem )  __attribute__((__nonnull__(1))) ;
#line 258 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 263
extern  __attribute__((__nothrow__)) int euidaccess(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 267
extern  __attribute__((__nothrow__)) int eaccess(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 275
extern  __attribute__((__nothrow__)) int faccessat(int __fd , char const   *__file ,
                                                   int __type , int __flag )  __attribute__((__nonnull__(2))) ;
#line 304
extern  __attribute__((__nothrow__)) __off64_t lseek(int __fd , __off64_t __offset ,
                                                     int __whence )  __asm__("lseek64")  ;
#line 312
extern  __attribute__((__nothrow__)) __off64_t lseek64(int __fd , __off64_t __offset ,
                                                       int __whence ) ;
#line 320
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 355
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64")  ;
#line 358
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pwrite64")  ;
#line 371
extern ssize_t pread64(int __fd , void *__buf , size_t __nbytes , __off64_t __offset ) ;
#line 375
extern ssize_t pwrite64(int __fd , void const   *__buf , size_t __n , __off64_t __offset ) ;
#line 384
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 393
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 405
extern unsigned int sleep(unsigned int __seconds ) ;
#line 412
extern  __attribute__((__nothrow__)) __useconds_t ualarm(__useconds_t __value , __useconds_t __interval ) ;
#line 420
extern int usleep(__useconds_t __useconds ) ;
#line 429
extern int pause(void) ;
#line 433
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 438
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 443
extern  __attribute__((__nothrow__)) int lchown(char const   *__file , __uid_t __owner ,
                                                __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 451
extern  __attribute__((__nothrow__)) int fchownat(int __fd , char const   *__file ,
                                                  __uid_t __owner , __gid_t __group ,
                                                  int __flag )  __attribute__((__nonnull__(2))) ;
#line 457
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 461
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 471
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 477
extern  __attribute__((__nothrow__)) char *get_current_dir_name(void) ;
#line 484
extern  __attribute__((__nothrow__)) char *getwd(char *__buf )  __attribute__((__nonnull__(1),
__deprecated__)) ;
#line 490
extern  __attribute__((__nothrow__)) int dup(int __fd ) ;
#line 493
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 496
extern char **__environ ;
#line 498
extern char **environ ;
#line 504
extern  __attribute__((__nothrow__)) int execve(char const   *__path , char * const  *__argv ,
                                                char * const  *__envp )  __attribute__((__nonnull__(1))) ;
#line 510
extern  __attribute__((__nothrow__)) int fexecve(int __fd , char * const  *__argv ,
                                                 char * const  *__envp ) ;
#line 516
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 521
extern  __attribute__((__nothrow__)) int execle(char const   *__path , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 526
extern  __attribute__((__nothrow__)) int execl(char const   *__path , char const   *__arg 
                                               , ...)  __attribute__((__nonnull__(1))) ;
#line 531
extern  __attribute__((__nothrow__)) int execvp(char const   *__file , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 537
extern  __attribute__((__nothrow__)) int execlp(char const   *__file , char const   *__arg 
                                                , ...)  __attribute__((__nonnull__(1))) ;
#line 543
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 548
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 557
extern  __attribute__((__nothrow__)) long pathconf(char const   *__path , int __name )  __attribute__((__nonnull__(1))) ;
#line 561
extern  __attribute__((__nothrow__)) long fpathconf(int __fd , int __name ) ;
#line 564
extern  __attribute__((__nothrow__)) long sysconf(int __name )  __attribute__((__const__)) ;
#line 568
extern  __attribute__((__nothrow__)) size_t confstr(int __name , char *__buf , size_t __len ) ;
#line 573
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 576
extern  __attribute__((__nothrow__)) __pid_t getppid(void) ;
#line 581
extern  __attribute__((__nothrow__)) __pid_t getpgrp(void) ;
#line 591
extern  __attribute__((__nothrow__)) __pid_t __getpgid(__pid_t __pid ) ;
#line 593
extern  __attribute__((__nothrow__)) __pid_t getpgid(__pid_t __pid ) ;
#line 600
extern  __attribute__((__nothrow__)) int setpgid(__pid_t __pid , __pid_t __pgid ) ;
#line 617
extern  __attribute__((__nothrow__)) int setpgrp(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 638
extern  __attribute__((__nothrow__)) __pid_t getsid(__pid_t __pid ) ;
#line 642
extern  __attribute__((__nothrow__)) __uid_t getuid(void) ;
#line 645
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 648
extern  __attribute__((__nothrow__)) __gid_t getgid(void) ;
#line 651
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 656
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 660
extern  __attribute__((__nothrow__)) int group_member(__gid_t __gid ) ;
#line 667
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 672
extern  __attribute__((__nothrow__)) int setreuid(__uid_t __ruid , __uid_t __euid ) ;
#line 677
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 684
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 689
extern  __attribute__((__nothrow__)) int setregid(__gid_t __rgid , __gid_t __egid ) ;
#line 694
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 700
extern  __attribute__((__nothrow__)) int getresuid(__uid_t *__ruid , __uid_t *__euid ,
                                                   __uid_t *__suid ) ;
#line 705
extern  __attribute__((__nothrow__)) int getresgid(__gid_t *__rgid , __gid_t *__egid ,
                                                   __gid_t *__sgid ) ;
#line 710
extern  __attribute__((__nothrow__)) int setresuid(__uid_t __ruid , __uid_t __euid ,
                                                   __uid_t __suid ) ;
#line 715
extern  __attribute__((__nothrow__)) int setresgid(__gid_t __rgid , __gid_t __egid ,
                                                   __gid_t __sgid ) ;
#line 723
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 730
extern  __attribute__((__nothrow__)) __pid_t vfork(void) ;
#line 736
extern  __attribute__((__nothrow__)) char *ttyname(int __fd ) ;
#line 740
extern  __attribute__((__nothrow__)) int ttyname_r(int __fd , char *__buf , size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 745
extern  __attribute__((__nothrow__)) int isatty(int __fd ) ;
#line 751
extern  __attribute__((__nothrow__)) int ttyslot(void) ;
#line 756
extern  __attribute__((__nothrow__)) int link(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 762
extern  __attribute__((__nothrow__)) int linkat(int __fromfd , char const   *__from ,
                                                int __tofd , char const   *__to ,
                                                int __flags )  __attribute__((__nonnull__(2,4))) ;
#line 769
extern  __attribute__((__nothrow__)) int symlink(char const   *__from , char const   *__to )  __attribute__((__nonnull__(1,2))) ;
#line 775
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   * __restrict  __path ,
                                                      char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 782
extern  __attribute__((__nothrow__)) int symlinkat(char const   *__from , int __tofd ,
                                                   char const   *__to )  __attribute__((__nonnull__(1,3))) ;
#line 786
extern  __attribute__((__nothrow__)) ssize_t readlinkat(int __fd , char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len )  __attribute__((__nonnull__(2,3))) ;
#line 792
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 796
extern  __attribute__((__nothrow__)) int unlinkat(int __fd , char const   *__name ,
                                                  int __flag )  __attribute__((__nonnull__(2))) ;
#line 801
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 805
extern  __attribute__((__nothrow__)) __pid_t tcgetpgrp(int __fd ) ;
#line 808
extern  __attribute__((__nothrow__)) int tcsetpgrp(int __fd , __pid_t __pgrp_id ) ;
#line 815
extern char *getlogin(void) ;
#line 823
extern int getlogin_r(char *__name , size_t __name_len )  __attribute__((__nonnull__(1))) ;
#line 828
extern  __attribute__((__nothrow__)) int setlogin(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 73
extern int optind ;
#line 78
extern int opterr ;
#line 82
extern int optopt ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 845 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 852
extern  __attribute__((__nothrow__)) int sethostname(char const   *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 857
extern  __attribute__((__nothrow__)) int sethostid(long __id ) ;
#line 863
extern  __attribute__((__nothrow__)) int getdomainname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 865
extern  __attribute__((__nothrow__)) int setdomainname(char const   *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 872
extern  __attribute__((__nothrow__)) int vhangup(void) ;
#line 875
extern  __attribute__((__nothrow__)) int revoke(char const   *__file )  __attribute__((__nonnull__(1))) ;
#line 883
extern  __attribute__((__nothrow__)) int profil(unsigned short *__sample_buffer ,
                                                size_t __size , size_t __offset ,
                                                unsigned int __scale )  __attribute__((__nonnull__(1))) ;
#line 891
extern  __attribute__((__nothrow__)) int acct(char const   *__name ) ;
#line 895
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 896
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 897
extern  __attribute__((__nothrow__)) void setusershell(void) ;
#line 903
extern  __attribute__((__nothrow__)) int daemon(int __nochdir , int __noclose ) ;
#line 910
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 914
extern char *getpass(char const   *__prompt )  __attribute__((__nonnull__(1))) ;
#line 923
extern int fsync(int __fd ) ;
#line 930
extern long gethostid(void) ;
#line 933
extern  __attribute__((__nothrow__)) void sync(void) ;
#line 938
extern  __attribute__((__nothrow__)) int getpagesize(void)  __attribute__((__const__)) ;
#line 943
extern  __attribute__((__nothrow__)) int getdtablesize(void) ;
#line 952
extern  __attribute__((__nothrow__)) int truncate(char const   *__file , __off64_t __length )  __asm__("truncate64") __attribute__((__nonnull__(1))) ;
#line 960
extern  __attribute__((__nothrow__)) int truncate64(char const   *__file , __off64_t __length )  __attribute__((__nonnull__(1))) ;
#line 973
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off64_t __length )  __asm__("ftruncate64")  ;
#line 980
extern  __attribute__((__nothrow__)) int ftruncate64(int __fd , __off64_t __length ) ;
#line 990
extern  __attribute__((__nothrow__)) int brk(void *__addr ) ;
#line 996
extern  __attribute__((__nothrow__)) void *sbrk(intptr_t __delta ) ;
#line 1011
extern  __attribute__((__nothrow__)) long syscall(long __sysno  , ...) ;
#line 1037
extern int lockf(int __fd , int __cmd , __off64_t __len )  __asm__("lockf64")  ;
#line 1044
extern int lockf64(int __fd , int __cmd , __off64_t __len ) ;
#line 1065
extern int fdatasync(int __fildes ) ;
#line 1073
extern  __attribute__((__nothrow__)) char *crypt(char const   *__key , char const   *__salt )  __attribute__((__nonnull__(1,2))) ;
#line 1078
extern  __attribute__((__nothrow__)) void encrypt(char *__block , int __edflag )  __attribute__((__nonnull__(1))) ;
#line 1085
extern  __attribute__((__nothrow__)) void swab(void const   * __restrict  __from ,
                                               void * __restrict  __to , ssize_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 34 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int bcmp(void const   *__s1 , void const   *__s2 ,
                                              size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 38
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 41
extern  __attribute__((__nothrow__)) void bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 45
extern  __attribute__((__nothrow__)) int ffs(int __i )  __attribute__((__const__)) ;
#line 48
extern  __attribute__((__nothrow__)) char *index(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 51
extern  __attribute__((__nothrow__)) char *rindex(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 54
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 58
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 43
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 51
extern  __attribute__((__nothrow__)) void *memccpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                   int __c , size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 59
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 62
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 66
extern  __attribute__((__nothrow__)) void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 73
extern  __attribute__((__nothrow__)) void *rawmemchr(void const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 77
extern  __attribute__((__nothrow__)) void *memrchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 87
extern  __attribute__((__nothrow__)) char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 92
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 95
extern  __attribute__((__nothrow__)) char *strncat(char * __restrict  __dest , char const   * __restrict  __src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 99
extern  __attribute__((__nothrow__)) int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 106
extern  __attribute__((__nothrow__)) int strcoll(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 109
extern  __attribute__((__nothrow__)) size_t strxfrm(char * __restrict  __dest , char const   * __restrict  __src ,
                                                    size_t __n )  __attribute__((__nonnull__(2))) ;
#line 121
extern  __attribute__((__nothrow__)) int strcoll_l(char const   *__s1 , char const   *__s2 ,
                                                   __locale_t __l )  __attribute__((__pure__,
__nonnull__(1,2,3))) ;
#line 124
extern  __attribute__((__nothrow__)) size_t strxfrm_l(char *__dest , char const   *__src ,
                                                      size_t __n , __locale_t __l )  __attribute__((__nonnull__(2,4))) ;
#line 130
extern  __attribute__((__nothrow__)) char *strdup(char const   *__s )  __attribute__((__nonnull__(1),
__malloc__)) ;
#line 138
extern  __attribute__((__nothrow__)) char *strndup(char const   *__string , size_t __n )  __attribute__((__nonnull__(1),
__malloc__)) ;
#line 167
extern  __attribute__((__nothrow__)) char *strchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 177
extern  __attribute__((__nothrow__)) char *strchrnul(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
extern  __attribute__((__nothrow__)) size_t strcspn(char const   *__s , char const   *__reject )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 188
extern  __attribute__((__nothrow__)) size_t strspn(char const   *__s , char const   *__accept )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 191
extern  __attribute__((__nothrow__)) char *strpbrk(char const   *__s , char const   *__accept )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 199
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 205
extern  __attribute__((__nothrow__)) char *__strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                                                      char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
#line 210
extern  __attribute__((__nothrow__)) char *strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                                                    char ** __restrict  __save_ptr )  __attribute__((__nonnull__(2,3))) ;
#line 217
extern  __attribute__((__nothrow__)) char *strcasestr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 225
extern  __attribute__((__nothrow__)) void *memmem(void const   *__haystack , size_t __haystacklen ,
                                                  void const   *__needle , size_t __needlelen )  __attribute__((__pure__,
__nonnull__(1,3))) ;
#line 231
extern  __attribute__((__nothrow__)) void *__mempcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                     size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 234
extern  __attribute__((__nothrow__)) void *mempcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) size_t strnlen(char const   *__string , size_t __maxlen )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 281
extern  __attribute__((__nothrow__)) char *strerror_r(int __errnum , char *__buf ,
                                                      size_t __buflen )  __attribute__((__nonnull__(2))) ;
#line 288
extern  __attribute__((__nothrow__)) void __bzero(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 317
extern  __attribute__((__nothrow__)) int ffsl(long __l )  __attribute__((__const__)) ;
#line 319
extern  __attribute__((__nothrow__)) int ffsll(long long __ll )  __attribute__((__const__)) ;
#line 336
extern  __attribute__((__nothrow__)) int strcasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                      __locale_t __loc )  __attribute__((__pure__,
__nonnull__(1,2,3))) ;
#line 340
extern  __attribute__((__nothrow__)) int strncasecmp_l(char const   *__s1 , char const   *__s2 ,
                                                       size_t __n , __locale_t __loc )  __attribute__((__pure__,
__nonnull__(1,2,4))) ;
#line 348
extern  __attribute__((__nothrow__)) char *strsep(char ** __restrict  __stringp ,
                                                  char const   * __restrict  __delim )  __attribute__((__nonnull__(1,2))) ;
#line 355
extern  __attribute__((__nothrow__)) int strverscmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 359
extern  __attribute__((__nothrow__)) char *strsignal(int __sig ) ;
#line 362
extern  __attribute__((__nothrow__)) char *__stpcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 364
extern  __attribute__((__nothrow__)) char *stpcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 369
extern  __attribute__((__nothrow__)) char *__stpncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                                                     size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 372
extern  __attribute__((__nothrow__)) char *stpncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 377
extern  __attribute__((__nothrow__)) char *strfry(char *__string )  __attribute__((__nonnull__(1))) ;
#line 380
extern  __attribute__((__nothrow__)) void *memfrob(void *__s , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 387
extern  __attribute__((__nothrow__)) char *basename(char const   *__filename )  __attribute__((__nonnull__(1))) ;
#line 394 "/usr/include/bits/string2.h"
extern void *__rawmemchr(void const   *__s , int __c ) ;
#line 969
__inline static size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 970 "/usr/include/bits/string2.h"
__inline static size_t __strcspn_c1(char const   *__s , int __reject ) 
{ register size_t __result ;

  {
#line 973
  __result = (size_t )0;
#line 974
  while (1) {
#line 974
    if ((int const   )*(__s + __result) != 0) {
#line 974
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 974
        break;
      }
    } else {
#line 974
      break;
    }
#line 975
    __result ++;
  }
#line 976
  return (__result);
}
}
#line 979
__inline static size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 981 "/usr/include/bits/string2.h"
__inline static size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ register size_t __result ;

  {
#line 984
  __result = (size_t )0;
#line 985
  while (1) {
#line 985
    if ((int const   )*(__s + __result) != 0) {
#line 985
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 985
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 985
          break;
        }
      } else {
#line 985
        break;
      }
    } else {
#line 985
      break;
    }
#line 987
    __result ++;
  }
#line 988
  return (__result);
}
}
#line 991
__inline static size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 993 "/usr/include/bits/string2.h"
__inline static size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ register size_t __result ;

  {
#line 997
  __result = (size_t )0;
#line 998
  while (1) {
#line 998
    if ((int const   )*(__s + __result) != 0) {
#line 998
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 998
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 998
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 998
            break;
          }
        } else {
#line 998
          break;
        }
      } else {
#line 998
        break;
      }
    } else {
#line 998
      break;
    }
#line 1000
    __result ++;
  }
#line 1001
  return (__result);
}
}
#line 1045
__inline static size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1046 "/usr/include/bits/string2.h"
__inline static size_t __strspn_c1(char const   *__s , int __accept ) 
{ register size_t __result ;

  {
#line 1049
  __result = (size_t )0;
#line 1051
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1052
    __result ++;
  }
#line 1053
  return (__result);
}
}
#line 1056
__inline static size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1058 "/usr/include/bits/string2.h"
__inline static size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ register size_t __result ;

  {
#line 1061
  __result = (size_t )0;
#line 1063
  while (1) {
#line 1063
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1063
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1063
        break;
      }
    }
#line 1064
    __result ++;
  }
#line 1065
  return (__result);
}
}
#line 1068
__inline static size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1070 "/usr/include/bits/string2.h"
__inline static size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ register size_t __result ;

  {
#line 1073
  __result = (size_t )0;
#line 1075
  while (1) {
#line 1075
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1075
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1075
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1075
          break;
        }
      }
    }
#line 1077
    __result ++;
  }
#line 1078
  return (__result);
}
}
#line 1121
__inline static char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1123 "/usr/include/bits/string2.h"
__inline static char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ char *tmp ;

  {
#line 1127
  while (1) {
#line 1127
    if ((int const   )*__s != 0) {
#line 1127
      if ((int const   )*__s != (int const   )__accept1) {
#line 1127
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1127
          break;
        }
      } else {
#line 1127
        break;
      }
    } else {
#line 1127
      break;
    }
#line 1128
    __s ++;
  }
#line 1129
  if ((int const   )*__s == 0) {
#line 1129
    tmp = (char *)((void *)0);
  } else {
#line 1129
    tmp = (char *)((unsigned long )__s);
  }
#line 1129
  return (tmp);
}
}
#line 1132
__inline static char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1134 "/usr/include/bits/string2.h"
__inline static char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ char *tmp ;

  {
#line 1139
  while (1) {
#line 1139
    if ((int const   )*__s != 0) {
#line 1139
      if ((int const   )*__s != (int const   )__accept1) {
#line 1139
        if ((int const   )*__s != (int const   )__accept2) {
#line 1139
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1139
            break;
          }
        } else {
#line 1139
          break;
        }
      } else {
#line 1139
        break;
      }
    } else {
#line 1139
      break;
    }
#line 1141
    __s ++;
  }
#line 1142
  if ((int const   )*__s == 0) {
#line 1142
    tmp = (char *)((void *)0);
  } else {
#line 1142
    tmp = (char *)((unsigned long )__s);
  }
#line 1142
  return (tmp);
}
}
#line 1173
__inline static char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1174 "/usr/include/bits/string2.h"
__inline static char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1178
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1179
    __s = *__nextp;
  }
#line 1180
  while ((int )*__s == (int )__sep) {
#line 1181
    __s ++;
  }
#line 1182
  __result = (char *)((void *)0);
#line 1183
  if ((int )*__s != 0) {
#line 1185
    tmp = __s;
#line 1185
    __s ++;
#line 1185
    __result = tmp;
#line 1186
    while ((int )*__s != 0) {
#line 1187
      tmp___0 = __s;
#line 1187
      __s ++;
#line 1187
      if ((int )*tmp___0 == (int )__sep) {
#line 1189
        *(__s + -1) = (char )'\000';
#line 1190
        break;
      }
    }
#line 1192
    *__nextp = __s;
  }
#line 1194
  return (__result);
}
}
#line 1205
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 1223
__inline static char *__strsep_1c(char **__s , char __reject ) ;
#line 1224 "/usr/include/bits/string2.h"
__inline static char *__strsep_1c(char **__s , char __reject ) 
{ register char *__retval ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 1227
  __retval = *__s;
#line 1228
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
    {
#line 1228
    tmp___1 = __builtin_strchr(__retval, (int )__reject);
#line 1228
    *__s = tmp___1;
    }
#line 1228
    if ((unsigned long )*__s != (unsigned long )((void *)0)) {
#line 1229
      tmp = *__s;
#line 1229
      (*__s) ++;
#line 1229
      *tmp = (char )'\000';
    }
  }
#line 1230
  return (__retval);
}
}
#line 1233
__inline static char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1234 "/usr/include/bits/string2.h"
__inline static char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1237
  __retval = *__s;
#line 1238
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1240
    __cp = __retval;
#line 1241
    while (1) {
#line 1243
      if ((int )*__cp == 0) {
#line 1245
        __cp = (char *)((void *)0);
#line 1246
        break;
      }
#line 1248
      if ((int )*__cp == (int )__reject1) {
#line 1250
        tmp = __cp;
#line 1250
        __cp ++;
#line 1250
        *tmp = (char )'\000';
#line 1251
        break;
      } else {
#line 1248
        if ((int )*__cp == (int )__reject2) {
#line 1250
          tmp = __cp;
#line 1250
          __cp ++;
#line 1250
          *tmp = (char )'\000';
#line 1251
          break;
        }
      }
#line 1253
      __cp ++;
    }
#line 1255
    *__s = __cp;
  }
#line 1257
  return (__retval);
}
}
#line 1260
__inline static char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1262 "/usr/include/bits/string2.h"
__inline static char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1265
  __retval = *__s;
#line 1266
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1268
    __cp = __retval;
#line 1269
    while (1) {
#line 1271
      if ((int )*__cp == 0) {
#line 1273
        __cp = (char *)((void *)0);
#line 1274
        break;
      }
#line 1276
      if ((int )*__cp == (int )__reject1) {
#line 1278
        tmp = __cp;
#line 1278
        __cp ++;
#line 1278
        *tmp = (char )'\000';
#line 1279
        break;
      } else {
#line 1276
        if ((int )*__cp == (int )__reject2) {
#line 1278
          tmp = __cp;
#line 1278
          __cp ++;
#line 1278
          *tmp = (char )'\000';
#line 1279
          break;
        } else {
#line 1276
          if ((int )*__cp == (int )__reject3) {
#line 1278
            tmp = __cp;
#line 1278
            __cp ++;
#line 1278
            *tmp = (char )'\000';
#line 1279
            break;
          }
        }
      }
#line 1281
      __cp ++;
    }
#line 1283
    *__s = __cp;
  }
#line 1285
  return (__retval);
}
}
#line 1304
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 1323
extern  __attribute__((__nothrow__)) char *__strndup(char const   *__string , size_t __n )  __attribute__((__malloc__)) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 83
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 102
extern  __attribute__((__nothrow__)) int isalnum(int  ) ;
#line 103
extern  __attribute__((__nothrow__)) int isalpha(int  ) ;
#line 104
extern  __attribute__((__nothrow__)) int iscntrl(int  ) ;
#line 105
extern  __attribute__((__nothrow__)) int isdigit(int  ) ;
#line 106
extern  __attribute__((__nothrow__)) int islower(int  ) ;
#line 107
extern  __attribute__((__nothrow__)) int isgraph(int  ) ;
#line 108
extern  __attribute__((__nothrow__)) int isprint(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ispunct(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int isspace(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int isupper(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int isxdigit(int  ) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 128
extern  __attribute__((__nothrow__)) int isblank(int  ) ;
#line 135
extern  __attribute__((__nothrow__)) int isctype(int __c , int __mask ) ;
#line 142
extern  __attribute__((__nothrow__)) int isascii(int __c ) ;
#line 146
extern  __attribute__((__nothrow__)) int toascii(int __c ) ;
#line 150
extern  __attribute__((__nothrow__)) int _toupper(int  ) ;
#line 151
extern  __attribute__((__nothrow__)) int _tolower(int  ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = *(*tmp___1 + __c);
      }
    } else {
#line 193
      tmp___0 = (int const   )__c;
    }
  } else {
#line 193
    tmp___0 = (int const   )__c;
  }
#line 193
  return ((int )tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = *(*tmp___1 + __c);
      }
    } else {
#line 199
      tmp___0 = (int const   )__c;
    }
  } else {
#line 199
    tmp___0 = (int const   )__c;
  }
#line 199
  return ((int )tmp___0);
}
}
#line 247
extern  __attribute__((__nothrow__)) int isalnum_l(int  , __locale_t  ) ;
#line 248
extern  __attribute__((__nothrow__)) int isalpha_l(int  , __locale_t  ) ;
#line 249
extern  __attribute__((__nothrow__)) int iscntrl_l(int  , __locale_t  ) ;
#line 250
extern  __attribute__((__nothrow__)) int isdigit_l(int  , __locale_t  ) ;
#line 251
extern  __attribute__((__nothrow__)) int islower_l(int  , __locale_t  ) ;
#line 252
extern  __attribute__((__nothrow__)) int isgraph_l(int  , __locale_t  ) ;
#line 253
extern  __attribute__((__nothrow__)) int isprint_l(int  , __locale_t  ) ;
#line 254
extern  __attribute__((__nothrow__)) int ispunct_l(int  , __locale_t  ) ;
#line 255
extern  __attribute__((__nothrow__)) int isspace_l(int  , __locale_t  ) ;
#line 256
extern  __attribute__((__nothrow__)) int isupper_l(int  , __locale_t  ) ;
#line 257
extern  __attribute__((__nothrow__)) int isxdigit_l(int  , __locale_t  ) ;
#line 259
extern  __attribute__((__nothrow__)) int isblank_l(int  , __locale_t  ) ;
#line 263
extern  __attribute__((__nothrow__)) int __tolower_l(int __c , __locale_t __l ) ;
#line 264
extern  __attribute__((__nothrow__)) int tolower_l(int __c , __locale_t __l ) ;
#line 267
extern  __attribute__((__nothrow__)) int __toupper_l(int __c , __locale_t __l ) ;
#line 268
extern  __attribute__((__nothrow__)) int toupper_l(int __c , __locale_t __l ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *setlocale(int __category , char const   *__locale ) ;
#line 128
extern  __attribute__((__nothrow__)) struct lconv *localeconv(void) ;
#line 154
extern  __attribute__((__nothrow__)) __locale_t newlocale(int __category_mask , char const   *__locale ,
                                                          __locale_t __base ) ;
#line 189
extern  __attribute__((__nothrow__)) __locale_t duplocale(__locale_t __dataset ) ;
#line 193
extern  __attribute__((__nothrow__)) void freelocale(__locale_t __dataset ) ;
#line 200
extern  __attribute__((__nothrow__)) __locale_t uselocale(__locale_t __dataset ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 55 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 55
extern char *program_invocation_short_name ;
#line 227 "/usr/include/bits/fcntl.h"
extern  __attribute__((__nothrow__)) ssize_t readahead(int __fd , __off64_t __offset ,
                                                       size_t __count ) ;
#line 232
extern int sync_file_range(int __fd , __off64_t __from , __off64_t __to , unsigned int __flags ) ;
#line 237
extern int vmsplice(int __fdout , struct iovec  const  *__iov , size_t __count , unsigned int __flags ) ;
#line 241
extern  __attribute__((__nothrow__)) int splice(int __fdin , __off64_t *__offin ,
                                                int __fdout , __off64_t *__offout ,
                                                size_t __len , unsigned int __flags ) ;
#line 246
extern  __attribute__((__nothrow__)) int tee(int __fdin , int __fdout , size_t __len ,
                                             unsigned int __flags ) ;
#line 215 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 218
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 226
__inline static  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 228
__inline static  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 241
__inline static  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __asm__("fstatat64") __attribute__((__nonnull__(2,3))) ;
#line 250
__inline static  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 263
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 272
__inline static  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 280
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 287
extern  __attribute__((__nothrow__)) int lchmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 293
extern  __attribute__((__nothrow__)) int fchmod(int __fd , __mode_t __mode ) ;
#line 299
extern  __attribute__((__nothrow__)) int fchmodat(int __fd , char const   *__file ,
                                                  __mode_t mode , int __flag )  __attribute__((__nonnull__(2))) ;
#line 307
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 312
extern  __attribute__((__nothrow__)) __mode_t getumask(void) ;
#line 316
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 323
extern  __attribute__((__nothrow__)) int mkdirat(int __fd , char const   *__path ,
                                                 __mode_t __mode )  __attribute__((__nonnull__(2))) ;
#line 331
__inline static  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
#line 339
__inline static  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
#line 345
extern  __attribute__((__nothrow__)) int mkfifo(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 352
extern  __attribute__((__nothrow__)) int mkfifoat(int __fd , char const   *__path ,
                                                  __mode_t __mode )  __attribute__((__nonnull__(2))) ;
#line 391
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __asm__("__fxstat64") __attribute__((__nonnull__(3))) ;
#line 394
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __asm__("__xstat64") __attribute__((__nonnull__(2,3))) ;
#line 397
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __asm__("__lxstat64") __attribute__((__nonnull__(2,3))) ;
#line 400
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag )  __asm__("__fxstatat64") __attribute__((__nonnull__(3,4))) ;
#line 413
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 415
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 417
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 419
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag )  __attribute__((__nonnull__(3,4))) ;
#line 423
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(2,4))) ;
#line 426
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(3,5))) ;
#line 433
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __asm__("stat64") __attribute__((__nonnull__(1,2))) ;
#line 433 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 436
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 436
  return (tmp);
}
}
#line 440
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __asm__("lstat64") __attribute__((__nonnull__(1,2))) ;
#line 440 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 443
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 443
  return (tmp);
}
}
#line 447
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __asm__("fstat64") __attribute__((__nonnull__(2))) ;
#line 447 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  {
#line 450
  tmp = __fxstat(1, __fd, __statbuf);
  }
#line 450
  return (tmp);
}
}
#line 454
__inline static  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __asm__("fstatat64") __attribute__((__nonnull__(2,3))) ;
#line 454 "/usr/include/sys/stat.h"
__inline static int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                            int __flag ) 
{ int tmp ;

  {
  {
#line 458
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  }
#line 458
  return (tmp);
}
}
#line 463
__inline static  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
#line 463 "/usr/include/sys/stat.h"
__inline static int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  {
#line 466
  tmp = __xmknod(0, __path, __mode, & __dev);
  }
#line 466
  return (tmp);
}
}
#line 471
__inline static  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
#line 471 "/usr/include/sys/stat.h"
__inline static int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  {
#line 475
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
  }
#line 475
  return (tmp);
}
}
#line 482
__inline static  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 482 "/usr/include/sys/stat.h"
__inline static int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 485
  tmp = __xstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 485
  return (tmp);
}
}
#line 489
__inline static  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 489 "/usr/include/sys/stat.h"
__inline static int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 492
  tmp = __lxstat64(1, (char const   *)__path, (struct stat64 *)__statbuf);
  }
#line 492
  return (tmp);
}
}
#line 496
__inline static  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 496 "/usr/include/sys/stat.h"
__inline static int fstat64(int __fd , struct stat64 *__statbuf ) 
{ int tmp ;

  {
  {
#line 499
  tmp = __fxstat64(1, __fd, __statbuf);
  }
#line 499
  return (tmp);
}
}
#line 503
__inline static  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
#line 503 "/usr/include/sys/stat.h"
__inline static int fstatat64(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                              int __flag ) 
{ int tmp ;

  {
  {
#line 507
  tmp = __fxstatat64(1, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  }
#line 507
  return (tmp);
}
}
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 88
extern int open(char const   *__file , int __oflag  , ...)  __asm__("open64") __attribute__((__nonnull__(1))) ;
#line 95
extern int open64(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 113
extern int openat(int __fd , char const   *__file , int __oflag  , ...)  __asm__("openat64") __attribute__((__nonnull__(2))) ;
#line 120
extern int openat64(int __fd , char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(2))) ;
#line 133
extern int creat(char const   *__file , __mode_t __mode )  __asm__("creat64") __attribute__((__nonnull__(1))) ;
#line 140
extern int creat64(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 180
extern  __attribute__((__nothrow__)) int posix_fadvise(int __fd , __off64_t __offset ,
                                                       __off64_t __len , int __advise )  __asm__("posix_fadvise64")  ;
#line 188
extern  __attribute__((__nothrow__)) int posix_fadvise64(int __fd , __off64_t __offset ,
                                                         __off64_t __len , int __advise ) ;
#line 201
extern int posix_fallocate(int __fd , __off64_t __offset , __off64_t __len )  __asm__("posix_fallocate64")  ;
#line 209
extern int posix_fallocate64(int __fd , __off64_t __offset , __off64_t __len ) ;
#line 55 "/usr/include/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double acos(double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) double __acos(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double asin(double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) double __asin(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double atan(double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) double __atan(double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) double atan2(double __y , double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) double __atan2(double __y , double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) double __cos(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double sin(double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) double __sin(double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) double tan(double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) double __tan(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double cosh(double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) double __cosh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double sinh(double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) double __sinh(double __x ) ;
#line 77
extern  __attribute__((__nothrow__)) double tanh(double __x ) ;
#line 77
extern  __attribute__((__nothrow__)) double __tanh(double __x ) ;
#line 82
extern  __attribute__((__nothrow__)) void sincos(double __x , double *__sinx , double *__cosx ) ;
#line 82
extern  __attribute__((__nothrow__)) void __sincos(double __x , double *__sinx , double *__cosx ) ;
#line 89
extern  __attribute__((__nothrow__)) double acosh(double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) double __acosh(double __x ) ;
#line 91
extern  __attribute__((__nothrow__)) double asinh(double __x ) ;
#line 91
extern  __attribute__((__nothrow__)) double __asinh(double __x ) ;
#line 93
extern  __attribute__((__nothrow__)) double atanh(double __x ) ;
#line 93
extern  __attribute__((__nothrow__)) double __atanh(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double exp(double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) double __exp(double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) double frexp(double __x , int *__exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) double __frexp(double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) double ldexp(double __x , int __exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) double __ldexp(double __x , int __exponent ) ;
#line 110
extern  __attribute__((__nothrow__)) double log(double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) double __log(double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) double log10(double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) double __log10(double __x ) ;
#line 116
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
#line 116
extern  __attribute__((__nothrow__)) double __modf(double __x , double *__iptr ) ;
#line 121
extern  __attribute__((__nothrow__)) double exp10(double __x ) ;
#line 121
extern  __attribute__((__nothrow__)) double __exp10(double __x ) ;
#line 123
extern  __attribute__((__nothrow__)) double pow10(double __x ) ;
#line 123
extern  __attribute__((__nothrow__)) double __pow10(double __x ) ;
#line 129
extern  __attribute__((__nothrow__)) double expm1(double __x ) ;
#line 129
extern  __attribute__((__nothrow__)) double __expm1(double __x ) ;
#line 132
extern  __attribute__((__nothrow__)) double log1p(double __x ) ;
#line 132
extern  __attribute__((__nothrow__)) double __log1p(double __x ) ;
#line 135
extern  __attribute__((__nothrow__)) double logb(double __x ) ;
#line 135
extern  __attribute__((__nothrow__)) double __logb(double __x ) ;
#line 142
extern  __attribute__((__nothrow__)) double exp2(double __x ) ;
#line 142
extern  __attribute__((__nothrow__)) double __exp2(double __x ) ;
#line 145
extern  __attribute__((__nothrow__)) double log2(double __x ) ;
#line 145
extern  __attribute__((__nothrow__)) double __log2(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
#line 154
extern  __attribute__((__nothrow__)) double __pow(double __x , double __y ) ;
#line 157
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
#line 157
extern  __attribute__((__nothrow__)) double __sqrt(double __x ) ;
#line 163
extern  __attribute__((__nothrow__)) double hypot(double __x , double __y ) ;
#line 163
extern  __attribute__((__nothrow__)) double __hypot(double __x , double __y ) ;
#line 170
extern  __attribute__((__nothrow__)) double cbrt(double __x ) ;
#line 170
extern  __attribute__((__nothrow__)) double __cbrt(double __x ) ;
#line 179
extern  __attribute__((__nothrow__)) double ceil(double __x )  __attribute__((__const__)) ;
#line 179
extern  __attribute__((__nothrow__)) double __ceil(double __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) double fabs(double __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) double __fabs(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double floor(double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) double __floor(double __x )  __attribute__((__const__)) ;
#line 188
extern  __attribute__((__nothrow__)) double fmod(double __x , double __y ) ;
#line 188
extern  __attribute__((__nothrow__)) double __fmod(double __x , double __y ) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinf(double __value )  __attribute__((__const__)) ;
#line 196
extern  __attribute__((__nothrow__)) int __finite(double __value )  __attribute__((__const__)) ;
#line 202
extern  __attribute__((__nothrow__)) int isinf(double __value )  __attribute__((__const__)) ;
#line 205
extern  __attribute__((__nothrow__)) int finite(double __value )  __attribute__((__const__)) ;
#line 208
extern  __attribute__((__nothrow__)) double drem(double __x , double __y ) ;
#line 208
extern  __attribute__((__nothrow__)) double __drem(double __x , double __y ) ;
#line 212
extern  __attribute__((__nothrow__)) double significand(double __x ) ;
#line 212
extern  __attribute__((__nothrow__)) double __significand(double __x ) ;
#line 218
extern  __attribute__((__nothrow__)) double copysign(double __x , double __y )  __attribute__((__const__)) ;
#line 218
extern  __attribute__((__nothrow__)) double __copysign(double __x , double __y )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) double __nan(char const   *__tagb )  __attribute__((__const__)) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnan(double __value )  __attribute__((__const__)) ;
#line 235
extern  __attribute__((__nothrow__)) int isnan(double __value )  __attribute__((__const__)) ;
#line 238
extern  __attribute__((__nothrow__)) double j0(double  ) ;
#line 238
extern  __attribute__((__nothrow__)) double __j0(double  ) ;
#line 239
extern  __attribute__((__nothrow__)) double j1(double  ) ;
#line 239
extern  __attribute__((__nothrow__)) double __j1(double  ) ;
#line 240
extern  __attribute__((__nothrow__)) double jn(int  , double  ) ;
#line 240
extern  __attribute__((__nothrow__)) double __jn(int  , double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double y0(double  ) ;
#line 241
extern  __attribute__((__nothrow__)) double __y0(double  ) ;
#line 242
extern  __attribute__((__nothrow__)) double y1(double  ) ;
#line 242
extern  __attribute__((__nothrow__)) double __y1(double  ) ;
#line 243
extern  __attribute__((__nothrow__)) double yn(int  , double  ) ;
#line 243
extern  __attribute__((__nothrow__)) double __yn(int  , double  ) ;
#line 250
extern  __attribute__((__nothrow__)) double erf(double  ) ;
#line 250
extern  __attribute__((__nothrow__)) double __erf(double  ) ;
#line 251
extern  __attribute__((__nothrow__)) double erfc(double  ) ;
#line 251
extern  __attribute__((__nothrow__)) double __erfc(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double lgamma(double  ) ;
#line 252
extern  __attribute__((__nothrow__)) double __lgamma(double  ) ;
#line 259
extern  __attribute__((__nothrow__)) double tgamma(double  ) ;
#line 259
extern  __attribute__((__nothrow__)) double __tgamma(double  ) ;
#line 265
extern  __attribute__((__nothrow__)) double gamma(double  ) ;
#line 265
extern  __attribute__((__nothrow__)) double __gamma(double  ) ;
#line 272
extern  __attribute__((__nothrow__)) double lgamma_r(double  , int *__signgamp ) ;
#line 272
extern  __attribute__((__nothrow__)) double __lgamma_r(double  , int *__signgamp ) ;
#line 280
extern  __attribute__((__nothrow__)) double rint(double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) double __rint(double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) double nextafter(double __x , double __y )  __attribute__((__const__)) ;
#line 283
extern  __attribute__((__nothrow__)) double __nextafter(double __x , double __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) double nexttoward(double __x , long double __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) double __nexttoward(double __x , long double __y )  __attribute__((__const__)) ;
#line 289
extern  __attribute__((__nothrow__)) double remainder(double __x , double __y ) ;
#line 289
extern  __attribute__((__nothrow__)) double __remainder(double __x , double __y ) ;
#line 293
extern  __attribute__((__nothrow__)) double scalbn(double __x , int __n ) ;
#line 293
extern  __attribute__((__nothrow__)) double __scalbn(double __x , int __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int ilogb(double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __ilogb(double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) double scalbln(double __x , long __n ) ;
#line 302
extern  __attribute__((__nothrow__)) double __scalbln(double __x , long __n ) ;
#line 306
extern  __attribute__((__nothrow__)) double nearbyint(double __x ) ;
#line 306
extern  __attribute__((__nothrow__)) double __nearbyint(double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) double round(double __x )  __attribute__((__const__)) ;
#line 310
extern  __attribute__((__nothrow__)) double __round(double __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) double trunc(double __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) double __trunc(double __x )  __attribute__((__const__)) ;
#line 319
extern  __attribute__((__nothrow__)) double remquo(double __x , double __y , int *__quo ) ;
#line 319
extern  __attribute__((__nothrow__)) double __remquo(double __x , double __y , int *__quo ) ;
#line 326
extern  __attribute__((__nothrow__)) long lrint(double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long __lrint(double __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long llrint(double __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long __llrint(double __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long lround(double __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long __lround(double __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long llround(double __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long __llround(double __x ) ;
#line 336
extern  __attribute__((__nothrow__)) double fdim(double __x , double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) double __fdim(double __x , double __y ) ;
#line 339
extern  __attribute__((__nothrow__)) double fmax(double __x , double __y ) ;
#line 339
extern  __attribute__((__nothrow__)) double __fmax(double __x , double __y ) ;
#line 342
extern  __attribute__((__nothrow__)) double fmin(double __x , double __y ) ;
#line 342
extern  __attribute__((__nothrow__)) double __fmin(double __x , double __y ) ;
#line 346
extern  __attribute__((__nothrow__)) int __fpclassify(double __value )  __attribute__((__const__)) ;
#line 350
__inline static  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
#line 355
extern  __attribute__((__nothrow__)) double fma(double __x , double __y , double __z ) ;
#line 355
extern  __attribute__((__nothrow__)) double __fma(double __x , double __y , double __z ) ;
#line 364
extern  __attribute__((__nothrow__)) double scalb(double __x , double __n ) ;
#line 364
extern  __attribute__((__nothrow__)) double __scalb(double __x , double __n ) ;
#line 55
extern  __attribute__((__nothrow__)) float acosf(float __x ) ;
#line 55
extern  __attribute__((__nothrow__)) float __acosf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float asinf(float __x ) ;
#line 57
extern  __attribute__((__nothrow__)) float __asinf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float atanf(float __x ) ;
#line 59
extern  __attribute__((__nothrow__)) float __atanf(float __x ) ;
#line 61
extern  __attribute__((__nothrow__)) float atan2f(float __y , float __x ) ;
#line 61
extern  __attribute__((__nothrow__)) float __atan2f(float __y , float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float cosf(float __x ) ;
#line 64
extern  __attribute__((__nothrow__)) float __cosf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float sinf(float __x ) ;
#line 66
extern  __attribute__((__nothrow__)) float __sinf(float __x ) ;
#line 68
extern  __attribute__((__nothrow__)) float tanf(float __x ) ;
#line 68
extern  __attribute__((__nothrow__)) float __tanf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float coshf(float __x ) ;
#line 73
extern  __attribute__((__nothrow__)) float __coshf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float sinhf(float __x ) ;
#line 75
extern  __attribute__((__nothrow__)) float __sinhf(float __x ) ;
#line 77
extern  __attribute__((__nothrow__)) float tanhf(float __x ) ;
#line 77
extern  __attribute__((__nothrow__)) float __tanhf(float __x ) ;
#line 82
extern  __attribute__((__nothrow__)) void sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 82
extern  __attribute__((__nothrow__)) void __sincosf(float __x , float *__sinx , float *__cosx ) ;
#line 89
extern  __attribute__((__nothrow__)) float acoshf(float __x ) ;
#line 89
extern  __attribute__((__nothrow__)) float __acoshf(float __x ) ;
#line 91
extern  __attribute__((__nothrow__)) float asinhf(float __x ) ;
#line 91
extern  __attribute__((__nothrow__)) float __asinhf(float __x ) ;
#line 93
extern  __attribute__((__nothrow__)) float atanhf(float __x ) ;
#line 93
extern  __attribute__((__nothrow__)) float __atanhf(float __x ) ;
#line 101
extern  __attribute__((__nothrow__)) float expf(float __x ) ;
#line 101
extern  __attribute__((__nothrow__)) float __expf(float __x ) ;
#line 104
extern  __attribute__((__nothrow__)) float frexpf(float __x , int *__exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) float __frexpf(float __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) float ldexpf(float __x , int __exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) float __ldexpf(float __x , int __exponent ) ;
#line 110
extern  __attribute__((__nothrow__)) float logf(float __x ) ;
#line 110
extern  __attribute__((__nothrow__)) float __logf(float __x ) ;
#line 113
extern  __attribute__((__nothrow__)) float log10f(float __x ) ;
#line 113
extern  __attribute__((__nothrow__)) float __log10f(float __x ) ;
#line 116
extern  __attribute__((__nothrow__)) float modff(float __x , float *__iptr ) ;
#line 116
extern  __attribute__((__nothrow__)) float __modff(float __x , float *__iptr ) ;
#line 121
extern  __attribute__((__nothrow__)) float exp10f(float __x ) ;
#line 121
extern  __attribute__((__nothrow__)) float __exp10f(float __x ) ;
#line 123
extern  __attribute__((__nothrow__)) float pow10f(float __x ) ;
#line 123
extern  __attribute__((__nothrow__)) float __pow10f(float __x ) ;
#line 129
extern  __attribute__((__nothrow__)) float expm1f(float __x ) ;
#line 129
extern  __attribute__((__nothrow__)) float __expm1f(float __x ) ;
#line 132
extern  __attribute__((__nothrow__)) float log1pf(float __x ) ;
#line 132
extern  __attribute__((__nothrow__)) float __log1pf(float __x ) ;
#line 135
extern  __attribute__((__nothrow__)) float logbf(float __x ) ;
#line 135
extern  __attribute__((__nothrow__)) float __logbf(float __x ) ;
#line 142
extern  __attribute__((__nothrow__)) float exp2f(float __x ) ;
#line 142
extern  __attribute__((__nothrow__)) float __exp2f(float __x ) ;
#line 145
extern  __attribute__((__nothrow__)) float log2f(float __x ) ;
#line 145
extern  __attribute__((__nothrow__)) float __log2f(float __x ) ;
#line 154
extern  __attribute__((__nothrow__)) float powf(float __x , float __y ) ;
#line 154
extern  __attribute__((__nothrow__)) float __powf(float __x , float __y ) ;
#line 157
extern  __attribute__((__nothrow__)) float sqrtf(float __x ) ;
#line 157
extern  __attribute__((__nothrow__)) float __sqrtf(float __x ) ;
#line 163
extern  __attribute__((__nothrow__)) float hypotf(float __x , float __y ) ;
#line 163
extern  __attribute__((__nothrow__)) float __hypotf(float __x , float __y ) ;
#line 170
extern  __attribute__((__nothrow__)) float cbrtf(float __x ) ;
#line 170
extern  __attribute__((__nothrow__)) float __cbrtf(float __x ) ;
#line 179
extern  __attribute__((__nothrow__)) float ceilf(float __x )  __attribute__((__const__)) ;
#line 179
extern  __attribute__((__nothrow__)) float __ceilf(float __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) float fabsf(float __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) float __fabsf(float __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) float floorf(float __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) float __floorf(float __x )  __attribute__((__const__)) ;
#line 188
extern  __attribute__((__nothrow__)) float fmodf(float __x , float __y ) ;
#line 188
extern  __attribute__((__nothrow__)) float __fmodf(float __x , float __y ) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinff(float __value )  __attribute__((__const__)) ;
#line 196
extern  __attribute__((__nothrow__)) int __finitef(float __value )  __attribute__((__const__)) ;
#line 202
extern  __attribute__((__nothrow__)) int isinff(float __value )  __attribute__((__const__)) ;
#line 205
extern  __attribute__((__nothrow__)) int finitef(float __value )  __attribute__((__const__)) ;
#line 208
extern  __attribute__((__nothrow__)) float dremf(float __x , float __y ) ;
#line 208
extern  __attribute__((__nothrow__)) float __dremf(float __x , float __y ) ;
#line 212
extern  __attribute__((__nothrow__)) float significandf(float __x ) ;
#line 212
extern  __attribute__((__nothrow__)) float __significandf(float __x ) ;
#line 218
extern  __attribute__((__nothrow__)) float copysignf(float __x , float __y )  __attribute__((__const__)) ;
#line 218
extern  __attribute__((__nothrow__)) float __copysignf(float __x , float __y )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) float nanf(char const   *__tagb )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) float __nanf(char const   *__tagb )  __attribute__((__const__)) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnanf(float __value )  __attribute__((__const__)) ;
#line 235
extern  __attribute__((__nothrow__)) int isnanf(float __value )  __attribute__((__const__)) ;
#line 238
extern  __attribute__((__nothrow__)) float j0f(float  ) ;
#line 238
extern  __attribute__((__nothrow__)) float __j0f(float  ) ;
#line 239
extern  __attribute__((__nothrow__)) float j1f(float  ) ;
#line 239
extern  __attribute__((__nothrow__)) float __j1f(float  ) ;
#line 240
extern  __attribute__((__nothrow__)) float jnf(int  , float  ) ;
#line 240
extern  __attribute__((__nothrow__)) float __jnf(int  , float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float y0f(float  ) ;
#line 241
extern  __attribute__((__nothrow__)) float __y0f(float  ) ;
#line 242
extern  __attribute__((__nothrow__)) float y1f(float  ) ;
#line 242
extern  __attribute__((__nothrow__)) float __y1f(float  ) ;
#line 243
extern  __attribute__((__nothrow__)) float ynf(int  , float  ) ;
#line 243
extern  __attribute__((__nothrow__)) float __ynf(int  , float  ) ;
#line 250
extern  __attribute__((__nothrow__)) float erff(float  ) ;
#line 250
extern  __attribute__((__nothrow__)) float __erff(float  ) ;
#line 251
extern  __attribute__((__nothrow__)) float erfcf(float  ) ;
#line 251
extern  __attribute__((__nothrow__)) float __erfcf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float lgammaf(float  ) ;
#line 252
extern  __attribute__((__nothrow__)) float __lgammaf(float  ) ;
#line 259
extern  __attribute__((__nothrow__)) float tgammaf(float  ) ;
#line 259
extern  __attribute__((__nothrow__)) float __tgammaf(float  ) ;
#line 265
extern  __attribute__((__nothrow__)) float gammaf(float  ) ;
#line 265
extern  __attribute__((__nothrow__)) float __gammaf(float  ) ;
#line 272
extern  __attribute__((__nothrow__)) float lgammaf_r(float  , int *__signgamp ) ;
#line 272
extern  __attribute__((__nothrow__)) float __lgammaf_r(float  , int *__signgamp ) ;
#line 280
extern  __attribute__((__nothrow__)) float rintf(float __x ) ;
#line 280
extern  __attribute__((__nothrow__)) float __rintf(float __x ) ;
#line 283
extern  __attribute__((__nothrow__)) float nextafterf(float __x , float __y )  __attribute__((__const__)) ;
#line 283
extern  __attribute__((__nothrow__)) float __nextafterf(float __x , float __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) float nexttowardf(float __x , long double __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) float __nexttowardf(float __x , long double __y )  __attribute__((__const__)) ;
#line 289
extern  __attribute__((__nothrow__)) float remainderf(float __x , float __y ) ;
#line 289
extern  __attribute__((__nothrow__)) float __remainderf(float __x , float __y ) ;
#line 293
extern  __attribute__((__nothrow__)) float scalbnf(float __x , int __n ) ;
#line 293
extern  __attribute__((__nothrow__)) float __scalbnf(float __x , int __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int ilogbf(float __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __ilogbf(float __x ) ;
#line 302
extern  __attribute__((__nothrow__)) float scalblnf(float __x , long __n ) ;
#line 302
extern  __attribute__((__nothrow__)) float __scalblnf(float __x , long __n ) ;
#line 306
extern  __attribute__((__nothrow__)) float nearbyintf(float __x ) ;
#line 306
extern  __attribute__((__nothrow__)) float __nearbyintf(float __x ) ;
#line 310
extern  __attribute__((__nothrow__)) float roundf(float __x )  __attribute__((__const__)) ;
#line 310
extern  __attribute__((__nothrow__)) float __roundf(float __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) float truncf(float __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) float __truncf(float __x )  __attribute__((__const__)) ;
#line 319
extern  __attribute__((__nothrow__)) float remquof(float __x , float __y , int *__quo ) ;
#line 319
extern  __attribute__((__nothrow__)) float __remquof(float __x , float __y , int *__quo ) ;
#line 326
extern  __attribute__((__nothrow__)) long lrintf(float __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long __lrintf(float __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long llrintf(float __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long __llrintf(float __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long lroundf(float __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long __lroundf(float __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long llroundf(float __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long __llroundf(float __x ) ;
#line 336
extern  __attribute__((__nothrow__)) float fdimf(float __x , float __y ) ;
#line 336
extern  __attribute__((__nothrow__)) float __fdimf(float __x , float __y ) ;
#line 339
extern  __attribute__((__nothrow__)) float fmaxf(float __x , float __y ) ;
#line 339
extern  __attribute__((__nothrow__)) float __fmaxf(float __x , float __y ) ;
#line 342
extern  __attribute__((__nothrow__)) float fminf(float __x , float __y ) ;
#line 342
extern  __attribute__((__nothrow__)) float __fminf(float __x , float __y ) ;
#line 346
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value )  __attribute__((__const__)) ;
#line 350
__inline static  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
#line 355
extern  __attribute__((__nothrow__)) float fmaf(float __x , float __y , float __z ) ;
#line 355
extern  __attribute__((__nothrow__)) float __fmaf(float __x , float __y , float __z ) ;
#line 364
extern  __attribute__((__nothrow__)) float scalbf(float __x , float __n ) ;
#line 364
extern  __attribute__((__nothrow__)) float __scalbf(float __x , float __n ) ;
#line 55
extern  __attribute__((__nothrow__)) long double acosl(long double __x ) ;
#line 55
extern  __attribute__((__nothrow__)) long double __acosl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double asinl(long double __x ) ;
#line 57
extern  __attribute__((__nothrow__)) long double __asinl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double atanl(long double __x ) ;
#line 59
extern  __attribute__((__nothrow__)) long double __atanl(long double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) long double atan2l(long double __y , long double __x ) ;
#line 61
extern  __attribute__((__nothrow__)) long double __atan2l(long double __y , long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double cosl(long double __x ) ;
#line 64
extern  __attribute__((__nothrow__)) long double __cosl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double sinl(long double __x ) ;
#line 66
extern  __attribute__((__nothrow__)) long double __sinl(long double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) long double tanl(long double __x ) ;
#line 68
extern  __attribute__((__nothrow__)) long double __tanl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double coshl(long double __x ) ;
#line 73
extern  __attribute__((__nothrow__)) long double __coshl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double sinhl(long double __x ) ;
#line 75
extern  __attribute__((__nothrow__)) long double __sinhl(long double __x ) ;
#line 77
extern  __attribute__((__nothrow__)) long double tanhl(long double __x ) ;
#line 77
extern  __attribute__((__nothrow__)) long double __tanhl(long double __x ) ;
#line 82
extern  __attribute__((__nothrow__)) void sincosl(long double __x , long double *__sinx ,
                                                  long double *__cosx ) ;
#line 82
extern  __attribute__((__nothrow__)) void __sincosl(long double __x , long double *__sinx ,
                                                    long double *__cosx ) ;
#line 89
extern  __attribute__((__nothrow__)) long double acoshl(long double __x ) ;
#line 89
extern  __attribute__((__nothrow__)) long double __acoshl(long double __x ) ;
#line 91
extern  __attribute__((__nothrow__)) long double asinhl(long double __x ) ;
#line 91
extern  __attribute__((__nothrow__)) long double __asinhl(long double __x ) ;
#line 93
extern  __attribute__((__nothrow__)) long double atanhl(long double __x ) ;
#line 93
extern  __attribute__((__nothrow__)) long double __atanhl(long double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) long double expl(long double __x ) ;
#line 101
extern  __attribute__((__nothrow__)) long double __expl(long double __x ) ;
#line 104
extern  __attribute__((__nothrow__)) long double frexpl(long double __x , int *__exponent ) ;
#line 104
extern  __attribute__((__nothrow__)) long double __frexpl(long double __x , int *__exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) long double ldexpl(long double __x , int __exponent ) ;
#line 107
extern  __attribute__((__nothrow__)) long double __ldexpl(long double __x , int __exponent ) ;
#line 110
extern  __attribute__((__nothrow__)) long double logl(long double __x ) ;
#line 110
extern  __attribute__((__nothrow__)) long double __logl(long double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) long double log10l(long double __x ) ;
#line 113
extern  __attribute__((__nothrow__)) long double __log10l(long double __x ) ;
#line 116
extern  __attribute__((__nothrow__)) long double modfl(long double __x , long double *__iptr ) ;
#line 116
extern  __attribute__((__nothrow__)) long double __modfl(long double __x , long double *__iptr ) ;
#line 121
extern  __attribute__((__nothrow__)) long double exp10l(long double __x ) ;
#line 121
extern  __attribute__((__nothrow__)) long double __exp10l(long double __x ) ;
#line 123
extern  __attribute__((__nothrow__)) long double pow10l(long double __x ) ;
#line 123
extern  __attribute__((__nothrow__)) long double __pow10l(long double __x ) ;
#line 129
extern  __attribute__((__nothrow__)) long double expm1l(long double __x ) ;
#line 129
extern  __attribute__((__nothrow__)) long double __expm1l(long double __x ) ;
#line 132
extern  __attribute__((__nothrow__)) long double log1pl(long double __x ) ;
#line 132
extern  __attribute__((__nothrow__)) long double __log1pl(long double __x ) ;
#line 135
extern  __attribute__((__nothrow__)) long double logbl(long double __x ) ;
#line 135
extern  __attribute__((__nothrow__)) long double __logbl(long double __x ) ;
#line 142
extern  __attribute__((__nothrow__)) long double exp2l(long double __x ) ;
#line 142
extern  __attribute__((__nothrow__)) long double __exp2l(long double __x ) ;
#line 145
extern  __attribute__((__nothrow__)) long double log2l(long double __x ) ;
#line 145
extern  __attribute__((__nothrow__)) long double __log2l(long double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) long double powl(long double __x , long double __y ) ;
#line 154
extern  __attribute__((__nothrow__)) long double __powl(long double __x , long double __y ) ;
#line 157
extern  __attribute__((__nothrow__)) long double sqrtl(long double __x ) ;
#line 157
extern  __attribute__((__nothrow__)) long double __sqrtl(long double __x ) ;
#line 163
extern  __attribute__((__nothrow__)) long double hypotl(long double __x , long double __y ) ;
#line 163
extern  __attribute__((__nothrow__)) long double __hypotl(long double __x , long double __y ) ;
#line 170
extern  __attribute__((__nothrow__)) long double cbrtl(long double __x ) ;
#line 170
extern  __attribute__((__nothrow__)) long double __cbrtl(long double __x ) ;
#line 179
extern  __attribute__((__nothrow__)) long double ceill(long double __x )  __attribute__((__const__)) ;
#line 179
extern  __attribute__((__nothrow__)) long double __ceill(long double __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) long double fabsl(long double __x )  __attribute__((__const__)) ;
#line 182
extern  __attribute__((__nothrow__)) long double __fabsl(long double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) long double floorl(long double __x )  __attribute__((__const__)) ;
#line 185
extern  __attribute__((__nothrow__)) long double __floorl(long double __x )  __attribute__((__const__)) ;
#line 188
extern  __attribute__((__nothrow__)) long double fmodl(long double __x , long double __y ) ;
#line 188
extern  __attribute__((__nothrow__)) long double __fmodl(long double __x , long double __y ) ;
#line 193
extern  __attribute__((__nothrow__)) int __isinfl(long double __value )  __attribute__((__const__)) ;
#line 196
extern  __attribute__((__nothrow__)) int __finitel(long double __value )  __attribute__((__const__)) ;
#line 202
extern  __attribute__((__nothrow__)) int isinfl(long double __value )  __attribute__((__const__)) ;
#line 205
extern  __attribute__((__nothrow__)) int finitel(long double __value )  __attribute__((__const__)) ;
#line 208
extern  __attribute__((__nothrow__)) long double dreml(long double __x , long double __y ) ;
#line 208
extern  __attribute__((__nothrow__)) long double __dreml(long double __x , long double __y ) ;
#line 212
extern  __attribute__((__nothrow__)) long double significandl(long double __x ) ;
#line 212
extern  __attribute__((__nothrow__)) long double __significandl(long double __x ) ;
#line 218
extern  __attribute__((__nothrow__)) long double copysignl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 218
extern  __attribute__((__nothrow__)) long double __copysignl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb )  __attribute__((__const__)) ;
#line 225
extern  __attribute__((__nothrow__)) long double __nanl(char const   *__tagb )  __attribute__((__const__)) ;
#line 231
extern  __attribute__((__nothrow__)) int __isnanl(long double __value )  __attribute__((__const__)) ;
#line 235
extern  __attribute__((__nothrow__)) int isnanl(long double __value )  __attribute__((__const__)) ;
#line 238
extern  __attribute__((__nothrow__)) long double j0l(long double  ) ;
#line 238
extern  __attribute__((__nothrow__)) long double __j0l(long double  ) ;
#line 239
extern  __attribute__((__nothrow__)) long double j1l(long double  ) ;
#line 239
extern  __attribute__((__nothrow__)) long double __j1l(long double  ) ;
#line 240
extern  __attribute__((__nothrow__)) long double jnl(int  , long double  ) ;
#line 240
extern  __attribute__((__nothrow__)) long double __jnl(int  , long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double y0l(long double  ) ;
#line 241
extern  __attribute__((__nothrow__)) long double __y0l(long double  ) ;
#line 242
extern  __attribute__((__nothrow__)) long double y1l(long double  ) ;
#line 242
extern  __attribute__((__nothrow__)) long double __y1l(long double  ) ;
#line 243
extern  __attribute__((__nothrow__)) long double ynl(int  , long double  ) ;
#line 243
extern  __attribute__((__nothrow__)) long double __ynl(int  , long double  ) ;
#line 250
extern  __attribute__((__nothrow__)) long double erfl(long double  ) ;
#line 250
extern  __attribute__((__nothrow__)) long double __erfl(long double  ) ;
#line 251
extern  __attribute__((__nothrow__)) long double erfcl(long double  ) ;
#line 251
extern  __attribute__((__nothrow__)) long double __erfcl(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double lgammal(long double  ) ;
#line 252
extern  __attribute__((__nothrow__)) long double __lgammal(long double  ) ;
#line 259
extern  __attribute__((__nothrow__)) long double tgammal(long double  ) ;
#line 259
extern  __attribute__((__nothrow__)) long double __tgammal(long double  ) ;
#line 265
extern  __attribute__((__nothrow__)) long double gammal(long double  ) ;
#line 265
extern  __attribute__((__nothrow__)) long double __gammal(long double  ) ;
#line 272
extern  __attribute__((__nothrow__)) long double lgammal_r(long double  , int *__signgamp ) ;
#line 272
extern  __attribute__((__nothrow__)) long double __lgammal_r(long double  , int *__signgamp ) ;
#line 280
extern  __attribute__((__nothrow__)) long double rintl(long double __x ) ;
#line 280
extern  __attribute__((__nothrow__)) long double __rintl(long double __x ) ;
#line 283
extern  __attribute__((__nothrow__)) long double nextafterl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 283
extern  __attribute__((__nothrow__)) long double __nextafterl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) long double nexttowardl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 285
extern  __attribute__((__nothrow__)) long double __nexttowardl(long double __x , long double __y )  __attribute__((__const__)) ;
#line 289
extern  __attribute__((__nothrow__)) long double remainderl(long double __x , long double __y ) ;
#line 289
extern  __attribute__((__nothrow__)) long double __remainderl(long double __x , long double __y ) ;
#line 293
extern  __attribute__((__nothrow__)) long double scalbnl(long double __x , int __n ) ;
#line 293
extern  __attribute__((__nothrow__)) long double __scalbnl(long double __x , int __n ) ;
#line 297
extern  __attribute__((__nothrow__)) int ilogbl(long double __x ) ;
#line 297
extern  __attribute__((__nothrow__)) int __ilogbl(long double __x ) ;
#line 302
extern  __attribute__((__nothrow__)) long double scalblnl(long double __x , long __n ) ;
#line 302
extern  __attribute__((__nothrow__)) long double __scalblnl(long double __x , long __n ) ;
#line 306
extern  __attribute__((__nothrow__)) long double nearbyintl(long double __x ) ;
#line 306
extern  __attribute__((__nothrow__)) long double __nearbyintl(long double __x ) ;
#line 310
extern  __attribute__((__nothrow__)) long double roundl(long double __x )  __attribute__((__const__)) ;
#line 310
extern  __attribute__((__nothrow__)) long double __roundl(long double __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) long double truncl(long double __x )  __attribute__((__const__)) ;
#line 314
extern  __attribute__((__nothrow__)) long double __truncl(long double __x )  __attribute__((__const__)) ;
#line 319
extern  __attribute__((__nothrow__)) long double remquol(long double __x , long double __y ,
                                                         int *__quo ) ;
#line 319
extern  __attribute__((__nothrow__)) long double __remquol(long double __x , long double __y ,
                                                           int *__quo ) ;
#line 326
extern  __attribute__((__nothrow__)) long lrintl(long double __x ) ;
#line 326
extern  __attribute__((__nothrow__)) long __lrintl(long double __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long llrintl(long double __x ) ;
#line 327
extern  __attribute__((__nothrow__)) long long __llrintl(long double __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long lroundl(long double __x ) ;
#line 331
extern  __attribute__((__nothrow__)) long __lroundl(long double __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long llroundl(long double __x ) ;
#line 332
extern  __attribute__((__nothrow__)) long long __llroundl(long double __x ) ;
#line 336
extern  __attribute__((__nothrow__)) long double fdiml(long double __x , long double __y ) ;
#line 336
extern  __attribute__((__nothrow__)) long double __fdiml(long double __x , long double __y ) ;
#line 339
extern  __attribute__((__nothrow__)) long double fmaxl(long double __x , long double __y ) ;
#line 339
extern  __attribute__((__nothrow__)) long double __fmaxl(long double __x , long double __y ) ;
#line 342
extern  __attribute__((__nothrow__)) long double fminl(long double __x , long double __y ) ;
#line 342
extern  __attribute__((__nothrow__)) long double __fminl(long double __x , long double __y ) ;
#line 346
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value )  __attribute__((__const__)) ;
#line 350
__inline static  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
#line 355
extern  __attribute__((__nothrow__)) long double fmal(long double __x , long double __y ,
                                                      long double __z ) ;
#line 355
extern  __attribute__((__nothrow__)) long double __fmal(long double __x , long double __y ,
                                                        long double __z ) ;
#line 364
extern  __attribute__((__nothrow__)) long double scalbl(long double __x , long double __n ) ;
#line 364
extern  __attribute__((__nothrow__)) long double __scalbl(long double __x , long double __n ) ;
#line 157 "/usr/include/math.h"
extern int signgam ;
#line 296
extern _LIB_VERSION_TYPE _LIB_VERSION ;
#line 322
extern int matherr(struct exception *__exc ) ;
#line 35 "/usr/include/bits/mathinline.h"
__inline static  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
#line 35 "/usr/include/bits/mathinline.h"
__inline static int __signbitf(float __x ) 
{ union __anonunion___u_37 __u ;

  {
#line 38
  __u.__f = __x;
#line 39
  return (__u.__i < 0);
}
}
#line 41
__inline static  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
#line 41 "/usr/include/bits/mathinline.h"
__inline static int __signbit(double __x ) 
{ union __anonunion___u_38 __u ;

  {
#line 44
  __u.__d = __x;
#line 45
  return (__u.__i[1] < 0);
}
}
#line 47
__inline static  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
#line 47 "/usr/include/bits/mathinline.h"
__inline static int __signbitl(long double __x ) 
{ union __anonunion___u_39 __u ;

  {
#line 50
  __u.__l = __x;
#line 51
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 184 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t clock(void) ;
#line 187
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 190
extern  __attribute__((__nothrow__)) double difftime(time_t __time1 , time_t __time0 )  __attribute__((__const__)) ;
#line 194
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 200
extern  __attribute__((__nothrow__)) size_t strftime(char * __restrict  __s , size_t __maxsize ,
                                                     char const   * __restrict  __format ,
                                                     struct tm  const  * __restrict  __tp ) ;
#line 208
extern  __attribute__((__nothrow__)) char *strptime(char const   * __restrict  __s ,
                                                    char const   * __restrict  __fmt ,
                                                    struct tm *__tp ) ;
#line 218
extern  __attribute__((__nothrow__)) size_t strftime_l(char * __restrict  __s , size_t __maxsize ,
                                                       char const   * __restrict  __format ,
                                                       struct tm  const  * __restrict  __tp ,
                                                       __locale_t __loc ) ;
#line 223
extern  __attribute__((__nothrow__)) char *strptime_l(char const   * __restrict  __s ,
                                                      char const   * __restrict  __fmt ,
                                                      struct tm *__tp , __locale_t __loc ) ;
#line 232
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 236
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 242
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
#line 247
extern  __attribute__((__nothrow__)) struct tm *localtime_r(time_t const   * __restrict  __timer ,
                                                            struct tm * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) char *asctime(struct tm  const  *__tp ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 265
extern  __attribute__((__nothrow__)) char *asctime_r(struct tm  const  * __restrict  __tp ,
                                                     char * __restrict  __buf ) ;
#line 269
extern  __attribute__((__nothrow__)) char *ctime_r(time_t const   * __restrict  __timer ,
                                                   char * __restrict  __buf ) ;
#line 275
extern char *__tzname[2] ;
#line 276
extern int __daylight ;
#line 277
extern long __timezone ;
#line 282
extern char *tzname[2] ;
#line 286
extern  __attribute__((__nothrow__)) void tzset(void) ;
#line 290
extern int daylight ;
#line 291
extern long timezone ;
#line 297
extern  __attribute__((__nothrow__)) int stime(time_t const   *__when ) ;
#line 312
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
#line 315
extern  __attribute__((__nothrow__)) time_t timelocal(struct tm *__tp ) ;
#line 318
extern  __attribute__((__nothrow__)) int dysize(int __year )  __attribute__((__const__)) ;
#line 327
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 332
extern  __attribute__((__nothrow__)) int clock_getres(clockid_t __clock_id , struct timespec *__res ) ;
#line 335
extern  __attribute__((__nothrow__)) int clock_gettime(clockid_t __clock_id , struct timespec *__tp ) ;
#line 338
extern  __attribute__((__nothrow__)) int clock_settime(clockid_t __clock_id , struct timespec  const  *__tp ) ;
#line 346
extern int clock_nanosleep(clockid_t __clock_id , int __flags , struct timespec  const  *__req ,
                           struct timespec *__rem ) ;
#line 351
extern  __attribute__((__nothrow__)) int clock_getcpuclockid(pid_t __pid , clockid_t *__clock_id ) ;
#line 356
extern  __attribute__((__nothrow__)) int timer_create(clockid_t __clock_id , struct sigevent * __restrict  __evp ,
                                                      timer_t * __restrict  __timerid ) ;
#line 361
extern  __attribute__((__nothrow__)) int timer_delete(timer_t __timerid ) ;
#line 364
extern  __attribute__((__nothrow__)) int timer_settime(timer_t __timerid , int __flags ,
                                                       struct itimerspec  const  * __restrict  __value ,
                                                       struct itimerspec * __restrict  __ovalue ) ;
#line 369
extern  __attribute__((__nothrow__)) int timer_gettime(timer_t __timerid , struct itimerspec *__value ) ;
#line 373
extern  __attribute__((__nothrow__)) int timer_getoverrun(timer_t __timerid ) ;
#line 389
extern int getdate_err ;
#line 398
extern struct tm *getdate(char const   *__string ) ;
#line 412
extern int getdate_r(char const   * __restrict  __string , struct tm * __restrict  __resbufp ) ;
#line 103 "/usr/include/bits/sigset.h"
__inline static int __sigismember(__sigset_t const   *__set , int __sig ) ;
#line 104
__inline static int __sigaddset(__sigset_t *__set , int __sig ) ;
#line 105
__inline static int __sigdelset(__sigset_t *__set , int __sig ) ;
#line 117 "/usr/include/bits/sigset.h"
__inline static int __sigismember(__sigset_t const   *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
#line 117
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 117
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 117
  if (__set->__val[__word] & __mask) {
#line 117
    tmp = 1;
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 118 "/usr/include/bits/sigset.h"
__inline static int __sigaddset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
#line 118
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 118
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 118
  __set->__val[__word] |= __mask;
#line 118
  return (0);
}
}
#line 119 "/usr/include/bits/sigset.h"
__inline static int __sigdelset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
#line 119
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 119
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 119
  __set->__val[__word] &= ~ __mask;
#line 119
  return (0);
}
}
#line 80 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t __sysv_signal(int __sig , void (*__handler)(int  ) ) ;
#line 83
extern  __attribute__((__nothrow__)) __sighandler_t sysv_signal(int __sig , void (*__handler)(int  ) ) ;
#line 92
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 109
extern  __attribute__((__nothrow__)) __sighandler_t bsd_signal(int __sig , void (*__handler)(int  ) ) ;
#line 117
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 124
extern  __attribute__((__nothrow__)) int killpg(__pid_t __pgrp , int __sig ) ;
#line 129
extern  __attribute__((__nothrow__)) int raise(int __sig ) ;
#line 134
extern  __attribute__((__nothrow__)) __sighandler_t ssignal(int __sig , void (*__handler)(int  ) ) ;
#line 136
extern  __attribute__((__nothrow__)) int gsignal(int __sig ) ;
#line 141
extern void psignal(int __sig , char const   *__s ) ;
#line 153
extern int __sigpause(int __sig_or_mask , int __is_sig ) ;
#line 162
extern int sigpause(int __sig )  __asm__("__xpg_sigpause")  ;
#line 181
extern  __attribute__((__nothrow__)) int sigblock(int __mask )  __attribute__((__deprecated__)) ;
#line 184
extern  __attribute__((__nothrow__)) int sigsetmask(int __mask )  __attribute__((__deprecated__)) ;
#line 187
extern  __attribute__((__nothrow__)) int siggetmask(void)  __attribute__((__deprecated__)) ;
#line 216
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 219
extern  __attribute__((__nothrow__)) int sigfillset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 225
extern  __attribute__((__nothrow__)) int sigdelset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 228
extern  __attribute__((__nothrow__)) int sigismember(sigset_t const   *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 233
extern  __attribute__((__nothrow__)) int sigisemptyset(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 236
extern  __attribute__((__nothrow__)) int sigandset(sigset_t *__set , sigset_t const   *__left ,
                                                   sigset_t const   *__right )  __attribute__((__nonnull__(1,2,3))) ;
#line 240
extern  __attribute__((__nothrow__)) int sigorset(sigset_t *__set , sigset_t const   *__left ,
                                                  sigset_t const   *__right )  __attribute__((__nonnull__(1,2,3))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 257
extern int sigsuspend(sigset_t const   *__set )  __attribute__((__nonnull__(1))) ;
#line 260
extern  __attribute__((__nothrow__)) int sigaction(int __sig , struct sigaction  const  * __restrict  __act ,
                                                   struct sigaction * __restrict  __oact ) ;
#line 264
extern  __attribute__((__nothrow__)) int sigpending(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 271
extern int sigwait(sigset_t const   * __restrict  __set , int * __restrict  __sig )  __attribute__((__nonnull__(1,2))) ;
#line 279
extern int sigwaitinfo(sigset_t const   * __restrict  __set , siginfo_t * __restrict  __info )  __attribute__((__nonnull__(1))) ;
#line 287
extern int sigtimedwait(sigset_t const   * __restrict  __set , siginfo_t * __restrict  __info ,
                        struct timespec  const  * __restrict  __timeout )  __attribute__((__nonnull__(1))) ;
#line 294
extern  __attribute__((__nothrow__)) int sigqueue(__pid_t __pid , int __sig , union sigval __val ) ;
#line 304
extern char const   * const  _sys_siglist[65] ;
#line 305
extern char const   * const  sys_siglist[65] ;
#line 328
extern  __attribute__((__nothrow__)) int sigvec(int __sig , struct sigvec  const  *__vec ,
                                                struct sigvec *__ovec ) ;
#line 336
extern  __attribute__((__nothrow__)) int sigreturn(struct sigcontext *__scp ) ;
#line 346
extern  __attribute__((__nothrow__)) int siginterrupt(int __sig , int __interrupt ) ;
#line 357
extern  __attribute__((__nothrow__)) int sigstack(struct sigstack *__ss , struct sigstack *__oss )  __attribute__((__deprecated__)) ;
#line 362
extern  __attribute__((__nothrow__)) int sigaltstack(struct sigaltstack  const  * __restrict  __ss ,
                                                     struct sigaltstack * __restrict  __oss ) ;
#line 371
extern  __attribute__((__nothrow__)) int sighold(int __sig ) ;
#line 374
extern  __attribute__((__nothrow__)) int sigrelse(int __sig ) ;
#line 377
extern  __attribute__((__nothrow__)) int sigignore(int __sig ) ;
#line 380
extern  __attribute__((__nothrow__)) __sighandler_t sigset(int __sig , void (*__disp)(int  ) ) ;
#line 31 "/usr/include/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
#line 36
extern  __attribute__((__nothrow__)) int pthread_kill(pthread_t __threadid , int __signo ) ;
#line 394 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmin(void) ;
#line 396
extern  __attribute__((__nothrow__)) int __libc_current_sigrtmax(void) ;
#line 68 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_fail(char const   *__assertion ,
                                                                      char const   *__file ,
                                                                      unsigned int __line ,
                                                                      char const   *__function ) ;
#line 73
extern  __attribute__((__nothrow__, __noreturn__)) void __assert_perror_fail(int __errnum ,
                                                                             char const   *__file ,
                                                                             unsigned int __line ,
                                                                             char const   *__function ) ;
#line 81
extern  __attribute__((__nothrow__, __noreturn__)) void __assert(char const   *__assertion ,
                                                                 char const   *__file ,
                                                                 int __line ) ;
#line 74 "/usr/include/bits/sched.h"
extern  __attribute__((__nothrow__)) int clone(int (*__fn)(void *__arg ) , void *__child_stack ,
                                               int __flags , void *__arg  , ...) ;
#line 78
extern  __attribute__((__nothrow__)) int unshare(int __flags ) ;
#line 40 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int sched_setparam(__pid_t __pid , struct sched_param  const  *__param ) ;
#line 44
extern  __attribute__((__nothrow__)) int sched_getparam(__pid_t __pid , struct sched_param *__param ) ;
#line 47
extern  __attribute__((__nothrow__)) int sched_setscheduler(__pid_t __pid , int __policy ,
                                                            struct sched_param  const  *__param ) ;
#line 51
extern  __attribute__((__nothrow__)) int sched_getscheduler(__pid_t __pid ) ;
#line 54
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
#line 57
extern  __attribute__((__nothrow__)) int sched_get_priority_max(int __algorithm ) ;
#line 60
extern  __attribute__((__nothrow__)) int sched_get_priority_min(int __algorithm ) ;
#line 63
extern  __attribute__((__nothrow__)) int sched_rr_get_interval(__pid_t __pid , struct timespec *__t ) ;
#line 76
extern  __attribute__((__nothrow__)) int sched_setaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t const   *__cpuset ) ;
#line 80
extern  __attribute__((__nothrow__)) int sched_getaffinity(__pid_t __pid , size_t __cpusetsize ,
                                                           cpu_set_t *__cpuset ) ;
#line 221 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
#line 230
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 238
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 243
extern  __attribute__((__nothrow__)) int pthread_tryjoin_np(pthread_t __th , void **__thread_return ) ;
#line 251
extern int pthread_timedjoin_np(pthread_t __th , void **__thread_return , struct timespec  const  *__abstime ) ;
#line 259
extern  __attribute__((__nothrow__)) int pthread_detach(pthread_t __th ) ;
#line 263
extern  __attribute__((__nothrow__)) pthread_t pthread_self(void)  __attribute__((__const__)) ;
#line 266
__inline static  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
#line 274
extern  __attribute__((__nothrow__)) int pthread_attr_init(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 277
extern  __attribute__((__nothrow__)) int pthread_attr_destroy(pthread_attr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 281
extern  __attribute__((__nothrow__)) int pthread_attr_getdetachstate(pthread_attr_t const   *__attr ,
                                                                     int *__detachstate )  __attribute__((__nonnull__(1,2))) ;
#line 286
extern  __attribute__((__nothrow__)) int pthread_attr_setdetachstate(pthread_attr_t *__attr ,
                                                                     int __detachstate )  __attribute__((__nonnull__(1))) ;
#line 292
extern  __attribute__((__nothrow__)) int pthread_attr_getguardsize(pthread_attr_t const   *__attr ,
                                                                   size_t *__guardsize )  __attribute__((__nonnull__(1,2))) ;
#line 297
extern  __attribute__((__nothrow__)) int pthread_attr_setguardsize(pthread_attr_t *__attr ,
                                                                   size_t __guardsize )  __attribute__((__nonnull__(1))) ;
#line 303
extern  __attribute__((__nothrow__)) int pthread_attr_getschedparam(pthread_attr_t const   * __restrict  __attr ,
                                                                    struct sched_param * __restrict  __param )  __attribute__((__nonnull__(1,2))) ;
#line 309
extern  __attribute__((__nothrow__)) int pthread_attr_setschedparam(pthread_attr_t * __restrict  __attr ,
                                                                    struct sched_param  const  * __restrict  __param )  __attribute__((__nonnull__(1,2))) ;
#line 314
extern  __attribute__((__nothrow__)) int pthread_attr_getschedpolicy(pthread_attr_t const   * __restrict  __attr ,
                                                                     int * __restrict  __policy )  __attribute__((__nonnull__(1,2))) ;
#line 319
extern  __attribute__((__nothrow__)) int pthread_attr_setschedpolicy(pthread_attr_t *__attr ,
                                                                     int __policy )  __attribute__((__nonnull__(1))) ;
#line 323
extern  __attribute__((__nothrow__)) int pthread_attr_getinheritsched(pthread_attr_t const   * __restrict  __attr ,
                                                                      int * __restrict  __inherit )  __attribute__((__nonnull__(1,2))) ;
#line 328
extern  __attribute__((__nothrow__)) int pthread_attr_setinheritsched(pthread_attr_t *__attr ,
                                                                      int __inherit )  __attribute__((__nonnull__(1))) ;
#line 334
extern  __attribute__((__nothrow__)) int pthread_attr_getscope(pthread_attr_t const   * __restrict  __attr ,
                                                               int * __restrict  __scope )  __attribute__((__nonnull__(1,2))) ;
#line 339
extern  __attribute__((__nothrow__)) int pthread_attr_setscope(pthread_attr_t *__attr ,
                                                               int __scope )  __attribute__((__nonnull__(1))) ;
#line 343
extern  __attribute__((__nothrow__)) int pthread_attr_getstackaddr(pthread_attr_t const   * __restrict  __attr ,
                                                                   void ** __restrict  __stackaddr )  __attribute__((__nonnull__(1,2),
__deprecated__)) ;
#line 351
extern  __attribute__((__nothrow__)) int pthread_attr_setstackaddr(pthread_attr_t *__attr ,
                                                                   void *__stackaddr )  __attribute__((__nonnull__(1),
__deprecated__)) ;
#line 356
extern  __attribute__((__nothrow__)) int pthread_attr_getstacksize(pthread_attr_t const   * __restrict  __attr ,
                                                                   size_t * __restrict  __stacksize )  __attribute__((__nonnull__(1,2))) ;
#line 363
extern  __attribute__((__nothrow__)) int pthread_attr_setstacksize(pthread_attr_t *__attr ,
                                                                   size_t __stacksize )  __attribute__((__nonnull__(1))) ;
#line 369
extern  __attribute__((__nothrow__)) int pthread_attr_getstack(pthread_attr_t const   * __restrict  __attr ,
                                                               void ** __restrict  __stackaddr ,
                                                               size_t * __restrict  __stacksize )  __attribute__((__nonnull__(1,2,3))) ;
#line 377
extern  __attribute__((__nothrow__)) int pthread_attr_setstack(pthread_attr_t *__attr ,
                                                               void *__stackaddr ,
                                                               size_t __stacksize )  __attribute__((__nonnull__(1))) ;
#line 384
extern  __attribute__((__nothrow__)) int pthread_attr_setaffinity_np(pthread_attr_t *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t const   *__cpuset )  __attribute__((__nonnull__(1,3))) ;
#line 391
extern  __attribute__((__nothrow__)) int pthread_attr_getaffinity_np(pthread_attr_t const   *__attr ,
                                                                     size_t __cpusetsize ,
                                                                     cpu_set_t *__cpuset )  __attribute__((__nonnull__(1,3))) ;
#line 400
extern  __attribute__((__nothrow__)) int pthread_getattr_np(pthread_t __th , pthread_attr_t *__attr )  __attribute__((__nonnull__(2))) ;
#line 409
extern  __attribute__((__nothrow__)) int pthread_setschedparam(pthread_t __target_thread ,
                                                               int __policy , struct sched_param  const  *__param )  __attribute__((__nonnull__(3))) ;
#line 414
extern  __attribute__((__nothrow__)) int pthread_getschedparam(pthread_t __target_thread ,
                                                               int * __restrict  __policy ,
                                                               struct sched_param * __restrict  __param )  __attribute__((__nonnull__(2,3))) ;
#line 420
extern  __attribute__((__nothrow__)) int pthread_setschedprio(pthread_t __target_thread ,
                                                              int __prio ) ;
#line 426
extern  __attribute__((__nothrow__)) int pthread_getconcurrency(void) ;
#line 429
extern  __attribute__((__nothrow__)) int pthread_setconcurrency(int __level ) ;
#line 437
extern  __attribute__((__nothrow__)) int pthread_yield(void) ;
#line 442
extern  __attribute__((__nothrow__)) int pthread_setaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t const   *__cpuset )  __attribute__((__nonnull__(3))) ;
#line 447
extern  __attribute__((__nothrow__)) int pthread_getaffinity_np(pthread_t __th , size_t __cpusetsize ,
                                                                cpu_set_t *__cpuset )  __attribute__((__nonnull__(3))) ;
#line 462
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) )  __attribute__((__nonnull__(1,2))) ;
#line 474
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
#line 478
extern int pthread_setcanceltype(int __type , int *__oldtype ) ;
#line 481
extern int pthread_cancel(pthread_t __th ) ;
#line 486
extern void pthread_testcancel(void) ;
#line 648
extern void __pthread_register_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 659
extern void __pthread_unregister_cancel(__pthread_unwind_buf_t *__buf ) ;
#line 682
extern void __pthread_register_cancel_defer(__pthread_unwind_buf_t *__buf ) ;
#line 694
extern void __pthread_unregister_cancel_restore(__pthread_unwind_buf_t *__buf ) ;
#line 699
extern  __attribute__((__noreturn__)) void __pthread_unwind_next(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
#line 709
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 715
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
#line 720
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 724
extern  __attribute__((__nothrow__)) int pthread_mutex_trylock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 728
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 733
extern  __attribute__((__nothrow__)) int pthread_mutex_timedlock(pthread_mutex_t * __restrict  __mutex ,
                                                                 struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2))) ;
#line 739
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 745
extern  __attribute__((__nothrow__)) int pthread_mutex_getprioceiling(pthread_mutex_t const   * __restrict  __mutex ,
                                                                      int * __restrict  __prioceiling )  __attribute__((__nonnull__(1,2))) ;
#line 752
extern  __attribute__((__nothrow__)) int pthread_mutex_setprioceiling(pthread_mutex_t * __restrict  __mutex ,
                                                                      int __prioceiling ,
                                                                      int * __restrict  __old_ceiling )  __attribute__((__nonnull__(1,3))) ;
#line 761
extern  __attribute__((__nothrow__)) int pthread_mutex_consistent_np(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
#line 770
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 774
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 778
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getpshared(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                      int * __restrict  __pshared )  __attribute__((__nonnull__(1,2))) ;
#line 784
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setpshared(pthread_mutexattr_t *__attr ,
                                                                      int __pshared )  __attribute__((__nonnull__(1))) ;
#line 790
extern  __attribute__((__nothrow__)) int pthread_mutexattr_gettype(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                   int * __restrict  __kind )  __attribute__((__nonnull__(1,2))) ;
#line 797
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind )  __attribute__((__nonnull__(1))) ;
#line 801
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprotocol(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                       int * __restrict  __protocol )  __attribute__((__nonnull__(1,2))) ;
#line 808
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprotocol(pthread_mutexattr_t *__attr ,
                                                                       int __protocol )  __attribute__((__nonnull__(1))) ;
#line 813
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getprioceiling(pthread_mutexattr_t const   * __restrict  __attr ,
                                                                          int * __restrict  __prioceiling )  __attribute__((__nonnull__(1,2))) ;
#line 819
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *__attr ,
                                                                          int __prioceiling )  __attribute__((__nonnull__(1))) ;
#line 826
extern  __attribute__((__nothrow__)) int pthread_mutexattr_getrobust_np(pthread_mutexattr_t const   *__attr ,
                                                                        int *__robustness )  __attribute__((__nonnull__(1,2))) ;
#line 831
extern  __attribute__((__nothrow__)) int pthread_mutexattr_setrobust_np(pthread_mutexattr_t *__attr ,
                                                                        int __robustness )  __attribute__((__nonnull__(1))) ;
#line 842
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock ,
                                                             pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nonnull__(1))) ;
#line 847
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 851
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 855
extern  __attribute__((__nothrow__)) int pthread_rwlock_tryrdlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 860
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedrdlock(pthread_rwlock_t * __restrict  __rwlock ,
                                                                    struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2))) ;
#line 866
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 870
extern  __attribute__((__nothrow__)) int pthread_rwlock_trywrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 875
extern  __attribute__((__nothrow__)) int pthread_rwlock_timedwrlock(pthread_rwlock_t * __restrict  __rwlock ,
                                                                    struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2))) ;
#line 881
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
#line 888
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_init(pthread_rwlockattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 892
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_destroy(pthread_rwlockattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 896
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getpshared(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                       int * __restrict  __pshared )  __attribute__((__nonnull__(1,2))) ;
#line 902
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *__attr ,
                                                                       int __pshared )  __attribute__((__nonnull__(1))) ;
#line 907
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_getkind_np(pthread_rwlockattr_t const   * __restrict  __attr ,
                                                                       int * __restrict  __pref )  __attribute__((__nonnull__(1,2))) ;
#line 913
extern  __attribute__((__nothrow__)) int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t *__attr ,
                                                                       int __pref )  __attribute__((__nonnull__(1))) ;
#line 922
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
#line 927
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 931
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 935
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
#line 943
extern int pthread_cond_wait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex )  __attribute__((__nonnull__(1,2))) ;
#line 954
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2,3))) ;
#line 962
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 966
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 970
extern  __attribute__((__nothrow__)) int pthread_condattr_getpshared(pthread_condattr_t const   * __restrict  __attr ,
                                                                     int * __restrict  __pshared )  __attribute__((__nonnull__(1,2))) ;
#line 976
extern  __attribute__((__nothrow__)) int pthread_condattr_setpshared(pthread_condattr_t *__attr ,
                                                                     int __pshared )  __attribute__((__nonnull__(1))) ;
#line 981
extern  __attribute__((__nothrow__)) int pthread_condattr_getclock(pthread_condattr_t const   * __restrict  __attr ,
                                                                   __clockid_t * __restrict  __clock_id )  __attribute__((__nonnull__(1,2))) ;
#line 987
extern  __attribute__((__nothrow__)) int pthread_condattr_setclock(pthread_condattr_t *__attr ,
                                                                   __clockid_t __clock_id )  __attribute__((__nonnull__(1))) ;
#line 998
extern  __attribute__((__nothrow__)) int pthread_spin_init(pthread_spinlock_t *__lock ,
                                                           int __pshared )  __attribute__((__nonnull__(1))) ;
#line 1002
extern  __attribute__((__nothrow__)) int pthread_spin_destroy(pthread_spinlock_t *__lock )  __attribute__((__nonnull__(1))) ;
#line 1006
extern  __attribute__((__nothrow__)) int pthread_spin_lock(pthread_spinlock_t *__lock )  __attribute__((__nonnull__(1))) ;
#line 1010
extern  __attribute__((__nothrow__)) int pthread_spin_trylock(pthread_spinlock_t *__lock )  __attribute__((__nonnull__(1))) ;
#line 1014
extern  __attribute__((__nothrow__)) int pthread_spin_unlock(pthread_spinlock_t *__lock )  __attribute__((__nonnull__(1))) ;
#line 1022
extern  __attribute__((__nothrow__)) int pthread_barrier_init(pthread_barrier_t * __restrict  __barrier ,
                                                              pthread_barrierattr_t const   * __restrict  __attr ,
                                                              unsigned int __count )  __attribute__((__nonnull__(1))) ;
#line 1028
extern  __attribute__((__nothrow__)) int pthread_barrier_destroy(pthread_barrier_t *__barrier )  __attribute__((__nonnull__(1))) ;
#line 1032
extern  __attribute__((__nothrow__)) int pthread_barrier_wait(pthread_barrier_t *__barrier )  __attribute__((__nonnull__(1))) ;
#line 1037
extern  __attribute__((__nothrow__)) int pthread_barrierattr_init(pthread_barrierattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 1041
extern  __attribute__((__nothrow__)) int pthread_barrierattr_destroy(pthread_barrierattr_t *__attr )  __attribute__((__nonnull__(1))) ;
#line 1045
extern  __attribute__((__nothrow__)) int pthread_barrierattr_getpshared(pthread_barrierattr_t const   * __restrict  __attr ,
                                                                        int * __restrict  __pshared )  __attribute__((__nonnull__(1,2))) ;
#line 1051
extern  __attribute__((__nothrow__)) int pthread_barrierattr_setpshared(pthread_barrierattr_t *__attr ,
                                                                        int __pshared )  __attribute__((__nonnull__(1))) ;
#line 1065
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) )  __attribute__((__nonnull__(1))) ;
#line 1070
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
#line 1073
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
#line 1076
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
#line 1082
extern  __attribute__((__nothrow__)) int pthread_getcpuclockid(pthread_t __thread_id ,
                                                               __clockid_t *__clock_id )  __attribute__((__nonnull__(2))) ;
#line 1099
extern  __attribute__((__nothrow__)) int pthread_atfork(void (*__prepare)(void) ,
                                                        void (*__parent)(void) , void (*__child)(void) ) ;
#line 1106
__inline static  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
#line 1106 "/usr/include/pthread.h"
__inline static int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 

  {
#line 1109
  return (__thread1 == __thread2);
}
}
#line 54 "/usr/lib/gcc/x86_64-redhat-linux/4.1.2/include/omp.h"
extern void omp_set_num_threads(int  ) ;
#line 55
extern int omp_get_num_threads(void) ;
#line 56
extern int omp_get_max_threads(void) ;
#line 57
extern int omp_get_thread_num(void) ;
#line 58
extern int omp_get_num_procs(void) ;
#line 60
extern int omp_in_parallel(void) ;
#line 62
extern void omp_set_dynamic(int  ) ;
#line 63
extern int omp_get_dynamic(void) ;
#line 65
extern void omp_set_nested(int  ) ;
#line 66
extern int omp_get_nested(void) ;
#line 68
extern void omp_init_lock(omp_lock_t * ) ;
#line 69
extern void omp_destroy_lock(omp_lock_t * ) ;
#line 70
extern void omp_set_lock(omp_lock_t * ) ;
#line 71
extern void omp_unset_lock(omp_lock_t * ) ;
#line 72
extern int omp_test_lock(omp_lock_t * ) ;
#line 74
extern void omp_init_nest_lock(omp_nest_lock_t * ) ;
#line 75
extern void omp_destroy_nest_lock(omp_nest_lock_t * ) ;
#line 76
extern void omp_set_nest_lock(omp_nest_lock_t * ) ;
#line 77
extern void omp_unset_nest_lock(omp_nest_lock_t * ) ;
#line 78
extern int omp_test_nest_lock(omp_nest_lock_t * ) ;
#line 80
extern double omp_get_wtime(void) ;
#line 81
extern double omp_get_wtick(void) ;
#line 42 "/usr/include/sys/timeb.h"
extern int ftime(struct timeb *__timebuf ) ;
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 142
extern DIR *fdopendir(int __fd ) ;
#line 150
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 166
extern struct dirent *readdir(DIR *__dirp )  __asm__("readdir64") __attribute__((__nonnull__(1))) ;
#line 174
extern struct dirent64 *readdir64(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 190
extern int readdir_r(DIR * __restrict  __dirp , struct dirent * __restrict  __entry ,
                     struct dirent ** __restrict  __result )  __asm__("readdir64_r") __attribute__((__nonnull__(1,2,3))) ;
#line 201
extern int readdir64_r(DIR * __restrict  __dirp , struct dirent64 * __restrict  __entry ,
                       struct dirent64 ** __restrict  __result )  __attribute__((__nonnull__(1,2,3))) ;
#line 209
extern  __attribute__((__nothrow__)) void rewinddir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 215
extern  __attribute__((__nothrow__)) void seekdir(DIR *__dirp , long __pos )  __attribute__((__nonnull__(1))) ;
#line 218
extern  __attribute__((__nothrow__)) long telldir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 257
extern int scandir(char const   * __restrict  __dir , struct dirent *** __restrict  __namelist ,
                   int (*__selector)(struct dirent  const  * ) , int (*__cmp)(void const   * ,
                                                                              void const   * ) )  __asm__("scandir64") __attribute__((__nonnull__(1,2))) ;
#line 271
extern int scandir64(char const   * __restrict  __dir , struct dirent64 *** __restrict  __namelist ,
                     int (*__selector)(struct dirent64  const  * ) , int (*__cmp)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,2))) ;
#line 284
extern  __attribute__((__nothrow__)) int alphasort(void const   *__e1 , void const   *__e2 )  __asm__("alphasort64") __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 293
extern  __attribute__((__nothrow__)) int alphasort64(void const   *__e1 , void const   *__e2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 304
extern  __attribute__((__nothrow__)) int versionsort(void const   *__e1 , void const   *__e2 )  __asm__("versionsort64") __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 314
extern  __attribute__((__nothrow__)) int versionsort64(void const   *__e1 , void const   *__e2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 330
extern  __attribute__((__nothrow__)) __ssize_t getdirentries(int __fd , char * __restrict  __buf ,
                                                             size_t __nbytes , __off64_t * __restrict  __basep )  __asm__("getdirentries64") __attribute__((__nonnull__(2,4))) ;
#line 341
extern  __attribute__((__nothrow__)) __ssize_t getdirentries64(int __fd , char * __restrict  __buf ,
                                                               size_t __nbytes , __off64_t * __restrict  __basep )  __attribute__((__nonnull__(2,4))) ;
#line 55 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 62
extern  __attribute__((__nothrow__)) int getrlimit64(__rlimit_resource_t __resource ,
                                                     struct rlimit64 *__rlimits ) ;
#line 74
extern  __attribute__((__nothrow__)) int setrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit  const  *__rlimits )  __asm__("setrlimit64")  ;
#line 82
extern  __attribute__((__nothrow__)) int setrlimit64(__rlimit_resource_t __resource ,
                                                     struct rlimit64  const  *__rlimits ) ;
#line 88
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
#line 94
extern  __attribute__((__nothrow__)) int getpriority(__priority_which_t __which ,
                                                     id_t __who ) ;
#line 98
extern  __attribute__((__nothrow__)) int setpriority(__priority_which_t __which ,
                                                     id_t __who , int __prio ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 139
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 155
extern int waitid(idtype_t __idtype , __id_t __id , siginfo_t *__infop , int __options ) ;
#line 169
extern  __attribute__((__nothrow__)) __pid_t wait3(union wait *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 179
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , union wait *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 73 "/usr/include/pwd.h"
extern void setpwent(void) ;
#line 79
extern void endpwent(void) ;
#line 85
extern struct passwd *getpwent(void) ;
#line 95
extern struct passwd *fgetpwent(FILE *__stream ) ;
#line 103
extern int putpwent(struct passwd  const  * __restrict  __p , FILE * __restrict  __f ) ;
#line 111
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 140
extern int getpwent_r(struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 145
extern int getpwuid_r(__uid_t __uid , struct passwd * __restrict  __resultbuf , char * __restrict  __buffer ,
                      size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 150
extern int getpwnam_r(char const   * __restrict  __name , struct passwd * __restrict  __resultbuf ,
                      char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 164
extern int fgetpwent_r(FILE * __restrict  __stream , struct passwd * __restrict  __resultbuf ,
                       char * __restrict  __buffer , size_t __buflen , struct passwd ** __restrict  __result ) ;
#line 181
extern int getpw(__uid_t __uid , char *__buffer ) ;
#line 73 "/usr/include/sys/time.h"
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
#line 79
extern  __attribute__((__nothrow__)) int settimeofday(struct timeval  const  *__tv ,
                                                      struct timezone  const  *__tz )  __attribute__((__nonnull__(1))) ;
#line 87
extern  __attribute__((__nothrow__)) int adjtime(struct timeval  const  *__delta ,
                                                 struct timeval *__olddelta ) ;
#line 127
extern  __attribute__((__nothrow__)) int getitimer(__itimer_which_t __which , struct itimerval *__value ) ;
#line 133
extern  __attribute__((__nothrow__)) int setitimer(__itimer_which_t __which , struct itimerval  const  * __restrict  __new ,
                                                   struct itimerval * __restrict  __old ) ;
#line 140
extern  __attribute__((__nothrow__)) int utimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
#line 145
extern  __attribute__((__nothrow__)) int lutimes(char const   *__file , struct timeval  const  *__tvp )  __attribute__((__nonnull__(1))) ;
#line 149
extern  __attribute__((__nothrow__)) int futimes(int __fd , struct timeval  const  *__tvp ) ;
#line 156
extern  __attribute__((__nothrow__)) int futimesat(int __fd , char const   *__file ,
                                                   struct timeval  const  *__tvp ) ;
#line 49 "/usr/include/sys/times.h"
extern  __attribute__((__nothrow__)) clock_t times(struct tms *__buffer ) ;
#line 122 "./magick/geometry.h"
extern char *GetPageGeometry(char const   * ) ;
#line 125
extern MagickBooleanType IsGeometry(char const   * ) ;
#line 125
extern MagickBooleanType IsSceneGeometry(char const   * , MagickBooleanType  ) ;
#line 129
extern MagickStatusType GetGeometry(char const   * , long * , long * , unsigned long * ,
                                    unsigned long * ) ;
#line 129
extern MagickStatusType ParseAbsoluteGeometry(char const   * , RectangleInfo * ) ;
#line 129
extern MagickStatusType ParseAffineGeometry(char const   * , AffineMatrix * , ExceptionInfo * ) ;
#line 129
extern MagickStatusType ParseGeometry(char const   * , GeometryInfo * ) ;
#line 129
extern MagickStatusType ParseGravityGeometry(Image const   * , char const   * , RectangleInfo * ,
                                             ExceptionInfo * ) ;
#line 129
extern MagickStatusType ParseMetaGeometry(char const   * , long * , long * , unsigned long * ,
                                          unsigned long * ) ;
#line 129
extern MagickStatusType ParsePageGeometry(Image const   * , char const   * , RectangleInfo * ,
                                          ExceptionInfo * ) ;
#line 129
extern MagickStatusType ParseRegionGeometry(Image const   * , char const   * , RectangleInfo * ,
                                            ExceptionInfo * ) ;
#line 141
extern void GravityAdjustGeometry(unsigned long  , unsigned long  , GravityType  ,
                                  RectangleInfo * ) ;
#line 141
extern void SetGeometry(Image const   * , RectangleInfo * ) ;
#line 141
extern void SetGeometryInfo(GeometryInfo * ) ;
#line 52 "./magick/colorspace.h"
extern MagickBooleanType RGBTransformImage(Image * , ColorspaceType  ) ;
#line 52
extern MagickBooleanType SetImageColorspace(Image * , ColorspaceType  ) ;
#line 52
extern MagickBooleanType TransformImageColorspace(Image * , ColorspaceType  ) ;
#line 52
extern MagickBooleanType TransformRGBImage(Image * , ColorspaceType  ) ;
#line 37 "./magick/constitute.h"
extern Image *ConstituteImage(unsigned long  , unsigned long  , char const   * , StorageType  ,
                              void const   * , ExceptionInfo * ) ;
#line 37
extern Image *PingImage(ImageInfo const   * , ExceptionInfo * ) ;
#line 37
extern Image *PingImages(ImageInfo const   * , ExceptionInfo * ) ;
#line 37
extern Image *ReadImage(ImageInfo const   * , ExceptionInfo * ) ;
#line 37
extern Image *ReadImages(ImageInfo const   * , ExceptionInfo * ) ;
#line 37
extern Image *ReadInlineImage(ImageInfo const   * , char const   * , ExceptionInfo * ) ;
#line 46
extern MagickBooleanType WriteImage(ImageInfo const   * , Image * ) ;
#line 46
extern MagickBooleanType WriteImages(ImageInfo const   * , Image * , char const   * ,
                                     ExceptionInfo * ) ;
#line 50
extern void DestroyConstitute(void) ;
#line 82 "./magick/pixel.h"
extern MagickBooleanType ExportImagePixels(Image const   * , long  , long  , unsigned long  ,
                                           unsigned long  , char const   * , StorageType  ,
                                           void * , ExceptionInfo * ) ;
#line 82
extern MagickBooleanType ImportImagePixels(Image * , long  , long  , unsigned long  ,
                                           unsigned long  , char const   * , StorageType  ,
                                           void const   * ) ;
#line 88
extern void GetMagickPixelPacket(Image const   * , MagickPixelPacket * ) ;
#line 28 "./magick/semaphore.h"
extern MagickBooleanType LockSemaphoreInfo(SemaphoreInfo * ) ;
#line 28
extern MagickBooleanType UnlockSemaphoreInfo(SemaphoreInfo * ) ;
#line 32
extern SemaphoreInfo *AllocateSemaphoreInfo(void) ;
#line 35
extern void AcquireSemaphoreInfo(SemaphoreInfo ** ) ;
#line 35
extern void DestroySemaphore(void) ;
#line 35
extern void DestroySemaphoreInfo(SemaphoreInfo ** ) ;
#line 35
extern void InitializeSemaphore(void) ;
#line 35
extern void RelinquishSemaphoreInfo(SemaphoreInfo * ) ;
#line 133 "./magick/exception.h"
extern char *GetExceptionMessage(int  ) ;
#line 136
extern char const   *GetLocaleExceptionMessage(ExceptionType  , char const   * ) ;
#line 139
extern ErrorHandler SetErrorHandler(void (*)(ExceptionType  , char const   * , char const   * ) ) ;
#line 142
extern ExceptionInfo *AcquireExceptionInfo(void) ;
#line 142
extern ExceptionInfo *DestroyExceptionInfo(ExceptionInfo * ) ;
#line 146
extern FatalErrorHandler SetFatalErrorHandler(void (*)(ExceptionType  , char const   * ,
                                                       char const   * ) ) ;
#line 149
extern MagickBooleanType ThrowException(ExceptionInfo * , ExceptionType  , char const   * ,
                                        char const   * ) ;
#line 149
extern MagickBooleanType ( /* format attribute */  ThrowMagickException)(ExceptionInfo * ,
                                                                         char const   * ,
                                                                         char const   * ,
                                                                         unsigned long  ,
                                                                         ExceptionType  ,
                                                                         char const   * ,
                                                                         char const   * 
                                                                         , ...) ;
#line 149
extern MagickBooleanType ( /* format attribute */  ThrowMagickExceptionList)(ExceptionInfo * ,
                                                                             char const   * ,
                                                                             char const   * ,
                                                                             unsigned long  ,
                                                                             ExceptionType  ,
                                                                             char const   * ,
                                                                             char const   * ,
                                                                             va_list  ) ;
#line 159
extern void CatchException(ExceptionInfo * ) ;
#line 159
extern void ClearMagickException(ExceptionInfo * ) ;
#line 159
extern void GetExceptionInfo(ExceptionInfo * ) ;
#line 159
extern void InheritException(ExceptionInfo * , ExceptionInfo const   * ) ;
#line 159
extern void MagickError(ExceptionType  , char const   * , char const   * ) ;
#line 159
extern void MagickFatalError(ExceptionType  , char const   * , char const   * ) ;
#line 159
extern void MagickWarning(ExceptionType  , char const   * , char const   * ) ;
#line 168
extern WarningHandler SetWarningHandler(void (*)(ExceptionType  , char const   * ,
                                                 char const   * ) ) ;
#line 81 "./magick/color.h"
extern char **GetColorList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 84
extern ColorInfo const   *GetColorInfo(char const   * , ExceptionInfo * ) ;
#line 84
extern ColorInfo const   **GetColorInfoList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 88
extern ColorPacket *GetImageHistogram(Image const   * , unsigned long * , ExceptionInfo * ) ;
#line 91
extern Image *UniqueImageColors(Image const   * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsColorSimilar(Image const   * , PixelPacket const   * ,
                                        PixelPacket const   * ) ;
#line 94
extern MagickBooleanType IsGrayImage(Image * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsHistogramImage(Image const   * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsImageSimilar(Image const   * , Image const   * , long *x ,
                                        long *y , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsMagickColorSimilar(MagickPixelPacket const   * , MagickPixelPacket const   * ) ;
#line 94
extern MagickBooleanType IsMonochromeImage(Image * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsOpacitySimilar(Image const   * , PixelPacket const   * ,
                                          PixelPacket const   * ) ;
#line 94
extern MagickBooleanType IsOpaqueImage(Image const   * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType IsPaletteImage(Image const   * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType ListColorInfo(FILE * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType QueryColorDatabase(char const   * , PixelPacket * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType QueryColorname(Image const   * , PixelPacket const   * ,
                                        ComplianceType  , char * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType QueryMagickColor(char const   * , MagickPixelPacket * , ExceptionInfo * ) ;
#line 94
extern MagickBooleanType QueryMagickColorname(Image const   * , MagickPixelPacket const   * ,
                                              ComplianceType  , char * , ExceptionInfo * ) ;
#line 112
extern unsigned long GetNumberColors(Image const   * , FILE * , ExceptionInfo * ) ;
#line 115
extern void ConcatenateColorComponent(MagickPixelPacket const   * , ChannelType  ,
                                      ComplianceType  , char * ) ;
#line 115
extern void DestroyColorList(void) ;
#line 115
extern void GetColorTuple(MagickPixelPacket const   * , MagickBooleanType  , char * ) ;
#line 28 "./magick/stream.h"
extern Image *ReadStream(ImageInfo const   * , size_t (*)(Image const   * , void const   * ,
                                                          size_t  ) , ExceptionInfo * ) ;
#line 31
extern MagickBooleanType WriteStream(ImageInfo const   * , Image * , size_t (*)(Image const   * ,
                                                                                void const   * ,
                                                                                size_t  ) ) ;
#line 37 "./magick/blob.h"
extern FILE *GetBlobFileHandle(Image const   * ) ;
#line 40
extern Image *BlobToImage(ImageInfo const   * , void const   * , size_t  , ExceptionInfo * ) ;
#line 40
extern Image *PingBlob(ImageInfo const   * , void const   * , size_t  , ExceptionInfo * ) ;
#line 44
extern MagickBooleanType BlobToFile(char * , void const   * , size_t  , ExceptionInfo * ) ;
#line 44
extern MagickBooleanType FileToImage(Image * , char const   * ) ;
#line 44
extern MagickBooleanType GetBlobError(Image const   * ) ;
#line 44
extern MagickBooleanType ImageToFile(Image * , char * , ExceptionInfo * ) ;
#line 44
extern MagickBooleanType InjectImageBlob(ImageInfo const   * , Image * , Image * ,
                                         char const   * , ExceptionInfo * ) ;
#line 44
extern MagickBooleanType IsBlobExempt(Image const   * ) ;
#line 44
extern MagickBooleanType IsBlobSeekable(Image const   * ) ;
#line 44
extern MagickBooleanType IsBlobTemporary(Image const   * ) ;
#line 55
extern MagickSizeType GetBlobSize(Image const   * ) ;
#line 58
extern StreamHandler GetBlobStreamHandler(Image const   * ) ;
#line 61
extern unsigned char *FileToBlob(char const   * , size_t  , size_t * , ExceptionInfo * ) ;
#line 61
extern unsigned char *GetBlobStreamData(Image const   * ) ;
#line 61
extern unsigned char *ImageToBlob(ImageInfo const   * , Image * , size_t * , ExceptionInfo * ) ;
#line 61
extern unsigned char *ImagesToBlob(ImageInfo const   * , Image * , size_t * , ExceptionInfo * ) ;
#line 67
extern void DestroyBlob(Image * ) ;
#line 67
extern void DuplicateBlob(Image * , Image const   * ) ;
#line 67
extern void SetBlobExempt(Image * , MagickBooleanType  ) ;
#line 52 "./magick/cache-view.h"
extern ClassType GetCacheViewStorageClass(ViewInfo const   * ) ;
#line 55
extern ColorspaceType GetCacheViewColorspace(ViewInfo const   * ) ;
#line 58
extern IndexPacket const   *GetCacheViewVirtualIndexQueue(ViewInfo const   * ) ;
#line 61
extern PixelPacket const   *GetCacheViewVirtualPixels(ViewInfo const   * , long  ,
                                                      long  , unsigned long  , unsigned long  ,
                                                      ExceptionInfo * ) ;
#line 61
extern PixelPacket const   *GetCacheViewVirtualPixelQueue(ViewInfo const   * ) ;
#line 66
extern ExceptionInfo *GetCacheViewException(ViewInfo const   * ) ;
#line 69
extern IndexPacket *GetCacheViewAuthenticIndexQueue(ViewInfo * ) ;
#line 72
extern MagickBooleanType GetOneCacheViewVirtualPixel(ViewInfo const   * , long  ,
                                                     long  , PixelPacket * , ExceptionInfo * ) ;
#line 72
extern MagickBooleanType GetOneCacheViewVirtualMethodPixel(ViewInfo const   * , VirtualPixelMethod  ,
                                                           long  , long  , PixelPacket * ,
                                                           ExceptionInfo * ) ;
#line 72
extern MagickBooleanType GetOneCacheViewAuthenticPixel(ViewInfo const   * , long  ,
                                                       long  , PixelPacket * , ExceptionInfo * ) ;
#line 72
extern MagickBooleanType SetCacheViewStorageClass(ViewInfo * , ClassType  ) ;
#line 72
extern MagickBooleanType SetCacheViewVirtualPixelMethod(ViewInfo * , VirtualPixelMethod  ) ;
#line 72
extern MagickBooleanType SyncCacheViewAuthenticPixels(ViewInfo * , ExceptionInfo * ) ;
#line 84
extern MagickSizeType GetCacheViewExtent(ViewInfo const   * ) ;
#line 87
extern PixelPacket *GetCacheViewAuthenticPixelQueue(ViewInfo * ) ;
#line 87
extern PixelPacket *GetCacheViewAuthenticPixels(ViewInfo * , long  , long  , unsigned long  ,
                                                unsigned long  , ExceptionInfo * ) ;
#line 87
extern PixelPacket *QueueCacheViewAuthenticPixels(ViewInfo * , long  , long  , unsigned long  ,
                                                  unsigned long  , ExceptionInfo * ) ;
#line 94
extern ViewInfo *AcquireCacheView(Image const   * ) ;
#line 94
extern ViewInfo *CloneCacheView(ViewInfo const   * ) ;
#line 94
extern ViewInfo *DestroyCacheView(ViewInfo * ) ;
#line 85 "./magick/composite.h"
extern MagickBooleanType CompositeImage(Image * , CompositeOperator  , Image const   * ,
                                        long  , long  ) ;
#line 85
extern MagickBooleanType CompositeImageChannel(Image * , ChannelType  , CompositeOperator  ,
                                               Image const   * , long  , long  ) ;
#line 46 "./magick/compress.h"
extern MagickBooleanType HuffmanDecodeImage(Image * ) ;
#line 46
extern MagickBooleanType HuffmanEncodeImage(ImageInfo const   * , Image * , Image * ) ;
#line 46
extern MagickBooleanType Huffman2DEncodeImage(ImageInfo const   * , Image * , Image * ) ;
#line 46
extern MagickBooleanType LZWEncodeImage(Image * , size_t  , unsigned char * ) ;
#line 46
extern MagickBooleanType PackbitsEncodeImage(Image * , size_t  , unsigned char * ) ;
#line 46
extern MagickBooleanType ZLIBEncodeImage(Image * , size_t  , unsigned char * ) ;
#line 54
extern void Ascii85Encode(Image * , unsigned char  ) ;
#line 54
extern void Ascii85Flush(Image * ) ;
#line 54
extern void Ascii85Initialize(Image * ) ;
#line 59 "./magick/effect.h"
extern Image *AdaptiveBlurImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *AdaptiveBlurImageChannel(Image const   * , ChannelType  , double  ,
                                       double  , ExceptionInfo * ) ;
#line 59
extern Image *AdaptiveSharpenImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *AdaptiveSharpenImageChannel(Image const   * , ChannelType  , double  ,
                                          double  , ExceptionInfo * ) ;
#line 59
extern Image *BlurImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *BlurImageChannel(Image const   * , ChannelType  , double  , double  ,
                               ExceptionInfo * ) ;
#line 59
extern Image *DespeckleImage(Image const   * , ExceptionInfo * ) ;
#line 59
extern Image *EdgeImage(Image const   * , double  , ExceptionInfo * ) ;
#line 59
extern Image *EmbossImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *GaussianBlurImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *GaussianBlurImageChannel(Image const   * , ChannelType  , double  ,
                                       double  , ExceptionInfo * ) ;
#line 59
extern Image *MedianFilterImage(Image const   * , double  , ExceptionInfo * ) ;
#line 59
extern Image *MotionBlurImage(Image const   * , double  , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *MotionBlurImageChannel(Image const   * , ChannelType  , double  , double  ,
                                     double  , ExceptionInfo * ) ;
#line 59
extern Image *PreviewImage(Image const   * , PreviewType  , ExceptionInfo * ) ;
#line 59
extern Image *RadialBlurImage(Image const   * , double  , ExceptionInfo * ) ;
#line 59
extern Image *RadialBlurImageChannel(Image const   * , ChannelType  , double  , ExceptionInfo * ) ;
#line 59
extern Image *ReduceNoiseImage(Image const   * , double  , ExceptionInfo * ) ;
#line 59
extern Image *SelectiveBlurImage(Image const   * , double  , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *SelectiveBlurImageChannel(Image const   * , ChannelType  , double  ,
                                        double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *ShadeImage(Image const   * , MagickBooleanType  , double  , double  ,
                         ExceptionInfo * ) ;
#line 59
extern Image *SharpenImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 59
extern Image *SharpenImageChannel(Image const   * , ChannelType  , double  , double  ,
                                  ExceptionInfo * ) ;
#line 59
extern Image *SpreadImage(Image const   * , double  , ExceptionInfo * ) ;
#line 59
extern Image *UnsharpMaskImage(Image const   * , double  , double  , double  , double  ,
                               ExceptionInfo * ) ;
#line 59
extern Image *UnsharpMaskImageChannel(Image const   * , ChannelType  , double  , double  ,
                                      double  , double  , ExceptionInfo * ) ;
#line 55 "./magick/layer.h"
extern Image *CoalesceImages(Image const   * , ExceptionInfo * ) ;
#line 55
extern Image *DisposeImages(Image const   * , ExceptionInfo * ) ;
#line 55
extern Image *CompareImageLayers(Image const   * , ImageLayerMethod  , ExceptionInfo * ) ;
#line 55
extern Image *DeconstructImages(Image const   * , ExceptionInfo * ) ;
#line 55
extern Image *MergeImageLayers(Image * , ImageLayerMethod  , ExceptionInfo * ) ;
#line 55
extern Image *OptimizeImageLayers(Image const   * , ExceptionInfo * ) ;
#line 55
extern Image *OptimizePlusImageLayers(Image const   * , ExceptionInfo * ) ;
#line 64
extern void CompositeLayers(Image * , CompositeOperator  , Image * , long  , long  ,
                            ExceptionInfo * ) ;
#line 64
extern void OptimizeImageTransparency(Image const   * , ExceptionInfo * ) ;
#line 64
extern void RemoveDuplicateLayers(Image ** , ExceptionInfo * ) ;
#line 64
extern void RemoveZeroDelayLayers(Image ** , ExceptionInfo * ) ;
#line 29 "./magick/monitor.h"
extern MagickProgressMonitor SetImageProgressMonitor(Image * , MagickBooleanType (*)(char const   * ,
                                                                                     MagickOffsetType  ,
                                                                                     MagickSizeType  ,
                                                                                     void * ) ,
                                                     void * ) ;
#line 29
extern MagickProgressMonitor SetImageInfoProgressMonitor(ImageInfo * , MagickBooleanType (*)(char const   * ,
                                                                                             MagickOffsetType  ,
                                                                                             MagickSizeType  ,
                                                                                             void * ) ,
                                                         void * ) ;
#line 33 "./magick/monitor.h"
__inline static MagickBooleanType QuantumTick(MagickOffsetType offset , MagickSizeType span ) 
{ 

  {
#line 36
  if (span <= 100ULL) {
#line 37
    return (1);
  }
#line 38
  if (offset == (long long )(span - 1ULL)) {
#line 39
    return (1);
  }
#line 40
  if ((unsigned long long )offset % (span / 100ULL) == 0ULL) {
#line 41
    return (1);
  }
#line 42
  return (0);
}
}
#line 44 "./magick/string_.h"
extern char *AcquireString(char const   * ) ;
#line 44
extern char *CloneString(char ** , char const   * ) ;
#line 44
extern char *ConstantString(char const   * ) ;
#line 44
extern char *DestroyString(char * ) ;
#line 44
extern char **DestroyStringList(char ** ) ;
#line 44
extern char *EscapeString(char const   * , char  ) ;
#line 44
extern char *FileToString(char const   * , size_t  , ExceptionInfo * ) ;
#line 44
extern char *GetEnvironmentValue(char const   * ) ;
#line 44
extern char *StringInfoToHexString(StringInfo const   * ) ;
#line 44
extern char *StringInfoToString(StringInfo const   * ) ;
#line 44
extern char **StringToArgv(char const   * , int * ) ;
#line 44
extern char *StringToken(char const   * , char ** ) ;
#line 44
extern char **StringToList(char const   * ) ;
#line 59
extern char const   *GetStringInfoPath(StringInfo const   * ) ;
#line 62
extern double StringToDouble(char const   * , double  ) ;
#line 65
extern long FormatMagickSize(MagickSizeType  , char * ) ;
#line 65
extern long ( /* format attribute */  FormatMagickString)(char * , size_t  , char const   * 
                                                          , ...) ;
#line 65
extern long ( /* format attribute */  FormatMagickStringList)(char * , size_t  , char const   * ,
                                                              va_list  ) ;
#line 65
extern long FormatMagickTime(time_t  , size_t  , char * ) ;
#line 65
extern long LocaleCompare(char const   * , char const   * ) ;
#line 65
extern long LocaleNCompare(char const   * , char const   * , size_t  ) ;
#line 75
extern MagickBooleanType ConcatenateString(char ** , char const   * ) ;
#line 75
extern MagickBooleanType SubstituteString(char ** , char const   * , char const   * ) ;
#line 79
extern int CompareStringInfo(StringInfo const   * , StringInfo const   * ) ;
#line 82
extern size_t ConcatenateMagickString(char * , char const   * , size_t  ) ;
#line 82
extern size_t CopyMagickString(char * , char const   * , size_t  ) ;
#line 82
extern size_t GetStringInfoLength(StringInfo const   * ) ;
#line 87
extern StringInfo *AcquireStringInfo(size_t  ) ;
#line 87
extern StringInfo *CloneStringInfo(StringInfo const   * ) ;
#line 87
extern StringInfo *ConfigureFileToStringInfo(char const   * ) ;
#line 87
extern StringInfo *DestroyStringInfo(StringInfo * ) ;
#line 87
extern StringInfo *FileToStringInfo(char const   * , size_t  , ExceptionInfo * ) ;
#line 87
extern StringInfo *SplitStringInfo(StringInfo * , size_t  ) ;
#line 87
extern StringInfo *StringToStringInfo(char const   * ) ;
#line 96
extern unsigned char *GetStringInfoDatum(StringInfo const   * ) ;
#line 99
extern void ConcatenateStringInfo(StringInfo * , StringInfo const   * ) ;
#line 99
extern void LocaleLower(char * ) ;
#line 99
extern void LocaleUpper(char * ) ;
#line 99
extern void PrintStringInfo(FILE *file , char const   * , StringInfo const   * ) ;
#line 99
extern void ResetStringInfo(StringInfo * ) ;
#line 99
extern void SetStringInfo(StringInfo * , StringInfo const   * ) ;
#line 99
extern void SetStringInfoDatum(StringInfo * , unsigned char const   * ) ;
#line 99
extern void SetStringInfoLength(StringInfo * , size_t  ) ;
#line 99
extern void SetStringInfoPath(StringInfo * , char const   * ) ;
#line 99
extern void StripString(char * ) ;
#line 51 "./magick/profile.h"
extern char *GetNextImageProfile(Image const   * ) ;
#line 54
extern StringInfo const   *GetImageProfile(Image const   * , char const   * ) ;
#line 57
extern MagickBooleanType CloneImageProfiles(Image * , Image const   * ) ;
#line 57
extern MagickBooleanType DeleteImageProfile(Image * , char const   * ) ;
#line 57
extern MagickBooleanType ProfileImage(Image * , char const   * , void const   * ,
                                      size_t  , MagickBooleanType  ) ;
#line 57
extern MagickBooleanType SetImageProfile(Image * , char const   * , StringInfo const   * ) ;
#line 57
extern MagickBooleanType SyncImageProfiles(Image * ) ;
#line 65
extern StringInfo *RemoveImageProfile(Image * , char const   * ) ;
#line 68
extern void DestroyImageProfiles(Image * ) ;
#line 68
extern void ResetImageProfileIterator(Image const   * ) ;
#line 78 "./magick/quantum.h"
__inline static Quantum RoundToQuantum(MagickRealType value ) 
{ 

  {
#line 83
  if (value <= 0.0) {
#line 84
    return ((unsigned short)0);
  }
#line 85
  if (value >= (MagickRealType )65535UL) {
#line 86
    return ((unsigned short)65535);
  }
#line 87
  return ((unsigned short )(value + 0.5));
}
}
#line 105 "./magick/quantum.h"
__inline static unsigned char ScaleQuantumToChar(Quantum quantum ) 
{ 

  {
#line 108
  return ((unsigned char )((((unsigned long )quantum + 128UL) - (((unsigned long )quantum + 128UL) >> 8)) >> 8));
}
}
#line 142
extern MagickBooleanType SetQuantumDepth(Image const   * , QuantumInfo * , unsigned long  ) ;
#line 142
extern MagickBooleanType SetQuantumFormat(Image const   * , QuantumInfo * , QuantumFormatType  ) ;
#line 142
extern MagickBooleanType SetQuantumPad(Image const   * , QuantumInfo * , unsigned long  ) ;
#line 147
extern QuantumInfo *AcquireQuantumInfo(ImageInfo const   * , Image * ) ;
#line 147
extern QuantumInfo *DestroyQuantumInfo(QuantumInfo * ) ;
#line 151
extern QuantumType GetQuantumType(Image * , ExceptionInfo * ) ;
#line 154
extern size_t ExportQuantumPixels(Image const   * , ViewInfo const   * , QuantumInfo const   * ,
                                  QuantumType  , unsigned char * , ExceptionInfo * ) ;
#line 154
extern size_t GetQuantumExtent(Image const   * , QuantumInfo const   * , QuantumType  ) ;
#line 154
extern size_t ImportQuantumPixels(Image * , ViewInfo * , QuantumInfo const   * , QuantumType  ,
                                  unsigned char const   * , ExceptionInfo * ) ;
#line 161
extern unsigned char *GetQuantumPixels(QuantumInfo const   * ) ;
#line 164
extern void GetQuantumInfo(ImageInfo const   * , QuantumInfo * ) ;
#line 164
extern void SetQuantumAlphaType(QuantumInfo * , QuantumAlphaType  ) ;
#line 164
extern void SetQuantumImageType(Image * , QuantumType  ) ;
#line 164
extern void SetQuantumMinIsWhite(QuantumInfo * , MagickBooleanType  ) ;
#line 164
extern void SetQuantumPack(QuantumInfo * , MagickBooleanType  ) ;
#line 164
extern void SetQuantumQuantum(QuantumInfo * , unsigned long  ) ;
#line 164
extern void SetQuantumScale(QuantumInfo * , double  ) ;
#line 70 "./magick/resample.h"
extern MagickBooleanType ResamplePixelColor(ResampleFilter * , double  , double  ,
                                            MagickPixelPacket * ) ;
#line 70
extern MagickBooleanType SetResampleFilterInterpolateMethod(ResampleFilter * , InterpolatePixelMethod  ) ;
#line 70
extern MagickBooleanType SetResampleFilterVirtualPixelMethod(ResampleFilter * , VirtualPixelMethod  ) ;
#line 78
extern ResampleFilter *AcquireResampleFilter(Image const   * , ExceptionInfo * ) ;
#line 78
extern ResampleFilter *DestroyResampleFilter(ResampleFilter * ) ;
#line 82
extern void ScaleResampleFilter(ResampleFilter * , double  , double  , double  , double  ) ;
#line 82
extern void SetResampleFilter(ResampleFilter * , FilterTypes  , double  ) ;
#line 25 "./magick/resize.h"
extern Image *AdaptiveResizeImage(Image const   * , unsigned long  , unsigned long  ,
                                  ExceptionInfo * ) ;
#line 25
extern Image *LiquidRescaleImage(Image const   * , unsigned long  , unsigned long  ,
                                 double  , double  , ExceptionInfo * ) ;
#line 25
extern Image *MagnifyImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *MinifyImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *ResampleImage(Image const   * , double  , double  , FilterTypes  , double  ,
                            ExceptionInfo * ) ;
#line 25
extern Image *ResizeImage(Image const   * , unsigned long  , unsigned long  , FilterTypes  ,
                          double  , ExceptionInfo * ) ;
#line 25
extern Image *SampleImage(Image const   * , unsigned long  , unsigned long  , ExceptionInfo * ) ;
#line 25
extern Image *ScaleImage(Image const   * , unsigned long  , unsigned long  , ExceptionInfo * ) ;
#line 25
extern Image *ThumbnailImage(Image const   * , unsigned long  , unsigned long  , ExceptionInfo * ) ;
#line 25
extern Image *ZoomImage(Image const   * , unsigned long  , unsigned long  , ExceptionInfo * ) ;
#line 53 "./magick/timer.h"
extern double GetElapsedTime(TimerInfo * ) ;
#line 53
extern double GetUserTime(TimerInfo * ) ;
#line 57
extern MagickBooleanType ContinueTimer(TimerInfo * ) ;
#line 60
extern TimerInfo *AcquireTimerInfo(void) ;
#line 60
extern TimerInfo *DestroyTimerInfo(TimerInfo * ) ;
#line 64
extern void GetTimerInfo(TimerInfo * ) ;
#line 64
extern void ResetTimer(TimerInfo * ) ;
#line 64
extern void StartTimer(TimerInfo * , MagickBooleanType  ) ;
#line 478 "./magick/image.h"
extern ExceptionType CatchImageException(Image * ) ;
#line 481
extern Image *AcquireImage(ImageInfo const   * ) ;
#line 481
extern Image *AppendImages(Image const   * , MagickBooleanType  , ExceptionInfo * ) ;
#line 481
extern Image *AverageImages(Image const   * , ExceptionInfo * ) ;
#line 481
extern Image *CloneImage(Image const   * , unsigned long  , unsigned long  , MagickBooleanType  ,
                         ExceptionInfo * ) ;
#line 481
extern Image *CombineImages(Image const   * , ChannelType  , ExceptionInfo * ) ;
#line 481
extern Image *DestroyImage(Image * ) ;
#line 481
extern Image *GetImageClipMask(Image const   * , ExceptionInfo * ) ;
#line 481
extern Image *GetImageMask(Image const   * , ExceptionInfo * ) ;
#line 481
extern Image *NewMagickImage(ImageInfo const   * , unsigned long  , unsigned long  ,
                             MagickPixelPacket const   * ) ;
#line 481
extern Image *ReferenceImage(Image * ) ;
#line 481
extern Image *SeparateImages(Image const   * , ChannelType  , ExceptionInfo * ) ;
#line 496
extern ImageInfo *AcquireImageInfo(void) ;
#line 496
extern ImageInfo *CloneImageInfo(ImageInfo const   * ) ;
#line 496
extern ImageInfo *DestroyImageInfo(ImageInfo * ) ;
#line 501
extern ImageType GetImageType(Image * , ExceptionInfo * ) ;
#line 504
extern MagickBooleanType AcquireImageColormap(Image * , unsigned long  ) ;
#line 504
extern MagickBooleanType ClipImage(Image * ) ;
#line 504
extern MagickBooleanType ClipImagePath(Image * , char const   * , MagickBooleanType  ) ;
#line 504
extern MagickBooleanType CycleColormapImage(Image * , long  ) ;
#line 504
extern MagickBooleanType GetImageAlphaChannel(Image const   * ) ;
#line 504
extern MagickBooleanType IsTaintImage(Image const   * ) ;
#line 504
extern MagickBooleanType IsMagickConflict(char const   * ) ;
#line 504
extern MagickBooleanType IsHighDynamicRangeImage(Image const   * , ExceptionInfo * ) ;
#line 504
extern MagickBooleanType IsImageObject(Image const   * ) ;
#line 504
extern MagickBooleanType ListMagickInfo(FILE * , ExceptionInfo * ) ;
#line 504
extern MagickBooleanType ModifyImage(Image ** , ExceptionInfo * ) ;
#line 504
extern MagickBooleanType PlasmaImage(Image * , SegmentInfo const   * , unsigned long  ,
                                     unsigned long  ) ;
#line 504
extern MagickBooleanType ResetImagePage(Image * , char const   * ) ;
#line 504
extern MagickBooleanType SeparateImageChannel(Image * , ChannelType  ) ;
#line 504
extern MagickBooleanType SetImageAlphaChannel(Image * , AlphaChannelType  ) ;
#line 504
extern MagickBooleanType SetImageBackgroundColor(Image * ) ;
#line 504
extern MagickBooleanType SetImageClipMask(Image * , Image const   * ) ;
#line 504
extern MagickBooleanType SetImageExtent(Image * , unsigned long  , unsigned long  ) ;
#line 504
extern MagickBooleanType SetImageInfo(ImageInfo * , MagickBooleanType  , ExceptionInfo * ) ;
#line 504
extern MagickBooleanType SetImageMask(Image * , Image const   * ) ;
#line 504
extern MagickBooleanType SetImageOpacity(Image * , Quantum  ) ;
#line 504
extern MagickBooleanType SetImageStorageClass(Image * , ClassType  ) ;
#line 504
extern MagickBooleanType SetImageType(Image * , ImageType  ) ;
#line 504
extern MagickBooleanType SortColormapByIntensity(Image * ) ;
#line 504
extern MagickBooleanType StripImage(Image * ) ;
#line 504
extern MagickBooleanType SyncImage(Image * ) ;
#line 504
extern MagickBooleanType SyncImageSettings(ImageInfo const   * , Image * ) ;
#line 504
extern MagickBooleanType SyncImagesSettings(ImageInfo * , Image * ) ;
#line 504
extern MagickBooleanType TextureImage(Image * , Image const   * ) ;
#line 535
extern size_t InterpretImageFilename(ImageInfo const   * , Image * , char const   * ,
                                     int  , char * ) ;
#line 538
extern VirtualPixelMethod GetImageVirtualPixelMethod(Image const   * ) ;
#line 538
extern VirtualPixelMethod SetImageVirtualPixelMethod(Image const   * , VirtualPixelMethod  ) ;
#line 542
extern void AcquireNextImage(ImageInfo const   * , Image * ) ;
#line 542
extern void DestroyImagePixels(Image * ) ;
#line 542
extern void DisassociateImageStream(Image * ) ;
#line 542
extern void GetImageException(Image * , ExceptionInfo * ) ;
#line 542
extern void GetImageInfo(ImageInfo * ) ;
#line 542
extern void SetImageInfoBlob(ImageInfo * , void const   * , size_t  ) ;
#line 542
extern void SetImageInfoFile(ImageInfo * , FILE * ) ;
#line 87 "./magick/type.h"
extern char **GetTypeList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 90
extern MagickBooleanType ListTypeInfo(FILE * , ExceptionInfo * ) ;
#line 93
extern TypeInfo const   *GetTypeInfo(char const   * , ExceptionInfo * ) ;
#line 93
extern TypeInfo const   *GetTypeInfoByFamily(char const   * , StyleType  , StretchType  ,
                                             unsigned long  , ExceptionInfo * ) ;
#line 93
extern TypeInfo const   **GetTypeInfoList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 99
extern void DestroyTypeList(void) ;
#line 363 "./magick/draw.h"
extern DrawInfo *AcquireDrawInfo(void) ;
#line 363
extern DrawInfo *CloneDrawInfo(ImageInfo const   * , DrawInfo const   * ) ;
#line 363
extern DrawInfo *DestroyDrawInfo(DrawInfo * ) ;
#line 368
extern MagickBooleanType DrawAffineImage(Image * , Image const   * , AffineMatrix const   * ) ;
#line 368
extern MagickBooleanType DrawClipPath(Image * , DrawInfo const   * , char const   * ) ;
#line 368
extern MagickBooleanType DrawGradientImage(Image * , DrawInfo const   * ) ;
#line 368
extern MagickBooleanType DrawImage(Image * , DrawInfo const   * ) ;
#line 368
extern MagickBooleanType DrawPatternPath(Image * , DrawInfo const   * , char const   * ,
                                         Image ** ) ;
#line 368
extern MagickBooleanType DrawPrimitive(Image * , DrawInfo const   * , PrimitiveInfo const   * ) ;
#line 376
extern void GetAffineMatrix(AffineMatrix * ) ;
#line 376
extern void GetDrawInfo(ImageInfo const   * , DrawInfo * ) ;
#line 27 "./magick/annotate.h"
extern long FormatMagickCaption(Image * , DrawInfo * , char * , TypeMetric * ) ;
#line 30
extern MagickBooleanType AnnotateImage(Image * , DrawInfo const   * ) ;
#line 30
extern MagickBooleanType GetMultilineTypeMetrics(Image * , DrawInfo const   * , TypeMetric * ) ;
#line 30
extern MagickBooleanType GetTypeMetrics(Image * , DrawInfo const   * , TypeMetric * ) ;
#line 25 "./magick/artifact.h"
extern char *GetNextImageArtifact(Image const   * ) ;
#line 25
extern char *RemoveImageArtifact(Image * , char const   * ) ;
#line 29
extern char const   *GetImageArtifact(Image const   * , char const   * ) ;
#line 32
extern MagickBooleanType CloneImageArtifacts(Image * , Image const   * ) ;
#line 32
extern MagickBooleanType DefineImageArtifact(Image * , char const   * ) ;
#line 32
extern MagickBooleanType DeleteImageArtifact(Image * , char const   * ) ;
#line 32
extern MagickBooleanType SetImageArtifact(Image * , char const   * , char const   * ) ;
#line 38
extern void DestroyImageArtifacts(Image * ) ;
#line 38
extern void ResetImageArtifactIterator(Image const   * ) ;
#line 27 "./magick/cache.h"
extern IndexPacket const   *GetVirtualIndexQueue(Image const   * ) ;
#line 30
extern PixelPacket const   *GetVirtualPixels(Image const   * , long  , long  , unsigned long  ,
                                             unsigned long  , ExceptionInfo * ) ;
#line 30
extern PixelPacket const   *GetVirtualPixelQueue(Image const   * ) ;
#line 35
extern IndexPacket *GetAuthenticIndexQueue(Image const   * ) ;
#line 38
extern long GetPixelCacheThreadId(void) ;
#line 41
extern MagickBooleanType GetOneVirtualMagickPixel(Image const   * , long  , long  ,
                                                  MagickPixelPacket * , ExceptionInfo * ) ;
#line 41
extern MagickBooleanType GetOneVirtualPixel(Image const   * , long  , long  , PixelPacket * ,
                                            ExceptionInfo * ) ;
#line 41
extern MagickBooleanType GetOneVirtualMethodPixel(Image const   * , VirtualPixelMethod  ,
                                                  long  , long  , PixelPacket * ,
                                                  ExceptionInfo * ) ;
#line 41
extern MagickBooleanType GetOneAuthenticPixel(Image * , long  , long  , PixelPacket * ,
                                              ExceptionInfo * ) ;
#line 41
extern MagickBooleanType PersistPixelCache(Image * , char const   * , MagickBooleanType  ,
                                           MagickOffsetType * , ExceptionInfo * ) ;
#line 41
extern MagickBooleanType SyncAuthenticPixels(Image * , ExceptionInfo * ) ;
#line 54
extern MagickSizeType GetImageExtent(Image const   * ) ;
#line 57
extern PixelPacket *GetAuthenticPixels(Image * , long  , long  , unsigned long  ,
                                       unsigned long  , ExceptionInfo * ) ;
#line 57
extern PixelPacket *GetAuthenticPixelQueue(Image const   * ) ;
#line 57
extern PixelPacket *QueueAuthenticPixels(Image * , long  , long  , unsigned long  ,
                                         unsigned long  , ExceptionInfo * ) ;
#line 64
extern unsigned long GetPixelCacheMaximumThreads(void) ;
#line 67
extern VirtualPixelMethod GetPixelCacheVirtualMethod(Image const   * ) ;
#line 67
extern VirtualPixelMethod SetPixelCacheVirtualMethod(Image const   * , VirtualPixelMethod  ) ;
#line 71
extern void DestroyPixelCacheResources(void) ;
#line 71
extern void SetPixelCacheMaximumThreads(unsigned long  ) ;
#line 61 "./magick/log.h"
extern char **GetLogList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 64
extern char const   *GetLogName(void) ;
#line 64
extern char const   *SetLogName(char const   * ) ;
#line 68
extern LogInfo const   **GetLogInfoList(char const   * , unsigned long * , ExceptionInfo * ) ;
#line 71
extern LogEventType SetLogEventMask(char const   * ) ;
#line 74
extern MagickBooleanType IsEventLogging(void) ;
#line 74
extern MagickBooleanType ListLogInfo(FILE * , ExceptionInfo * ) ;
#line 74
extern MagickBooleanType ( /* format attribute */  LogMagickEvent)(LogEventType  ,
                                                                   char const   * ,
                                                                   char const   * ,
                                                                   unsigned long  ,
                                                                   char const   * 
                                                                   , ...) ;
#line 74
extern MagickBooleanType ( /* format attribute */  LogMagickEventList)(LogEventType  ,
                                                                       char const   * ,
                                                                       char const   * ,
                                                                       unsigned long  ,
                                                                       char const   * ,
                                                                       va_list  ) ;
#line 84
extern void CloseMagickLog(void) ;
#line 84
extern void DestroyLogList(void) ;
#line 84
extern void SetLogFormat(char const   * ) ;
#line 29 "./magick/color-private.h"
__inline static MagickBooleanType IsColorEqual(PixelPacket const   *p , PixelPacket const   *q ) 
{ 

  {
#line 32
  if ((int const   )p->red == (int const   )q->red) {
#line 32
    if ((int const   )p->green == (int const   )q->green) {
#line 32
      if ((int const   )p->blue == (int const   )q->blue) {
#line 33
        return (1);
      }
    }
  }
#line 34
  return (0);
}
}
#line 37 "./magick/color-private.h"
__inline static IndexPacket ConstrainColormapIndex(Image *image , unsigned long index___0 ) 
{ 

  {
#line 40
  if (index___0 < image->colors) {
#line 41
    return ((unsigned short )index___0);
  }
  {
#line 42
  ThrowMagickException(& image->exception, "./magick/color-private.h", "ConstrainColormapIndex",
                       42UL, 425, "InvalidColormapIndex", "`%s\'", image->filename);
  }
#line 44
  return ((unsigned short)0);
}
}
#line 47 "./magick/color-private.h"
__inline static MagickBooleanType IsGray(PixelPacket const   *pixel ) 
{ 

  {
#line 49
  if ((int const   )pixel->red == (int const   )pixel->green) {
#line 49
    if ((int const   )pixel->green == (int const   )pixel->blue) {
#line 50
      return (1);
    }
  }
#line 51
  return (0);
}
}
#line 54 "./magick/color-private.h"
__inline static MagickBooleanType IsMagickColorEqual(MagickPixelPacket const   *p ,
                                                     MagickPixelPacket const   *q ) 
{ 

  {
#line 57
  if ((int const   )p->matte != 0) {
#line 57
    if ((int const   )q->matte == 0) {
#line 57
      if (p->opacity != (MagickRealType const   )(unsigned short)0) {
#line 59
        return (0);
      }
    }
  }
#line 60
  if ((int const   )q->matte != 0) {
#line 60
    if ((int const   )p->matte == 0) {
#line 60
      if (q->opacity != (MagickRealType const   )(unsigned short)0) {
#line 62
        return (0);
      }
    }
  }
#line 63
  if ((int const   )p->matte != 0) {
#line 63
    if ((int const   )q->matte != 0) {
#line 65
      if (p->opacity != q->opacity) {
#line 66
        return (0);
      }
#line 67
      if (p->opacity == (MagickRealType const   )(unsigned short)65535) {
#line 68
        return (1);
      }
    }
  }
#line 70
  if (p->red != q->red) {
#line 71
    return (0);
  }
#line 72
  if (p->green != q->green) {
#line 73
    return (0);
  }
#line 74
  if (p->blue != q->blue) {
#line 75
    return (0);
  }
#line 76
  if ((int const   )p->colorspace == 12) {
#line 76
    if (p->index != q->index) {
#line 77
      return (0);
    }
  }
#line 78
  return (1);
}
}
#line 81 "./magick/color-private.h"
__inline static MagickBooleanType IsMagickGray(MagickPixelPacket const   *pixel ) 
{ 

  {
#line 83
  if ((int const   )pixel->colorspace != 1) {
#line 84
    return (0);
  }
#line 85
  if (pixel->red == pixel->green) {
#line 85
    if (pixel->green == pixel->blue) {
#line 86
      return (1);
    }
  }
#line 87
  return (0);
}
}
#line 90 "./magick/color-private.h"
__inline static MagickRealType MagickPixelIntensity(MagickPixelPacket const   *pixel ) 
{ MagickRealType intensity ;

  {
#line 96
  intensity = (0.299 * (double )pixel->red + 0.587 * (double )pixel->green) + 0.114 * (double )pixel->blue;
#line 97
  return (intensity);
}
}
#line 100 "./magick/color-private.h"
__inline static Quantum MagickPixelIntensityToQuantum(MagickPixelPacket const   *pixel ) 
{ 

  {
#line 104
  return ((unsigned short )(((0.299 * (double )pixel->red + 0.587 * (double )pixel->green) + 0.114 * (double )pixel->blue) + 0.5));
}
}
#line 110 "./magick/color-private.h"
__inline static MagickRealType MagickPixelLuminance(MagickPixelPacket const   *pixel ) 
{ MagickRealType luminance ;

  {
#line 116
  luminance = (0.21267 * (double )pixel->red + 0.71516 * (double )pixel->green) + 0.07217 * (double )pixel->blue;
#line 117
  return (luminance);
}
}
#line 120 "./magick/color-private.h"
__inline static MagickRealType PixelIntensity(PixelPacket const   *pixel ) 
{ MagickRealType intensity ;

  {
#line 125
  if ((int const   )pixel->red == (int const   )pixel->green) {
#line 125
    if ((int const   )pixel->green == (int const   )pixel->blue) {
#line 126
      return ((double )pixel->red);
    }
  }
#line 127
  intensity = (0.299 * (double )pixel->red + 0.587 * (double )pixel->green) + 0.114 * (double )pixel->blue;
#line 129
  return (intensity);
}
}
#line 132 "./magick/color-private.h"
__inline static Quantum PixelIntensityToQuantum(PixelPacket const   *pixel ) 
{ 

  {
#line 135
  if ((int const   )pixel->red == (int const   )pixel->green) {
#line 135
    if ((int const   )pixel->green == (int const   )pixel->blue) {
#line 136
      return ((unsigned short )pixel->red);
    }
  }
#line 138
  return ((unsigned short )(((306U * (unsigned int )pixel->red + 601U * (unsigned int )pixel->green) + 117U * (unsigned int )pixel->blue) >> 10U));
}
}
#line 38 "./magick/decorate.h"
extern Image *BorderImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 38
extern Image *FrameImage(Image const   * , FrameInfo const   * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType RaiseImage(Image * , RectangleInfo const   * , MagickBooleanType  ) ;
#line 25 "./magick/enhance.h"
extern MagickBooleanType ClutImage(Image * , Image const   * ) ;
#line 25
extern MagickBooleanType ClutImageChannel(Image * , ChannelType  , Image const   * ) ;
#line 25
extern MagickBooleanType ContrastImage(Image * , MagickBooleanType  ) ;
#line 25
extern MagickBooleanType ContrastStretchImage(Image * , char const   * ) ;
#line 25
extern MagickBooleanType ContrastStretchImageChannel(Image * , ChannelType  , double  ,
                                                     double  ) ;
#line 25
extern MagickBooleanType EqualizeImage(Image *image ) ;
#line 25
extern MagickBooleanType EqualizeImageChannel(Image *image , ChannelType  ) ;
#line 25
extern MagickBooleanType GammaImage(Image * , char const   * ) ;
#line 25
extern MagickBooleanType GammaImageChannel(Image * , ChannelType  , double  ) ;
#line 25
extern MagickBooleanType LevelImage(Image * , char const   * ) ;
#line 25
extern MagickBooleanType LevelImageChannel(Image * , ChannelType  , double  , double  ,
                                           double  ) ;
#line 25
extern MagickBooleanType LevelizeImageChannel(Image * , ChannelType  , double  , double  ,
                                              double  ) ;
#line 25
extern MagickBooleanType LevelImageColors(Image * , ChannelType  , MagickPixelPacket const   * ,
                                          MagickPixelPacket const   * , MagickBooleanType  ) ;
#line 25
extern MagickBooleanType LinearStretchImage(Image * , double  , double  ) ;
#line 25
extern MagickBooleanType ModulateImage(Image * , char const   * ) ;
#line 25
extern MagickBooleanType NegateImage(Image * , MagickBooleanType  ) ;
#line 25
extern MagickBooleanType NegateImageChannel(Image * , ChannelType  , MagickBooleanType  ) ;
#line 25
extern MagickBooleanType NormalizeImage(Image * ) ;
#line 25
extern MagickBooleanType NormalizeImageChannel(Image * , ChannelType  ) ;
#line 25
extern MagickBooleanType SigmoidalContrastImage(Image * , MagickBooleanType  , char const   * ) ;
#line 25
extern MagickBooleanType SigmoidalContrastImageChannel(Image * , ChannelType  , MagickBooleanType  ,
                                                       double  , double  ) ;
#line 53
extern Image *EnhanceImage(Image const   * , ExceptionInfo * ) ;
#line 79 "./magick/fx.h"
Image *AddNoiseImage(Image const   *image , NoiseType noise_type , ExceptionInfo *exception ) ;
#line 79
Image *AddNoiseImageChannel(Image const   *image , ChannelType channel , NoiseType noise_type ,
                            ExceptionInfo *exception ) ;
#line 79
Image *CharcoalImage(Image const   *image , double radius , double sigma , ExceptionInfo *exception ) ;
#line 79
Image *ColorizeImage(Image const   *image , char const   *opacity , PixelPacket colorize ,
                     ExceptionInfo *exception ) ;
#line 79
Image *ConvolveImage(Image const   *image , unsigned long order , double const   *kernel ,
                     ExceptionInfo *exception ) ;
#line 79
Image *ConvolveImageChannel(Image const   *image , ChannelType channel , unsigned long order ,
                            double const   *kernel , ExceptionInfo *exception ) ;
#line 79
Image *FxImage(Image const   *image , char const   *expression , ExceptionInfo *exception ) ;
#line 79
Image *FxImageChannel(Image const   *image , ChannelType channel , char const   *expression ,
                      ExceptionInfo *exception ) ;
#line 79
Image *ImplodeImage(Image const   *image , double amount , ExceptionInfo *exception ) ;
#line 79
Image *MorphImages(Image const   *image , unsigned long number_frames , ExceptionInfo *exception ) ;
#line 79
Image *PolaroidImage(Image const   *image , DrawInfo const   *draw_info , double angle ,
                     ExceptionInfo *exception ) ;
#line 79
Image *RecolorImage(Image const   *image , unsigned long order , double const   *color_matrix ,
                    ExceptionInfo *exception ) ;
#line 79
Image *SepiaToneImage(Image const   *image , double threshold , ExceptionInfo *exception ) ;
#line 79
Image *ShadowImage(Image const   *image , double opacity , double sigma , long x_offset ,
                   long y_offset , ExceptionInfo *exception ) ;
#line 79
Image *SketchImage(Image const   *image , double radius , double sigma , double angle ,
                   ExceptionInfo *exception ) ;
#line 79
Image *SteganoImage(Image const   *image , Image const   *watermark , ExceptionInfo *exception ) ;
#line 79
Image *StereoImage(Image const   *left_image , Image const   *right_image , ExceptionInfo *exception ) ;
#line 79
Image *StereoAnaglyphImage(Image const   *left_image , Image const   *right_image ,
                           long x_offset , long y_offset , ExceptionInfo *exception ) ;
#line 79
Image *SwirlImage(Image const   *image , double degrees , ExceptionInfo *exception ) ;
#line 79
Image *TintImage(Image const   *image , char const   *opacity , PixelPacket tint ,
                 ExceptionInfo *exception ) ;
#line 79
Image *VignetteImage(Image const   *image , double radius , double sigma , long x ,
                     long y , ExceptionInfo *exception ) ;
#line 79
Image *WaveImage(Image const   *image , double amplitude , double wave_length , ExceptionInfo *exception ) ;
#line 111
MagickBooleanType EvaluateImage(Image *image , MagickEvaluateOperator op , double value ,
                                ExceptionInfo *exception ) ;
#line 111
MagickBooleanType EvaluateImageChannel(Image *image , ChannelType channel , MagickEvaluateOperator op ,
                                       double value , ExceptionInfo *exception ) ;
#line 111
MagickBooleanType FunctionImage(Image *image , MagickFunction function , unsigned long number_parameters ,
                                double const   *parameters , ExceptionInfo *exception ) ;
#line 111
MagickBooleanType FunctionImageChannel(Image *image , ChannelType channel , MagickFunction function ,
                                       unsigned long number_parameters , double const   *parameters ,
                                       ExceptionInfo *exception ) ;
#line 111
MagickBooleanType SolarizeImage(Image *image , double threshold ) ;
#line 28 "./magick/fx-private.h"
FxInfo *AcquireFxInfo(Image const   *image , char const   *expression ) ;
#line 28
FxInfo *DestroyFxInfo(FxInfo *fx_info ) ;
#line 32
MagickBooleanType FxEvaluateExpression(FxInfo *fx_info , MagickRealType *alpha , ExceptionInfo *exception ) ;
#line 32
MagickBooleanType FxEvaluateChannelExpression(FxInfo *fx_info , ChannelType channel ,
                                              long x , long y , MagickRealType *alpha ,
                                              ExceptionInfo *exception ) ;
#line 25 "./magick/gem.h"
extern double ExpandAffine(AffineMatrix const   * ) ;
#line 28
extern unsigned long GetOptimalKernelWidth(double  , double  ) ;
#line 28
extern unsigned long GetOptimalKernelWidth1D(double  , double  ) ;
#line 28
extern unsigned long GetOptimalKernelWidth2D(double  , double  ) ;
#line 33
extern void ConvertHSBToRGB(double  , double  , double  , Quantum * , Quantum * ,
                            Quantum * ) ;
#line 33
extern void ConvertHSLToRGB(double  , double  , double  , Quantum * , Quantum * ,
                            Quantum * ) ;
#line 33
extern void ConvertHWBToRGB(double  , double  , double  , Quantum * , Quantum * ,
                            Quantum * ) ;
#line 33
extern void ConvertRGBToHSB(Quantum  , Quantum  , Quantum  , double * , double * ,
                            double * ) ;
#line 33
extern void ConvertRGBToHSL(Quantum  , Quantum  , Quantum  , double * , double * ,
                            double * ) ;
#line 33
extern void ConvertRGBToHWB(Quantum  , Quantum  , Quantum  , double * , double * ,
                            double * ) ;
#line 25 "./magick/list.h"
extern Image *CloneImageList(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *CloneImages(Image const   * , char const   * , ExceptionInfo * ) ;
#line 25
extern Image *DestroyImageList(Image * ) ;
#line 25
extern Image *GetFirstImageInList(Image const   * ) ;
#line 25
extern Image *GetImageFromList(Image const   * , long  ) ;
#line 25
extern Image *GetLastImageInList(Image const   * ) ;
#line 25
extern Image *GetNextImageInList(Image const   * ) ;
#line 25
extern Image *GetPreviousImageInList(Image const   * ) ;
#line 25
extern Image **ImageListToArray(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *NewImageList(void) ;
#line 25
extern Image *RemoveImageFromList(Image ** ) ;
#line 25
extern Image *RemoveLastImageFromList(Image ** ) ;
#line 25
extern Image *RemoveFirstImageFromList(Image ** ) ;
#line 25
extern Image *SpliceImageIntoList(Image ** , unsigned long  , Image const   * ) ;
#line 25
extern Image *SplitImageList(Image * ) ;
#line 25
extern Image *SyncNextImageInList(Image const   * ) ;
#line 43
extern long GetImageIndexInList(Image const   * ) ;
#line 46
extern unsigned long GetImageListLength(Image const   * ) ;
#line 49
extern void AppendImageToList(Image ** , Image const   * ) ;
#line 49
extern void DeleteImageFromList(Image ** ) ;
#line 49
extern void DeleteImages(Image ** , char const   * , ExceptionInfo * ) ;
#line 49
extern void InsertImageInList(Image ** , Image * ) ;
#line 49
extern void PrependImageToList(Image ** , Image * ) ;
#line 49
extern void ReplaceImageInList(Image ** , Image * ) ;
#line 49
extern void ReverseImageList(Image ** ) ;
#line 49
extern void SyncImageList(Image * ) ;
#line 34 "./magick/image-private.h"
extern char const   *BackgroundColor ;
#line 34
extern char const   *BorderColor ;
#line 34
extern char const   *DefaultTileFrame ;
#line 34
extern char const   *DefaultTileGeometry ;
#line 34
extern char const   *DefaultTileLabel ;
#line 34
extern char const   *ForegroundColor ;
#line 34
extern char const   *MatteColor ;
#line 34
extern char const   *LoadImageTag ;
#line 34
extern char const   *LoadImagesTag ;
#line 34
extern char const   *PSDensityGeometry ;
#line 34
extern char const   *PSPageGeometry ;
#line 34
extern char const   *SaveImageTag ;
#line 34
extern char const   *SaveImagesTag ;
#line 49
extern double const   DefaultResolution ;
#line 52 "./magick/image-private.h"
__inline static double DegreesToRadians(double degrees ) 
{ 

  {
#line 54
  return ((3.14159265358979323846264338327950288419716939937510 * degrees) / 180.0);
}
}
#line 57 "./magick/image-private.h"
__inline static MagickRealType RadiansToDegrees(MagickRealType radians ) 
{ 

  {
#line 59
  return ((180.0 * radians) / 3.14159265358979323846264338327950288419716939937510);
}
}
#line 62 "./magick/image-private.h"
__inline static unsigned char ScaleColor5to8(unsigned long color ) 
{ 

  {
#line 64
  return ((unsigned char )((color << 3) | (color >> 2)));
}
}
#line 67 "./magick/image-private.h"
__inline static unsigned char ScaleColor6to8(unsigned long color ) 
{ 

  {
#line 69
  return ((unsigned char )((color << 2) | (color >> 4)));
}
}
#line 72 "./magick/image-private.h"
__inline static unsigned long ScaleColor8to5(unsigned char color ) 
{ 

  {
#line 74
  return ((unsigned long )(((int )color & -8) >> 3));
}
}
#line 77 "./magick/image-private.h"
__inline static unsigned long ScaleColor8to6(unsigned char color ) 
{ 

  {
#line 79
  return ((unsigned long )(((int )color & -4) >> 2));
}
}
#line 30 "./magick/memory_.h"
extern void *AcquireMagickMemory(size_t  ) ;
#line 30
extern void *AcquireQuantumMemory(size_t  , size_t  ) ;
#line 30
extern void *CopyMagickMemory(void * , void const   * , size_t  ) ;
#line 30
extern void DestroyMagickMemory(void) ;
#line 30
extern void GetMagickMemoryMethods(AcquireMemoryHandler * , ResizeMemoryHandler * ,
                                   DestroyMemoryHandler * ) ;
#line 30
extern void *RelinquishMagickMemory(void * ) ;
#line 30
extern void *ResetMagickMemory(void * , int  , size_t  ) ;
#line 30
extern void *ResizeMagickMemory(void * , size_t  ) ;
#line 30
extern void *ResizeQuantumMemory(void * , size_t  , size_t  ) ;
#line 30
extern void SetMagickMemoryMethods(void *(*)(size_t  ) , void *(*)(void * , size_t  ) ,
                                   void (*)(void * ) ) ;
#line 27 "./magick/monitor-private.h"
__inline static MagickBooleanType SetImageProgress(Image const   *image , char const   *tag ,
                                                   MagickOffsetType offset , MagickSizeType extent ) 
{ char message[4096] ;
  MagickBooleanType tmp ;
  MagickBooleanType tmp___0 ;

  {
#line 33
  if ((unsigned long )image->progress_monitor == (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                         MagickOffsetType  ,
                                                                                         MagickSizeType  ,
                                                                                         void * ))((void *)0))) {
#line 34
    return (1);
  }
  {
#line 35
  tmp = QuantumTick(offset, extent);
  }
#line 35
  if ((int )tmp == 0) {
#line 36
    return (1);
  }
  {
#line 37
  FormatMagickString(message, 4096UL, "%s/%s", tag, image->filename);
#line 38
  tmp___0 = (*(image->progress_monitor))((char const   *)(message), offset, extent,
                                         (void *)image->client_data);
  }
#line 38
  return (tmp___0);
}
}
#line 105 "./magick/option.h"
extern char **GetMagickOptions(MagickOption  ) ;
#line 105
extern char *GetNextImageOption(ImageInfo const   * ) ;
#line 105
extern char *RemoveImageOption(ImageInfo * , char const   * ) ;
#line 110
extern char const   *GetImageOption(ImageInfo const   * , char const   * ) ;
#line 110
extern char const   *MagickOptionToMnemonic(MagickOption  , long  ) ;
#line 114
extern long ParseChannelOption(char const   * ) ;
#line 114
extern long ParseMagickOption(MagickOption  , MagickBooleanType  , char const   * ) ;
#line 118
extern MagickBooleanType CloneImageOptions(ImageInfo * , ImageInfo const   * ) ;
#line 118
extern MagickBooleanType DefineImageOption(ImageInfo * , char const   * ) ;
#line 118
extern MagickBooleanType DeleteImageOption(ImageInfo * , char const   * ) ;
#line 118
extern MagickBooleanType IsMagickOption(char const   * ) ;
#line 118
extern MagickBooleanType ListMagickOptions(FILE * , MagickOption  , ExceptionInfo * ) ;
#line 118
extern MagickBooleanType SetImageOption(ImageInfo * , char const   * , char const   * ) ;
#line 126
extern void DestroyImageOptions(ImageInfo * ) ;
#line 126
extern void ResetImageOptionIterator(ImageInfo const   * ) ;
#line 85 "./magick/quantum-private.h"
__inline static MagickSizeType GetQuantumRange(unsigned long depth ) 
{ 

  {
#line 87
  return ((1ULL << (depth - 1UL)) + ((1ULL << (depth - 1UL)) - 1ULL));
}
}
#line 94
__inline static void InitializeQuantumState(QuantumInfo const   *quantum_info , EndianType endian ,
                                            QuantumState *quantum_state ) ;
#line 94 "./magick/quantum-private.h"
static unsigned long const   mask[32]  = 
#line 94
  {      (unsigned long const   )0UL,      (unsigned long const   )1UL,      (unsigned long const   )3UL,      (unsigned long const   )7UL, 
        (unsigned long const   )15UL,      (unsigned long const   )31UL,      (unsigned long const   )63UL,      (unsigned long const   )127UL, 
        (unsigned long const   )255UL,      (unsigned long const   )511UL,      (unsigned long const   )1023UL,      (unsigned long const   )2047UL, 
        (unsigned long const   )4095UL,      (unsigned long const   )8191UL,      (unsigned long const   )16383UL,      (unsigned long const   )32767UL, 
        (unsigned long const   )65535UL,      (unsigned long const   )131071UL,      (unsigned long const   )262143UL,      (unsigned long const   )524287UL, 
        (unsigned long const   )1048575UL,      (unsigned long const   )2097151UL,      (unsigned long const   )4194303UL,      (unsigned long const   )8388607UL, 
        (unsigned long const   )16777215UL,      (unsigned long const   )33554431UL,      (unsigned long const   )67108863UL,      (unsigned long const   )134217727UL, 
        (unsigned long const   )268435455UL,      (unsigned long const   )536870911UL,      (unsigned long const   )1073741823UL,      (unsigned long const   )2147483647UL};
#line 91 "./magick/quantum-private.h"
__inline static void InitializeQuantumState(QuantumInfo const   *quantum_info , EndianType endian ,
                                            QuantumState *quantum_state ) 
{ 

  {
  {
#line 105
  ResetMagickMemory((void *)quantum_state, 0, sizeof(& quantum_state));
#line 106
  quantum_state->endian = endian;
#line 107
  quantum_state->minimum = (double )quantum_info->minimum;
#line 108
  quantum_state->scale = (double )quantum_info->scale;
#line 109
  quantum_state->inverse_scale = 0.0;
  }
#line 110
  if (quantum_state->scale != 0.0) {
#line 111
    quantum_state->inverse_scale = 1.0 / quantum_state->scale;
  }
#line 112
  quantum_state->bits = 0UL;
#line 113
  quantum_state->mask = mask;
#line 114
  return;
}
}
#line 116 "./magick/quantum-private.h"
__inline static unsigned char *PopCharPixel(unsigned char pixel , unsigned char *pixels ) 
{ unsigned char *tmp ;

  {
#line 119
  tmp = pixels;
#line 119
  pixels ++;
#line 119
  *tmp = pixel;
#line 120
  return (pixels);
}
}
#line 123 "./magick/quantum-private.h"
__inline static unsigned char *PopLongPixel(EndianType endian , unsigned long pixel ,
                                            unsigned char *pixels ) 
{ register unsigned int quantum ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 129
  quantum = (unsigned int )pixel;
#line 130
  if ((int )endian != 1) {
#line 132
    tmp = pixels;
#line 132
    pixels ++;
#line 132
    *tmp = (unsigned char )(quantum >> 24);
#line 133
    tmp___0 = pixels;
#line 133
    pixels ++;
#line 133
    *tmp___0 = (unsigned char )(quantum >> 16);
#line 134
    tmp___1 = pixels;
#line 134
    pixels ++;
#line 134
    *tmp___1 = (unsigned char )(quantum >> 8);
#line 135
    tmp___2 = pixels;
#line 135
    pixels ++;
#line 135
    *tmp___2 = (unsigned char )quantum;
#line 136
    return (pixels);
  }
#line 138
  tmp___3 = pixels;
#line 138
  pixels ++;
#line 138
  *tmp___3 = (unsigned char )quantum;
#line 139
  tmp___4 = pixels;
#line 139
  pixels ++;
#line 139
  *tmp___4 = (unsigned char )(quantum >> 8);
#line 140
  tmp___5 = pixels;
#line 140
  pixels ++;
#line 140
  *tmp___5 = (unsigned char )(quantum >> 16);
#line 141
  tmp___6 = pixels;
#line 141
  pixels ++;
#line 141
  *tmp___6 = (unsigned char )(quantum >> 24);
#line 142
  return (pixels);
}
}
#line 145 "./magick/quantum-private.h"
__inline static unsigned char *PopShortPixel(EndianType endian , unsigned short pixel ,
                                             unsigned char *pixels ) 
{ register unsigned int quantum ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 151
  quantum = (unsigned int )pixel;
#line 152
  if ((int )endian != 1) {
#line 154
    tmp = pixels;
#line 154
    pixels ++;
#line 154
    *tmp = (unsigned char )(quantum >> 8);
#line 155
    tmp___0 = pixels;
#line 155
    pixels ++;
#line 155
    *tmp___0 = (unsigned char )quantum;
#line 156
    return (pixels);
  }
#line 158
  tmp___1 = pixels;
#line 158
  pixels ++;
#line 158
  *tmp___1 = (unsigned char )quantum;
#line 159
  tmp___2 = pixels;
#line 159
  pixels ++;
#line 159
  *tmp___2 = (unsigned char )(quantum >> 8);
#line 160
  return (pixels);
}
}
#line 163 "./magick/quantum-private.h"
__inline static unsigned char const   *PushCharPixel(unsigned char const   *pixels ,
                                                     unsigned char *pixel ) 
{ unsigned char const   *tmp ;

  {
#line 166
  tmp = pixels;
#line 166
  pixels ++;
#line 166
  *pixel = (unsigned char )*tmp;
#line 167
  return (pixels);
}
}
#line 170 "./magick/quantum-private.h"
__inline static unsigned char const   *PushLongPixel(EndianType endian , unsigned char const   *pixels ,
                                                     unsigned long *pixel ) 
{ register unsigned int quantum ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;

  {
#line 176
  if ((int )endian != 1) {
#line 178
    tmp = pixels;
#line 178
    pixels ++;
#line 178
    quantum = (unsigned int )((int const   )*tmp << 24);
#line 179
    tmp___0 = pixels;
#line 179
    pixels ++;
#line 179
    quantum |= (unsigned int )((int const   )*tmp___0 << 16);
#line 180
    tmp___1 = pixels;
#line 180
    pixels ++;
#line 180
    quantum |= (unsigned int )((int const   )*tmp___1 << 8);
#line 181
    tmp___2 = pixels;
#line 181
    pixels ++;
#line 181
    quantum |= (unsigned int )*tmp___2;
  } else {
#line 185
    tmp___3 = pixels;
#line 185
    pixels ++;
#line 185
    quantum = (unsigned int )*tmp___3;
#line 186
    tmp___4 = pixels;
#line 186
    pixels ++;
#line 186
    quantum |= (unsigned int )((int const   )*tmp___4 << 8);
#line 187
    tmp___5 = pixels;
#line 187
    pixels ++;
#line 187
    quantum |= (unsigned int )((int const   )*tmp___5 << 16);
#line 188
    tmp___6 = pixels;
#line 188
    pixels ++;
#line 188
    quantum |= (unsigned int )((int const   )*tmp___6 << 24);
  }
#line 190
  *pixel = (unsigned long )(quantum & 4294967295U);
#line 191
  return (pixels);
}
}
#line 194 "./magick/quantum-private.h"
__inline static unsigned char const   *PushShortPixel(EndianType endian , unsigned char const   *pixels ,
                                                      unsigned short *pixel ) 
{ register unsigned int quantum ;
  unsigned char const   *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;

  {
#line 200
  if ((int )endian != 1) {
#line 202
    tmp = pixels;
#line 202
    pixels ++;
#line 202
    quantum = (unsigned int )((int const   )*tmp << 8);
#line 203
    tmp___0 = pixels;
#line 203
    pixels ++;
#line 203
    quantum |= (unsigned int )*tmp___0;
  } else {
#line 207
    tmp___1 = pixels;
#line 207
    pixels ++;
#line 207
    quantum = (unsigned int )*tmp___1;
#line 208
    tmp___2 = pixels;
#line 208
    pixels ++;
#line 208
    quantum |= (unsigned int )((int const   )*tmp___2 << 8);
  }
#line 210
  *pixel = (unsigned short )(quantum & 65535U);
#line 211
  return (pixels);
}
}
#line 214 "./magick/quantum-private.h"
__inline static Quantum ScaleAnyToQuantum(QuantumAny quantum , QuantumAny range ) 
{ 

  {
#line 217
  return ((unsigned short )(((double )65535UL * (double )quantum) / (double )range + 0.5));
}
}
#line 220 "./magick/quantum-private.h"
__inline static QuantumAny ScaleQuantumToAny(Quantum quantum , QuantumAny range ) 
{ 

  {
#line 223
  return ((unsigned long long )(((double )range * (double )quantum) / (double )65535UL + 0.5));
}
}
#line 302 "./magick/quantum-private.h"
__inline static Quantum ScaleCharToQuantum(unsigned char value ) 
{ 

  {
#line 305
  return ((unsigned short )(257UL * (unsigned long )value));
}
}
#line 311 "./magick/quantum-private.h"
__inline static Quantum ScaleLongToQuantum(unsigned long value ) 
{ 

  {
#line 314
  return ((unsigned short )(((unsigned long long )value + 32768ULL) / 65537ULL));
}
}
#line 321 "./magick/quantum-private.h"
__inline static Quantum ScaleMapToQuantum(MagickRealType value ) 
{ 

  {
#line 326
  if (value <= 0.0) {
#line 327
    return ((unsigned short)0);
  }
#line 328
  if (value + 0.5 >= (MagickRealType )65535UL) {
#line 329
    return ((unsigned short)65535);
  }
#line 330
  return ((unsigned short )(value + 0.5));
}
}
#line 334 "./magick/quantum-private.h"
__inline static unsigned long ScaleQuantumToLong(Quantum quantum ) 
{ 

  {
#line 337
  return (65537UL * (unsigned long )quantum);
}
}
#line 347 "./magick/quantum-private.h"
__inline static unsigned long ScaleQuantumToMap(Quantum quantum ) 
{ 

  {
#line 349
  if ((int )quantum >= 65535) {
#line 350
    return (65535UL);
  }
#line 352
  return ((unsigned long )quantum);
}
}
#line 360 "./magick/quantum-private.h"
__inline static unsigned short ScaleQuantumToShort(Quantum quantum ) 
{ 

  {
#line 363
  return (quantum);
}
}
#line 373 "./magick/quantum-private.h"
__inline static Quantum ScaleShortToQuantum(unsigned short value ) 
{ 

  {
#line 375
  return (value);
}
}
#line 31 "./magick/pixel-private.h"
__inline static MagickPixelPacket *CloneMagickPixelPacket(MagickPixelPacket const   *pixel ) 
{ MagickPixelPacket *clone_pixel ;
  void *tmp ;
  ExceptionInfo exception ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 37
  tmp = AcquireMagickMemory(sizeof(*clone_pixel));
#line 37
  clone_pixel = (MagickPixelPacket *)tmp;
  }
#line 38
  if ((unsigned long )clone_pixel == (unsigned long )((MagickPixelPacket *)((void *)0))) {
    {
#line 39
    GetExceptionInfo(& exception);
#line 39
    tmp___0 = __errno_location();
#line 39
    tmp___1 = strerror(*tmp___0);
    }
#line 39
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 39
      tmp___2 = "unknown";
    } else {
#line 39
      tmp___2 = "MemoryAllocationFailed";
    }
    {
#line 39
    ThrowMagickException(& exception, "./magick/pixel-private.h", "CloneMagickPixelPacket",
                         39UL, 700, tmp___2, "`%s\'", tmp___1);
#line 39
    CatchException(& exception);
#line 39
    DestroyExceptionInfo(& exception);
#line 39
    _exit(1);
    }
  }
#line 40
  *clone_pixel = (struct _MagickPixelPacket )*pixel;
#line 41
  return (clone_pixel);
}
}
#line 44 "./magick/pixel-private.h"
__inline static MagickBooleanType IsGrayPixel(PixelPacket const   *pixel ) 
{ 

  {
#line 47
  if ((int const   )pixel->red == (int const   )pixel->green) {
#line 47
    if ((int const   )pixel->green == (int const   )pixel->blue) {
#line 48
      return (1);
    }
  }
#line 54
  return (0);
}
}
#line 57 "./magick/pixel-private.h"
__inline static MagickBooleanType IsMonochromePixel(PixelPacket const   *pixel ) 
{ 

  {
#line 60
  if ((int const   )pixel->red == 0) {
    goto _L;
  } else {
#line 60
    if ((int const   )pixel->red == 65535) {
      _L: /* CIL Label */ 
#line 60
      if ((int const   )pixel->red == (int const   )pixel->green) {
#line 60
        if ((int const   )pixel->green == (int const   )pixel->blue) {
#line 62
          return (1);
        }
      }
    }
  }
#line 70
  return (0);
}
}
#line 73 "./magick/pixel-private.h"
__inline static void SetMagickPixelPacket(Image const   *image , PixelPacket const   *color ,
                                          IndexPacket const   *index___0 , MagickPixelPacket *pixel ) 
{ 

  {
#line 76
  pixel->red = (double )color->red;
#line 77
  pixel->green = (double )color->green;
#line 78
  pixel->blue = (double )color->blue;
#line 79
  pixel->opacity = (double )color->opacity;
#line 80
  if ((int const   )image->colorspace == 12) {
    goto _L;
  } else {
#line 80
    if ((int const   )image->storage_class == 2) {
      _L: /* CIL Label */ 
#line 80
      if ((unsigned long )index___0 != (unsigned long )((IndexPacket const   *)((void *)0))) {
#line 83
        pixel->index = (double )*index___0;
      }
    }
  }
#line 84
  return;
}
}
#line 86 "./magick/pixel-private.h"
__inline static void SetPixelPacket(Image const   *image , MagickPixelPacket const   *pixel ,
                                    PixelPacket *color , IndexPacket *index___0 ) 
{ 

  {
  {
#line 89
  color->red = RoundToQuantum((double )pixel->red);
#line 90
  color->green = RoundToQuantum((double )pixel->green);
#line 91
  color->blue = RoundToQuantum((double )pixel->blue);
#line 92
  color->opacity = RoundToQuantum((double )pixel->opacity);
  }
#line 93
  if ((int const   )image->colorspace == 12) {
    goto _L;
  } else {
#line 93
    if ((int const   )image->storage_class == 2) {
      _L: /* CIL Label */ 
#line 93
      if ((unsigned long )index___0 != (unsigned long )((IndexPacket const   *)((void *)0))) {
        {
#line 96
        *index___0 = RoundToQuantum((double )pixel->index);
        }
      }
    }
  }
#line 97
  return;
}
}
#line 25 "./magick/property.h"
extern char *GetNextImageProperty(Image const   * ) ;
#line 25
extern char *InterpretImageProperties(ImageInfo const   * , Image * , char const   * ) ;
#line 25
extern char *RemoveImageProperty(Image * , char const   * ) ;
#line 30
extern char const   *GetImageProperty(Image const   * , char const   * ) ;
#line 30
extern char const   *GetMagickProperty(ImageInfo const   * , Image * , char const   * ) ;
#line 34
extern MagickBooleanType CloneImageProperties(Image * , Image const   * ) ;
#line 34
extern MagickBooleanType DefineImageProperty(Image * , char const   * ) ;
#line 34
extern MagickBooleanType DeleteImageProperty(Image * , char const   * ) ;
#line 34
extern MagickBooleanType ( /* format attribute */  FormatImageProperty)(Image * ,
                                                                        char const   * ,
                                                                        char const   * 
                                                                        , ...) ;
#line 34
extern MagickBooleanType ( /* format attribute */  FormatImagePropertyList)(Image * ,
                                                                            char const   * ,
                                                                            char const   * ,
                                                                            va_list  ) ;
#line 34
extern MagickBooleanType SetImageProperty(Image * , char const   * , char const   * ) ;
#line 44
extern void DestroyImageProperties(Image * ) ;
#line 44
extern void ResetImagePropertyIterator(Image const   * ) ;
#line 36 "./magick/random_.h"
extern double GetRandomValue(RandomInfo * ) ;
#line 36
extern double GetPseudoRandomValue(void) ;
#line 40
extern RandomInfo *AcquireRandomInfo(void) ;
#line 40
extern RandomInfo *DestroyRandomInfo(RandomInfo * ) ;
#line 44
extern StringInfo *GetRandomKey(RandomInfo * , size_t  ) ;
#line 47
extern void DestroyRandomReservoir(void) ;
#line 47
extern void SeedPseudoRandomGenerator(unsigned long  ) ;
#line 47
extern void SetRandomKey(RandomInfo * , size_t  , unsigned char * ) ;
#line 47
extern void SetRandomTrueRandom(MagickBooleanType  ) ;
#line 27 "./magick/resample-private.h"
__inline static ResampleFilter **DestroyResampleFilterThreadSet(ResampleFilter **filter ) 
{ register long i ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 33
  if (! ((unsigned long )filter != (unsigned long )((ResampleFilter **)((void *)0)))) {
    {
#line 33
    __assert_fail("filter != (ResampleFilter **) ((void *)0)", "./magick/resample-private.h",
                  33U, "DestroyResampleFilterThreadSet");
    }
  }
#line 34
  i = 0L;
#line 34
  while (1) {
    {
#line 34
    tmp = GetPixelCacheMaximumThreads();
    }
#line 34
    if (! (i < (long )tmp)) {
#line 34
      break;
    }
#line 35
    if ((unsigned long )*(filter + i) != (unsigned long )((ResampleFilter *)((void *)0))) {
      {
#line 36
      *(filter + i) = DestroyResampleFilter(*(filter + i));
      }
    }
#line 34
    i ++;
  }
  {
#line 37
  tmp___0 = RelinquishMagickMemory((void *)filter);
  }
#line 37
  return ((ResampleFilter **)tmp___0);
}
}
#line 40 "./magick/resample-private.h"
__inline static ResampleFilter **AcquireResampleFilterThreadSet(Image const   *image ,
                                                                MagickBooleanType interpolate ,
                                                                ExceptionInfo *exception ) 
{ register long i ;
  ResampleFilter **filter ;
  unsigned long number_threads ;
  void *tmp ;
  ResampleFilter **tmp___0 ;

  {
  {
#line 53
  number_threads = GetPixelCacheMaximumThreads();
#line 54
  tmp = AcquireQuantumMemory(number_threads, sizeof(*filter));
#line 54
  filter = (ResampleFilter **)tmp;
  }
#line 56
  if ((unsigned long )filter == (unsigned long )((ResampleFilter **)((void *)0))) {
#line 57
    return ((ResampleFilter **)((void *)0));
  }
  {
#line 58
  ResetMagickMemory((void *)filter, 0, number_threads * sizeof(*filter));
#line 59
  i = 0L;
  }
#line 59
  while (i < (long )number_threads) {
    {
#line 61
    *(filter + i) = AcquireResampleFilter(image, exception);
    }
#line 62
    if ((unsigned long )*(filter + i) == (unsigned long )((ResampleFilter *)((void *)0))) {
      {
#line 63
      tmp___0 = DestroyResampleFilterThreadSet(filter);
      }
#line 63
      return (tmp___0);
    }
#line 64
    if ((int )interpolate != 0) {
      {
#line 65
      SetResampleFilter(*(filter + i), 1, 1.0);
      }
    }
#line 59
    i ++;
  }
#line 67
  return (filter);
}
}
#line 25 "./magick/shear.h"
extern Image *AffineTransformImage(Image const   * , AffineMatrix const   * , ExceptionInfo * ) ;
#line 25
extern Image *DeskewImage(Image const   * , double  , ExceptionInfo * ) ;
#line 25
extern Image *RotateImage(Image const   * , double  , ExceptionInfo * ) ;
#line 25
extern Image *ShearImage(Image const   * , double  , double  , ExceptionInfo * ) ;
#line 28 "./magick/splay-tree.h"
extern MagickBooleanType AddValueToSplayTree(SplayTreeInfo * , void const   * , void const   * ) ;
#line 28
extern MagickBooleanType DeleteNodeByValueFromSplayTree(SplayTreeInfo * , void const   * ) ;
#line 28
extern MagickBooleanType DeleteNodeFromSplayTree(SplayTreeInfo * , void const   * ) ;
#line 33
extern int CompareSplayTreeString(void const   * , void const   * ) ;
#line 33
extern int CompareSplayTreeStringInfo(void const   * , void const   * ) ;
#line 37
extern SplayTreeInfo *CloneSplayTree(SplayTreeInfo * , void *(*)(void * ) , void *(*)(void * ) ) ;
#line 37
extern SplayTreeInfo *DestroySplayTree(SplayTreeInfo * ) ;
#line 37
extern SplayTreeInfo *NewSplayTree(int (*)(void const   * , void const   * ) , void *(*)(void * ) ,
                                   void *(*)(void * ) ) ;
#line 43
extern unsigned long GetNumberOfNodesInSplayTree(SplayTreeInfo const   * ) ;
#line 46
extern void *GetNextKeyInSplayTree(SplayTreeInfo * ) ;
#line 46
extern void *GetNextValueInSplayTree(SplayTreeInfo * ) ;
#line 46
extern void *GetValueFromSplayTree(SplayTreeInfo * , void const   * ) ;
#line 46
extern void *RemoveNodeByValueFromSplayTree(SplayTreeInfo * , void const   * ) ;
#line 46
extern void *RemoveNodeFromSplayTree(SplayTreeInfo * , void const   * ) ;
#line 46
extern void ResetSplayTreeIterator(SplayTreeInfo * ) ;
#line 39 "./magick/statistic.h"
extern ChannelStatistics *GetImageChannelStatistics(Image const   * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageChannelExtrema(Image const   * , ChannelType  , unsigned long * ,
                                                unsigned long * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageChannelMean(Image const   * , ChannelType  , double * ,
                                             double * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageChannelKurtosis(Image const   * , ChannelType  ,
                                                 double * , double * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageChannelRange(Image const   * , ChannelType  , double * ,
                                              double * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageExtrema(Image const   * , unsigned long * , unsigned long * ,
                                         ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageRange(Image const   * , double * , double * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageMean(Image const   * , double * , double * , ExceptionInfo * ) ;
#line 42
extern MagickBooleanType GetImageKurtosis(Image const   * , double * , double * ,
                                          ExceptionInfo * ) ;
#line 42
extern MagickBooleanType SetImageChannelDepth(Image * , ChannelType  , unsigned long  ) ;
#line 42
extern MagickBooleanType SetImageDepth(Image * , unsigned long  ) ;
#line 59
extern RectangleInfo GetImageBoundingBox(Image const   * , ExceptionInfo *exception ) ;
#line 62
extern unsigned long GetImageChannelDepth(Image const   * , ChannelType  , ExceptionInfo * ) ;
#line 62
extern unsigned long GetImageDepth(Image const   * , ExceptionInfo * ) ;
#line 62
extern unsigned long GetImageQuantumDepth(Image const   * , MagickBooleanType  ) ;
#line 25 "./magick/transform.h"
extern Image *ChopImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *ConsolidateCMYKImages(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *CropImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *ExcerptImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *ExtentImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *FlipImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *FlopImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *RollImage(Image const   * , long  , long  , ExceptionInfo * ) ;
#line 25
extern Image *ShaveImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *SpliceImage(Image const   * , RectangleInfo const   * , ExceptionInfo * ) ;
#line 25
extern Image *TransposeImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *TransverseImage(Image const   * , ExceptionInfo * ) ;
#line 25
extern Image *TrimImage(Image const   * , ExceptionInfo * ) ;
#line 40
extern MagickBooleanType TransformImage(Image ** , char const   * , char const   * ) ;
#line 40
extern MagickBooleanType TransformImages(Image ** , char const   * , char const   * ) ;
#line 38 "./magick/utility.h"
extern char *Base64Encode(unsigned char const   * , size_t  , size_t * ) ;
#line 38
extern char **GetPathComponents(char const   * , unsigned long * ) ;
#line 38
extern char **ListFiles(char const   * , char const   * , unsigned long * ) ;
#line 43
extern FILE *OpenMagickStream(char const   * , char const   * ) ;
#line 46
extern int SystemCommand(MagickBooleanType  , char const   * ) ;
#line 49
extern MagickBooleanType AcquireUniqueFilename(char * ) ;
#line 49
extern MagickBooleanType AcquireUniqueSymbolicLink(char const   * , char * ) ;
#line 49
extern MagickBooleanType ExpandFilenames(int * , char *** ) ;
#line 49
extern MagickBooleanType GetPathAttributes(char const   * , void * ) ;
#line 49
extern MagickBooleanType GetExecutionPath(char * , size_t  ) ;
#line 49
extern MagickBooleanType IsMagickTrue(char const   * ) ;
#line 49
extern MagickBooleanType IsPathAccessible(char const   * ) ;
#line 58
extern unsigned char *Base64Decode(char const   * , size_t * ) ;
#line 61
extern unsigned long MultilineCensus(char const   * ) ;
#line 64
extern void AppendImageFormat(char const   * , char * ) ;
#line 64
extern void ChopPathComponents(char * , unsigned long  ) ;
#line 64
extern void ExpandFilename(char * ) ;
#line 64
extern void GetPathComponent(char const   * , PathType  , char * ) ;
#line 137 "magick/fx.c"
FxInfo *AcquireFxInfo(Image const   *image , char const   *expression ) 
{ char fx_op[2] ;
  FxInfo *fx_info ;
  register long i ;
  void *tmp ;
  ExceptionInfo exception ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  unsigned long tmp___3 ;
  void *tmp___4 ;
  ExceptionInfo exception___0 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  Image *tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 148
  tmp = AcquireMagickMemory(sizeof(*fx_info));
#line 148
  fx_info = (FxInfo *)tmp;
  }
#line 149
  if ((unsigned long )fx_info == (unsigned long )((FxInfo *)((void *)0))) {
    {
#line 150
    GetExceptionInfo(& exception);
#line 150
    tmp___0 = __errno_location();
#line 150
    tmp___1 = strerror(*tmp___0);
    }
#line 150
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 150
      tmp___2 = "unknown";
    } else {
#line 150
      tmp___2 = "MemoryAllocationFailed";
    }
    {
#line 150
    ThrowMagickException(& exception, "magick/fx.c", "AcquireFxInfo", 150UL, 700,
                         tmp___2, "`%s\'", tmp___1);
#line 150
    CatchException(& exception);
#line 150
    DestroyExceptionInfo(& exception);
#line 150
    _exit(1);
    }
  }
  {
#line 151
  ResetMagickMemory((void *)fx_info, 0, sizeof(*fx_info));
#line 152
  fx_info->exception = AcquireExceptionInfo();
#line 153
  fx_info->images = image;
#line 154
  fx_info->matte = (enum __anonenum_MagickBooleanType_81 )image->matte;
#line 155
  fx_info->colors = NewSplayTree(& CompareSplayTreeString, & RelinquishMagickMemory,
                                 & RelinquishMagickMemory);
#line 157
  fx_info->symbols = NewSplayTree(& CompareSplayTreeString, & RelinquishMagickMemory,
                                  & RelinquishMagickMemory);
#line 159
  tmp___3 = GetImageListLength(fx_info->images);
#line 159
  tmp___4 = AcquireQuantumMemory(tmp___3, sizeof(*(fx_info->resample_filter)));
#line 159
  fx_info->resample_filter = (ResampleFilter **)tmp___4;
  }
#line 161
  if ((unsigned long )fx_info->resample_filter == (unsigned long )((ResampleFilter **)((void *)0))) {
    {
#line 162
    GetExceptionInfo(& exception___0);
#line 162
    tmp___5 = __errno_location();
#line 162
    tmp___6 = strerror(*tmp___5);
    }
#line 162
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 162
      tmp___7 = "unknown";
    } else {
#line 162
      tmp___7 = "MemoryAllocationFailed";
    }
    {
#line 162
    ThrowMagickException(& exception___0, "magick/fx.c", "AcquireFxInfo", 162UL, 700,
                         tmp___7, "`%s\'", tmp___6);
#line 162
    CatchException(& exception___0);
#line 162
    DestroyExceptionInfo(& exception___0);
#line 162
    _exit(1);
    }
  }
#line 163
  i = 0L;
#line 163
  while (1) {
    {
#line 163
    tmp___9 = GetImageListLength(fx_info->images);
    }
#line 163
    if (! (i < (long )tmp___9)) {
#line 163
      break;
    }
    {
#line 165
    tmp___8 = GetImageFromList(fx_info->images, i);
#line 165
    *(fx_info->resample_filter + i) = AcquireResampleFilter((Image const   *)tmp___8,
                                                            fx_info->exception);
#line 167
    SetResampleFilter(*(fx_info->resample_filter + i), 1, 1.0);
#line 163
    i ++;
    }
  }
  {
#line 169
  fx_info->expression = ConstantString(expression);
#line 170
  fx_info->file = stderr;
#line 171
  SubstituteString(& fx_info->expression, " ", "");
#line 172
  tmp___10 = strstr((char const   *)fx_info->expression, "e+");
  }
#line 172
  if ((unsigned long )tmp___10 != (unsigned long )((char *)((void *)0))) {
    goto _L;
  } else {
    {
#line 172
    tmp___11 = strstr((char const   *)fx_info->expression, "e-");
    }
#line 172
    if ((unsigned long )tmp___11 != (unsigned long )((char *)((void *)0))) {
      _L: /* CIL Label */ 
      {
#line 178
      SubstituteString(& fx_info->expression, "0e+", "0*10^");
#line 179
      SubstituteString(& fx_info->expression, "1e+", "1*10^");
#line 180
      SubstituteString(& fx_info->expression, "2e+", "2*10^");
#line 181
      SubstituteString(& fx_info->expression, "3e+", "3*10^");
#line 182
      SubstituteString(& fx_info->expression, "4e+", "4*10^");
#line 183
      SubstituteString(& fx_info->expression, "5e+", "5*10^");
#line 184
      SubstituteString(& fx_info->expression, "6e+", "6*10^");
#line 185
      SubstituteString(& fx_info->expression, "7e+", "7*10^");
#line 186
      SubstituteString(& fx_info->expression, "8e+", "8*10^");
#line 187
      SubstituteString(& fx_info->expression, "9e+", "9*10^");
#line 188
      SubstituteString(& fx_info->expression, "0e-", "0*10^-");
#line 189
      SubstituteString(& fx_info->expression, "1e-", "1*10^-");
#line 190
      SubstituteString(& fx_info->expression, "2e-", "2*10^-");
#line 191
      SubstituteString(& fx_info->expression, "3e-", "3*10^-");
#line 192
      SubstituteString(& fx_info->expression, "4e-", "4*10^-");
#line 193
      SubstituteString(& fx_info->expression, "5e-", "5*10^-");
#line 194
      SubstituteString(& fx_info->expression, "6e-", "6*10^-");
#line 195
      SubstituteString(& fx_info->expression, "7e-", "7*10^-");
#line 196
      SubstituteString(& fx_info->expression, "8e-", "8*10^-");
#line 197
      SubstituteString(& fx_info->expression, "9e-", "9*10^-");
      }
    }
  }
  {
#line 202
  fx_op[1] = (char )'\000';
#line 203
  fx_op[0] = (char)-11;
#line 204
  SubstituteString(& fx_info->expression, "<<", (char const   *)(fx_op));
#line 205
  fx_op[0] = (char)-10;
#line 206
  SubstituteString(& fx_info->expression, ">>", (char const   *)(fx_op));
#line 207
  fx_op[0] = (char)-9;
#line 208
  SubstituteString(& fx_info->expression, "<=", (char const   *)(fx_op));
#line 209
  fx_op[0] = (char)-8;
#line 210
  SubstituteString(& fx_info->expression, ">=", (char const   *)(fx_op));
#line 211
  fx_op[0] = (char)-7;
#line 212
  SubstituteString(& fx_info->expression, "==", (char const   *)(fx_op));
#line 213
  fx_op[0] = (char)-6;
#line 214
  SubstituteString(& fx_info->expression, "!=", (char const   *)(fx_op));
#line 215
  fx_op[0] = (char)-5;
#line 216
  SubstituteString(& fx_info->expression, "&&", (char const   *)(fx_op));
#line 217
  fx_op[0] = (char)-4;
#line 218
  SubstituteString(& fx_info->expression, "||", (char const   *)(fx_op));
  }
#line 219
  return (fx_info);
}
}
#line 255 "magick/fx.c"
static Quantum GenerateNoise(Quantum pixel , NoiseType noise_type , MagickRealType attenuate ) 
{ MagickRealType alpha ;
  MagickRealType beta ;
  MagickRealType noise ;
  MagickRealType sigma ;
  Quantum tmp ;
  MagickRealType tau ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  Quantum tmp___7 ;
  Quantum tmp___8 ;
  double tmp___9 ;
  Quantum tmp___10 ;
  double tmp___11 ;
  Quantum tmp___12 ;
  double tmp___13 ;
  Quantum tmp___14 ;
  Quantum tmp___15 ;
  double tmp___16 ;
  Quantum tmp___17 ;
  MagickRealType poisson ;
  register long i ;
  unsigned char tmp___18 ;
  Quantum tmp___19 ;
  double tmp___20 ;
  Quantum tmp___21 ;

  {
  {
#line 274
  alpha = GetPseudoRandomValue();
  }
#line 275
  if (alpha == 0.0) {
#line 276
    alpha = 1.0;
  }
#line 277
  switch ((int )noise_type) {
  case 1: 
  default: 
  {
#line 282
  tmp = ScaleCharToQuantum((unsigned char )(attenuate * 4.0 + 0.5));
#line 282
  noise = (double )pixel + (MagickRealType )tmp * (alpha - 0.5);
  }
#line 283
  break;
  case 2: 
  {
#line 290
  beta = GetPseudoRandomValue();
#line 291
  tmp___0 = log(alpha);
#line 291
  tmp___1 = sqrt(- 2.0 * tmp___0);
#line 291
  tmp___2 = cos((2.0 * 3.14159265358979323846264338327950288419716939937510) * beta);
#line 291
  sigma = tmp___1 * tmp___2;
#line 292
  tmp___3 = log(alpha);
#line 292
  tmp___4 = sqrt(- 2.0 * tmp___3);
#line 292
  tmp___5 = sin((2.0 * 3.14159265358979323846264338327950288419716939937510) * beta);
#line 292
  tau = tmp___4 * tmp___5;
#line 293
  tmp___6 = sqrt((double )pixel);
#line 293
  tmp___7 = ScaleCharToQuantum((unsigned char )(attenuate * 4.0 + 0.5));
#line 293
  tmp___8 = ScaleCharToQuantum((unsigned char )(attenuate * 20.0 + 0.5));
#line 293
  noise = ((double )pixel + (tmp___6 * (double )tmp___7) * sigma) + (MagickRealType )tmp___8 * tau;
  }
#line 295
  break;
  case 3: 
#line 299
  if (alpha <= attenuate * 1.0e-5) {
#line 300
    sigma = (double )65535UL;
  } else {
    {
#line 302
    tmp___9 = log(alpha);
#line 302
    sigma = sqrt(- 2.0 * tmp___9);
    }
  }
  {
#line 303
  beta = GetPseudoRandomValue();
#line 304
  tmp___10 = ScaleCharToQuantum((unsigned char )(attenuate * 1.0 + 0.5));
#line 304
  tmp___11 = cos((2.0 * 3.14159265358979323846264338327950288419716939937510) * beta);
#line 304
  noise = (double )pixel + (((MagickRealType )((int )pixel * (int )tmp___10) * sigma) / 2.0) * tmp___11;
  }
#line 306
  break;
  case 4: 
#line 310
  if (alpha < (attenuate * 0.10) / 2.0) {
#line 311
    noise = 0.0;
  } else {
#line 313
    if (alpha >= 1.0 - (attenuate * 0.10) / 2.0) {
#line 314
      noise = (double )65535UL;
    } else {
#line 316
      noise = (double )pixel;
    }
  }
#line 317
  break;
  case 5: 
#line 321
  if (alpha <= 0.5) {
#line 323
    if (alpha <= attenuate * 1.0e-5) {
#line 324
      noise = (double )pixel - (double )65535UL;
    } else {
      {
#line 326
      tmp___12 = ScaleCharToQuantum((unsigned char )(attenuate * 10.0 + 0.5));
#line 326
      tmp___13 = log(2.0 * alpha);
#line 326
      tmp___14 = ScaleCharToQuantum((unsigned char )((double )tmp___12 * tmp___13 + 0.5));
#line 326
      noise = (double )pixel + (double )tmp___14;
      }
    }
#line 328
    break;
  }
#line 330
  beta = 1.0 - alpha;
#line 331
  if (beta <= 0.5 * (attenuate * 1.0e-5)) {
#line 332
    noise = (double )((unsigned long )pixel + 65535UL);
  } else {
    {
#line 334
    tmp___15 = ScaleCharToQuantum((unsigned char )(attenuate * 10.0 + 0.5));
#line 334
    tmp___16 = log(2.0 * beta);
#line 334
    tmp___17 = ScaleCharToQuantum((unsigned char )((double )tmp___15 * tmp___16 + 0.5));
#line 334
    noise = (double )pixel - (double )tmp___17;
    }
  }
#line 336
  break;
  case 6: 
  {
#line 346
  tmp___18 = ScaleQuantumToChar(pixel);
#line 346
  poisson = exp(- (attenuate * 0.05) * (double )tmp___18);
#line 347
  i = 0L;
  }
#line 347
  while (alpha > poisson) {
    {
#line 349
    beta = GetPseudoRandomValue();
#line 350
    alpha *= beta;
#line 347
    i ++;
    }
  }
  {
#line 352
  tmp___19 = ScaleCharToQuantum((unsigned char )((MagickRealType )i / (attenuate * 0.05)));
#line 352
  noise = (double )tmp___19;
  }
#line 354
  break;
  case 7: 
  {
#line 358
  tmp___20 = GetPseudoRandomValue();
#line 358
  noise = (double )65535UL * tmp___20;
  }
#line 359
  break;
  }
  {
#line 362
  tmp___21 = RoundToQuantum(noise);
  }
#line 362
  return (tmp___21);
}
}
#line 365 "magick/fx.c"
Image *AddNoiseImage(Image const   *image , NoiseType noise_type , ExceptionInfo *exception ) 
{ Image *noise_image ;

  {
  {
#line 371
  noise_image = AddNoiseImageChannel(image, 55, noise_type, exception);
  }
#line 372
  return (noise_image);
}
}
#line 375 "magick/fx.c"
Image *AddNoiseImageChannel(Image const   *image , ChannelType channel , NoiseType noise_type ,
                            ExceptionInfo *exception ) 
{ char const   *option ;
  Image *noise_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickRealType attenuate ;
  ViewInfo *image_view ;
  ViewInfo *noise_view ;
  MagickBooleanType tmp ;
  register IndexPacket const   * __restrict  indexes ;
  register PixelPacket const   * __restrict  p ;
  register IndexPacket * __restrict  noise_indexes ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___0 ;
  PixelPacket *tmp___1 ;
  IndexPacket const   *tmp___2 ;
  IndexPacket *tmp___3 ;
  Quantum tmp___4 ;
  MagickBooleanType tmp___5 ;
  MagickBooleanType proceed ;
  long tmp___6 ;

  {
#line 403
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 403
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 403U, "AddNoiseImageChannel");
    }
  }
#line 404
  if (! (image->signature == 2880220587UL)) {
    {
#line 404
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 404U, "AddNoiseImageChannel");
    }
  }
#line 405
  if ((int const   )image->debug != 0) {
    {
#line 406
    LogMagickEvent(1, "magick/fx.c", "AddNoiseImageChannel", 406UL, "%s", image->filename);
    }
  }
#line 407
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 407
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 407U,
                  "AddNoiseImageChannel");
    }
  }
#line 408
  if (! (exception->signature == 2880220587UL)) {
    {
#line 408
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 408U, "AddNoiseImageChannel");
    }
  }
  {
#line 409
  noise_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 410
  if ((unsigned long )noise_image == (unsigned long )((Image *)((void *)0))) {
#line 411
    return ((Image *)((void *)0));
  }
  {
#line 412
  tmp = SetImageStorageClass(noise_image, 1);
  }
#line 412
  if ((int )tmp == 0) {
    {
#line 414
    InheritException(exception, (ExceptionInfo const   *)(& noise_image->exception));
#line 415
    noise_image = DestroyImage(noise_image);
    }
#line 416
    return ((Image *)((void *)0));
  }
  {
#line 421
  attenuate = 1.0;
#line 422
  option = GetImageArtifact(image, "attenuate");
  }
#line 423
  if ((unsigned long )option != (unsigned long )((char *)((void *)0))) {
    {
#line 424
    attenuate = atof(option);
    }
  }
  {
#line 425
  status = 1;
#line 426
  progress = 0L;
#line 427
  image_view = AcquireCacheView(image);
#line 428
  noise_view = AcquireCacheView((Image const   *)noise_image);
#line 429
  y = 0L;
  }
#line 429
  while (y < (long )image->rows) {
    {
#line 446
    tmp___0 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y, (unsigned long )image->columns,
                                        1UL, exception);
#line 446
    p = (PixelPacket const   */* __restrict  */)tmp___0;
#line 447
    tmp___1 = GetCacheViewAuthenticPixels(noise_view, 0L, y, noise_image->columns,
                                          1UL, exception);
#line 447
    q = (PixelPacket */* __restrict  */)tmp___1;
    }
#line 449
    if ((unsigned long )p == (unsigned long )((PixelPacket *)((void *)0))) {
#line 451
      status = 0;
#line 452
      break;
    } else {
#line 449
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 451
        status = 0;
#line 452
        break;
      }
    }
    {
#line 454
    tmp___2 = GetCacheViewVirtualIndexQueue((ViewInfo const   *)image_view);
#line 454
    indexes = (IndexPacket const   */* __restrict  */)tmp___2;
#line 455
    tmp___3 = GetCacheViewAuthenticIndexQueue(noise_view);
#line 455
    noise_indexes = (IndexPacket */* __restrict  */)tmp___3;
#line 456
    x = 0L;
    }
#line 456
    while (x < (long )image->columns) {
#line 458
      if (((int )channel & 1) != 0) {
        {
#line 459
        q->red = GenerateNoise((unsigned short )p->red, noise_type, attenuate);
        }
      }
#line 460
      if (((int )channel & 2) != 0) {
        {
#line 461
        q->green = GenerateNoise((unsigned short )p->green, noise_type, attenuate);
        }
      }
#line 462
      if (((int )channel & 4) != 0) {
        {
#line 463
        q->blue = GenerateNoise((unsigned short )p->blue, noise_type, attenuate);
        }
      }
#line 464
      if (((int )channel & 8) != 0) {
        {
#line 465
        q->opacity = GenerateNoise((unsigned short )p->opacity, noise_type, attenuate);
        }
      }
#line 466
      if (((int )channel & 32) != 0) {
#line 466
        if ((int const   )image->colorspace == 12) {
          {
#line 468
          tmp___4 = GenerateNoise((unsigned short )*(indexes + x), noise_type, attenuate);
#line 468
          *(noise_indexes + x) = tmp___4;
          }
        }
      }
#line 470
      p ++;
#line 471
      q ++;
#line 456
      x ++;
    }
    {
#line 473
    tmp___5 = SyncCacheViewAuthenticPixels(noise_view, exception);
    }
#line 473
    if ((int )tmp___5 == 0) {
#line 474
      status = 0;
    }
#line 475
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 480
      tmp___6 = progress;
#line 480
      progress ++;
#line 480
      proceed = SetImageProgress(image, "AddNoise/Image", (long long )tmp___6, (unsigned long long )image->rows);
      }
#line 482
      if ((int )proceed == 0) {
#line 483
        status = 0;
      }
    }
#line 485
    if ((int )status == 0) {
#line 486
      break;
    }
#line 429
    y ++;
  }
  {
#line 488
  noise_view = DestroyCacheView(noise_view);
#line 489
  image_view = DestroyCacheView(image_view);
  }
#line 490
  if ((int )status == 0) {
    {
#line 491
    noise_image = DestroyImage(noise_image);
    }
  }
#line 492
  return (noise_image);
}
}
#line 526 "magick/fx.c"
Image *CharcoalImage(Image const   *image , double radius , double sigma , ExceptionInfo *exception ) 
{ Image *charcoal_image ;
  Image *clone_image ;
  Image *edge_image ;

  {
#line 534
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 534
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 534U, "CharcoalImage");
    }
  }
#line 535
  if (! (image->signature == 2880220587UL)) {
    {
#line 535
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 535U, "CharcoalImage");
    }
  }
#line 536
  if ((int const   )image->debug != 0) {
    {
#line 537
    LogMagickEvent(1, "magick/fx.c", "CharcoalImage", 537UL, "%s", image->filename);
    }
  }
#line 538
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 538
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 538U,
                  "CharcoalImage");
    }
  }
#line 539
  if (! (exception->signature == 2880220587UL)) {
    {
#line 539
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 539U, "CharcoalImage");
    }
  }
  {
#line 540
  clone_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 541
  if ((unsigned long )clone_image == (unsigned long )((Image *)((void *)0))) {
#line 542
    return ((Image *)((void *)0));
  }
  {
#line 543
  SetImageType(clone_image, 2);
#line 544
  edge_image = EdgeImage((Image const   *)clone_image, radius, exception);
#line 545
  clone_image = DestroyImage(clone_image);
  }
#line 546
  if ((unsigned long )edge_image == (unsigned long )((Image *)((void *)0))) {
#line 547
    return ((Image *)((void *)0));
  }
  {
#line 548
  charcoal_image = BlurImage((Image const   *)edge_image, radius, sigma, exception);
#line 549
  edge_image = DestroyImage(edge_image);
  }
#line 550
  if ((unsigned long )charcoal_image == (unsigned long )((Image *)((void *)0))) {
#line 551
    return ((Image *)((void *)0));
  }
  {
#line 552
  NormalizeImage(charcoal_image);
#line 553
  NegateImage(charcoal_image, 0);
#line 554
  SetImageType(charcoal_image, 2);
  }
#line 555
  return (charcoal_image);
}
}
#line 591 "magick/fx.c"
Image *ColorizeImage(Image const   *image , char const   *opacity , PixelPacket colorize ,
                     ExceptionInfo *exception ) 
{ GeometryInfo geometry_info ;
  Image *colorize_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket pixel ;
  MagickStatusType flags ;
  ViewInfo *colorize_view ;
  ViewInfo *image_view ;
  MagickBooleanType tmp ;
  MagickBooleanType sync___0 ;
  register PixelPacket const   * __restrict  p ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___0 ;
  PixelPacket *tmp___1 ;
  MagickBooleanType proceed ;
  long tmp___2 ;

  {
#line 622
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 622
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 622U, "ColorizeImage");
    }
  }
#line 623
  if (! (image->signature == 2880220587UL)) {
    {
#line 623
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 623U, "ColorizeImage");
    }
  }
#line 624
  if ((int const   )image->debug != 0) {
    {
#line 625
    LogMagickEvent(1, "magick/fx.c", "ColorizeImage", 625UL, "%s", image->filename);
    }
  }
#line 626
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 626
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 626U,
                  "ColorizeImage");
    }
  }
#line 627
  if (! (exception->signature == 2880220587UL)) {
    {
#line 627
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 627U, "ColorizeImage");
    }
  }
  {
#line 628
  colorize_image = CloneImage(image, (unsigned long )image->columns, (unsigned long )image->rows,
                              1, exception);
  }
#line 630
  if ((unsigned long )colorize_image == (unsigned long )((Image *)((void *)0))) {
#line 631
    return ((Image *)((void *)0));
  }
  {
#line 632
  tmp = SetImageStorageClass(colorize_image, 1);
  }
#line 632
  if ((int )tmp == 0) {
    {
#line 634
    InheritException(exception, (ExceptionInfo const   *)(& colorize_image->exception));
#line 635
    colorize_image = DestroyImage(colorize_image);
    }
#line 636
    return ((Image *)((void *)0));
  }
#line 638
  if ((unsigned long )opacity == (unsigned long )((char const   *)((void *)0))) {
#line 639
    return (colorize_image);
  }
  {
#line 643
  flags = ParseGeometry(opacity, & geometry_info);
#line 644
  pixel.red = geometry_info.rho;
#line 645
  pixel.green = geometry_info.rho;
#line 646
  pixel.blue = geometry_info.rho;
#line 647
  pixel.opacity = (double )(unsigned short)0;
  }
#line 648
  if ((flags & 8U) != 0U) {
#line 649
    pixel.green = geometry_info.sigma;
  }
#line 650
  if ((flags & 1U) != 0U) {
#line 651
    pixel.blue = geometry_info.xi;
  }
#line 652
  if ((flags & 2U) != 0U) {
#line 653
    pixel.opacity = geometry_info.psi;
  }
  {
#line 657
  status = 1;
#line 658
  progress = 0L;
#line 659
  image_view = AcquireCacheView(image);
#line 660
  colorize_view = AcquireCacheView((Image const   *)colorize_image);
#line 664
  y = 0L;
  }
#line 664
  while (y < (long )image->rows) {
#line 678
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 680
    tmp___0 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y, (unsigned long )image->columns,
                                        1UL, exception);
#line 680
    p = (PixelPacket const   */* __restrict  */)tmp___0;
#line 681
    tmp___1 = QueueCacheViewAuthenticPixels(colorize_view, 0L, y, colorize_image->columns,
                                            1UL, exception);
#line 681
    q = (PixelPacket */* __restrict  */)tmp___1;
    }
#line 683
    if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 685
      status = 0;
      goto __Cont;
    } else {
#line 683
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 685
        status = 0;
        goto __Cont;
      }
    }
#line 688
    x = 0L;
#line 688
    while (x < (long )image->columns) {
#line 690
      q->red = (unsigned short )(((double )p->red * (100.0 - pixel.red) + (MagickRealType )colorize.red * pixel.red) / 100.0);
#line 692
      q->green = (unsigned short )(((double )p->green * (100.0 - pixel.green) + (MagickRealType )colorize.green * pixel.green) / 100.0);
#line 694
      q->blue = (unsigned short )(((double )p->blue * (100.0 - pixel.blue) + (MagickRealType )colorize.blue * pixel.blue) / 100.0);
#line 696
      q->opacity = (unsigned short )(((double )p->opacity * (100.0 - pixel.opacity) + (MagickRealType )colorize.opacity * pixel.opacity) / 100.0);
#line 698
      p ++;
#line 699
      q ++;
#line 688
      x ++;
    }
    {
#line 701
    sync___0 = SyncCacheViewAuthenticPixels(colorize_view, exception);
    }
#line 702
    if ((int )sync___0 == 0) {
#line 703
      status = 0;
    }
#line 704
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 712
      tmp___2 = progress;
#line 712
      progress ++;
#line 712
      proceed = SetImageProgress(image, "Colorize/Image", (long long )tmp___2, (unsigned long long )image->rows);
      }
#line 713
      if ((int )proceed == 0) {
#line 714
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 664
    y ++;
  }
  {
#line 717
  image_view = DestroyCacheView(image_view);
#line 718
  colorize_view = DestroyCacheView(colorize_view);
  }
#line 719
  if ((int )status == 0) {
    {
#line 720
    colorize_image = DestroyImage(colorize_image);
    }
  }
#line 721
  return (colorize_image);
}
}
#line 759 "magick/fx.c"
Image *ConvolveImage(Image const   *image , unsigned long order , double const   *kernel ,
                     ExceptionInfo *exception ) 
{ Image *convolve_image ;

  {
  {
#line 765
  convolve_image = ConvolveImageChannel(image, 55, order, kernel, exception);
  }
#line 767
  return (convolve_image);
}
}
#line 770 "magick/fx.c"
Image *ConvolveImageChannel(Image const   *image , ChannelType channel , unsigned long order ,
                            double const   *kernel , ExceptionInfo *exception ) 
{ double *normal_kernel ;
  Image *convolve_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  MagickRealType bias ;
  MagickRealType gamma___0 ;
  register long i ;
  unsigned long width ;
  ViewInfo *convolve_view ;
  ViewInfo *image_view ;
  char const   *tmp ;
  MagickBooleanType tmp___0 ;
  char format[4096] ;
  char *message ;
  long u ;
  long v ;
  register double const   *k ;
  double const   *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  MagickBooleanType sync___0 ;
  register IndexPacket const   * __restrict  indexes ;
  register PixelPacket const   * __restrict  p ;
  register IndexPacket * __restrict  convolve_indexes ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___7 ;
  PixelPacket *tmp___8 ;
  IndexPacket const   *tmp___9 ;
  IndexPacket *tmp___10 ;
  long j ;
  long v___0 ;
  MagickPixelPacket pixel ;
  register double const   * __restrict  k___0 ;
  register long u___0 ;
  MagickRealType alpha ;
  MagickRealType gamma___1 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  MagickBooleanType proceed ;
  long tmp___14 ;
  void *tmp___15 ;

  {
#line 809
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 809
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 809U, "ConvolveImageChannel");
    }
  }
#line 810
  if (! (image->signature == 2880220587UL)) {
    {
#line 810
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 810U, "ConvolveImageChannel");
    }
  }
#line 811
  if ((int const   )image->debug != 0) {
    {
#line 812
    LogMagickEvent(1, "magick/fx.c", "ConvolveImageChannel", 812UL, "%s", image->filename);
    }
  }
#line 813
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 813
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 813U,
                  "ConvolveImageChannel");
    }
  }
#line 814
  if (! (exception->signature == 2880220587UL)) {
    {
#line 814
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 814U, "ConvolveImageChannel");
    }
  }
#line 815
  width = order;
#line 816
  if (width % 2UL == 0UL) {
#line 817
    if ((unsigned long )"KernelWidthMustBeAnOddNumber" == (unsigned long )((char const   *)((void *)0))) {
#line 817
      tmp = "unknown";
    } else {
#line 817
      tmp = "KernelWidthMustBeAnOddNumber";
    }
    {
#line 817
    ThrowMagickException(exception, "magick/fx.c", "ConvolveImageChannel", 817UL,
                         410, tmp, "`%s\'", image->filename);
    }
#line 817
    return ((Image *)((void *)0));
  }
  {
#line 818
  convolve_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 819
  if ((unsigned long )convolve_image == (unsigned long )((Image *)((void *)0))) {
#line 820
    return ((Image *)((void *)0));
  }
  {
#line 821
  tmp___0 = SetImageStorageClass(convolve_image, 1);
  }
#line 821
  if ((int )tmp___0 == 0) {
    {
#line 823
    InheritException(exception, (ExceptionInfo const   *)(& convolve_image->exception));
#line 824
    convolve_image = DestroyImage(convolve_image);
    }
#line 825
    return ((Image *)((void *)0));
  }
#line 827
  if ((int const   )image->debug != 0) {
    {
#line 840
    LogMagickEvent(8192, "magick/fx.c", "ConvolveImageChannel", 840UL, "  ConvolveImage with %ldx%ld kernel:",
                   width, width);
#line 842
    message = AcquireString("");
#line 843
    k = kernel;
#line 844
    v = 0L;
    }
#line 844
    while (v < (long )width) {
      {
#line 846
      *message = (char )'\000';
#line 847
      FormatMagickString(format, 4096UL, "%ld: ", v);
#line 848
      ConcatenateString(& message, (char const   *)(format));
#line 849
      u = 0L;
      }
#line 849
      while (u < (long )width) {
        {
#line 851
        tmp___1 = k;
#line 851
        k ++;
#line 851
        FormatMagickString(format, 4096UL, "%+f ", *tmp___1);
#line 852
        ConcatenateString(& message, (char const   *)(format));
#line 849
        u ++;
        }
      }
      {
#line 854
      LogMagickEvent(8192, "magick/fx.c", "ConvolveImageChannel", 854UL, "%s", message);
#line 844
      v ++;
      }
    }
    {
#line 856
    message = DestroyString(message);
    }
  }
  {
#line 861
  tmp___2 = AcquireQuantumMemory(width * width, sizeof(*normal_kernel));
#line 861
  normal_kernel = (double *)tmp___2;
  }
#line 863
  if ((unsigned long )normal_kernel == (unsigned long )((double *)((void *)0))) {
    {
#line 865
    convolve_image = DestroyImage(convolve_image);
    }
#line 866
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 866
      tmp___3 = "unknown";
    } else {
#line 866
      tmp___3 = "MemoryAllocationFailed";
    }
    {
#line 866
    ThrowMagickException(exception, "magick/fx.c", "ConvolveImageChannel", 866UL,
                         400, tmp___3, "`%s\'", image->filename);
    }
#line 866
    return ((Image *)((void *)0));
  }
#line 868
  gamma___0 = 0.0;
#line 869
  i = 0L;
#line 869
  while (i < (long )(width * width)) {
#line 870
    gamma___0 += (MagickRealType )*(kernel + i);
#line 869
    i ++;
  }
  {
#line 871
  tmp___6 = fabs(gamma___0);
  }
#line 871
  if (tmp___6 <= 1.0e-10) {
#line 871
    tmp___5 = 1.0;
  } else {
#line 871
    tmp___5 = gamma___0;
  }
#line 871
  gamma___0 = 1.0 / tmp___5;
#line 872
  i = 0L;
#line 872
  while (i < (long )(width * width)) {
#line 873
    *(normal_kernel + i) = gamma___0 * (MagickRealType )*(kernel + i);
#line 872
    i ++;
  }
  {
#line 877
  status = 1;
#line 878
  progress = 0L;
#line 879
  GetMagickPixelPacket(image, & zero);
#line 880
  bias = (double )image->bias;
#line 881
  image_view = AcquireCacheView(image);
#line 882
  convolve_view = AcquireCacheView((Image const   *)convolve_image);
#line 886
  y = 0L;
  }
#line 886
  while (y < (long )image->rows) {
#line 906
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 908
    tmp___7 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, - ((long )width / 2L),
                                        y - (long )(width / 2UL), (unsigned long )(image->columns + (unsigned long const   )width),
                                        width, exception);
#line 908
    p = (PixelPacket const   */* __restrict  */)tmp___7;
#line 910
    tmp___8 = GetCacheViewAuthenticPixels(convolve_view, 0L, y, convolve_image->columns,
                                          1UL, exception);
#line 910
    q = (PixelPacket */* __restrict  */)tmp___8;
    }
#line 912
    if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 914
      status = 0;
      goto __Cont;
    } else {
#line 912
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 914
        status = 0;
        goto __Cont;
      }
    }
    {
#line 917
    tmp___9 = GetCacheViewVirtualIndexQueue((ViewInfo const   *)image_view);
#line 917
    indexes = (IndexPacket const   */* __restrict  */)tmp___9;
#line 918
    tmp___10 = GetCacheViewAuthenticIndexQueue(convolve_view);
#line 918
    convolve_indexes = (IndexPacket */* __restrict  */)tmp___10;
#line 919
    x = 0L;
    }
#line 919
    while (x < (long )image->columns) {
#line 934
      pixel = zero;
#line 935
      k___0 = (double const   */* __restrict  */)normal_kernel;
#line 936
      j = 0L;
#line 937
      if (((int )channel & 8) == 0) {
        goto _L;
      } else {
#line 937
        if ((int const   )image->matte == 0) {
          _L: /* CIL Label */ 
#line 939
          v___0 = 0L;
#line 939
          while (v___0 < (long )width) {
#line 941
            u___0 = 0L;
#line 941
            while (u___0 < (long )width) {
#line 943
              pixel.red += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->red);
#line 944
              pixel.green += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->green);
#line 945
              pixel.blue += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->blue);
#line 946
              k___0 ++;
#line 941
              u___0 ++;
            }
#line 948
            j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 939
            v___0 ++;
          }
#line 950
          if (((int )channel & 1) != 0) {
            {
#line 951
            q->red = RoundToQuantum(pixel.red + bias);
            }
          }
#line 952
          if (((int )channel & 2) != 0) {
            {
#line 953
            q->green = RoundToQuantum(pixel.green + bias);
            }
          }
#line 954
          if (((int )channel & 4) != 0) {
            {
#line 955
            q->blue = RoundToQuantum(pixel.blue + bias);
            }
          }
#line 956
          if (((int )channel & 8) != 0) {
#line 958
            k___0 = (double const   */* __restrict  */)normal_kernel;
#line 959
            j = 0L;
#line 960
            v___0 = 0L;
#line 960
            while (v___0 < (long )width) {
#line 962
              u___0 = 0L;
#line 962
              while (u___0 < (long )width) {
#line 964
                pixel.opacity += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->opacity);
#line 965
                k___0 ++;
#line 962
                u___0 ++;
              }
#line 967
              j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 960
              v___0 ++;
            }
            {
#line 969
            q->opacity = RoundToQuantum(pixel.opacity + bias);
            }
          }
#line 971
          if (((int )channel & 32) != 0) {
#line 971
            if ((int const   )image->colorspace == 12) {
#line 974
              k___0 = (double const   */* __restrict  */)normal_kernel;
#line 975
              j = 0L;
#line 976
              v___0 = 0L;
#line 976
              while (v___0 < (long )width) {
#line 978
                u___0 = 0L;
#line 978
                while (u___0 < (long )width) {
#line 980
                  pixel.index += (MagickRealType )(*k___0 * (double const   )*(indexes + ((x + u___0) + j)));
#line 981
                  k___0 ++;
#line 978
                  u___0 ++;
                }
#line 983
                j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 976
                v___0 ++;
              }
              {
#line 985
              *(convolve_indexes + x) = RoundToQuantum(pixel.index + bias);
              }
            }
          }
        } else {
#line 994
          gamma___1 = 0.0;
#line 995
          v___0 = 0L;
#line 995
          while (v___0 < (long )width) {
#line 997
            u___0 = 0L;
#line 997
            while (u___0 < (long )width) {
#line 999
              alpha = (1.0 / (double )65535UL) * (double )(65535UL - (unsigned long )((p + u___0) + j)->opacity);
#line 1001
              pixel.red += (MagickRealType )((*k___0 * (double const   )alpha) * (double const   )((p + u___0) + j)->red);
#line 1002
              pixel.green += (MagickRealType )((*k___0 * (double const   )alpha) * (double const   )((p + u___0) + j)->green);
#line 1003
              pixel.blue += (MagickRealType )((*k___0 * (double const   )alpha) * (double const   )((p + u___0) + j)->blue);
#line 1004
              pixel.opacity += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->opacity);
#line 1005
              gamma___1 += (MagickRealType )(*k___0 * (double const   )alpha);
#line 1006
              k___0 ++;
#line 997
              u___0 ++;
            }
#line 1008
            j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 995
            v___0 ++;
          }
          {
#line 1010
          tmp___13 = fabs(gamma___1);
          }
#line 1010
          if (tmp___13 <= 1.0e-10) {
#line 1010
            tmp___12 = 1.0;
          } else {
#line 1010
            tmp___12 = gamma___1;
          }
#line 1010
          gamma___1 = 1.0 / tmp___12;
#line 1011
          if (((int )channel & 1) != 0) {
            {
#line 1012
            q->red = RoundToQuantum(gamma___1 * pixel.red + bias);
            }
          }
#line 1013
          if (((int )channel & 2) != 0) {
            {
#line 1014
            q->green = RoundToQuantum(gamma___1 * pixel.green + bias);
            }
          }
#line 1015
          if (((int )channel & 4) != 0) {
            {
#line 1016
            q->blue = RoundToQuantum(gamma___1 * pixel.blue + bias);
            }
          }
#line 1017
          if (((int )channel & 8) != 0) {
#line 1019
            k___0 = (double const   */* __restrict  */)normal_kernel;
#line 1020
            j = 0L;
#line 1021
            v___0 = 0L;
#line 1021
            while (v___0 < (long )width) {
#line 1023
              u___0 = 0L;
#line 1023
              while (u___0 < (long )width) {
#line 1025
                pixel.opacity += (MagickRealType )(*k___0 * (double const   )((p + u___0) + j)->opacity);
#line 1026
                k___0 ++;
#line 1023
                u___0 ++;
              }
#line 1028
              j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 1021
              v___0 ++;
            }
            {
#line 1030
            q->opacity = RoundToQuantum(pixel.opacity + bias);
            }
          }
#line 1032
          if (((int )channel & 32) != 0) {
#line 1032
            if ((int const   )image->colorspace == 12) {
#line 1035
              k___0 = (double const   */* __restrict  */)normal_kernel;
#line 1036
              j = 0L;
#line 1037
              v___0 = 0L;
#line 1037
              while (v___0 < (long )width) {
#line 1039
                u___0 = 0L;
#line 1039
                while (u___0 < (long )width) {
#line 1041
                  alpha = (1.0 / (double )65535UL) * (double )(65535UL - (unsigned long )((p + u___0) + j)->opacity);
#line 1043
                  pixel.index += (MagickRealType )((*k___0 * (double const   )alpha) * (double const   )*(indexes + ((x + u___0) + j)));
#line 1044
                  k___0 ++;
#line 1039
                  u___0 ++;
                }
#line 1046
                j = (long )((unsigned long const   )j + (image->columns + (unsigned long const   )width));
#line 1037
                v___0 ++;
              }
              {
#line 1048
              *(convolve_indexes + x) = RoundToQuantum(gamma___1 * pixel.index + bias);
              }
            }
          }
        }
      }
#line 1051
      p ++;
#line 1052
      q ++;
#line 919
      x ++;
    }
    {
#line 1054
    sync___0 = SyncCacheViewAuthenticPixels(convolve_view, exception);
    }
#line 1055
    if ((int )sync___0 == 0) {
#line 1056
      status = 0;
    }
#line 1057
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 1065
      tmp___14 = progress;
#line 1065
      progress ++;
#line 1065
      proceed = SetImageProgress(image, "Convolve/Image", (long long )tmp___14, (unsigned long long )image->rows);
      }
#line 1066
      if ((int )proceed == 0) {
#line 1067
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 886
    y ++;
  }
  {
#line 1070
  convolve_image->type = (enum __anonenum_ImageType_89 )image->type;
#line 1071
  convolve_view = DestroyCacheView(convolve_view);
#line 1072
  image_view = DestroyCacheView(image_view);
#line 1073
  tmp___15 = RelinquishMagickMemory((void *)normal_kernel);
#line 1073
  normal_kernel = (double *)tmp___15;
  }
#line 1074
  if ((int )status == 0) {
    {
#line 1075
    convolve_image = DestroyImage(convolve_image);
    }
  }
#line 1076
  return (convolve_image);
}
}
#line 1101 "magick/fx.c"
FxInfo *DestroyFxInfo(FxInfo *fx_info ) 
{ register long i ;
  unsigned long tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1106
  fx_info->exception = DestroyExceptionInfo(fx_info->exception);
#line 1107
  fx_info->expression = DestroyString(fx_info->expression);
#line 1108
  fx_info->symbols = DestroySplayTree(fx_info->symbols);
#line 1109
  fx_info->colors = DestroySplayTree(fx_info->colors);
#line 1110
  i = 0L;
  }
#line 1110
  while (1) {
    {
#line 1110
    tmp = GetImageListLength(fx_info->images);
    }
#line 1110
    if (! (i < (long )tmp)) {
#line 1110
      break;
    }
    {
#line 1111
    *(fx_info->resample_filter + i) = DestroyResampleFilter(*(fx_info->resample_filter + i));
#line 1110
    i ++;
    }
  }
  {
#line 1113
  tmp___0 = RelinquishMagickMemory((void *)fx_info->resample_filter);
#line 1113
  fx_info->resample_filter = (ResampleFilter **)tmp___0;
#line 1115
  tmp___1 = RelinquishMagickMemory((void *)fx_info);
#line 1115
  fx_info = (FxInfo *)tmp___1;
  }
#line 1116
  return (fx_info);
}
}
#line 1158 "magick/fx.c"
__inline static double MagickMax(double x , double y ) 
{ 

  {
#line 1160
  if (x > y) {
#line 1161
    return (x);
  }
#line 1162
  return (y);
}
}
#line 1165 "magick/fx.c"
__inline static double MagickMin(double x , double y ) 
{ 

  {
#line 1167
  if (x < y) {
#line 1168
    return (x);
  }
#line 1169
  return (y);
}
}
#line 1172 "magick/fx.c"
static Quantum ApplyEvaluateOperator(Quantum pixel , MagickEvaluateOperator op , MagickRealType value ) 
{ MagickRealType result ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  Quantum tmp___2 ;
  Quantum tmp___3 ;
  Quantum tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  Quantum tmp___9 ;
  Quantum tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  unsigned long tmp___13 ;
  int tmp___14 ;
  unsigned long tmp___15 ;
  Quantum tmp___16 ;
  Quantum tmp___17 ;

  {
#line 1178
  result = 0.0;
#line 1179
  switch ((int )op) {
  case 0: 
#line 1182
  break;
  case 1: 
#line 1185
  result = (MagickRealType )pixel + value;
#line 1186
  break;
  case 26: 
  {
#line 1198
  result = (MagickRealType )pixel + value;
#line 1199
  tmp = floor(result / (MagickRealType )65536UL);
#line 1199
  result -= (double )65536UL * tmp;
  }
#line 1200
  break;
  case 2: 
#line 1204
  result = (double )((unsigned long )pixel & (unsigned long )(value + 0.5));
#line 1206
  break;
  case 24: 
  {
#line 1210
  tmp___0 = cos((((2.0 * 3.14159265358979323846264338327950288419716939937510) * (1.0 / (double )65535UL)) * (double )pixel) * value);
#line 1210
  result = (double )65535UL * (0.5 * tmp___0 + 0.5);
  }
#line 1212
  break;
  case 3: 
#line 1216
  if (value == 0.0) {
#line 1216
    tmp___1 = 1.0;
  } else {
#line 1216
    tmp___1 = value;
  }
#line 1216
  result = (double )pixel / tmp___1;
#line 1217
  break;
  case 18: 
  {
#line 1221
  tmp___2 = GenerateNoise(pixel, 2, value);
#line 1221
  result = (double )tmp___2;
  }
#line 1222
  break;
  case 19: 
  {
#line 1226
  tmp___3 = GenerateNoise(pixel, 4, value);
#line 1226
  result = (double )tmp___3;
  }
#line 1227
  break;
  case 20: 
  {
#line 1231
  tmp___4 = GenerateNoise(pixel, 5, value);
#line 1231
  result = (double )tmp___4;
  }
#line 1232
  break;
  case 4: 
#line 1236
  result = (double )((unsigned long )pixel << (unsigned long )(value + 0.5));
#line 1238
  break;
  case 14: 
  {
#line 1242
  tmp___5 = log(((1.0 / (double )65535UL) * value) * (double )pixel + 1.0);
#line 1242
  tmp___6 = log(value + 1.0);
#line 1242
  result = ((double )65535UL * tmp___5) / tmp___6;
  }
#line 1244
  break;
  case 5: 
  {
#line 1248
  tmp___7 = MagickMax((double )pixel, value);
#line 1248
  result = tmp___7;
  }
#line 1249
  break;
  case 6: 
  {
#line 1253
  tmp___8 = MagickMin((double )pixel, value);
#line 1253
  result = tmp___8;
  }
#line 1254
  break;
  case 21: 
  {
#line 1258
  tmp___9 = GenerateNoise(pixel, 3, value);
#line 1258
  result = (double )tmp___9;
  }
#line 1260
  break;
  case 7: 
#line 1264
  result = value * (MagickRealType )pixel;
#line 1265
  break;
  case 8: 
#line 1269
  result = (double )((unsigned long )pixel | (unsigned long )(value + 0.5));
#line 1271
  break;
  case 22: 
  {
#line 1275
  tmp___10 = GenerateNoise(pixel, 6, value);
#line 1275
  result = (double )tmp___10;
  }
#line 1276
  break;
  case 13: 
  {
#line 1280
  tmp___11 = pow((1.0 / (double )65535UL) * (double )pixel, value);
#line 1280
  result = (double )65535UL * tmp___11;
  }
#line 1282
  break;
  case 9: 
#line 1286
  result = (double )((unsigned long )pixel >> (unsigned long )(value + 0.5));
#line 1288
  break;
  case 10: 
#line 1292
  result = value;
#line 1293
  break;
  case 25: 
  {
#line 1297
  tmp___12 = sin((((2.0 * 3.14159265358979323846264338327950288419716939937510) * (1.0 / (double )65535UL)) * (double )pixel) * value);
#line 1297
  result = (double )65535UL * (0.5 * tmp___12 + 0.5);
  }
#line 1299
  break;
  case 11: 
#line 1303
  result = (MagickRealType )pixel - value;
#line 1304
  break;
  case 15: 
#line 1308
  if ((double )pixel <= value) {
#line 1308
    tmp___13 = 0UL;
  } else {
#line 1308
    tmp___13 = 65535UL;
  }
#line 1308
  result = (double )tmp___13;
#line 1310
  break;
  case 16: 
#line 1314
  if ((double )pixel <= value) {
#line 1314
    tmp___14 = 0;
  } else {
#line 1314
    tmp___14 = (int )pixel;
  }
#line 1314
  result = (double )tmp___14;
#line 1315
  break;
  case 17: 
#line 1319
  if ((double )pixel > value) {
#line 1319
    tmp___15 = 65535UL;
  } else {
#line 1319
    tmp___15 = (unsigned long )pixel;
  }
#line 1319
  result = (double )tmp___15;
#line 1321
  break;
  case 23: 
  {
#line 1325
  tmp___16 = GenerateNoise(pixel, 1, value);
#line 1325
  result = (double )tmp___16;
  }
#line 1326
  break;
  case 12: 
#line 1330
  result = (double )((unsigned long )pixel ^ (unsigned long )(value + 0.5));
#line 1332
  break;
  }
  {
#line 1335
  tmp___17 = RoundToQuantum(result);
  }
#line 1335
  return (tmp___17);
}
}
#line 1338 "magick/fx.c"
MagickBooleanType EvaluateImage(Image *image , MagickEvaluateOperator op , double value ,
                                ExceptionInfo *exception ) 
{ MagickBooleanType status ;

  {
  {
#line 1344
  status = EvaluateImageChannel(image, 63, op, value, exception);
  }
#line 1345
  return (status);
}
}
#line 1348 "magick/fx.c"
MagickBooleanType EvaluateImageChannel(Image *image , ChannelType channel , MagickEvaluateOperator op ,
                                       double value , ExceptionInfo *exception ) 
{ long progress ;
  long y ;
  MagickBooleanType status ;
  ViewInfo *image_view ;
  MagickBooleanType tmp ;
  register IndexPacket * __restrict  indexes ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___0 ;
  IndexPacket *tmp___1 ;
  Quantum tmp___2 ;
  Quantum tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType proceed ;
  long tmp___5 ;

  {
#line 1364
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 1364
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 1364U, "EvaluateImageChannel");
    }
  }
#line 1365
  if (! (image->signature == 2880220587UL)) {
    {
#line 1365
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 1365U, "EvaluateImageChannel");
    }
  }
#line 1366
  if ((int )image->debug != 0) {
    {
#line 1367
    LogMagickEvent(1, "magick/fx.c", "EvaluateImageChannel", 1367UL, "%s", image->filename);
    }
  }
#line 1368
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 1368
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 1368U,
                  "EvaluateImageChannel");
    }
  }
#line 1369
  if (! (exception->signature == 2880220587UL)) {
    {
#line 1369
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 1369U, "EvaluateImageChannel");
    }
  }
  {
#line 1370
  tmp = SetImageStorageClass(image, 1);
  }
#line 1370
  if ((int )tmp == 0) {
    {
#line 1372
    InheritException(exception, (ExceptionInfo const   *)(& image->exception));
    }
#line 1373
    return (0);
  }
  {
#line 1375
  status = 1;
#line 1376
  progress = 0L;
#line 1377
  image_view = AcquireCacheView((Image const   *)image);
#line 1381
  y = 0L;
  }
#line 1381
  while (y < (long )image->rows) {
#line 1392
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 1394
    tmp___0 = GetCacheViewAuthenticPixels(image_view, 0L, y, image->columns, 1UL,
                                          exception);
#line 1394
    q = (PixelPacket */* __restrict  */)tmp___0;
    }
#line 1395
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 1397
      status = 0;
      goto __Cont;
    }
    {
#line 1400
    tmp___1 = GetCacheViewAuthenticIndexQueue(image_view);
#line 1400
    indexes = (IndexPacket */* __restrict  */)tmp___1;
#line 1401
    x = 0L;
    }
#line 1401
    while (x < (long )image->columns) {
#line 1403
      if (((int )channel & 1) != 0) {
        {
#line 1404
        q->red = ApplyEvaluateOperator(q->red, op, value);
        }
      }
#line 1405
      if (((int )channel & 2) != 0) {
        {
#line 1406
        q->green = ApplyEvaluateOperator(q->green, op, value);
        }
      }
#line 1407
      if (((int )channel & 4) != 0) {
        {
#line 1408
        q->blue = ApplyEvaluateOperator(q->blue, op, value);
        }
      }
#line 1409
      if (((int )channel & 8) != 0) {
#line 1411
        if ((int )image->matte == 0) {
          {
#line 1412
          q->opacity = ApplyEvaluateOperator(q->opacity, op, value);
          }
        } else {
          {
#line 1414
          tmp___2 = ApplyEvaluateOperator((unsigned short )(65535UL - (unsigned long )q->opacity),
                                          op, value);
#line 1414
          q->opacity = (unsigned short )(65535 - (int )tmp___2);
          }
        }
      }
#line 1417
      if (((int )channel & 32) != 0) {
#line 1417
        if ((unsigned long )indexes != (unsigned long )((IndexPacket *)((void *)0))) {
          {
#line 1418
          tmp___3 = ApplyEvaluateOperator(*(indexes + x), op, value);
#line 1418
          *(indexes + x) = tmp___3;
          }
        }
      }
#line 1419
      q ++;
#line 1401
      x ++;
    }
    {
#line 1421
    tmp___4 = SyncCacheViewAuthenticPixels(image_view, exception);
    }
#line 1421
    if ((int )tmp___4 == 0) {
#line 1422
      status = 0;
    }
#line 1423
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 1431
      tmp___5 = progress;
#line 1431
      progress ++;
#line 1431
      proceed = SetImageProgress((Image const   *)image, "Evaluate/Image ", (long long )tmp___5,
                                 (unsigned long long )image->rows);
      }
#line 1432
      if ((int )proceed == 0) {
#line 1433
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1381
    y ++;
  }
  {
#line 1436
  image_view = DestroyCacheView(image_view);
  }
#line 1437
  return (status);
}
}
#line 1480 "magick/fx.c"
static Quantum ApplyFunction(Quantum pixel , MagickFunction function , unsigned long number_parameters ,
                             MagickRealType const   *parameters , ExceptionInfo *exception ) 
{ MagickRealType result ;
  register long i ;
  double freq ;
  double phase ;
  double ampl ;
  double bias ;
  double tmp ;
  double width ;
  double range ;
  double center ;
  double bias___0 ;
  double tmp___0 ;
  double width___0 ;
  double range___0 ;
  double center___0 ;
  double bias___1 ;
  double tmp___1 ;
  Quantum tmp___2 ;

  {
#line 1491
  result = 0.0;
#line 1492
  switch ((int )function) {
  case 1: 
#line 1501
  result = 0.0;
#line 1502
  i = 0L;
#line 1502
  while (i < (long )number_parameters) {
#line 1503
    result = (result * (1.0 / (double )65535UL)) * (MagickRealType )pixel + (MagickRealType )*(parameters + i);
#line 1502
    i ++;
  }
#line 1504
  result *= (MagickRealType )65535UL;
#line 1505
  break;
  case 2: 
#line 1513
  if (number_parameters >= 1UL) {
#line 1513
    freq = (double )*(parameters + 0);
  } else {
#line 1513
    freq = 1.0;
  }
#line 1514
  if (number_parameters >= 2UL) {
#line 1514
    phase = (double )*(parameters + 1);
  } else {
#line 1514
    phase = 0.0;
  }
#line 1515
  if (number_parameters >= 3UL) {
#line 1515
    ampl = (double )*(parameters + 2);
  } else {
#line 1515
    ampl = 0.5;
  }
#line 1516
  if (number_parameters >= 4UL) {
#line 1516
    bias = (double )*(parameters + 3);
  } else {
#line 1516
    bias = 0.5;
  }
  {
#line 1517
  tmp = sin((2.0 * 3.14159265358979323846264338327950288419716939937510) * ((freq * (1.0 / (double )65535UL)) * (double )pixel + phase / 360.0));
#line 1517
  result = (double )65535UL * (ampl * tmp + bias);
  }
#line 1519
  break;
  case 3: 
#line 1527
  if (number_parameters >= 1UL) {
#line 1527
    width = (double )*(parameters + 0);
  } else {
#line 1527
    width = 1.0;
  }
#line 1528
  if (number_parameters >= 3UL) {
#line 1528
    range = (double )*(parameters + 1);
  } else {
#line 1528
    range = 1.0;
  }
#line 1529
  if (number_parameters >= 2UL) {
#line 1529
    center = (double )*(parameters + 2);
  } else {
#line 1529
    center = 0.5;
  }
#line 1530
  if (number_parameters >= 4UL) {
#line 1530
    bias___0 = (double )*(parameters + 3);
  } else {
#line 1530
    bias___0 = 0.5;
  }
#line 1531
  result = (2.0 / width) * ((1.0 / (double )65535UL) * (double )pixel - center);
#line 1532
  if (result <= - 1.0) {
#line 1533
    result = 1.0e-10 - 1.0;
  }
#line 1534
  if (result >= 1.0) {
#line 1535
    result = 1.0 - 1.0e-10;
  }
  {
#line 1536
  tmp___0 = asin(result);
#line 1536
  result = (double )65535UL * ((range / 3.14159265358979323846264338327950288419716939937510) * tmp___0 + bias___0);
  }
#line 1538
  break;
  case 4: 
#line 1546
  if (number_parameters >= 1UL) {
#line 1546
    width___0 = (double )*(parameters + 0);
  } else {
#line 1546
    width___0 = 1.0;
  }
#line 1547
  if (number_parameters >= 3UL) {
#line 1547
    range___0 = (double )*(parameters + 1);
  } else {
#line 1547
    range___0 = 1.0;
  }
#line 1548
  if (number_parameters >= 2UL) {
#line 1548
    center___0 = (double )*(parameters + 2);
  } else {
#line 1548
    center___0 = 0.5;
  }
#line 1549
  if (number_parameters >= 4UL) {
#line 1549
    bias___1 = (double )*(parameters + 3);
  } else {
#line 1549
    bias___1 = 0.5;
  }
  {
#line 1550
  result = (2.0 * width___0) * ((1.0 / (double )65535UL) * (double )pixel - center___0);
#line 1551
  tmp___1 = atan(result);
#line 1551
  result = (double )65535UL * ((range___0 / 3.14159265358979323846264338327950288419716939937510) * tmp___1 + bias___1);
  }
#line 1553
  break;
  case 0: 
#line 1556
  break;
  }
  {
#line 1558
  tmp___2 = RoundToQuantum(result);
  }
#line 1558
  return (tmp___2);
}
}
#line 1561 "magick/fx.c"
MagickBooleanType FunctionImage(Image *image , MagickFunction function , unsigned long number_parameters ,
                                double const   *parameters , ExceptionInfo *exception ) 
{ MagickBooleanType status ;

  {
  {
#line 1568
  status = FunctionImageChannel(image, 63, function, number_parameters, parameters,
                                exception);
  }
#line 1570
  return (status);
}
}
#line 1573 "magick/fx.c"
MagickBooleanType FunctionImageChannel(Image *image , ChannelType channel , MagickFunction function ,
                                       unsigned long number_parameters , double const   *parameters ,
                                       ExceptionInfo *exception ) 
{ long progress ;
  long y ;
  MagickBooleanType status ;
  ViewInfo *image_view ;
  MagickBooleanType tmp ;
  register IndexPacket * __restrict  indexes ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___0 ;
  IndexPacket *tmp___1 ;
  Quantum tmp___2 ;
  Quantum tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType proceed ;
  long tmp___5 ;

  {
#line 1590
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 1590
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 1590U, "FunctionImageChannel");
    }
  }
#line 1591
  if (! (image->signature == 2880220587UL)) {
    {
#line 1591
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 1591U, "FunctionImageChannel");
    }
  }
#line 1592
  if ((int )image->debug != 0) {
    {
#line 1593
    LogMagickEvent(1, "magick/fx.c", "FunctionImageChannel", 1593UL, "%s", image->filename);
    }
  }
#line 1594
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 1594
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 1594U,
                  "FunctionImageChannel");
    }
  }
#line 1595
  if (! (exception->signature == 2880220587UL)) {
    {
#line 1595
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 1595U, "FunctionImageChannel");
    }
  }
  {
#line 1596
  tmp = SetImageStorageClass(image, 1);
  }
#line 1596
  if ((int )tmp == 0) {
    {
#line 1598
    InheritException(exception, (ExceptionInfo const   *)(& image->exception));
    }
#line 1599
    return (0);
  }
  {
#line 1601
  status = 1;
#line 1602
  progress = 0L;
#line 1603
  image_view = AcquireCacheView((Image const   *)image);
#line 1607
  y = 0L;
  }
#line 1607
  while (y < (long )image->rows) {
#line 1618
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 1620
    tmp___0 = GetCacheViewAuthenticPixels(image_view, 0L, y, image->columns, 1UL,
                                          exception);
#line 1620
    q = (PixelPacket */* __restrict  */)tmp___0;
    }
#line 1621
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 1623
      status = 0;
      goto __Cont;
    }
    {
#line 1626
    tmp___1 = GetCacheViewAuthenticIndexQueue(image_view);
#line 1626
    indexes = (IndexPacket */* __restrict  */)tmp___1;
#line 1627
    x = 0L;
    }
#line 1627
    while (x < (long )image->columns) {
#line 1629
      if (((int )channel & 1) != 0) {
        {
#line 1630
        q->red = ApplyFunction(q->red, function, number_parameters, parameters, exception);
        }
      }
#line 1632
      if (((int )channel & 2) != 0) {
        {
#line 1633
        q->green = ApplyFunction(q->green, function, number_parameters, parameters,
                                 exception);
        }
      }
#line 1635
      if (((int )channel & 4) != 0) {
        {
#line 1636
        q->blue = ApplyFunction(q->blue, function, number_parameters, parameters,
                                exception);
        }
      }
#line 1638
      if (((int )channel & 8) != 0) {
#line 1640
        if ((int )image->matte == 0) {
          {
#line 1641
          q->opacity = ApplyFunction(q->opacity, function, number_parameters, parameters,
                                     exception);
          }
        } else {
          {
#line 1644
          tmp___2 = ApplyFunction((unsigned short )(65535UL - (unsigned long )q->opacity),
                                  function, number_parameters, parameters, exception);
#line 1644
          q->opacity = (unsigned short )(65535 - (int )tmp___2);
          }
        }
      }
#line 1648
      if (((int )channel & 32) != 0) {
#line 1648
        if ((unsigned long )indexes != (unsigned long )((IndexPacket *)((void *)0))) {
          {
#line 1649
          tmp___3 = ApplyFunction(*(indexes + x), function, number_parameters, parameters,
                                  exception);
#line 1649
          *(indexes + x) = tmp___3;
          }
        }
      }
#line 1651
      q ++;
#line 1627
      x ++;
    }
    {
#line 1653
    tmp___4 = SyncCacheViewAuthenticPixels(image_view, exception);
    }
#line 1653
    if ((int )tmp___4 == 0) {
#line 1654
      status = 0;
    }
#line 1655
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 1663
      tmp___5 = progress;
#line 1663
      progress ++;
#line 1663
      proceed = SetImageProgress((Image const   *)image, "Function/Image ", (long long )tmp___5,
                                 (unsigned long long )image->rows);
      }
#line 1664
      if ((int )proceed == 0) {
#line 1665
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 1607
    y ++;
  }
  {
#line 1668
  image_view = DestroyCacheView(image_view);
  }
#line 1669
  return (status);
}
}
#line 1708 "magick/fx.c"
static MagickRealType FxChannelStatistics(FxInfo *fx_info , Image const   *image ,
                                          ChannelType channel , char const   *symbol ,
                                          ExceptionInfo *exception ) 
{ char key[4096] ;
  char statistic[4096] ;
  char const   *value ;
  register char const   *p ;
  void *tmp ;
  double tmp___0 ;
  unsigned long depth ;
  long tmp___1 ;
  double kurtosis ;
  double skewness ;
  long tmp___2 ;
  double maxima ;
  double minima ;
  long tmp___3 ;
  double mean ;
  double standard_deviation ;
  long tmp___4 ;
  double maxima___0 ;
  double minima___0 ;
  long tmp___5 ;
  double kurtosis___0 ;
  double skewness___0 ;
  long tmp___6 ;
  double mean___0 ;
  double standard_deviation___0 ;
  long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  double tmp___10 ;

  {
#line 1721
  p = symbol;
#line 1721
  while (1) {
#line 1721
    if ((int const   )*p != 46) {
#line 1721
      if (! ((int const   )*p != 0)) {
#line 1721
        break;
      }
    } else {
#line 1721
      break;
    }
#line 1721
    p ++;
  }
#line 1722
  if ((int const   )*p == 46) {
#line 1723
    p ++;
#line 1723
    switch ((int )*p) {
    case 114: 
#line 1725
    channel = 1;
#line 1725
    break;
    case 103: 
#line 1726
    channel = 2;
#line 1726
    break;
    case 98: 
#line 1727
    channel = 4;
#line 1727
    break;
    case 99: 
#line 1728
    channel = 1;
#line 1728
    break;
    case 109: 
#line 1729
    channel = 2;
#line 1729
    break;
    case 121: 
#line 1730
    channel = 4;
#line 1730
    break;
    case 107: 
#line 1731
    channel = 32;
#line 1731
    break;
    default: ;
#line 1732
    break;
    }
  }
  {
#line 1734
  FormatMagickString(key, 4096UL, "%p.%ld.%s", image, (long )channel, symbol);
#line 1736
  tmp = GetValueFromSplayTree(fx_info->symbols, (void const   *)(key));
#line 1736
  value = (char const   *)tmp;
  }
#line 1737
  if ((unsigned long )value != (unsigned long )((char const   *)((void *)0))) {
    {
#line 1738
    tmp___0 = atof(value);
    }
#line 1738
    return ((1.0 / (double )65535UL) * tmp___0);
  }
  {
#line 1739
  DeleteNodeFromSplayTree(fx_info->symbols, (void const   *)(key));
#line 1740
  tmp___1 = LocaleNCompare(symbol, "depth", 5UL);
  }
#line 1740
  if (tmp___1 == 0L) {
    {
#line 1745
    depth = GetImageChannelDepth(image, channel, exception);
#line 1746
    FormatMagickString(statistic, 4096UL, "%lu", depth);
    }
  }
  {
#line 1748
  tmp___2 = LocaleNCompare(symbol, "kurtosis", 8UL);
  }
#line 1748
  if (tmp___2 == 0L) {
    {
#line 1754
    GetImageChannelKurtosis(image, channel, & kurtosis, & skewness, exception);
#line 1756
    FormatMagickString(statistic, 4096UL, "%g", kurtosis);
    }
  }
  {
#line 1758
  tmp___3 = LocaleNCompare(symbol, "maxima", 6UL);
  }
#line 1758
  if (tmp___3 == 0L) {
    {
#line 1764
    GetImageChannelRange(image, channel, & minima, & maxima, exception);
#line 1765
    FormatMagickString(statistic, 4096UL, "%g", maxima);
    }
  }
  {
#line 1767
  tmp___4 = LocaleNCompare(symbol, "mean", 4UL);
  }
#line 1767
  if (tmp___4 == 0L) {
    {
#line 1773
    GetImageChannelMean(image, channel, & mean, & standard_deviation, exception);
#line 1775
    FormatMagickString(statistic, 4096UL, "%g", mean);
    }
  }
  {
#line 1777
  tmp___5 = LocaleNCompare(symbol, "minima", 6UL);
  }
#line 1777
  if (tmp___5 == 0L) {
    {
#line 1783
    GetImageChannelRange(image, channel, & minima___0, & maxima___0, exception);
#line 1784
    FormatMagickString(statistic, 4096UL, "%g", minima___0);
    }
  }
  {
#line 1786
  tmp___6 = LocaleNCompare(symbol, "skewness", 8UL);
  }
#line 1786
  if (tmp___6 == 0L) {
    {
#line 1792
    GetImageChannelKurtosis(image, channel, & kurtosis___0, & skewness___0, exception);
#line 1794
    FormatMagickString(statistic, 4096UL, "%g", skewness___0);
    }
  }
  {
#line 1796
  tmp___7 = LocaleNCompare(symbol, "standard_deviation", 18UL);
  }
#line 1796
  if (tmp___7 == 0L) {
    {
#line 1802
    GetImageChannelMean(image, channel, & mean___0, & standard_deviation___0, exception);
#line 1804
    FormatMagickString(statistic, 4096UL, "%g", standard_deviation___0);
    }
  }
  {
#line 1807
  tmp___8 = ConstantString((char const   *)(statistic));
#line 1807
  tmp___9 = ConstantString((char const   *)(key));
#line 1807
  AddValueToSplayTree(fx_info->symbols, (void const   *)tmp___9, (void const   *)tmp___8);
#line 1809
  tmp___10 = atof((char const   *)(statistic));
  }
#line 1809
  return ((1.0 / (double )65535UL) * tmp___10);
}
}
#line 1812
static MagickRealType FxEvaluateSubexpression(FxInfo *fx_info , ChannelType channel ,
                                              long x , long y , char const   *expression ,
                                              MagickRealType *beta , ExceptionInfo *exception ) ;
#line 1816 "magick/fx.c"
__inline static MagickRealType FxMax(FxInfo *fx_info , ChannelType channel , long x ,
                                     long y , char const   *expression , ExceptionInfo *exception ) 
{ MagickRealType alpha ;
  MagickRealType beta ;
  double tmp ;

  {
  {
#line 1823
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression, & beta, exception);
#line 1824
  tmp = MagickMax(alpha, beta);
  }
#line 1824
  return (tmp);
}
}
#line 1827 "magick/fx.c"
__inline static MagickRealType FxMin(FxInfo *fx_info , ChannelType channel , long x ,
                                     long y , char const   *expression , ExceptionInfo *exception ) 
{ MagickRealType alpha ;
  MagickRealType beta ;
  double tmp ;

  {
  {
#line 1834
  alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression, & beta, exception);
#line 1835
  tmp = MagickMin(alpha, beta);
  }
#line 1835
  return (tmp);
}
}
#line 1838 "magick/fx.c"
__inline static char const   *FxSubexpression(char const   *expression , ExceptionInfo *exception ) 
{ char const   *subexpression ;
  register long level ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1847
  level = 0L;
#line 1848
  subexpression = expression;
#line 1849
  while (1) {
#line 1849
    if ((int const   )*subexpression != 0) {
#line 1849
      if (! (level != 1L)) {
        {
#line 1849
        tmp___4 = __builtin_strchr((char *)")", (int )*subexpression);
        }
#line 1849
        if (! ((unsigned long )tmp___4 == (unsigned long )((char *)((void *)0)))) {
#line 1849
          break;
        }
      }
    } else {
#line 1849
      break;
    }
    {
#line 1852
    tmp___2 = __builtin_strchr((char *)"(", (int )*subexpression);
    }
#line 1852
    if ((unsigned long )tmp___2 != (unsigned long )((char *)((void *)0))) {
#line 1853
      level ++;
    } else {
      {
#line 1855
      tmp___0 = __builtin_strchr((char *)")", (int )*subexpression);
      }
#line 1855
      if ((unsigned long )tmp___0 != (unsigned long )((char *)((void *)0))) {
#line 1856
        level --;
      }
    }
#line 1857
    subexpression ++;
  }
#line 1859
  if ((int const   )*subexpression == 0) {
    {
#line 1860
    ThrowMagickException(exception, "magick/fx.c", "FxSubexpression", 1860UL, 410,
                         "UnbalancedParenthesis", "`%s\'", expression);
    }
  }
#line 1862
  return (subexpression);
}
}
#line 1865 "magick/fx.c"
static MagickRealType FxGetSymbol(FxInfo *fx_info , ChannelType channel , long x ,
                                  long y , char const   *expression , ExceptionInfo *exception ) 
{ char *q ;
  char subexpression[4096] ;
  char symbol[4096] ;
  char const   *p ;
  char const   *value ;
  Image *image ;
  MagickPixelPacket pixel ;
  MagickRealType alpha ;
  MagickRealType beta ;
  PointInfo point ;
  register long i ;
  size_t length ;
  unsigned long level ;
  char *tmp ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char name[4096] ;
  size_t tmp___9 ;
  MagickPixelPacket *color ;
  void *tmp___10 ;
  size_t tmp___11 ;
  MagickPixelPacket *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  MagickBooleanType tmp___15 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  GeometryInfo channel_info ;
  MagickStatusType flags ;
  long tmp___26 ;
  long tmp___27 ;
  MagickRealType tmp___28 ;
  long tmp___29 ;
  long tmp___30 ;
  MagickRealType tmp___31 ;
  long tmp___32 ;
  long tmp___33 ;
  long tmp___34 ;
  double hue ;
  double lightness ;
  double saturation ;
  Quantum tmp___35 ;
  Quantum tmp___36 ;
  Quantum tmp___37 ;
  long tmp___38 ;
  MagickRealType tmp___39 ;
  long tmp___40 ;
  long tmp___41 ;
  long tmp___42 ;
  long tmp___43 ;
  long tmp___44 ;
  long tmp___45 ;
  long tmp___46 ;
  long tmp___47 ;
  long tmp___48 ;
  Quantum tmp___49 ;
  long tmp___50 ;
  long tmp___51 ;
  long tmp___52 ;
  double hue___0 ;
  double lightness___0 ;
  double saturation___0 ;
  Quantum tmp___53 ;
  Quantum tmp___54 ;
  Quantum tmp___55 ;
  long tmp___56 ;
  double luminence ;
  long tmp___57 ;
  MagickRealType tmp___58 ;
  long tmp___59 ;
  MagickRealType tmp___60 ;
  long tmp___61 ;
  MagickRealType tmp___62 ;
  long tmp___63 ;
  long tmp___64 ;
  unsigned long tmp___65 ;
  long tmp___66 ;
  long tmp___67 ;
  long tmp___68 ;
  long tmp___69 ;
  long tmp___70 ;
  long tmp___71 ;
  long tmp___72 ;
  long tmp___73 ;
  long tmp___74 ;
  double hue___1 ;
  double lightness___1 ;
  double saturation___1 ;
  Quantum tmp___75 ;
  Quantum tmp___76 ;
  Quantum tmp___77 ;
  long tmp___78 ;
  MagickRealType tmp___79 ;
  long tmp___80 ;
  MagickRealType tmp___81 ;
  long tmp___82 ;
  long tmp___83 ;
  long tmp___84 ;
  long tmp___85 ;
  MagickRealType depth ;
  unsigned long tmp___86 ;
  long tmp___87 ;
  void *tmp___88 ;
  double tmp___89 ;

  {
  {
#line 1899
  p = expression;
#line 1900
  i = GetImageIndexInList(fx_info->images);
#line 1901
  level = 0UL;
#line 1902
  point.x = (double )x;
#line 1903
  point.y = (double )y;
#line 1904
  tmp___8 = __ctype_b_loc();
  }
#line 1904
  if (((int const   )*(*tmp___8 + (int )*(p + 1)) & 1024) == 0) {
    {
#line 1906
    tmp___2 = __builtin_strchr((char *)"suv", (int )*p);
    }
#line 1906
    if ((unsigned long )tmp___2 != (unsigned long )((char *)((void *)0))) {
#line 1908
      switch ((int )*p) {
      case 115: 
      default: 
      {
#line 1913
      i = GetImageIndexInList(fx_info->images);
      }
#line 1914
      break;
      case 117: 
#line 1916
      i = 0L;
#line 1916
      break;
      case 118: 
#line 1917
      i = 1L;
#line 1917
      break;
      }
#line 1919
      p ++;
#line 1920
      if ((int const   )*p == 91) {
#line 1922
        level ++;
#line 1923
        q = subexpression;
#line 1924
        p ++;
#line 1924
        while ((int const   )*p != 0) {
#line 1926
          if ((int const   )*p == 91) {
#line 1927
            level ++;
          } else {
#line 1929
            if ((int const   )*p == 93) {
#line 1931
              level --;
#line 1932
              if (level == 0UL) {
#line 1933
                break;
              }
            }
          }
#line 1935
          tmp = q;
#line 1935
          q ++;
#line 1935
          tmp___0 = p;
#line 1935
          p ++;
#line 1935
          *tmp = (char )*tmp___0;
        }
        {
#line 1937
        *q = (char )'\000';
#line 1938
        alpha = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)(subexpression),
                                        & beta, exception);
#line 1940
        i = (long )(alpha + 0.5);
#line 1941
        p ++;
        }
      }
#line 1943
      if ((int const   )*p == 46) {
#line 1944
        p ++;
      }
    }
    {
#line 1946
    tmp___7 = __ctype_b_loc();
    }
#line 1946
    if (((int const   )*(*tmp___7 + (int )*(p + 1)) & 1024) == 0) {
#line 1946
      if ((int const   )*p == 112) {
#line 1948
        p ++;
#line 1949
        if ((int const   )*p == 123) {
#line 1951
          level ++;
#line 1952
          q = subexpression;
#line 1953
          p ++;
#line 1953
          while ((int const   )*p != 0) {
#line 1955
            if ((int const   )*p == 123) {
#line 1956
              level ++;
            } else {
#line 1958
              if ((int const   )*p == 125) {
#line 1960
                level --;
#line 1961
                if (level == 0UL) {
#line 1962
                  break;
                }
              }
            }
#line 1964
            tmp___3 = q;
#line 1964
            q ++;
#line 1964
            tmp___4 = p;
#line 1964
            p ++;
#line 1964
            *tmp___3 = (char )*tmp___4;
          }
          {
#line 1966
          *q = (char )'\000';
#line 1967
          alpha = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)(subexpression),
                                          & beta, exception);
#line 1969
          point.x = alpha;
#line 1970
          point.y = beta;
#line 1971
          p ++;
          }
        } else {
#line 1974
          if ((int const   )*p == 91) {
#line 1976
            level ++;
#line 1977
            q = subexpression;
#line 1978
            p ++;
#line 1978
            while ((int const   )*p != 0) {
#line 1980
              if ((int const   )*p == 91) {
#line 1981
                level ++;
              } else {
#line 1983
                if ((int const   )*p == 93) {
#line 1985
                  level --;
#line 1986
                  if (level == 0UL) {
#line 1987
                    break;
                  }
                }
              }
#line 1989
              tmp___5 = q;
#line 1989
              q ++;
#line 1989
              tmp___6 = p;
#line 1989
              p ++;
#line 1989
              *tmp___5 = (char )*tmp___6;
            }
            {
#line 1991
            *q = (char )'\000';
#line 1992
            alpha = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)(subexpression),
                                            & beta, exception);
#line 1994
            point.x += alpha;
#line 1995
            point.y += beta;
#line 1996
            p ++;
            }
          }
        }
#line 1998
        if ((int const   )*p == 46) {
#line 1999
          p ++;
        }
      }
    }
  }
  {
#line 2002
  length = GetImageListLength(fx_info->images);
  }
#line 2003
  while (i < 0L) {
#line 2004
    i += (long )length;
  }
  {
#line 2005
  i = (long )((unsigned long )i % length);
#line 2006
  image = GetImageFromList(fx_info->images, i);
  }
#line 2007
  if ((unsigned long )image == (unsigned long )((Image *)((void *)0))) {
    {
#line 2009
    ThrowMagickException(exception, "magick/fx.c", "FxGetSymbol", 2009UL, 410, "NoSuchImage",
                         "`%s\'", expression);
    }
#line 2011
    return (0.0);
  }
  {
#line 2013
  ResamplePixelColor(*(fx_info->resample_filter + i), point.x, point.y, & pixel);
#line 2014
  tmp___18 = strlen(p);
  }
#line 2014
  if (tmp___18 > 2UL) {
    {
#line 2014
    tmp___19 = LocaleCompare(p, "intensity");
    }
#line 2014
    if (tmp___19 != 0L) {
      {
#line 2014
      tmp___20 = LocaleCompare(p, "luminance");
      }
#line 2014
      if (tmp___20 != 0L) {
        {
#line 2014
        tmp___21 = LocaleCompare(p, "hue");
        }
#line 2014
        if (tmp___21 != 0L) {
          {
#line 2014
          tmp___22 = LocaleCompare(p, "saturation");
          }
#line 2014
          if (tmp___22 != 0L) {
            {
#line 2014
            tmp___23 = LocaleCompare(p, "lightness");
            }
#line 2014
            if (tmp___23 != 0L) {
              {
#line 2024
              CopyMagickString(name, p, 4096UL);
#line 2025
              tmp___9 = strlen((char const   *)(name));
#line 2025
              q = name + (tmp___9 - 1UL);
              }
#line 2025
              while ((unsigned long )q > (unsigned long )(name)) {
#line 2027
                if ((int )*q == 41) {
#line 2028
                  break;
                }
#line 2029
                if ((int )*q == 46) {
#line 2031
                  *q = (char )'\000';
#line 2032
                  break;
                }
#line 2025
                q --;
              }
              {
#line 2035
              tmp___16 = strlen((char const   *)(name));
              }
#line 2035
              if (tmp___16 > 2UL) {
                {
#line 2035
                tmp___17 = GetValueFromSplayTree(fx_info->symbols, (void const   *)(name));
                }
#line 2035
                if ((unsigned long )tmp___17 == (unsigned long )((char const   *)((void *)0))) {
                  {
#line 2041
                  tmp___10 = GetValueFromSplayTree(fx_info->colors, (void const   *)(name));
#line 2041
                  color = (MagickPixelPacket *)tmp___10;
                  }
#line 2043
                  if ((unsigned long )color != (unsigned long )((MagickPixelPacket *)((void *)0))) {
                    {
#line 2045
                    pixel = *color;
#line 2046
                    tmp___11 = strlen((char const   *)(name));
#line 2046
                    p += tmp___11;
                    }
                  } else {
                    {
#line 2049
                    tmp___15 = QueryMagickColor((char const   *)(name), & pixel, fx_info->exception);
                    }
#line 2049
                    if ((int )tmp___15 != 0) {
                      {
#line 2051
                      tmp___12 = CloneMagickPixelPacket((MagickPixelPacket const   *)(& pixel));
#line 2051
                      tmp___13 = ConstantString((char const   *)(name));
#line 2051
                      AddValueToSplayTree(fx_info->colors, (void const   *)tmp___13,
                                          (void const   *)tmp___12);
#line 2053
                      tmp___14 = strlen((char const   *)(name));
#line 2053
                      p += tmp___14;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 2057
  CopyMagickString(symbol, p, 4096UL);
#line 2058
  StripString(symbol);
  }
#line 2059
  if ((int )symbol[0] == 0) {
#line 2061
    switch ((int )channel) {
    case 1: 
#line 2063
    return ((1.0 / (double )65535UL) * pixel.red);
    case 2: 
#line 2064
    return ((1.0 / (double )65535UL) * pixel.green);
    case 4: 
#line 2065
    return ((1.0 / (double )65535UL) * pixel.blue);
    case 8: 
#line 2068
    if ((int )pixel.matte == 0) {
#line 2070
      fx_info->matte = 0;
#line 2071
      return (1.0);
    }
#line 2073
    return ((1.0 / (double )65535UL) * ((MagickRealType )65535UL - pixel.opacity));
    case 32: 
#line 2077
    if ((int )image->colorspace != 12) {
      {
#line 2079
      ThrowMagickException(exception, "magick/fx.c", "FxGetSymbol", 2079UL, 410, "ColorSeparatedImageRequired",
                           "`%s\'", image->filename);
      }
#line 2082
      return (0.0);
    }
#line 2084
    return ((1.0 / (double )65535UL) * pixel.index);
    default: ;
#line 2087
    break;
    }
    {
#line 2089
    ThrowMagickException(exception, "magick/fx.c", "FxGetSymbol", 2089UL, 410, "UnableToParseExpression",
                         "`%s\'", p);
    }
#line 2091
    return (0.0);
  }
#line 2093
  switch ((int )symbol[0]) {
  case 65: 
  case 97: 
  {
#line 2098
  tmp___24 = LocaleCompare((char const   *)(symbol), "a");
  }
#line 2098
  if (tmp___24 == 0L) {
#line 2099
    return ((1.0 / (double )65535UL) * ((MagickRealType )65535UL - pixel.opacity));
  }
#line 2100
  break;
  case 66: 
  case 98: 
  {
#line 2105
  tmp___25 = LocaleCompare((char const   *)(symbol), "b");
  }
#line 2105
  if (tmp___25 == 0L) {
#line 2106
    return ((1.0 / (double )65535UL) * pixel.blue);
  }
#line 2107
  break;
  case 67: 
  case 99: 
  {
#line 2112
  tmp___26 = LocaleNCompare((char const   *)(symbol), "channel", 7UL);
  }
#line 2112
  if (tmp___26 == 0L) {
    {
#line 2120
    flags = ParseGeometry((char const   *)(symbol + 7), & channel_info);
    }
#line 2121
    if ((int )image->colorspace == 12) {
#line 2122
      switch ((int )channel) {
      case 1: 
#line 2126
      if ((flags & 4U) == 0U) {
#line 2127
        return (0.0);
      }
#line 2128
      return (channel_info.rho);
      case 2: 
#line 2132
      if ((flags & 8U) == 0U) {
#line 2133
        return (0.0);
      }
#line 2134
      return (channel_info.sigma);
      case 4: 
#line 2138
      if ((flags & 1U) == 0U) {
#line 2139
        return (0.0);
      }
#line 2140
      return (channel_info.xi);
      case 32: 
#line 2144
      if ((flags & 2U) == 0U) {
#line 2145
        return (0.0);
      }
#line 2146
      return (channel_info.psi);
      case 8: 
#line 2150
      if ((flags & 16U) == 0U) {
#line 2151
        return (0.0);
      }
#line 2152
      return (channel_info.chi);
      default: ;
#line 2155
      return (0.0);
      }
    }
#line 2157
    switch ((int )channel) {
    case 1: 
#line 2161
    if ((flags & 4U) == 0U) {
#line 2162
      return (0.0);
    }
#line 2163
    return (channel_info.rho);
    case 2: 
#line 2167
    if ((flags & 8U) == 0U) {
#line 2168
      return (0.0);
    }
#line 2169
    return (channel_info.sigma);
    case 4: 
#line 2173
    if ((flags & 1U) == 0U) {
#line 2174
      return (0.0);
    }
#line 2175
    return (channel_info.xi);
    case 8: 
#line 2179
    if ((flags & 2U) == 0U) {
#line 2180
      return (0.0);
    }
#line 2181
    return (channel_info.psi);
    case 32: 
#line 2185
    if ((flags & 16U) == 0U) {
#line 2186
      return (0.0);
    }
#line 2187
    return (channel_info.chi);
    default: ;
#line 2190
    return (0.0);
    }
#line 2192
    return (0.0);
  }
  {
#line 2194
  tmp___27 = LocaleCompare((char const   *)(symbol), "c");
  }
#line 2194
  if (tmp___27 == 0L) {
#line 2195
    return ((1.0 / (double )65535UL) * pixel.red);
  }
#line 2196
  break;
  case 68: 
  case 100: 
  {
#line 2201
  tmp___29 = LocaleNCompare((char const   *)(symbol), "depth", 5UL);
  }
#line 2201
  if (tmp___29 == 0L) {
    {
#line 2202
    tmp___28 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2202
    return (tmp___28);
  }
#line 2203
  break;
  case 71: 
  case 103: 
  {
#line 2208
  tmp___30 = LocaleCompare((char const   *)(symbol), "g");
  }
#line 2208
  if (tmp___30 == 0L) {
#line 2209
    return ((1.0 / (double )65535UL) * pixel.green);
  }
#line 2210
  break;
  case 75: 
  case 107: 
  {
#line 2215
  tmp___32 = LocaleNCompare((char const   *)(symbol), "kurtosis", 8UL);
  }
#line 2215
  if (tmp___32 == 0L) {
    {
#line 2216
    tmp___31 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2216
    return (tmp___31);
  }
  {
#line 2217
  tmp___33 = LocaleCompare((char const   *)(symbol), "k");
  }
#line 2217
  if (tmp___33 == 0L) {
#line 2219
    if ((int )image->colorspace != 12) {
      {
#line 2221
      ThrowMagickException(exception, "magick/fx.c", "FxGetSymbol", 2221UL, 410, "ColorSeparatedImageRequired",
                           "`%s\'", image->filename);
      }
#line 2224
      return (0.0);
    }
#line 2226
    return ((1.0 / (double )65535UL) * pixel.index);
  }
#line 2228
  break;
  case 72: 
  case 104: 
  {
#line 2233
  tmp___34 = LocaleCompare((char const   *)(symbol), "h");
  }
#line 2233
  if (tmp___34 == 0L) {
#line 2234
    return ((double )image->rows);
  }
  {
#line 2235
  tmp___38 = LocaleCompare((char const   *)(symbol), "hue");
  }
#line 2235
  if (tmp___38 == 0L) {
    {
#line 2242
    tmp___35 = RoundToQuantum(pixel.blue);
#line 2242
    tmp___36 = RoundToQuantum(pixel.green);
#line 2242
    tmp___37 = RoundToQuantum(pixel.red);
#line 2242
    ConvertRGBToHSL(tmp___37, tmp___36, tmp___35, & hue, & saturation, & lightness);
    }
#line 2244
    return (hue);
  }
#line 2246
  break;
  case 73: 
  case 105: 
  {
#line 2251
  tmp___40 = LocaleCompare((char const   *)(symbol), "image.depth");
  }
#line 2251
  if (tmp___40 == 0L) {
    {
#line 2258
    tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol + 6),
                                   exception);
    }
#line 2258
    return (tmp___39);
  } else {
    {
#line 2251
    tmp___41 = LocaleCompare((char const   *)(symbol), "image.minima");
    }
#line 2251
    if (tmp___41 == 0L) {
      {
#line 2258
      tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol + 6),
                                     exception);
      }
#line 2258
      return (tmp___39);
    } else {
      {
#line 2251
      tmp___42 = LocaleCompare((char const   *)(symbol), "image.maxima");
      }
#line 2251
      if (tmp___42 == 0L) {
        {
#line 2258
        tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol + 6),
                                       exception);
        }
#line 2258
        return (tmp___39);
      } else {
        {
#line 2251
        tmp___43 = LocaleCompare((char const   *)(symbol), "image.mean");
        }
#line 2251
        if (tmp___43 == 0L) {
          {
#line 2258
          tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel,
                                         (char const   *)(symbol + 6), exception);
          }
#line 2258
          return (tmp___39);
        } else {
          {
#line 2251
          tmp___44 = LocaleCompare((char const   *)(symbol), "image.kurtosis");
          }
#line 2251
          if (tmp___44 == 0L) {
            {
#line 2258
            tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel,
                                           (char const   *)(symbol + 6), exception);
            }
#line 2258
            return (tmp___39);
          } else {
            {
#line 2251
            tmp___45 = LocaleCompare((char const   *)(symbol), "image.skewness");
            }
#line 2251
            if (tmp___45 == 0L) {
              {
#line 2258
              tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel,
                                             (char const   *)(symbol + 6), exception);
              }
#line 2258
              return (tmp___39);
            } else {
              {
#line 2251
              tmp___46 = LocaleCompare((char const   *)(symbol), "image.standard_deviation");
              }
#line 2251
              if (tmp___46 == 0L) {
                {
#line 2258
                tmp___39 = FxChannelStatistics(fx_info, (Image const   *)image, channel,
                                               (char const   *)(symbol + 6), exception);
                }
#line 2258
                return (tmp___39);
              }
            }
          }
        }
      }
    }
  }
  {
#line 2259
  tmp___47 = LocaleCompare((char const   *)(symbol), "image.resolution.x");
  }
#line 2259
  if (tmp___47 == 0L) {
#line 2260
    return (image->x_resolution);
  }
  {
#line 2261
  tmp___48 = LocaleCompare((char const   *)(symbol), "image.resolution.y");
  }
#line 2261
  if (tmp___48 == 0L) {
#line 2262
    return (image->y_resolution);
  }
  {
#line 2263
  tmp___50 = LocaleCompare((char const   *)(symbol), "intensity");
  }
#line 2263
  if (tmp___50 == 0L) {
    {
#line 2264
    tmp___49 = MagickPixelIntensityToQuantum((MagickPixelPacket const   *)(& pixel));
    }
#line 2264
    return ((1.0 / (double )65535UL) * (double )tmp___49);
  }
  {
#line 2265
  tmp___51 = LocaleCompare((char const   *)(symbol), "i");
  }
#line 2265
  if (tmp___51 == 0L) {
#line 2266
    return ((double )x);
  }
#line 2267
  break;
  case 74: 
  case 106: 
  {
#line 2272
  tmp___52 = LocaleCompare((char const   *)(symbol), "j");
  }
#line 2272
  if (tmp___52 == 0L) {
#line 2273
    return ((double )y);
  }
#line 2274
  break;
  case 76: 
  case 108: 
  {
#line 2279
  tmp___56 = LocaleCompare((char const   *)(symbol), "lightness");
  }
#line 2279
  if (tmp___56 == 0L) {
    {
#line 2286
    tmp___53 = RoundToQuantum(pixel.blue);
#line 2286
    tmp___54 = RoundToQuantum(pixel.green);
#line 2286
    tmp___55 = RoundToQuantum(pixel.red);
#line 2286
    ConvertRGBToHSL(tmp___55, tmp___54, tmp___53, & hue___0, & saturation___0, & lightness___0);
    }
#line 2288
    return (lightness___0);
  }
  {
#line 2290
  tmp___57 = LocaleCompare((char const   *)(symbol), "luminance");
  }
#line 2290
  if (tmp___57 == 0L) {
#line 2295
    luminence = (0.2126 * pixel.red + 0.7152 * pixel.green) + 0.0722 * pixel.blue;
#line 2296
    return ((1.0 / (double )65535UL) * luminence);
  }
#line 2298
  break;
  case 77: 
  case 109: 
  {
#line 2303
  tmp___59 = LocaleNCompare((char const   *)(symbol), "maxima", 6UL);
  }
#line 2303
  if (tmp___59 == 0L) {
    {
#line 2304
    tmp___58 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2304
    return (tmp___58);
  }
  {
#line 2305
  tmp___61 = LocaleNCompare((char const   *)(symbol), "mean", 4UL);
  }
#line 2305
  if (tmp___61 == 0L) {
    {
#line 2306
    tmp___60 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2306
    return (tmp___60);
  }
  {
#line 2307
  tmp___63 = LocaleNCompare((char const   *)(symbol), "minima", 6UL);
  }
#line 2307
  if (tmp___63 == 0L) {
    {
#line 2308
    tmp___62 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2308
    return (tmp___62);
  }
  {
#line 2309
  tmp___64 = LocaleCompare((char const   *)(symbol), "m");
  }
#line 2309
  if (tmp___64 == 0L) {
#line 2310
    return ((1.0 / (double )65535UL) * pixel.blue);
  }
#line 2311
  break;
  case 78: 
  case 110: 
  {
#line 2316
  tmp___66 = LocaleCompare((char const   *)(symbol), "n");
  }
#line 2316
  if (tmp___66 == 0L) {
    {
#line 2317
    tmp___65 = GetImageListLength(fx_info->images);
    }
#line 2317
    return ((double )tmp___65);
  }
#line 2318
  break;
  case 79: 
  case 111: 
  {
#line 2323
  tmp___67 = LocaleCompare((char const   *)(symbol), "o");
  }
#line 2323
  if (tmp___67 == 0L) {
#line 2324
    return ((1.0 / (double )65535UL) * pixel.opacity);
  }
#line 2325
  break;
  case 80: 
  case 112: 
  {
#line 2330
  tmp___68 = LocaleCompare((char const   *)(symbol), "page.height");
  }
#line 2330
  if (tmp___68 == 0L) {
#line 2331
    return ((double )image->page.height);
  }
  {
#line 2332
  tmp___69 = LocaleCompare((char const   *)(symbol), "page.width");
  }
#line 2332
  if (tmp___69 == 0L) {
#line 2333
    return ((double )image->page.width);
  }
  {
#line 2334
  tmp___70 = LocaleCompare((char const   *)(symbol), "page.x");
  }
#line 2334
  if (tmp___70 == 0L) {
#line 2335
    return ((double )image->page.x);
  }
  {
#line 2336
  tmp___71 = LocaleCompare((char const   *)(symbol), "page.y");
  }
#line 2336
  if (tmp___71 == 0L) {
#line 2337
    return ((double )image->page.y);
  }
#line 2338
  break;
  case 82: 
  case 114: 
  {
#line 2343
  tmp___72 = LocaleCompare((char const   *)(symbol), "resolution.x");
  }
#line 2343
  if (tmp___72 == 0L) {
#line 2344
    return (image->x_resolution);
  }
  {
#line 2345
  tmp___73 = LocaleCompare((char const   *)(symbol), "resolution.y");
  }
#line 2345
  if (tmp___73 == 0L) {
#line 2346
    return (image->y_resolution);
  }
  {
#line 2347
  tmp___74 = LocaleCompare((char const   *)(symbol), "r");
  }
#line 2347
  if (tmp___74 == 0L) {
#line 2348
    return ((1.0 / (double )65535UL) * pixel.red);
  }
#line 2349
  break;
  case 83: 
  case 115: 
  {
#line 2354
  tmp___78 = LocaleCompare((char const   *)(symbol), "saturation");
  }
#line 2354
  if (tmp___78 == 0L) {
    {
#line 2361
    tmp___75 = RoundToQuantum(pixel.blue);
#line 2361
    tmp___76 = RoundToQuantum(pixel.green);
#line 2361
    tmp___77 = RoundToQuantum(pixel.red);
#line 2361
    ConvertRGBToHSL(tmp___77, tmp___76, tmp___75, & hue___1, & saturation___1, & lightness___1);
    }
#line 2363
    return (saturation___1);
  }
  {
#line 2365
  tmp___80 = LocaleNCompare((char const   *)(symbol), "skewness", 8UL);
  }
#line 2365
  if (tmp___80 == 0L) {
    {
#line 2366
    tmp___79 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2366
    return (tmp___79);
  }
  {
#line 2367
  tmp___82 = LocaleNCompare((char const   *)(symbol), "standard_deviation", 18UL);
  }
#line 2367
  if (tmp___82 == 0L) {
    {
#line 2368
    tmp___81 = FxChannelStatistics(fx_info, (Image const   *)image, channel, (char const   *)(symbol),
                                   exception);
    }
#line 2368
    return (tmp___81);
  }
#line 2369
  break;
  case 84: 
  case 116: 
  {
#line 2374
  tmp___83 = LocaleCompare((char const   *)(symbol), "t");
  }
#line 2374
  if (tmp___83 == 0L) {
#line 2375
    return ((double )(fx_info->images)->scene);
  }
#line 2376
  break;
  case 87: 
  case 119: 
  {
#line 2381
  tmp___84 = LocaleCompare((char const   *)(symbol), "w");
  }
#line 2381
  if (tmp___84 == 0L) {
#line 2382
    return ((double )image->columns);
  }
#line 2383
  break;
  case 89: 
  case 121: 
  {
#line 2388
  tmp___85 = LocaleCompare((char const   *)(symbol), "y");
  }
#line 2388
  if (tmp___85 == 0L) {
#line 2389
    return ((1.0 / (double )65535UL) * pixel.green);
  }
#line 2390
  break;
  case 90: 
  case 122: 
  {
#line 2395
  tmp___87 = LocaleCompare((char const   *)(symbol), "z");
  }
#line 2395
  if (tmp___87 == 0L) {
    {
#line 2400
    tmp___86 = GetImageChannelDepth((Image const   *)image, channel, fx_info->exception);
#line 2400
    depth = (double )tmp___86;
    }
#line 2402
    return (depth);
  }
#line 2404
  break;
  default: ;
#line 2407
  break;
  }
  {
#line 2409
  tmp___88 = GetValueFromSplayTree(fx_info->symbols, (void const   *)(symbol));
#line 2409
  value = (char const   *)tmp___88;
  }
#line 2410
  if ((unsigned long )value != (unsigned long )((char const   *)((void *)0))) {
    {
#line 2411
    tmp___89 = atof(value);
    }
#line 2411
    return (tmp___89);
  }
  {
#line 2412
  ThrowMagickException(exception, "magick/fx.c", "FxGetSymbol", 2412UL, 410, "UnableToParseExpression",
                       "`%s\'", symbol);
  }
#line 2414
  return (0.0);
}
}
#line 2417 "magick/fx.c"
static char const   *FxOperatorPrecedence(char const   *expression , ExceptionInfo *exception ) 
{ FxPrecedence precedence ;
  FxPrecedence target ;
  register char const   *subexpression ;
  register int c ;
  unsigned long level ;
  unsigned short const   **tmp ;
  long tmp___0 ;
  unsigned short const   **tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  void *tmp___14 ;
  char *tmp___15 ;
  char const   *tmp___16 ;

  {
#line 2454
  c = 0;
#line 2455
  level = 0UL;
#line 2456
  subexpression = (char const   *)((void *)0);
#line 2457
  target = 1;
#line 2458
  while ((int const   )*expression != 0) {
    {
#line 2460
    precedence = 0;
#line 2461
    tmp = __ctype_b_loc();
    }
#line 2461
    if (((int const   )*(*tmp + (int )((char )*expression)) & 8192) != 0) {
#line 2463
      expression ++;
#line 2464
      continue;
    } else {
#line 2461
      if (c == 64) {
#line 2463
        expression ++;
#line 2464
        continue;
      }
    }
    {
#line 2466
    tmp___0 = LocaleNCompare(expression, "atan2", 5UL);
    }
#line 2466
    if (tmp___0 == 0L) {
#line 2468
      expression += 5;
#line 2469
      continue;
    }
#line 2471
    if (c == 123) {
#line 2472
      level ++;
    } else {
#line 2471
      if (c == 91) {
#line 2472
        level ++;
      } else {
#line 2474
        if (c == 125) {
#line 2475
          level --;
        } else {
#line 2474
          if (c == 93) {
#line 2475
            level --;
          }
        }
      }
    }
#line 2476
    if (level == 0UL) {
#line 2477
      switch ((int )((unsigned char )*expression)) {
      case 126: 
      case 33: 
#line 2482
      precedence = 2;
#line 2483
      break;
      case 94: 
#line 2487
      precedence = 3;
#line 2488
      break;
      default: ;
#line 2492
      if (c != 0) {
        {
#line 2492
        tmp___1 = __ctype_b_loc();
        }
#line 2492
        if (((int const   )*(*tmp___1 + (int )((char )c)) & 2048) != 0) {
          goto _L___0;
        } else {
          {
#line 2492
          tmp___3 = __builtin_strchr((char *)")", c);
          }
#line 2492
          if ((unsigned long )tmp___3 != (unsigned long )((char *)((void *)0))) {
            _L___0: /* CIL Label */ 
            {
#line 2492
            tmp___4 = __ctype_b_loc();
            }
#line 2492
            if (((int const   )*(*tmp___4 + (int )((char )*expression)) & 512) != 0) {
              goto _L;
            } else {
              {
#line 2492
              tmp___6 = __builtin_strchr((char *)"(", (int )*expression);
              }
#line 2492
              if ((unsigned long )tmp___6 != (unsigned long )((char *)((void *)0))) {
                goto _L;
              } else {
                {
#line 2492
                tmp___7 = __ctype_b_loc();
                }
#line 2492
                if (((int const   )*(*tmp___7 + (int )((char )c)) & 2048) == 0) {
                  {
#line 2492
                  tmp___8 = __ctype_b_loc();
                  }
#line 2492
                  if (((int const   )*(*tmp___8 + (int )((char )*expression)) & 2048) != 0) {
                    _L: /* CIL Label */ 
                    {
#line 2492
                    tmp___10 = __builtin_strchr((char *)"xy", (int )*expression);
                    }
#line 2492
                    if ((unsigned long )tmp___10 == (unsigned long )((char *)((void *)0))) {
#line 2499
                      precedence = 4;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 2500
      break;
      case 42: 
      case 47: 
      case 37: 
#line 2506
      precedence = 4;
#line 2507
      break;
      case 43: 
      case 45: 
      {
#line 2512
      tmp___12 = __builtin_strchr((char *)"(+-/*%:&^|<>~,", c);
      }
#line 2512
      if ((unsigned long )tmp___12 == (unsigned long )((char *)((void *)0))) {
#line 2514
        precedence = 5;
      } else {
        {
#line 2512
        tmp___13 = __ctype_b_loc();
        }
#line 2512
        if (((int const   )*(*tmp___13 + c) & 1024) != 0) {
#line 2514
          precedence = 5;
        }
      }
#line 2515
      break;
      case 245: 
      case 246: 
#line 2520
      precedence = 6;
#line 2521
      break;
      case 60: 
      case 247: 
      case 248: 
      case 62: 
#line 2528
      precedence = 7;
#line 2529
      break;
      case 249: 
      case 250: 
#line 2534
      precedence = 8;
#line 2535
      break;
      case 38: 
#line 2539
      precedence = 9;
#line 2540
      break;
      case 124: 
#line 2544
      precedence = 10;
#line 2545
      break;
      case 251: 
#line 2549
      precedence = 11;
#line 2550
      break;
      case 252: 
#line 2554
      precedence = 12;
#line 2555
      break;
      case 58: 
      case 63: 
#line 2560
      precedence = 13;
#line 2561
      break;
      case 61: 
#line 2565
      precedence = 14;
#line 2566
      break;
      case 44: 
#line 2570
      precedence = 15;
#line 2571
      break;
      case 59: 
#line 2575
      precedence = 16;
#line 2576
      break;
      }
    }
#line 2579
    if ((int )precedence == 2) {
      goto _L___1;
    } else {
#line 2579
      if ((int )precedence == 13) {
        goto _L___1;
      } else {
#line 2579
        if ((int )precedence == 14) {
          _L___1: /* CIL Label */ 
#line 2583
          if ((int )precedence > (int )target) {
#line 2588
            target = precedence;
#line 2589
            subexpression = expression;
          }
        } else {
#line 2593
          if ((int )precedence >= (int )target) {
#line 2598
            target = precedence;
#line 2599
            subexpression = expression;
          }
        }
      }
    }
    {
#line 2601
    tmp___15 = __builtin_strchr((char *)"(", (int )*expression);
    }
#line 2601
    if ((unsigned long )tmp___15 != (unsigned long )((char *)((void *)0))) {
      {
#line 2602
      expression = FxSubexpression(expression, exception);
      }
    }
#line 2603
    tmp___16 = expression;
#line 2603
    expression ++;
#line 2603
    c = (int )*tmp___16;
  }
#line 2605
  return (subexpression);
}
}
#line 2608 "magick/fx.c"
static MagickRealType FxEvaluateSubexpression(FxInfo *fx_info , ChannelType channel ,
                                              long x , long y , char const   *expression ,
                                              MagickRealType *beta , ExceptionInfo *exception ) 
{ char *q ;
  char subexpression[4096] ;
  MagickRealType alpha ;
  MagickRealType gamma___0 ;
  register char const   *p ;
  unsigned short const   **tmp ;
  double tmp___0 ;
  MagickRealType tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  MagickRealType gamma___1 ;
  char *tmp___14 ;
  double tmp___15 ;
  char numeric[4096] ;
  unsigned short const   **tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  MagickRealType tmp___19 ;
  size_t tmp___20 ;
  void *tmp___21 ;
  char *tmp___22 ;
  double tmp___23 ;
  long tmp___24 ;
  double tmp___25 ;
  long tmp___26 ;
  double tmp___27 ;
  long tmp___28 ;
  double tmp___29 ;
  long tmp___30 ;
  double tmp___31 ;
  long tmp___32 ;
  double tmp___33 ;
  long tmp___34 ;
  MagickRealType tmp___35 ;
  long tmp___36 ;
  MagickRealType tmp___37 ;
  long tmp___38 ;
  double tmp___39 ;
  long tmp___40 ;
  double tmp___41 ;
  long tmp___42 ;
  double tmp___43 ;
  long tmp___44 ;
  MagickRealType tmp___45 ;
  long tmp___46 ;
  char const   *type ;
  size_t tmp___47 ;
  size_t tmp___48 ;
  long tmp___49 ;
  long tmp___50 ;
  double tmp___51 ;
  long tmp___52 ;
  long tmp___53 ;
  double tmp___54 ;
  long tmp___55 ;
  MagickRealType tmp___56 ;
  long tmp___57 ;
  MagickRealType tmp___58 ;
  long tmp___59 ;
  MagickRealType tmp___60 ;
  long tmp___61 ;
  double tmp___62 ;
  long tmp___63 ;
  MagickRealType tmp___64 ;
  long tmp___65 ;
  MagickRealType tmp___66 ;
  long tmp___67 ;
  double tmp___68 ;
  long tmp___69 ;
  MagickRealType tmp___70 ;
  long tmp___71 ;
  MagickRealType tmp___72 ;
  long tmp___73 ;
  double tmp___74 ;
  long tmp___75 ;
  double tmp___76 ;
  double tmp___77 ;
  long tmp___78 ;
  double tmp___79 ;
  long tmp___80 ;
  MagickRealType tmp___81 ;
  long tmp___82 ;
  long tmp___83 ;
  long tmp___84 ;
  MagickRealType tmp___85 ;
  long tmp___86 ;
  long tmp___87 ;
  MagickRealType tmp___88 ;
  long tmp___89 ;
  double tmp___90 ;
  long tmp___91 ;
  MagickRealType tmp___92 ;
  long tmp___93 ;
  MagickRealType tmp___94 ;
  long tmp___95 ;
  long tmp___96 ;
  MagickRealType tmp___97 ;
  long tmp___98 ;
  long tmp___99 ;
  double tmp___100 ;
  long tmp___101 ;
  MagickRealType tmp___102 ;
  long tmp___103 ;
  long tmp___104 ;
  long tmp___105 ;
  double tmp___106 ;
  long tmp___107 ;
  double tmp___108 ;
  double tmp___109 ;
  long tmp___110 ;
  MagickRealType tmp___111 ;
  long tmp___112 ;
  MagickRealType tmp___113 ;
  long tmp___114 ;
  double tmp___115 ;
  long tmp___116 ;
  double tmp___117 ;
  long tmp___118 ;
  double tmp___119 ;
  long tmp___120 ;
  double tmp___121 ;
  long tmp___122 ;
  MagickRealType tmp___123 ;
  long tmp___124 ;
  double tmp___125 ;
  long tmp___126 ;
  double tmp___127 ;
  long tmp___128 ;
  long tmp___129 ;
  MagickRealType tmp___130 ;
  long tmp___131 ;
  MagickRealType tmp___132 ;
  long tmp___133 ;
  MagickRealType tmp___134 ;
  long tmp___135 ;
  MagickRealType tmp___136 ;
  long tmp___137 ;
  MagickRealType tmp___138 ;
  long tmp___139 ;
  MagickRealType tmp___140 ;
  long tmp___141 ;
  MagickRealType tmp___142 ;

  {
#line 2623
  *beta = 0.0;
#line 2624
  if ((int )exception->severity != 0) {
#line 2625
    return (0.0);
  }
#line 2626
  while (1) {
    {
#line 2626
    tmp = __ctype_b_loc();
    }
#line 2626
    if (! (((int const   )*(*tmp + (int )*expression) & 8192) != 0)) {
#line 2626
      break;
    }
#line 2627
    expression ++;
  }
#line 2628
  if ((int const   )*expression == 0) {
    {
#line 2630
    ThrowMagickException(exception, "magick/fx.c", "FxEvaluateSubexpression", 2630UL,
                         410, "MissingExpression", "`%s\'", expression);
    }
#line 2632
    return (0.0);
  }
  {
#line 2634
  p = FxOperatorPrecedence(expression, exception);
  }
#line 2635
  if ((unsigned long )p != (unsigned long )((char const   *)((void *)0))) {
    {
#line 2637
    CopyMagickString(subexpression, expression, (unsigned long )((p - expression) + 1));
#line 2639
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)(subexpression),
                                    beta, exception);
    }
#line 2641
    switch ((int )((unsigned char )*p)) {
    case 126: 
    {
#line 2645
    p ++;
#line 2645
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2646
    *beta = (double )(~ ((unsigned long )*beta));
    }
#line 2647
    return (*beta);
    case 33: 
    {
#line 2651
    p ++;
#line 2651
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2652
    if (*beta == 0.0) {
#line 2652
      tmp___0 = 1.0;
    } else {
#line 2652
      tmp___0 = 0.0;
    }
#line 2652
    return (tmp___0);
    case 94: 
    {
#line 2656
    p ++;
#line 2656
    tmp___1 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2656
    *beta = pow(alpha, tmp___1);
    }
#line 2658
    return (*beta);
    case 42: 
    {
#line 2662
    p ++;
#line 2662
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2663
    return (alpha * *beta);
    case 47: 
    {
#line 2667
    p ++;
#line 2667
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2668
    if (*beta == 0.0) {
#line 2670
      if ((int )exception->severity == 0) {
        {
#line 2671
        ThrowMagickException(exception, "magick/fx.c", "FxEvaluateSubexpression",
                             2671UL, 410, "DivideByZero", "`%s\'", expression);
        }
      }
#line 2673
      return (0.0);
    }
#line 2675
    return (alpha / *beta);
    case 37: 
    {
#line 2679
    p ++;
#line 2679
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2680
    tmp___2 = floor(*beta + 0.5);
#line 2680
    *beta = fabs(tmp___2);
    }
#line 2681
    if (*beta == 0.0) {
      {
#line 2683
      ThrowMagickException(exception, "magick/fx.c", "FxEvaluateSubexpression", 2683UL,
                           410, "DivideByZero", "`%s\'", expression);
      }
#line 2685
      return (0.0);
    }
    {
#line 2687
    tmp___3 = fmod(alpha, *beta);
    }
#line 2687
    return (tmp___3);
    case 43: 
    {
#line 2691
    p ++;
#line 2691
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2692
    return (alpha + *beta);
    case 45: 
    {
#line 2696
    p ++;
#line 2696
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2697
    return (alpha - *beta);
    case 245: 
    {
#line 2701
    p ++;
#line 2701
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2702
    *beta = (double )((unsigned long )(alpha + 0.5) << (unsigned long )(gamma___0 + 0.5));
    }
#line 2704
    return (*beta);
    case 246: 
    {
#line 2708
    p ++;
#line 2708
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2709
    *beta = (double )((unsigned long )(alpha + 0.5) >> (unsigned long )(gamma___0 + 0.5));
    }
#line 2711
    return (*beta);
    case 60: 
    {
#line 2715
    p ++;
#line 2715
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2716
    if (alpha < *beta) {
#line 2716
      tmp___4 = 1.0;
    } else {
#line 2716
      tmp___4 = 0.0;
    }
#line 2716
    return (tmp___4);
    case 247: 
    {
#line 2720
    p ++;
#line 2720
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2721
    if (alpha <= *beta) {
#line 2721
      tmp___5 = 1.0;
    } else {
#line 2721
      tmp___5 = 0.0;
    }
#line 2721
    return (tmp___5);
    case 62: 
    {
#line 2725
    p ++;
#line 2725
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2726
    if (alpha > *beta) {
#line 2726
      tmp___6 = 1.0;
    } else {
#line 2726
      tmp___6 = 0.0;
    }
#line 2726
    return (tmp___6);
    case 248: 
    {
#line 2730
    p ++;
#line 2730
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2731
    if (alpha >= *beta) {
#line 2731
      tmp___7 = 1.0;
    } else {
#line 2731
      tmp___7 = 0.0;
    }
#line 2731
    return (tmp___7);
    case 249: 
    {
#line 2735
    p ++;
#line 2735
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2736
    tmp___10 = fabs(alpha - *beta);
    }
#line 2736
    if (tmp___10 <= 1.0e-10) {
#line 2736
      tmp___9 = 1.0;
    } else {
#line 2736
      tmp___9 = 0.0;
    }
#line 2736
    return (tmp___9);
    case 250: 
    {
#line 2740
    p ++;
#line 2740
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2741
    tmp___13 = fabs(alpha - *beta);
    }
#line 2741
    if (tmp___13 > 1.0e-10) {
#line 2741
      tmp___12 = 1.0;
    } else {
#line 2741
      tmp___12 = 0.0;
    }
#line 2741
    return (tmp___12);
    case 38: 
    {
#line 2745
    p ++;
#line 2745
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2746
    *beta = (double )((unsigned long )(alpha + 0.5) & (unsigned long )(gamma___0 + 0.5));
    }
#line 2748
    return (*beta);
    case 124: 
    {
#line 2752
    p ++;
#line 2752
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2753
    *beta = (double )((unsigned long )(alpha + 0.5) | (unsigned long )(gamma___0 + 0.5));
    }
#line 2755
    return (*beta);
    case 251: 
    {
#line 2759
    p ++;
#line 2759
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2760
    if (alpha > 0.0) {
#line 2760
      if (gamma___0 > 0.0) {
#line 2760
        *beta = 1.0;
      } else {
#line 2760
        *beta = 0.0;
      }
    } else {
#line 2760
      *beta = 0.0;
    }
#line 2761
    return (*beta);
    case 252: 
    {
#line 2765
    p ++;
#line 2765
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2766
    if (alpha > 0.0) {
#line 2766
      *beta = 1.0;
    } else {
#line 2766
      if (gamma___0 > 0.0) {
#line 2766
        *beta = 1.0;
      } else {
#line 2766
        *beta = 0.0;
      }
    }
#line 2767
    return (*beta);
    case 63: 
    {
#line 2774
    p ++;
#line 2774
    CopyMagickString(subexpression, p, 4096UL);
#line 2775
    q = subexpression;
#line 2776
    tmp___14 = StringToken(":", & q);
#line 2776
    p = (char const   *)tmp___14;
    }
#line 2777
    if ((unsigned long )q == (unsigned long )((char *)((void *)0))) {
      {
#line 2779
      ThrowMagickException(exception, "magick/fx.c", "FxEvaluateSubexpression", 2779UL,
                           410, "UnableToParseExpression", "`%s\'", subexpression);
      }
#line 2781
      return (0.0);
    }
    {
#line 2783
    tmp___15 = fabs(alpha);
    }
#line 2783
    if (tmp___15 > 1.0e-10) {
      {
#line 2784
      gamma___1 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
      }
    } else {
      {
#line 2786
      gamma___1 = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)q,
                                          beta, exception);
      }
    }
#line 2787
    return (gamma___1);
    case 61: 
#line 2794
    q = subexpression;
#line 2795
    while (1) {
      {
#line 2795
      tmp___16 = __ctype_b_loc();
      }
#line 2795
      if (! (((int const   )*(*tmp___16 + (int )((unsigned char )*q)) & 1024) != 0)) {
#line 2795
        break;
      }
#line 2796
      q ++;
    }
#line 2797
    if ((int )*q != 0) {
      {
#line 2799
      ThrowMagickException(exception, "magick/fx.c", "FxEvaluateSubexpression", 2799UL,
                           410, "UnableToParseExpression", "`%s\'", subexpression);
      }
#line 2801
      return (0.0);
    }
    {
#line 2803
    ClearMagickException(exception);
#line 2804
    p ++;
#line 2804
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2805
    FormatMagickString(numeric, 4096UL, "%g", *beta);
#line 2806
    DeleteNodeFromSplayTree(fx_info->symbols, (void const   *)(subexpression));
#line 2807
    tmp___17 = ConstantString((char const   *)(numeric));
#line 2807
    tmp___18 = ConstantString((char const   *)(subexpression));
#line 2807
    AddValueToSplayTree(fx_info->symbols, (void const   *)tmp___18, (void const   *)tmp___17);
    }
#line 2809
    return (*beta);
    case 44: 
    {
#line 2813
    p ++;
#line 2813
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2814
    return (alpha);
    case 59: 
    {
#line 2818
    p ++;
#line 2818
    *beta = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
    }
#line 2819
    return (*beta);
    default: 
    {
#line 2823
    tmp___19 = FxEvaluateSubexpression(fx_info, channel, x, y, p, beta, exception);
#line 2823
    gamma___0 = alpha * tmp___19;
    }
#line 2825
    return (gamma___0);
    }
  }
  {
#line 2829
  tmp___22 = __builtin_strchr((char *)"(", (int )*expression);
  }
#line 2829
  if ((unsigned long )tmp___22 != (unsigned long )((char *)((void *)0))) {
    {
#line 2831
    CopyMagickString(subexpression, expression + 1, 4096UL);
#line 2832
    tmp___20 = strlen((char const   *)(subexpression));
#line 2832
    subexpression[tmp___20 - 1UL] = (char )'\000';
#line 2833
    gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)(subexpression),
                                        beta, exception);
    }
#line 2835
    return (gamma___0);
  }
#line 2837
  switch ((int )*expression) {
  case 43: 
  {
#line 2841
  gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 1, beta,
                                      exception);
  }
#line 2843
  return (1.0 * gamma___0);
  case 45: 
  {
#line 2847
  gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 1, beta,
                                      exception);
  }
#line 2849
  return (- 1.0 * gamma___0);
  case 126: 
  {
#line 2853
  gamma___0 = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 1, beta,
                                      exception);
  }
#line 2855
  return ((double )(~ ((unsigned long )(gamma___0 + 0.5))));
  case 65: 
  case 97: 
  {
#line 2860
  tmp___24 = LocaleNCompare(expression, "abs", 3UL);
  }
#line 2860
  if (tmp___24 == 0L) {
    {
#line 2862
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 2864
    tmp___23 = fabs(alpha);
    }
#line 2864
    return (tmp___23);
  }
  {
#line 2866
  tmp___26 = LocaleNCompare(expression, "acos", 4UL);
  }
#line 2866
  if (tmp___26 == 0L) {
    {
#line 2868
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 2870
    tmp___25 = acos(alpha);
    }
#line 2870
    return (tmp___25);
  }
  {
#line 2872
  tmp___28 = LocaleNCompare(expression, "asin", 4UL);
  }
#line 2872
  if (tmp___28 == 0L) {
    {
#line 2874
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 2876
    tmp___27 = asin(alpha);
    }
#line 2876
    return (tmp___27);
  }
  {
#line 2878
  tmp___30 = LocaleNCompare(expression, "alt", 3UL);
  }
#line 2878
  if (tmp___30 == 0L) {
    {
#line 2880
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
    }
#line 2882
    if ((long )alpha & 1L) {
#line 2882
      tmp___29 = - 1.0;
    } else {
#line 2882
      tmp___29 = 1.0;
    }
#line 2882
    return (tmp___29);
  }
  {
#line 2884
  tmp___32 = LocaleNCompare(expression, "atan2", 5UL);
  }
#line 2884
  if (tmp___32 == 0L) {
    {
#line 2886
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 5, beta,
                                    exception);
#line 2888
    tmp___31 = atan2(alpha, *beta);
    }
#line 2888
    return (tmp___31);
  }
  {
#line 2890
  tmp___34 = LocaleNCompare(expression, "atan", 4UL);
  }
#line 2890
  if (tmp___34 == 0L) {
    {
#line 2892
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 2894
    tmp___33 = atan(alpha);
    }
#line 2894
    return (tmp___33);
  }
  {
#line 2896
  tmp___36 = LocaleCompare(expression, "a");
  }
#line 2896
  if (tmp___36 == 0L) {
    {
#line 2897
    tmp___35 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 2897
    return (tmp___35);
  }
#line 2898
  break;
  case 66: 
  case 98: 
  {
#line 2903
  tmp___38 = LocaleCompare(expression, "b");
  }
#line 2903
  if (tmp___38 == 0L) {
    {
#line 2904
    tmp___37 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 2904
    return (tmp___37);
  }
#line 2905
  break;
  case 67: 
  case 99: 
  {
#line 2910
  tmp___40 = LocaleNCompare(expression, "ceil", 4UL);
  }
#line 2910
  if (tmp___40 == 0L) {
    {
#line 2912
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 2914
    tmp___39 = ceil(alpha);
    }
#line 2914
    return (tmp___39);
  }
  {
#line 2916
  tmp___42 = LocaleNCompare(expression, "cosh", 4UL);
  }
#line 2916
  if (tmp___42 == 0L) {
    {
#line 2918
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 2920
    tmp___41 = cosh(alpha);
    }
#line 2920
    return (tmp___41);
  }
  {
#line 2922
  tmp___44 = LocaleNCompare(expression, "cos", 3UL);
  }
#line 2922
  if (tmp___44 == 0L) {
    {
#line 2924
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 2926
    tmp___43 = cos(alpha);
    }
#line 2926
    return (tmp___43);
  }
  {
#line 2928
  tmp___46 = LocaleCompare(expression, "c");
  }
#line 2928
  if (tmp___46 == 0L) {
    {
#line 2929
    tmp___45 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 2929
    return (tmp___45);
  }
#line 2930
  break;
  case 68: 
  case 100: 
  {
#line 2935
  tmp___49 = LocaleNCompare(expression, "debug", 5UL);
  }
#line 2935
  if (tmp___49 == 0L) {
    {
#line 2940
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 5, beta,
                                    exception);
    }
#line 2942
    if ((int const   )(fx_info->images)->colorspace == 12) {
#line 2943
      switch ((int )channel) {
      case 1: 
#line 2945
      type = "cyan";
#line 2945
      break;
      case 2: 
#line 2946
      type = "magenta";
#line 2946
      break;
      case 4: 
#line 2947
      type = "yellow";
#line 2947
      break;
      case 8: 
#line 2948
      type = "opacity";
#line 2948
      break;
      case 32: 
#line 2949
      type = "black";
#line 2949
      break;
      default: 
#line 2950
      type = "unknown";
#line 2950
      break;
      }
    } else {
#line 2953
      switch ((int )channel) {
      case 1: 
#line 2955
      type = "red";
#line 2955
      break;
      case 2: 
#line 2956
      type = "green";
#line 2956
      break;
      case 4: 
#line 2957
      type = "blue";
#line 2957
      break;
      case 8: 
#line 2958
      type = "opacity";
#line 2958
      break;
      default: 
#line 2959
      type = "unknown";
#line 2959
      break;
      }
    }
    {
#line 2961
    CopyMagickString(subexpression, expression + 6, 4096UL);
#line 2962
    tmp___48 = strlen((char const   *)(subexpression));
    }
#line 2962
    if (tmp___48 > 1UL) {
      {
#line 2963
      tmp___47 = strlen((char const   *)(subexpression));
#line 2963
      subexpression[tmp___47 - 1UL] = (char )'\000';
      }
    }
#line 2964
    if ((unsigned long )fx_info->file != (unsigned long )((FILE *)((void *)0))) {
      {
#line 2965
      fprintf((FILE */* __restrict  */)fx_info->file, (char const   */* __restrict  */)"%s[%ld,%ld].%s: %s=%g\n",
              (fx_info->images)->filename, x, y, type, subexpression, alpha);
      }
    }
#line 2967
    return (0.0);
  }
#line 2969
  break;
  case 69: 
  case 101: 
  {
#line 2974
  tmp___50 = LocaleCompare(expression, "epsilon");
  }
#line 2974
  if (tmp___50 == 0L) {
#line 2975
    return (1.0e-10);
  }
  {
#line 2976
  tmp___52 = LocaleNCompare(expression, "exp", 3UL);
  }
#line 2976
  if (tmp___52 == 0L) {
    {
#line 2978
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 2980
    tmp___51 = exp(alpha);
    }
#line 2980
    return (tmp___51);
  }
  {
#line 2982
  tmp___53 = LocaleCompare(expression, "e");
  }
#line 2982
  if (tmp___53 == 0L) {
#line 2983
    return (2.7182818284590452354);
  }
#line 2984
  break;
  case 70: 
  case 102: 
  {
#line 2989
  tmp___55 = LocaleNCompare(expression, "floor", 5UL);
  }
#line 2989
  if (tmp___55 == 0L) {
    {
#line 2991
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 5, beta,
                                    exception);
#line 2993
    tmp___54 = floor(alpha);
    }
#line 2993
    return (tmp___54);
  }
#line 2995
  break;
  case 71: 
  case 103: 
  {
#line 3000
  tmp___57 = LocaleCompare(expression, "g");
  }
#line 3000
  if (tmp___57 == 0L) {
    {
#line 3001
    tmp___56 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3001
    return (tmp___56);
  }
#line 3002
  break;
  case 72: 
  case 104: 
  {
#line 3007
  tmp___59 = LocaleCompare(expression, "h");
  }
#line 3007
  if (tmp___59 == 0L) {
    {
#line 3008
    tmp___58 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3008
    return (tmp___58);
  }
  {
#line 3009
  tmp___61 = LocaleCompare(expression, "hue");
  }
#line 3009
  if (tmp___61 == 0L) {
    {
#line 3010
    tmp___60 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3010
    return (tmp___60);
  }
  {
#line 3011
  tmp___63 = LocaleNCompare(expression, "hypot", 5UL);
  }
#line 3011
  if (tmp___63 == 0L) {
    {
#line 3013
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 5, beta,
                                    exception);
#line 3015
    tmp___62 = hypot(alpha, *beta);
    }
#line 3015
    return (tmp___62);
  }
#line 3017
  break;
  case 75: 
  case 107: 
  {
#line 3022
  tmp___65 = LocaleCompare(expression, "k");
  }
#line 3022
  if (tmp___65 == 0L) {
    {
#line 3023
    tmp___64 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3023
    return (tmp___64);
  }
#line 3024
  break;
  case 73: 
  case 105: 
  {
#line 3029
  tmp___67 = LocaleCompare(expression, "intensity");
  }
#line 3029
  if (tmp___67 == 0L) {
    {
#line 3030
    tmp___66 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3030
    return (tmp___66);
  }
  {
#line 3031
  tmp___69 = LocaleNCompare(expression, "int", 3UL);
  }
#line 3031
  if (tmp___69 == 0L) {
    {
#line 3033
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3035
    tmp___68 = floor(alpha + 0.5);
    }
#line 3035
    return (tmp___68);
  }
  {
#line 3037
  tmp___71 = LocaleCompare(expression, "i");
  }
#line 3037
  if (tmp___71 == 0L) {
    {
#line 3038
    tmp___70 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3038
    return (tmp___70);
  }
#line 3039
  break;
  case 74: 
  case 106: 
  {
#line 3044
  tmp___73 = LocaleCompare(expression, "j");
  }
#line 3044
  if (tmp___73 == 0L) {
    {
#line 3045
    tmp___72 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3045
    return (tmp___72);
  }
#line 3046
  break;
  case 76: 
  case 108: 
  {
#line 3051
  tmp___75 = LocaleNCompare(expression, "ln", 2UL);
  }
#line 3051
  if (tmp___75 == 0L) {
    {
#line 3053
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 2, beta,
                                    exception);
#line 3055
    tmp___74 = log(alpha);
    }
#line 3055
    return (tmp___74);
  }
  {
#line 3057
  tmp___78 = LocaleNCompare(expression, "logtwo", 4UL);
  }
#line 3057
  if (tmp___78 == 0L) {
    {
#line 3059
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 3061
    tmp___76 = log10(alpha);
#line 3061
    tmp___77 = log10(2.0);
    }
#line 3061
    return (tmp___76 / tmp___77);
  }
  {
#line 3063
  tmp___80 = LocaleNCompare(expression, "log", 3UL);
  }
#line 3063
  if (tmp___80 == 0L) {
    {
#line 3065
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3067
    tmp___79 = log10(alpha);
    }
#line 3067
    return (tmp___79);
  }
  {
#line 3069
  tmp___82 = LocaleCompare(expression, "lightness");
  }
#line 3069
  if (tmp___82 == 0L) {
    {
#line 3070
    tmp___81 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3070
    return (tmp___81);
  }
#line 3071
  break;
  case 77: 
  case 109: 
  {
#line 3076
  tmp___83 = LocaleCompare(expression, "MaxRGB");
  }
#line 3076
  if (tmp___83 == 0L) {
#line 3077
    return ((double )65535UL);
  }
  {
#line 3078
  tmp___84 = LocaleNCompare(expression, "maxima", 6UL);
  }
#line 3078
  if (tmp___84 == 0L) {
#line 3079
    break;
  }
  {
#line 3080
  tmp___86 = LocaleNCompare(expression, "max", 3UL);
  }
#line 3080
  if (tmp___86 == 0L) {
    {
#line 3081
    tmp___85 = FxMax(fx_info, channel, x, y, expression + 3, exception);
    }
#line 3081
    return (tmp___85);
  }
  {
#line 3082
  tmp___87 = LocaleNCompare(expression, "minima", 6UL);
  }
#line 3082
  if (tmp___87 == 0L) {
#line 3083
    break;
  }
  {
#line 3084
  tmp___89 = LocaleNCompare(expression, "min", 3UL);
  }
#line 3084
  if (tmp___89 == 0L) {
    {
#line 3085
    tmp___88 = FxMin(fx_info, channel, x, y, expression + 3, exception);
    }
#line 3085
    return (tmp___88);
  }
  {
#line 3086
  tmp___91 = LocaleNCompare(expression, "mod", 3UL);
  }
#line 3086
  if (tmp___91 == 0L) {
    {
#line 3088
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3090
    tmp___90 = fmod(alpha, *beta);
    }
#line 3090
    return (tmp___90);
  }
  {
#line 3092
  tmp___93 = LocaleCompare(expression, "m");
  }
#line 3092
  if (tmp___93 == 0L) {
    {
#line 3093
    tmp___92 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3093
    return (tmp___92);
  }
#line 3094
  break;
  case 78: 
  case 110: 
  {
#line 3099
  tmp___95 = LocaleCompare(expression, "n");
  }
#line 3099
  if (tmp___95 == 0L) {
    {
#line 3100
    tmp___94 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3100
    return (tmp___94);
  }
#line 3101
  break;
  case 79: 
  case 111: 
  {
#line 3106
  tmp___96 = LocaleCompare(expression, "Opaque");
  }
#line 3106
  if (tmp___96 == 0L) {
#line 3107
    return (1.0);
  }
  {
#line 3108
  tmp___98 = LocaleCompare(expression, "o");
  }
#line 3108
  if (tmp___98 == 0L) {
    {
#line 3109
    tmp___97 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3109
    return (tmp___97);
  }
#line 3110
  break;
  case 80: 
  case 112: 
  {
#line 3115
  tmp___99 = LocaleCompare(expression, "pi");
  }
#line 3115
  if (tmp___99 == 0L) {
#line 3116
    return (3.14159265358979323846264338327950288419716939937510);
  }
  {
#line 3117
  tmp___101 = LocaleNCompare(expression, "pow", 3UL);
  }
#line 3117
  if (tmp___101 == 0L) {
    {
#line 3119
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3121
    tmp___100 = pow(alpha, *beta);
    }
#line 3121
    return (tmp___100);
  }
  {
#line 3123
  tmp___103 = LocaleCompare(expression, "p");
  }
#line 3123
  if (tmp___103 == 0L) {
    {
#line 3124
    tmp___102 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3124
    return (tmp___102);
  }
#line 3125
  break;
  case 81: 
  case 113: 
  {
#line 3130
  tmp___104 = LocaleCompare(expression, "QuantumRange");
  }
#line 3130
  if (tmp___104 == 0L) {
#line 3131
    return ((double )65535UL);
  }
  {
#line 3132
  tmp___105 = LocaleCompare(expression, "QuantumScale");
  }
#line 3132
  if (tmp___105 == 0L) {
#line 3133
    return (1.0 / (double )65535UL);
  }
#line 3134
  break;
  case 82: 
  case 114: 
  {
#line 3139
  tmp___107 = LocaleNCompare(expression, "rand", 4UL);
  }
#line 3139
  if (tmp___107 == 0L) {
    {
#line 3140
    tmp___106 = GetPseudoRandomValue();
    }
#line 3140
    return (tmp___106);
  }
  {
#line 3141
  tmp___110 = LocaleNCompare(expression, "round", 5UL);
  }
#line 3141
  if (tmp___110 == 0L) {
    {
#line 3143
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 5, beta,
                                    exception);
    }
#line 3145
    if (alpha >= 0.0) {
      {
#line 3146
      tmp___108 = floor(alpha + 0.5);
      }
#line 3146
      return (tmp___108);
    }
    {
#line 3147
    tmp___109 = ceil(alpha - 0.5);
    }
#line 3147
    return (tmp___109);
  }
  {
#line 3149
  tmp___112 = LocaleCompare(expression, "r");
  }
#line 3149
  if (tmp___112 == 0L) {
    {
#line 3150
    tmp___111 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3150
    return (tmp___111);
  }
#line 3151
  break;
  case 83: 
  case 115: 
  {
#line 3156
  tmp___114 = LocaleCompare(expression, "saturation");
  }
#line 3156
  if (tmp___114 == 0L) {
    {
#line 3157
    tmp___113 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3157
    return (tmp___113);
  }
  {
#line 3158
  tmp___116 = LocaleNCompare(expression, "sign", 4UL);
  }
#line 3158
  if (tmp___116 == 0L) {
    {
#line 3160
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
    }
#line 3162
    if (alpha < 0.0) {
#line 3162
      tmp___115 = - 1.0;
    } else {
#line 3162
      tmp___115 = 1.0;
    }
#line 3162
    return (tmp___115);
  }
  {
#line 3164
  tmp___118 = LocaleNCompare(expression, "sinh", 4UL);
  }
#line 3164
  if (tmp___118 == 0L) {
    {
#line 3166
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 3168
    tmp___117 = sinh(alpha);
    }
#line 3168
    return (tmp___117);
  }
  {
#line 3170
  tmp___120 = LocaleNCompare(expression, "sin", 3UL);
  }
#line 3170
  if (tmp___120 == 0L) {
    {
#line 3172
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3174
    tmp___119 = sin(alpha);
    }
#line 3174
    return (tmp___119);
  }
  {
#line 3176
  tmp___122 = LocaleNCompare(expression, "sqrt", 4UL);
  }
#line 3176
  if (tmp___122 == 0L) {
    {
#line 3178
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 3180
    tmp___121 = sqrt(alpha);
    }
#line 3180
    return (tmp___121);
  }
  {
#line 3182
  tmp___124 = LocaleCompare(expression, "s");
  }
#line 3182
  if (tmp___124 == 0L) {
    {
#line 3183
    tmp___123 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3183
    return (tmp___123);
  }
#line 3184
  break;
  case 84: 
  case 116: 
  {
#line 3189
  tmp___126 = LocaleNCompare(expression, "tanh", 4UL);
  }
#line 3189
  if (tmp___126 == 0L) {
    {
#line 3191
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 4, beta,
                                    exception);
#line 3193
    tmp___125 = tanh(alpha);
    }
#line 3193
    return (tmp___125);
  }
  {
#line 3195
  tmp___128 = LocaleNCompare(expression, "tan", 3UL);
  }
#line 3195
  if (tmp___128 == 0L) {
    {
#line 3197
    alpha = FxEvaluateSubexpression(fx_info, channel, x, y, expression + 3, beta,
                                    exception);
#line 3199
    tmp___127 = tan(alpha);
    }
#line 3199
    return (tmp___127);
  }
  {
#line 3201
  tmp___129 = LocaleCompare(expression, "Transparent");
  }
#line 3201
  if (tmp___129 == 0L) {
#line 3202
    return (0.0);
  }
  {
#line 3203
  tmp___131 = LocaleCompare(expression, "t");
  }
#line 3203
  if (tmp___131 == 0L) {
    {
#line 3204
    tmp___130 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3204
    return (tmp___130);
  }
#line 3205
  break;
  case 85: 
  case 117: 
  {
#line 3210
  tmp___133 = LocaleCompare(expression, "u");
  }
#line 3210
  if (tmp___133 == 0L) {
    {
#line 3211
    tmp___132 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3211
    return (tmp___132);
  }
#line 3212
  break;
  case 86: 
  case 118: 
  {
#line 3217
  tmp___135 = LocaleCompare(expression, "v");
  }
#line 3217
  if (tmp___135 == 0L) {
    {
#line 3218
    tmp___134 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3218
    return (tmp___134);
  }
#line 3219
  break;
  case 87: 
  case 119: 
  {
#line 3224
  tmp___137 = LocaleCompare(expression, "w");
  }
#line 3224
  if (tmp___137 == 0L) {
    {
#line 3225
    tmp___136 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3225
    return (tmp___136);
  }
#line 3226
  break;
  case 89: 
  case 121: 
  {
#line 3231
  tmp___139 = LocaleCompare(expression, "y");
  }
#line 3231
  if (tmp___139 == 0L) {
    {
#line 3232
    tmp___138 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3232
    return (tmp___138);
  }
#line 3233
  break;
  case 90: 
  case 122: 
  {
#line 3238
  tmp___141 = LocaleCompare(expression, "z");
  }
#line 3238
  if (tmp___141 == 0L) {
    {
#line 3239
    tmp___140 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3239
    return (tmp___140);
  }
#line 3240
  break;
  default: ;
#line 3243
  break;
  }
  {
#line 3245
  q = (char *)expression;
#line 3246
  alpha = strtod((char const   */* __restrict  */)expression, (char **/* __restrict  */)(& q));
  }
#line 3247
  if ((unsigned long )q == (unsigned long )expression) {
    {
#line 3248
    tmp___142 = FxGetSymbol(fx_info, channel, x, y, expression, exception);
    }
#line 3248
    return (tmp___142);
  }
#line 3249
  return (alpha);
}
}
#line 3252 "magick/fx.c"
MagickBooleanType FxEvaluateExpression(FxInfo *fx_info , MagickRealType *alpha , ExceptionInfo *exception ) 
{ MagickBooleanType status ;

  {
  {
#line 3258
  status = FxEvaluateChannelExpression(fx_info, 1, 0L, 0L, alpha, exception);
  }
#line 3259
  return (status);
}
}
#line 3262 "magick/fx.c"
MagickBooleanType FxPreprocessExpression(FxInfo *fx_info , MagickRealType *alpha ,
                                         ExceptionInfo *exception ) 
{ FILE *file ;
  MagickBooleanType status ;

  {
  {
#line 3271
  file = fx_info->file;
#line 3272
  fx_info->file = (FILE *)((void *)0);
#line 3273
  status = FxEvaluateChannelExpression(fx_info, 1, 0L, 0L, alpha, exception);
#line 3274
  fx_info->file = file;
  }
#line 3275
  return (status);
}
}
#line 3278 "magick/fx.c"
MagickBooleanType FxEvaluateChannelExpression(FxInfo *fx_info , ChannelType channel ,
                                              long x , long y , MagickRealType *alpha ,
                                              ExceptionInfo *exception ) 
{ MagickRealType beta ;
  int tmp ;

  {
  {
#line 3285
  beta = 0.0;
#line 3286
  *alpha = FxEvaluateSubexpression(fx_info, channel, x, y, (char const   *)fx_info->expression,
                                   & beta, exception);
  }
#line 3288
  if ((int )exception->severity == 410) {
#line 3288
    tmp = 0;
  } else {
#line 3288
    tmp = 1;
  }
#line 3288
  return ((enum __anonenum_MagickBooleanType_81 )tmp);
}
}
#line 3323 "magick/fx.c"
static FxInfo **DestroyFxThreadSet(FxInfo **fx_info ) 
{ register long i ;
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 3328
  if (! ((unsigned long )fx_info != (unsigned long )((FxInfo **)((void *)0)))) {
    {
#line 3328
    __assert_fail("fx_info != (FxInfo **) ((void *)0)", "magick/fx.c", 3328U, "DestroyFxThreadSet");
    }
  }
#line 3329
  i = 0L;
#line 3329
  while (1) {
    {
#line 3329
    tmp = GetPixelCacheMaximumThreads();
    }
#line 3329
    if (! (i < (long )tmp)) {
#line 3329
      break;
    }
#line 3330
    if ((unsigned long )*(fx_info + i) != (unsigned long )((FxInfo *)((void *)0))) {
      {
#line 3331
      *(fx_info + i) = DestroyFxInfo(*(fx_info + i));
      }
    }
#line 3329
    i ++;
  }
  {
#line 3332
  tmp___0 = RelinquishMagickMemory((void *)fx_info);
  }
#line 3332
  return ((FxInfo **)tmp___0);
}
}
#line 3335 "magick/fx.c"
static FxInfo **AcquireFxThreadSet(Image const   *image , char const   *expression ,
                                   ExceptionInfo *exception ) 
{ char *fx_expression ;
  FxInfo **fx_info ;
  MagickRealType alpha ;
  register long i ;
  unsigned long number_threads ;
  void *tmp ;
  FxInfo **tmp___0 ;

  {
  {
#line 3353
  number_threads = GetPixelCacheMaximumThreads();
#line 3354
  tmp = AcquireQuantumMemory(number_threads, sizeof(*fx_info));
#line 3354
  fx_info = (FxInfo **)tmp;
  }
#line 3355
  if ((unsigned long )fx_info == (unsigned long )((FxInfo **)((void *)0))) {
#line 3356
    return ((FxInfo **)((void *)0));
  }
  {
#line 3357
  ResetMagickMemory((void *)fx_info, 0, number_threads * sizeof(*fx_info));
  }
#line 3358
  if ((int const   )*expression != 64) {
    {
#line 3359
    fx_expression = ConstantString(expression);
    }
  } else {
    {
#line 3361
    fx_expression = FileToString(expression + 1, (unsigned long )(~ 0), exception);
    }
  }
#line 3362
  i = 0L;
#line 3362
  while (i < (long )number_threads) {
    {
#line 3364
    *(fx_info + i) = AcquireFxInfo(image, (char const   *)fx_expression);
    }
#line 3365
    if ((unsigned long )*(fx_info + i) == (unsigned long )((FxInfo *)((void *)0))) {
      {
#line 3366
      tmp___0 = DestroyFxThreadSet(fx_info);
      }
#line 3366
      return (tmp___0);
    }
    {
#line 3367
    FxPreprocessExpression(*(fx_info + i), & alpha, (*(fx_info + i))->exception);
#line 3362
    i ++;
    }
  }
  {
#line 3369
  fx_expression = DestroyString(fx_expression);
  }
#line 3370
  return (fx_info);
}
}
#line 3373 "magick/fx.c"
Image *FxImage(Image const   *image , char const   *expression , ExceptionInfo *exception ) 
{ Image *fx_image ;

  {
  {
#line 3379
  fx_image = FxImageChannel(image, 1, expression, exception);
  }
#line 3380
  return (fx_image);
}
}
#line 3383 "magick/fx.c"
Image *FxImageChannel(Image const   *image , ChannelType channel , char const   *expression ,
                      ExceptionInfo *exception ) 
{ FxInfo **fx_info ;
  Image *fx_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickRealType alpha ;
  ViewInfo *fx_view ;
  MagickBooleanType tmp ;
  char const   *tmp___0 ;
  MagickRealType alpha___0 ;
  register IndexPacket * __restrict  fx_indexes ;
  register long id ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___1 ;
  IndexPacket *tmp___2 ;
  Quantum tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType proceed ;
  long tmp___5 ;

  {
#line 3407
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 3407
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 3407U, "FxImageChannel");
    }
  }
#line 3408
  if (! (image->signature == 2880220587UL)) {
    {
#line 3408
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 3408U, "FxImageChannel");
    }
  }
#line 3409
  if ((int const   )image->debug != 0) {
    {
#line 3410
    LogMagickEvent(1, "magick/fx.c", "FxImageChannel", 3410UL, "%s", image->filename);
    }
  }
  {
#line 3411
  fx_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 3412
  if ((unsigned long )fx_image == (unsigned long )((Image *)((void *)0))) {
#line 3413
    return ((Image *)((void *)0));
  }
  {
#line 3414
  tmp = SetImageStorageClass(fx_image, 1);
  }
#line 3414
  if ((int )tmp == 0) {
    {
#line 3416
    InheritException(exception, (ExceptionInfo const   *)(& fx_image->exception));
#line 3417
    fx_image = DestroyImage(fx_image);
    }
#line 3418
    return ((Image *)((void *)0));
  }
  {
#line 3420
  fx_info = AcquireFxThreadSet(image, expression, exception);
  }
#line 3421
  if ((unsigned long )fx_info == (unsigned long )((FxInfo **)((void *)0))) {
    {
#line 3423
    fx_image = DestroyImage(fx_image);
    }
#line 3424
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 3424
      tmp___0 = "unknown";
    } else {
#line 3424
      tmp___0 = "MemoryAllocationFailed";
    }
    {
#line 3424
    ThrowMagickException(exception, "magick/fx.c", "FxImageChannel", 3424UL, 400,
                         tmp___0, "`%s\'", image->filename);
    }
#line 3424
    return ((Image *)((void *)0));
  }
  {
#line 3426
  status = FxPreprocessExpression(*(fx_info + 0), & alpha, exception);
  }
#line 3427
  if ((int )status == 0) {
    {
#line 3429
    fx_image = DestroyImage(fx_image);
#line 3430
    fx_info = DestroyFxThreadSet(fx_info);
    }
#line 3431
    return ((Image *)((void *)0));
  }
  {
#line 3436
  status = 1;
#line 3437
  progress = 0L;
#line 3438
  fx_view = AcquireCacheView((Image const   *)fx_image);
#line 3442
  y = 0L;
  }
#line 3442
  while (y < (long )fx_image->rows) {
#line 3457
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 3459
    tmp___1 = GetCacheViewAuthenticPixels(fx_view, 0L, y, fx_image->columns, 1UL,
                                          exception);
#line 3459
    q = (PixelPacket */* __restrict  */)tmp___1;
    }
#line 3460
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 3462
      status = 0;
      goto __Cont;
    }
    {
#line 3465
    tmp___2 = GetCacheViewAuthenticIndexQueue(fx_view);
#line 3465
    fx_indexes = (IndexPacket */* __restrict  */)tmp___2;
#line 3466
    id = GetPixelCacheThreadId();
#line 3467
    alpha___0 = 0.0;
#line 3468
    x = 0L;
    }
#line 3468
    while (x < (long )fx_image->columns) {
#line 3470
      if (((int )channel & 1) != 0) {
        {
#line 3472
        FxEvaluateChannelExpression(*(fx_info + id), 1, x, y, & alpha___0, exception);
#line 3474
        q->red = RoundToQuantum((double )65535UL * alpha___0);
        }
      }
#line 3476
      if (((int )channel & 2) != 0) {
        {
#line 3478
        FxEvaluateChannelExpression(*(fx_info + id), 2, x, y, & alpha___0, exception);
#line 3480
        q->green = RoundToQuantum((double )65535UL * alpha___0);
        }
      }
#line 3482
      if (((int )channel & 4) != 0) {
        {
#line 3484
        FxEvaluateChannelExpression(*(fx_info + id), 4, x, y, & alpha___0, exception);
#line 3486
        q->blue = RoundToQuantum((double )65535UL * alpha___0);
        }
      }
#line 3488
      if (((int )channel & 8) != 0) {
        {
#line 3490
        FxEvaluateChannelExpression(*(fx_info + id), 8, x, y, & alpha___0, exception);
        }
#line 3492
        if ((int const   )image->matte == 0) {
          {
#line 3493
          q->opacity = RoundToQuantum((double )65535UL * alpha___0);
          }
        } else {
          {
#line 3495
          q->opacity = RoundToQuantum((MagickRealType )65535UL - (MagickRealType )65535UL * alpha___0);
          }
        }
      }
#line 3498
      if (((int )channel & 32) != 0) {
#line 3498
        if ((int )fx_image->colorspace == 12) {
          {
#line 3501
          FxEvaluateChannelExpression(*(fx_info + id), 32, x, y, & alpha___0, exception);
#line 3503
          tmp___3 = RoundToQuantum((double )65535UL * alpha___0);
#line 3503
          *(fx_indexes + x) = tmp___3;
          }
        }
      }
#line 3506
      q ++;
#line 3468
      x ++;
    }
    {
#line 3508
    tmp___4 = SyncCacheViewAuthenticPixels(fx_view, exception);
    }
#line 3508
    if ((int )tmp___4 == 0) {
#line 3509
      status = 0;
    }
#line 3510
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 3518
      tmp___5 = progress;
#line 3518
      progress ++;
#line 3518
      proceed = SetImageProgress(image, "Fx/Image", (long long )tmp___5, (unsigned long long )image->rows);
      }
#line 3519
      if ((int )proceed == 0) {
#line 3520
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 3442
    y ++;
  }
  {
#line 3523
  fx_image->matte = (*(fx_info + 0))->matte;
#line 3524
  fx_view = DestroyCacheView(fx_view);
#line 3525
  fx_info = DestroyFxThreadSet(fx_info);
  }
#line 3526
  if ((int )status == 0) {
    {
#line 3527
    fx_image = DestroyImage(fx_image);
    }
  }
#line 3528
  return (fx_image);
}
}
#line 3565 "magick/fx.c"
Image *ImplodeImage(Image const   *image , double amount , ExceptionInfo *exception ) 
{ Image *implode_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  MagickRealType radius ;
  PointInfo center ;
  PointInfo scale ;
  ResampleFilter **resample_filter ;
  ViewInfo *image_view ;
  ViewInfo *implode_view ;
  MagickBooleanType tmp ;
  MagickPixelPacket pixel ;
  MagickRealType distance ;
  PointInfo delta ;
  register IndexPacket * __restrict  implode_indexes ;
  register long id ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___0 ;
  IndexPacket *tmp___1 ;
  double factor ;
  double tmp___2 ;
  double tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType proceed ;
  long tmp___5 ;

  {
#line 3600
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 3600
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 3600U, "ImplodeImage");
    }
  }
#line 3601
  if (! (image->signature == 2880220587UL)) {
    {
#line 3601
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 3601U, "ImplodeImage");
    }
  }
#line 3602
  if ((int const   )image->debug != 0) {
    {
#line 3603
    LogMagickEvent(1, "magick/fx.c", "ImplodeImage", 3603UL, "%s", image->filename);
    }
  }
#line 3604
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 3604
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 3604U,
                  "ImplodeImage");
    }
  }
#line 3605
  if (! (exception->signature == 2880220587UL)) {
    {
#line 3605
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 3605U, "ImplodeImage");
    }
  }
  {
#line 3606
  implode_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 3607
  if ((unsigned long )implode_image == (unsigned long )((Image *)((void *)0))) {
#line 3608
    return ((Image *)((void *)0));
  }
  {
#line 3609
  tmp = SetImageStorageClass(implode_image, 1);
  }
#line 3609
  if ((int )tmp == 0) {
    {
#line 3611
    InheritException(exception, (ExceptionInfo const   *)(& implode_image->exception));
#line 3612
    implode_image = DestroyImage(implode_image);
    }
#line 3613
    return ((Image *)((void *)0));
  }
#line 3615
  if ((int )implode_image->background_color.opacity != 0) {
#line 3616
    implode_image->matte = 1;
  }
#line 3620
  scale.x = 1.0;
#line 3621
  scale.y = 1.0;
#line 3622
  center.x = 0.5 * (double )image->columns;
#line 3623
  center.y = 0.5 * (double )image->rows;
#line 3624
  radius = center.x;
#line 3625
  if (image->columns > image->rows) {
#line 3626
    scale.y = (double )image->columns / (double )image->rows;
  } else {
#line 3628
    if (image->columns < image->rows) {
#line 3630
      scale.x = (double )image->rows / (double )image->columns;
#line 3631
      radius = center.y;
    }
  }
  {
#line 3636
  status = 1;
#line 3637
  progress = 0L;
#line 3638
  GetMagickPixelPacket((Image const   *)implode_image, & zero);
#line 3639
  resample_filter = AcquireResampleFilterThreadSet(image, 1, exception);
#line 3640
  image_view = AcquireCacheView(image);
#line 3641
  implode_view = AcquireCacheView((Image const   *)implode_image);
#line 3645
  y = 0L;
  }
#line 3645
  while (y < (long )image->rows) {
#line 3666
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 3668
    tmp___0 = GetCacheViewAuthenticPixels(implode_view, 0L, y, implode_image->columns,
                                          1UL, exception);
#line 3668
    q = (PixelPacket */* __restrict  */)tmp___0;
    }
#line 3670
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 3672
      status = 0;
      goto __Cont;
    }
    {
#line 3675
    tmp___1 = GetCacheViewAuthenticIndexQueue(implode_view);
#line 3675
    implode_indexes = (IndexPacket */* __restrict  */)tmp___1;
#line 3676
    delta.y = scale.y * ((double )y - center.y);
#line 3677
    pixel = zero;
#line 3678
    id = GetPixelCacheThreadId();
#line 3679
    x = 0L;
    }
#line 3679
    while (x < (long )image->columns) {
#line 3684
      delta.x = scale.x * ((double )x - center.x);
#line 3685
      distance = delta.x * delta.x + delta.y * delta.y;
#line 3686
      if (distance < radius * radius) {
#line 3694
        factor = 1.0;
#line 3695
        if (distance > 0.0) {
          {
#line 3696
          tmp___2 = sqrt(distance);
#line 3696
          tmp___3 = sin(((3.14159265358979323846264338327950288419716939937510 * tmp___2) / radius) / (double )2);
#line 3696
          factor = pow(tmp___3, - amount);
          }
        }
        {
#line 3698
        ResamplePixelColor(*(resample_filter + id), (factor * delta.x) / scale.x + center.x,
                           (factor * delta.y) / scale.y + center.y, & pixel);
#line 3701
        SetPixelPacket((Image const   *)implode_image, (MagickPixelPacket const   *)(& pixel),
                       (PixelPacket *)q, (IndexPacket *)(implode_indexes + x));
        }
      }
#line 3703
      q ++;
#line 3679
      x ++;
    }
    {
#line 3705
    tmp___4 = SyncCacheViewAuthenticPixels(implode_view, exception);
    }
#line 3705
    if ((int )tmp___4 == 0) {
#line 3706
      status = 0;
    }
#line 3707
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 3715
      tmp___5 = progress;
#line 3715
      progress ++;
#line 3715
      proceed = SetImageProgress(image, "Implode/Image", (long long )tmp___5, (unsigned long long )image->rows);
      }
#line 3716
      if ((int )proceed == 0) {
#line 3717
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 3645
    y ++;
  }
  {
#line 3720
  implode_view = DestroyCacheView(implode_view);
#line 3721
  image_view = DestroyCacheView(image_view);
#line 3722
  resample_filter = DestroyResampleFilterThreadSet(resample_filter);
  }
#line 3723
  if ((int )status == 0) {
    {
#line 3724
    implode_image = DestroyImage(implode_image);
    }
  }
#line 3725
  return (implode_image);
}
}
#line 3758 "magick/fx.c"
Image *MorphImages(Image const   *image , unsigned long number_frames , ExceptionInfo *exception ) 
{ Image *morph_image ;
  Image *morph_images ;
  long y ;
  MagickOffsetType scene ;
  MagickRealType alpha ;
  MagickRealType beta ;
  register Image const   *next ;
  register long i ;
  MagickBooleanType status ;
  MagickBooleanType tmp ;
  Image *tmp___0 ;
  Image *tmp___1 ;
  Image *tmp___2 ;
  ViewInfo *image_view ;
  ViewInfo *morph_view ;
  Image *tmp___3 ;
  Image *tmp___4 ;
  MagickBooleanType tmp___5 ;
  Image *tmp___6 ;
  MagickBooleanType sync___0 ;
  register PixelPacket const   * __restrict  p ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___7 ;
  PixelPacket *tmp___8 ;
  Image *tmp___9 ;
  MagickBooleanType proceed ;
  unsigned long tmp___10 ;
  Image *tmp___11 ;
  Image *tmp___12 ;
  Image *tmp___13 ;

  {
#line 3789
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 3789
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 3789U, "MorphImages");
    }
  }
#line 3790
  if (! (image->signature == 2880220587UL)) {
    {
#line 3790
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 3790U, "MorphImages");
    }
  }
#line 3791
  if ((int const   )image->debug != 0) {
    {
#line 3792
    LogMagickEvent(1, "magick/fx.c", "MorphImages", 3792UL, "%s", image->filename);
    }
  }
#line 3793
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 3793
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 3793U,
                  "MorphImages");
    }
  }
#line 3794
  if (! (exception->signature == 2880220587UL)) {
    {
#line 3794
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 3794U, "MorphImages");
    }
  }
  {
#line 3795
  morph_images = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 3796
  if ((unsigned long )morph_images == (unsigned long )((Image *)((void *)0))) {
#line 3797
    return ((Image *)((void *)0));
  }
  {
#line 3798
  tmp___1 = GetNextImageInList(image);
  }
#line 3798
  if ((unsigned long )tmp___1 == (unsigned long )((Image *)((void *)0))) {
#line 3803
    i = 1L;
#line 3803
    while (i < (long )number_frames) {
      {
#line 3805
      morph_image = CloneImage(image, 0UL, 0UL, 1, exception);
      }
#line 3806
      if ((unsigned long )morph_image == (unsigned long )((Image *)((void *)0))) {
        {
#line 3808
        morph_images = DestroyImageList(morph_images);
        }
#line 3809
        return ((Image *)((void *)0));
      }
      {
#line 3811
      AppendImageToList(& morph_images, (Image const   *)morph_image);
      }
#line 3812
      if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                             MagickOffsetType  ,
                                                                                             MagickSizeType  ,
                                                                                             void * ))((void *)0))) {
        {
#line 3812
        tmp = QuantumTick((long long )i, (unsigned long long )number_frames);
        }
#line 3812
        if ((int )tmp != 0) {
          {
#line 3815
          status = (*(image->progress_monitor))("Morph/Image", (long long )i, (unsigned long long )number_frames,
                                                (void *)image->client_data);
          }
#line 3817
          if ((int )status == 0) {
#line 3818
            break;
          }
        }
      }
#line 3803
      i ++;
    }
    {
#line 3821
    tmp___0 = GetFirstImageInList((Image const   *)morph_images);
    }
#line 3821
    return (tmp___0);
  }
#line 3826
  status = 1;
#line 3827
  scene = 0LL;
#line 3828
  next = image;
#line 3829
  while (1) {
    {
#line 3829
    tmp___11 = GetNextImageInList(next);
    }
#line 3829
    if (! ((unsigned long )tmp___11 != (unsigned long )((Image *)((void *)0)))) {
#line 3829
      break;
    }
#line 3831
    i = 0L;
#line 3831
    while (i < (long )number_frames) {
      {
#line 3837
      beta = ((double )i + 1.0) / ((double )number_frames + 1.0);
#line 3838
      alpha = 1.0 - beta;
#line 3839
      tmp___3 = GetNextImageInList(next);
#line 3839
      tmp___4 = GetNextImageInList(next);
#line 3839
      morph_image = ZoomImage(next, (unsigned long )((alpha * (MagickRealType )next->columns + beta * (MagickRealType )tmp___4->columns) + 0.5),
                              (unsigned long )((alpha * (MagickRealType )next->rows + beta * (MagickRealType )tmp___3->rows) + 0.5),
                              exception);
      }
#line 3842
      if ((unsigned long )morph_image == (unsigned long )((Image *)((void *)0))) {
        {
#line 3844
        morph_images = DestroyImageList(morph_images);
        }
#line 3845
        return ((Image *)((void *)0));
      }
      {
#line 3847
      tmp___5 = SetImageStorageClass(morph_image, 1);
      }
#line 3847
      if ((int )tmp___5 == 0) {
        {
#line 3849
        InheritException(exception, (ExceptionInfo const   *)(& morph_image->exception));
#line 3850
        morph_image = DestroyImage(morph_image);
        }
#line 3851
        return ((Image *)((void *)0));
      }
      {
#line 3853
      AppendImageToList(& morph_images, (Image const   *)morph_image);
#line 3854
      morph_images = GetLastImageInList((Image const   *)morph_images);
#line 3855
      tmp___6 = GetNextImageInList(next);
#line 3855
      morph_image = ZoomImage((Image const   *)tmp___6, morph_images->columns, morph_images->rows,
                              exception);
      }
#line 3857
      if ((unsigned long )morph_image == (unsigned long )((Image *)((void *)0))) {
        {
#line 3859
        morph_images = DestroyImageList(morph_images);
        }
#line 3860
        return ((Image *)((void *)0));
      }
      {
#line 3862
      image_view = AcquireCacheView((Image const   *)morph_image);
#line 3863
      morph_view = AcquireCacheView((Image const   *)morph_images);
#line 3867
      y = 0L;
      }
#line 3867
      while (y < (long )morph_images->rows) {
#line 3881
        if ((int )status == 0) {
          goto __Cont;
        }
        {
#line 3883
        tmp___7 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y,
                                            morph_image->columns, 1UL, exception);
#line 3883
        p = (PixelPacket const   */* __restrict  */)tmp___7;
#line 3885
        tmp___8 = GetCacheViewAuthenticPixels(morph_view, 0L, y, morph_images->columns,
                                              1UL, exception);
#line 3885
        q = (PixelPacket */* __restrict  */)tmp___8;
        }
#line 3887
        if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 3889
          status = 0;
          goto __Cont;
        } else {
#line 3887
          if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 3889
            status = 0;
            goto __Cont;
          }
        }
#line 3892
        x = 0L;
#line 3892
        while (x < (long )morph_images->columns) {
          {
#line 3894
          q->red = RoundToQuantum(alpha * (MagickRealType )q->red + beta * (MagickRealType )p->red);
#line 3895
          q->green = RoundToQuantum(alpha * (MagickRealType )q->green + beta * (MagickRealType )p->green);
#line 3896
          q->blue = RoundToQuantum(alpha * (MagickRealType )q->blue + beta * (MagickRealType )p->blue);
#line 3897
          q->opacity = RoundToQuantum(alpha * (MagickRealType )q->opacity + beta * (MagickRealType )p->opacity);
#line 3898
          p ++;
#line 3899
          q ++;
#line 3892
          x ++;
          }
        }
        {
#line 3901
        sync___0 = SyncCacheViewAuthenticPixels(morph_view, exception);
        }
#line 3902
        if ((int )sync___0 == 0) {
#line 3903
          status = 0;
        }
        __Cont: /* CIL Label */ 
#line 3867
        y ++;
      }
      {
#line 3905
      morph_view = DestroyCacheView(morph_view);
#line 3906
      image_view = DestroyCacheView(image_view);
#line 3907
      morph_image = DestroyImage(morph_image);
#line 3831
      i ++;
      }
    }
#line 3909
    if (i < (long )number_frames) {
#line 3910
      break;
    }
    {
#line 3914
    tmp___9 = GetNextImageInList(next);
#line 3914
    morph_image = CloneImage((Image const   *)tmp___9, 0UL, 0UL, 1, exception);
    }
#line 3915
    if ((unsigned long )morph_image == (unsigned long )((Image *)((void *)0))) {
      {
#line 3917
      morph_images = DestroyImageList(morph_images);
      }
#line 3918
      return ((Image *)((void *)0));
    }
    {
#line 3920
    AppendImageToList(& morph_images, (Image const   *)morph_image);
#line 3921
    morph_images = GetLastImageInList((Image const   *)morph_images);
    }
#line 3922
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 3930
      tmp___10 = GetImageListLength(image);
#line 3930
      proceed = SetImageProgress(image, "Morph/Image", scene, (unsigned long long )tmp___10);
      }
#line 3932
      if ((int )proceed == 0) {
#line 3933
        status = 0;
      }
    }
    {
#line 3935
    scene ++;
#line 3829
    tmp___2 = GetNextImageInList(next);
#line 3829
    next = (Image const   *)tmp___2;
    }
  }
  {
#line 3937
  tmp___12 = GetNextImageInList(next);
  }
#line 3937
  if ((unsigned long )tmp___12 != (unsigned long )((Image *)((void *)0))) {
    {
#line 3939
    morph_images = DestroyImageList(morph_images);
    }
#line 3940
    return ((Image *)((void *)0));
  }
  {
#line 3942
  tmp___13 = GetFirstImageInList((Image const   *)morph_images);
  }
#line 3942
  return (tmp___13);
}
}
#line 3974 "magick/fx.c"
Image *PolaroidImage(Image const   *image , DrawInfo const   *draw_info , double angle ,
                     ExceptionInfo *exception ) 
{ char const   *value ;
  long quantum ;
  Image *bend_image ;
  Image *caption_image ;
  Image *flop_image ;
  Image *picture_image ;
  Image *polaroid_image ;
  Image *rotate_image ;
  Image *trim_image ;
  unsigned long height ;
  double tmp ;
  double tmp___0 ;
  char *caption ;
  char geometry[4096] ;
  DrawInfo *annotate_info ;
  long count ;
  MagickBooleanType status ;
  TypeMetric metrics ;
  char *tmp___1 ;

  {
#line 3998
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 3998
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 3998U, "PolaroidImage");
    }
  }
#line 3999
  if (! (image->signature == 2880220587UL)) {
    {
#line 3999
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 3999U, "PolaroidImage");
    }
  }
#line 4000
  if ((int const   )image->debug != 0) {
    {
#line 4001
    LogMagickEvent(1, "magick/fx.c", "PolaroidImage", 4001UL, "%s", image->filename);
    }
  }
#line 4002
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 4002
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 4002U,
                  "PolaroidImage");
    }
  }
#line 4003
  if (! (exception->signature == 2880220587UL)) {
    {
#line 4003
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 4003U, "PolaroidImage");
    }
  }
  {
#line 4004
  tmp = MagickMax((double )image->columns, (double )image->rows);
#line 4004
  tmp___0 = MagickMax(tmp / 25.0, 10.0);
#line 4004
  quantum = (long )tmp___0;
#line 4006
  height = (unsigned long )(image->rows + (unsigned long const   )(2L * quantum));
#line 4007
  caption_image = (Image *)((void *)0);
#line 4008
  value = GetImageProperty(image, "Caption");
  }
#line 4009
  if ((unsigned long )value != (unsigned long )((char const   *)((void *)0))) {
    {
#line 4030
    caption_image = CloneImage(image, (unsigned long )image->columns, 1UL, 1, exception);
    }
#line 4031
    if ((unsigned long )caption_image == (unsigned long )((Image *)((void *)0))) {
#line 4032
      return ((Image *)((void *)0));
    }
    {
#line 4033
    annotate_info = CloneDrawInfo((ImageInfo const   *)((void *)0), draw_info);
#line 4034
    caption = InterpretImageProperties((ImageInfo const   *)((ImageInfo *)((void *)0)),
                                       (Image *)image, value);
#line 4036
    CloneString(& annotate_info->text, (char const   *)caption);
#line 4037
    count = FormatMagickCaption(caption_image, annotate_info, caption, & metrics);
#line 4038
    status = SetImageExtent(caption_image, (unsigned long )image->columns, (unsigned long )((double )(count + 1L) * (metrics.ascent - metrics.descent) + 0.5));
    }
#line 4040
    if ((int )status == 0) {
      {
#line 4041
      caption_image = DestroyImage(caption_image);
      }
    } else {
      {
#line 4044
      caption_image->background_color = (struct _PixelPacket )image->border_color;
#line 4045
      SetImageBackgroundColor(caption_image);
#line 4046
      CloneString(& annotate_info->text, (char const   *)caption);
#line 4047
      FormatMagickString(geometry, 4096UL, "+0+%g", metrics.ascent);
      }
#line 4049
      if ((int )annotate_info->gravity == 0) {
        {
#line 4050
        tmp___1 = AcquireString((char const   *)(geometry));
#line 4050
        CloneString(& annotate_info->geometry, (char const   *)tmp___1);
        }
      }
      {
#line 4052
      AnnotateImage(caption_image, (DrawInfo const   *)annotate_info);
#line 4053
      height += caption_image->rows;
      }
    }
    {
#line 4055
    annotate_info = DestroyDrawInfo(annotate_info);
#line 4056
    caption = DestroyString(caption);
    }
  }
  {
#line 4058
  picture_image = CloneImage(image, (unsigned long )(image->columns + (unsigned long const   )(2L * quantum)),
                             height, 1, exception);
  }
#line 4060
  if ((unsigned long )picture_image == (unsigned long )((Image *)((void *)0))) {
#line 4062
    if ((unsigned long )caption_image != (unsigned long )((Image *)((void *)0))) {
      {
#line 4063
      caption_image = DestroyImage(caption_image);
      }
    }
#line 4064
    return ((Image *)((void *)0));
  }
  {
#line 4066
  picture_image->background_color = (struct _PixelPacket )image->border_color;
#line 4067
  SetImageBackgroundColor(picture_image);
#line 4068
  CompositeImage(picture_image, 40, image, quantum, quantum);
  }
#line 4069
  if ((unsigned long )caption_image != (unsigned long )((Image *)((void *)0))) {
    {
#line 4071
    CompositeImage(picture_image, 40, (Image const   *)caption_image, quantum, (long )(image->rows + (unsigned long const   )((3L * quantum) / 2L)));
#line 4073
    caption_image = DestroyImage(caption_image);
    }
  }
  {
#line 4075
  QueryColorDatabase("none", & picture_image->background_color, exception);
#line 4076
  SetImageAlphaChannel(picture_image, 6);
#line 4077
  rotate_image = RotateImage((Image const   *)picture_image, 90.0, exception);
#line 4078
  picture_image = DestroyImage(picture_image);
  }
#line 4079
  if ((unsigned long )rotate_image == (unsigned long )((Image *)((void *)0))) {
#line 4080
    return ((Image *)((void *)0));
  }
  {
#line 4081
  picture_image = rotate_image;
#line 4082
  bend_image = WaveImage((Image const   *)picture_image, 0.01 * (double )picture_image->rows,
                         2.0 * (double )picture_image->columns, exception);
#line 4084
  picture_image = DestroyImage(picture_image);
  }
#line 4085
  if ((unsigned long )bend_image == (unsigned long )((Image *)((void *)0))) {
#line 4086
    return ((Image *)((void *)0));
  }
  {
#line 4087
  InheritException(& bend_image->exception, (ExceptionInfo const   *)exception);
#line 4088
  picture_image = bend_image;
#line 4089
  rotate_image = RotateImage((Image const   *)picture_image, - 90.0, exception);
#line 4090
  picture_image = DestroyImage(picture_image);
  }
#line 4091
  if ((unsigned long )rotate_image == (unsigned long )((Image *)((void *)0))) {
#line 4092
    return ((Image *)((void *)0));
  }
  {
#line 4093
  picture_image = rotate_image;
#line 4094
  picture_image->background_color = (struct _PixelPacket )image->background_color;
#line 4095
  polaroid_image = ShadowImage((Image const   *)picture_image, 80.0, 2.0, quantum / 3L,
                               quantum / 3L, exception);
  }
#line 4097
  if ((unsigned long )polaroid_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 4099
    picture_image = DestroyImage(picture_image);
    }
#line 4100
    return (picture_image);
  }
  {
#line 4102
  flop_image = FlopImage((Image const   *)polaroid_image, exception);
#line 4103
  polaroid_image = DestroyImage(polaroid_image);
  }
#line 4104
  if ((unsigned long )flop_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 4106
    picture_image = DestroyImage(picture_image);
    }
#line 4107
    return (picture_image);
  }
  {
#line 4109
  polaroid_image = flop_image;
#line 4110
  CompositeImage(polaroid_image, 40, (Image const   *)picture_image, (long )((- 0.01 * (double )picture_image->columns) / 2.0),
                 0L);
#line 4112
  picture_image = DestroyImage(picture_image);
#line 4113
  QueryColorDatabase("none", & polaroid_image->background_color, exception);
#line 4114
  rotate_image = RotateImage((Image const   *)polaroid_image, angle, exception);
#line 4115
  polaroid_image = DestroyImage(polaroid_image);
  }
#line 4116
  if ((unsigned long )rotate_image == (unsigned long )((Image *)((void *)0))) {
#line 4117
    return ((Image *)((void *)0));
  }
  {
#line 4118
  polaroid_image = rotate_image;
#line 4119
  trim_image = TrimImage((Image const   *)polaroid_image, exception);
#line 4120
  polaroid_image = DestroyImage(polaroid_image);
  }
#line 4121
  if ((unsigned long )trim_image == (unsigned long )((Image *)((void *)0))) {
#line 4122
    return ((Image *)((void *)0));
  }
#line 4123
  polaroid_image = trim_image;
#line 4124
  return (polaroid_image);
}
}
#line 4159 "magick/fx.c"
Image *RecolorImage(Image const   *image , unsigned long order , double const   *color_matrix ,
                    ExceptionInfo *exception ) 
{ Image *recolor_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  register double const   *k ;
  ViewInfo *image_view ;
  ViewInfo *recolor_view ;
  MagickBooleanType tmp ;
  char format[4096] ;
  char *message ;
  long u ;
  long v ;
  double const   *tmp___0 ;
  MagickPixelPacket pixel ;
  MagickPixelPacket recolor_pixel ;
  register IndexPacket const   * __restrict  indexes ;
  register PixelPacket const   * __restrict  p ;
  register long x ;
  register IndexPacket * __restrict  recolor_indexes ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___1 ;
  PixelPacket *tmp___2 ;
  IndexPacket *tmp___3 ;
  IndexPacket *tmp___4 ;
  MagickBooleanType tmp___5 ;
  MagickBooleanType proceed ;
  long tmp___6 ;

  {
#line 4187
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 4187
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 4187U, "RecolorImage");
    }
  }
#line 4188
  if (! (image->signature == 2880220587UL)) {
    {
#line 4188
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 4188U, "RecolorImage");
    }
  }
#line 4189
  if ((int const   )image->debug != 0) {
    {
#line 4190
    LogMagickEvent(1, "magick/fx.c", "RecolorImage", 4190UL, "%s", image->filename);
    }
  }
#line 4191
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 4191
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 4191U,
                  "RecolorImage");
    }
  }
#line 4192
  if (! (exception->signature == 2880220587UL)) {
    {
#line 4192
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 4192U, "RecolorImage");
    }
  }
  {
#line 4193
  recolor_image = CloneImage(image, (unsigned long )image->columns, (unsigned long )image->rows,
                             1, exception);
  }
#line 4195
  if ((unsigned long )recolor_image == (unsigned long )((Image *)((void *)0))) {
#line 4196
    return ((Image *)((void *)0));
  }
  {
#line 4197
  tmp = SetImageStorageClass(recolor_image, 1);
  }
#line 4197
  if ((int )tmp == 0) {
    {
#line 4199
    InheritException(exception, (ExceptionInfo const   *)(& recolor_image->exception));
#line 4200
    recolor_image = DestroyImage(recolor_image);
    }
#line 4201
    return ((Image *)((void *)0));
  }
#line 4203
  if ((int const   )image->debug != 0) {
    {
#line 4213
    LogMagickEvent(8192, "magick/fx.c", "RecolorImage", 4213UL, "  Recolor image with %ldx%ld color matrix:",
                   order, order);
#line 4215
    message = AcquireString("");
#line 4216
    k = color_matrix;
#line 4217
    v = 0L;
    }
#line 4217
    while (v < (long )order) {
      {
#line 4219
      *message = (char )'\000';
#line 4220
      FormatMagickString(format, 4096UL, "%ld: ", v);
#line 4221
      ConcatenateString(& message, (char const   *)(format));
#line 4222
      u = 0L;
      }
#line 4222
      while (u < (long )order) {
        {
#line 4224
        tmp___0 = k;
#line 4224
        k ++;
#line 4224
        FormatMagickString(format, 4096UL, "%+f ", *tmp___0);
#line 4225
        ConcatenateString(& message, (char const   *)(format));
#line 4222
        u ++;
        }
      }
      {
#line 4227
      LogMagickEvent(8192, "magick/fx.c", "RecolorImage", 4227UL, "%s", message);
#line 4217
      v ++;
      }
    }
    {
#line 4229
    message = DestroyString(message);
    }
  }
  {
#line 4234
  status = 1;
#line 4235
  progress = 0L;
#line 4236
  GetMagickPixelPacket(image, & zero);
#line 4237
  k = color_matrix;
#line 4238
  image_view = AcquireCacheView(image);
#line 4239
  recolor_view = AcquireCacheView((Image const   *)recolor_image);
#line 4243
  y = 0L;
  }
#line 4243
  while (y < (long )image->rows) {
#line 4264
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 4266
    tmp___1 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y, (unsigned long )image->columns,
                                        1UL, exception);
#line 4266
    p = (PixelPacket const   */* __restrict  */)tmp___1;
#line 4267
    tmp___2 = QueueCacheViewAuthenticPixels(recolor_view, 0L, y, recolor_image->columns,
                                            1UL, exception);
#line 4267
    q = (PixelPacket */* __restrict  */)tmp___2;
    }
#line 4269
    if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 4271
      status = 0;
      goto __Cont;
    } else {
#line 4269
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 4271
        status = 0;
        goto __Cont;
      }
    }
    {
#line 4274
    tmp___3 = GetCacheViewAuthenticIndexQueue(image_view);
#line 4274
    indexes = (IndexPacket const   */* __restrict  */)tmp___3;
#line 4275
    tmp___4 = GetCacheViewAuthenticIndexQueue(recolor_view);
#line 4275
    recolor_indexes = (IndexPacket */* __restrict  */)tmp___4;
#line 4276
    pixel = zero;
#line 4277
    recolor_pixel = zero;
#line 4278
    x = 0L;
    }
#line 4278
    while (x < (long )image->columns) {
      {
#line 4280
      SetMagickPixelPacket(image, (PixelPacket const   *)p, (IndexPacket const   *)indexes,
                           & pixel);
#line 4281
      SetMagickPixelPacket((Image const   *)recolor_image, (PixelPacket const   *)p,
                           (IndexPacket const   *)indexes, & recolor_pixel);
      }
#line 4282
      switch ((int )order) {
      case 0: 
#line 4285
      break;
      case 1: 
#line 4288
      recolor_pixel.red = (double )(*(k + 0) * (double const   )pixel.red);
#line 4289
      break;
      case 2: 
#line 4293
      recolor_pixel.red = (double )(*(k + 0) * (double const   )pixel.red + *(k + 1) * (double const   )pixel.green);
#line 4294
      recolor_pixel.green = (double )(*(k + 2) * (double const   )pixel.red + *(k + 3) * (double const   )pixel.green);
#line 4295
      break;
      case 3: 
#line 4299
      recolor_pixel.red = (double )((*(k + 0) * (double const   )pixel.red + *(k + 1) * (double const   )pixel.green) + *(k + 2) * (double const   )pixel.blue);
#line 4300
      recolor_pixel.green = (double )((*(k + 3) * (double const   )pixel.red + *(k + 4) * (double const   )pixel.green) + *(k + 5) * (double const   )pixel.blue);
#line 4301
      recolor_pixel.blue = (double )((*(k + 6) * (double const   )pixel.red + *(k + 7) * (double const   )pixel.green) + *(k + 8) * (double const   )pixel.blue);
#line 4302
      break;
      case 4: 
#line 4306
      recolor_pixel.red = (double )(((*(k + 0) * (double const   )pixel.red + *(k + 1) * (double const   )pixel.green) + *(k + 2) * (double const   )pixel.blue) + *(k + 12) * (double const   )65535UL);
#line 4308
      recolor_pixel.green = (double )(((*(k + 4) * (double const   )pixel.red + *(k + 5) * (double const   )pixel.green) + *(k + 6) * (double const   )pixel.blue) + *(k + 13) * (double const   )65535UL);
#line 4310
      recolor_pixel.blue = (double )(((*(k + 8) * (double const   )pixel.red + *(k + 9) * (double const   )pixel.green) + *(k + 10) * (double const   )pixel.blue) + *(k + 14) * (double const   )65535UL);
#line 4312
      break;
      case 5: 
#line 4316
      recolor_pixel.red = (double )((((*(k + 0) * (double const   )pixel.red + *(k + 1) * (double const   )pixel.green) + *(k + 2) * (double const   )pixel.blue) + *(k + 3) * (double const   )((MagickRealType )65535UL - pixel.opacity)) + *(k + 20) * (double const   )65535UL);
#line 4318
      recolor_pixel.green = (double )((((*(k + 5) * (double const   )pixel.red + *(k + 6) * (double const   )pixel.green) + *(k + 7) * (double const   )pixel.blue) + *(k + 8) * (double const   )((MagickRealType )65535UL - pixel.opacity)) + *(k + 21) * (double const   )65535UL);
#line 4320
      recolor_pixel.blue = (double )((((*(k + 10) * (double const   )pixel.red + *(k + 11) * (double const   )pixel.green) + *(k + 12) * (double const   )pixel.blue) + *(k + 13) * (double const   )((MagickRealType )65535UL - pixel.opacity)) + *(k + 22) * (double const   )65535UL);
#line 4322
      recolor_pixel.opacity = (double )65535UL - (double )((((*(k + 15) * (double const   )pixel.red + *(k + 16) * (double const   )pixel.green) + *(k + 17) * (double const   )pixel.blue) + *(k + 18) * (double const   )((MagickRealType )65535UL - pixel.opacity)) + *(k + 23) * (double const   )65535UL);
#line 4325
      break;
      default: 
#line 4329
      recolor_pixel.red = (double )(((((*(k + 0) * (double const   )pixel.red + *(k + 1) * (double const   )pixel.green) + *(k + 2) * (double const   )pixel.blue) + *(k + 3) * (double const   )pixel.index) + *(k + 4) * (double const   )((MagickRealType )(unsigned short)65535 - pixel.opacity)) + *(k + 30) * (double const   )65535UL);
#line 4332
      recolor_pixel.green = (double )(((((*(k + 6) * (double const   )pixel.red + *(k + 7) * (double const   )pixel.green) + *(k + 8) * (double const   )pixel.blue) + *(k + 9) * (double const   )pixel.index) + *(k + 10) * (double const   )((MagickRealType )(unsigned short)65535 - pixel.opacity)) + *(k + 31) * (double const   )65535UL);
#line 4335
      recolor_pixel.blue = (double )(((((*(k + 12) * (double const   )pixel.red + *(k + 13) * (double const   )pixel.green) + *(k + 14) * (double const   )pixel.blue) + *(k + 15) * (double const   )pixel.index) + *(k + 16) * (double const   )((MagickRealType )(unsigned short)65535 - pixel.opacity)) + *(k + 32) * (double const   )65535UL);
#line 4338
      if ((int const   )image->colorspace == 12) {
#line 4339
        recolor_pixel.index = (double )(((((*(k + 18) * (double const   )pixel.red + *(k + 19) * (double const   )pixel.green) + *(k + 20) * (double const   )pixel.blue) + *(k + 21) * (double const   )pixel.index) + *(k + 22) * (double const   )((MagickRealType )(unsigned short)65535 - pixel.opacity)) + *(k + 33) * (double const   )65535UL);
      }
#line 4342
      recolor_pixel.opacity = (double )65535UL - (double )(((((*(k + 24) * (double const   )pixel.red + *(k + 25) * (double const   )pixel.green) + *(k + 26) * (double const   )pixel.blue) + *(k + 27) * (double const   )pixel.index) + *(k + 28) * (double const   )((MagickRealType )65535UL - pixel.opacity)) + *(k + 34) * (double const   )65535UL);
#line 4345
      break;
      }
      {
#line 4348
      q->red = RoundToQuantum(recolor_pixel.red);
#line 4349
      q->green = RoundToQuantum(recolor_pixel.green);
#line 4350
      q->blue = RoundToQuantum(recolor_pixel.blue);
#line 4351
      q->opacity = RoundToQuantum(recolor_pixel.opacity);
      }
#line 4352
      if ((int const   )image->colorspace == 12) {
        {
#line 4353
        *(recolor_indexes + x) = RoundToQuantum(recolor_pixel.index);
        }
      }
#line 4354
      p ++;
#line 4355
      q ++;
#line 4278
      x ++;
    }
    {
#line 4357
    tmp___5 = SyncCacheViewAuthenticPixels(recolor_view, exception);
    }
#line 4357
    if ((int )tmp___5 == 0) {
#line 4358
      status = 0;
    }
#line 4359
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 4367
      tmp___6 = progress;
#line 4367
      progress ++;
#line 4367
      proceed = SetImageProgress(image, "Recolor/Image", (long long )tmp___6, (unsigned long long )image->rows);
      }
#line 4368
      if ((int )proceed == 0) {
#line 4369
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 4243
    y ++;
  }
  {
#line 4372
  recolor_view = DestroyCacheView(recolor_view);
#line 4373
  image_view = DestroyCacheView(image_view);
  }
#line 4374
  if ((int )status == 0) {
    {
#line 4375
    recolor_image = DestroyImage(recolor_image);
    }
  }
#line 4376
  return (recolor_image);
}
}
#line 4409 "magick/fx.c"
Image *SepiaToneImage(Image const   *image , double threshold , ExceptionInfo *exception ) 
{ Image *sepia_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  ViewInfo *image_view ;
  ViewInfo *sepia_view ;
  MagickBooleanType tmp ;
  register PixelPacket const   * __restrict  p ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___0 ;
  PixelPacket *tmp___1 ;
  MagickRealType intensity ;
  MagickRealType tone ;
  Quantum tmp___2 ;
  MagickBooleanType tmp___3 ;
  MagickBooleanType proceed ;
  long tmp___4 ;

  {
#line 4431
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 4431
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 4431U, "SepiaToneImage");
    }
  }
#line 4432
  if (! (image->signature == 2880220587UL)) {
    {
#line 4432
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 4432U, "SepiaToneImage");
    }
  }
#line 4433
  if ((int const   )image->debug != 0) {
    {
#line 4434
    LogMagickEvent(1, "magick/fx.c", "SepiaToneImage", 4434UL, "%s", image->filename);
    }
  }
#line 4435
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 4435
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 4435U,
                  "SepiaToneImage");
    }
  }
#line 4436
  if (! (exception->signature == 2880220587UL)) {
    {
#line 4436
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 4436U, "SepiaToneImage");
    }
  }
  {
#line 4437
  sepia_image = CloneImage(image, (unsigned long )image->columns, (unsigned long )image->rows,
                           1, exception);
  }
#line 4438
  if ((unsigned long )sepia_image == (unsigned long )((Image *)((void *)0))) {
#line 4439
    return ((Image *)((void *)0));
  }
  {
#line 4440
  tmp = SetImageStorageClass(sepia_image, 1);
  }
#line 4440
  if ((int )tmp == 0) {
    {
#line 4442
    InheritException(exception, (ExceptionInfo const   *)(& sepia_image->exception));
#line 4443
    sepia_image = DestroyImage(sepia_image);
    }
#line 4444
    return ((Image *)((void *)0));
  }
  {
#line 4449
  status = 1;
#line 4450
  progress = 0L;
#line 4451
  image_view = AcquireCacheView(image);
#line 4452
  sepia_view = AcquireCacheView((Image const   *)sepia_image);
#line 4456
  y = 0L;
  }
#line 4456
  while (y < (long )image->rows) {
#line 4467
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 4469
    tmp___0 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y, (unsigned long )image->columns,
                                        1UL, exception);
#line 4469
    p = (PixelPacket const   */* __restrict  */)tmp___0;
#line 4470
    tmp___1 = QueueCacheViewAuthenticPixels(sepia_view, 0L, y, sepia_image->columns,
                                            1UL, exception);
#line 4470
    q = (PixelPacket */* __restrict  */)tmp___1;
    }
#line 4472
    if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 4474
      status = 0;
      goto __Cont;
    } else {
#line 4472
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 4474
        status = 0;
        goto __Cont;
      }
    }
#line 4477
    x = 0L;
#line 4477
    while (x < (long )image->columns) {
      {
#line 4483
      tmp___2 = PixelIntensityToQuantum((PixelPacket const   *)p);
#line 4483
      intensity = (double )tmp___2;
      }
#line 4484
      if (intensity > threshold) {
#line 4484
        tone = (double )65535UL;
      } else {
#line 4484
        tone = (intensity + (double )65535UL) - threshold;
      }
      {
#line 4486
      q->red = RoundToQuantum(tone);
      }
#line 4487
      if (intensity > (7.0 * threshold) / 6.0) {
#line 4487
        tone = (double )65535UL;
      } else {
#line 4487
        tone = (intensity + (double )65535UL) - (7.0 * threshold) / 6.0;
      }
      {
#line 4489
      q->green = RoundToQuantum(tone);
      }
#line 4490
      if (intensity < threshold / 6.0) {
#line 4490
        tone = (double )0;
      } else {
#line 4490
        tone = intensity - threshold / 6.0;
      }
      {
#line 4491
      q->blue = RoundToQuantum(tone);
#line 4492
      tone = threshold / 7.0;
      }
#line 4493
      if ((double )q->green < tone) {
        {
#line 4494
        q->green = RoundToQuantum(tone);
        }
      }
#line 4495
      if ((double )q->blue < tone) {
        {
#line 4496
        q->blue = RoundToQuantum(tone);
        }
      }
#line 4497
      p ++;
#line 4498
      q ++;
#line 4477
      x ++;
    }
    {
#line 4500
    tmp___3 = SyncCacheViewAuthenticPixels(sepia_view, exception);
    }
#line 4500
    if ((int )tmp___3 == 0) {
#line 4501
      status = 0;
    }
#line 4502
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 4510
      tmp___4 = progress;
#line 4510
      progress ++;
#line 4510
      proceed = SetImageProgress(image, "SepiaTone/Image", (long long )tmp___4, (unsigned long long )image->rows);
      }
#line 4512
      if ((int )proceed == 0) {
#line 4513
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 4456
    y ++;
  }
  {
#line 4516
  sepia_view = DestroyCacheView(sepia_view);
#line 4517
  image_view = DestroyCacheView(image_view);
#line 4518
  NormalizeImage(sepia_image);
#line 4519
  ContrastImage(sepia_image, 1);
  }
#line 4520
  if ((int )status == 0) {
    {
#line 4521
    sepia_image = DestroyImage(sepia_image);
    }
  }
#line 4522
  return (sepia_image);
}
}
#line 4559 "magick/fx.c"
Image *ShadowImage(Image const   *image , double opacity , double sigma , long x_offset ,
                   long y_offset , ExceptionInfo *exception ) 
{ Image *border_image ;
  Image *clone_image ;
  Image *shadow_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  RectangleInfo border_info ;
  ViewInfo *image_view ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp ;
  MagickBooleanType tmp___0 ;
  MagickBooleanType proceed ;
  long tmp___1 ;

  {
#line 4583
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 4583
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 4583U, "ShadowImage");
    }
  }
#line 4584
  if (! (image->signature == 2880220587UL)) {
    {
#line 4584
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 4584U, "ShadowImage");
    }
  }
#line 4585
  if ((int const   )image->debug != 0) {
    {
#line 4586
    LogMagickEvent(1, "magick/fx.c", "ShadowImage", 4586UL, "%s", image->filename);
    }
  }
#line 4587
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 4587
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 4587U,
                  "ShadowImage");
    }
  }
#line 4588
  if (! (exception->signature == 2880220587UL)) {
    {
#line 4588
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 4588U, "ShadowImage");
    }
  }
  {
#line 4589
  clone_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 4590
  if ((unsigned long )clone_image == (unsigned long )((Image *)((void *)0))) {
#line 4591
    return ((Image *)((void *)0));
  }
  {
#line 4592
  SetImageVirtualPixelMethod((Image const   *)clone_image, 4);
#line 4593
  clone_image->compose = 40;
#line 4594
  border_info.width = (unsigned long )(2.0 * sigma + 0.5);
#line 4595
  border_info.height = (unsigned long )(2.0 * sigma + 0.5);
#line 4596
  border_info.x = 0L;
#line 4597
  border_info.y = 0L;
#line 4598
  QueryColorDatabase("none", & clone_image->border_color, exception);
#line 4599
  border_image = BorderImage((Image const   *)clone_image, (RectangleInfo const   *)(& border_info),
                             exception);
#line 4600
  clone_image = DestroyImage(clone_image);
  }
#line 4601
  if ((unsigned long )border_image == (unsigned long )((Image *)((void *)0))) {
#line 4602
    return ((Image *)((void *)0));
  }
#line 4603
  if ((int )border_image->matte == 0) {
    {
#line 4604
    SetImageAlphaChannel(border_image, 6);
    }
  }
  {
#line 4608
  status = 1;
#line 4609
  progress = 0L;
#line 4610
  image_view = AcquireCacheView((Image const   *)border_image);
#line 4614
  y = 0L;
  }
#line 4614
  while (y < (long )border_image->rows) {
#line 4622
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 4624
    tmp = GetCacheViewAuthenticPixels(image_view, 0L, y, border_image->columns, 1UL,
                                      exception);
#line 4624
    q = (PixelPacket */* __restrict  */)tmp;
    }
#line 4626
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 4628
      status = 0;
      goto __Cont;
    }
#line 4631
    x = 0L;
#line 4631
    while (x < (long )border_image->columns) {
#line 4633
      q->red = border_image->background_color.red;
#line 4634
      q->green = border_image->background_color.green;
#line 4635
      q->blue = border_image->background_color.blue;
#line 4636
      if ((int )border_image->matte == 0) {
#line 4637
        q->opacity = border_image->background_color.opacity;
      } else {
        {
#line 4639
        q->opacity = RoundToQuantum((double )65535UL - ((double )(65535UL - (unsigned long )q->opacity) * opacity) / 100.0);
        }
      }
#line 4641
      q ++;
#line 4631
      x ++;
    }
    {
#line 4643
    tmp___0 = SyncCacheViewAuthenticPixels(image_view, exception);
    }
#line 4643
    if ((int )tmp___0 == 0) {
#line 4644
      status = 0;
    }
#line 4645
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 4653
      tmp___1 = progress;
#line 4653
      progress ++;
#line 4653
      proceed = SetImageProgress(image, "Shadow/Image", (long long )tmp___1, (unsigned long long )border_image->rows);
      }
#line 4655
      if ((int )proceed == 0) {
#line 4656
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 4614
    y ++;
  }
  {
#line 4659
  image_view = DestroyCacheView(image_view);
#line 4660
  shadow_image = BlurImageChannel((Image const   *)border_image, 8, 0.0, sigma, exception);
#line 4661
  border_image = DestroyImage(border_image);
  }
#line 4662
  if ((unsigned long )shadow_image == (unsigned long )((Image *)((void *)0))) {
#line 4663
    return ((Image *)((void *)0));
  }
#line 4664
  if (shadow_image->page.width == 0UL) {
#line 4665
    shadow_image->page.width = shadow_image->columns;
  }
#line 4666
  if (shadow_image->page.height == 0UL) {
#line 4667
    shadow_image->page.height = shadow_image->rows;
  }
#line 4668
  shadow_image->page.width += (unsigned long )(x_offset - (long )border_info.width);
#line 4669
  shadow_image->page.height += (unsigned long )(y_offset - (long )border_info.height);
#line 4670
  shadow_image->page.x += x_offset - (long )border_info.width;
#line 4671
  shadow_image->page.y += y_offset - (long )border_info.height;
#line 4672
  return (shadow_image);
}
}
#line 4711 "magick/fx.c"
Image *SketchImage(Image const   *image , double radius , double sigma , double angle ,
                   ExceptionInfo *exception ) 
{ Image *blend_image ;
  Image *blur_image ;
  Image *dodge_image ;
  Image *random_image ;
  Image *sketch_image ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  ViewInfo *random_view ;
  MagickPixelPacket pixel ;
  register IndexPacket * __restrict  indexes ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp ;
  IndexPacket *tmp___0 ;
  double tmp___1 ;
  MagickBooleanType tmp___2 ;

  {
  {
#line 4736
  random_image = CloneImage(image, (unsigned long )(image->columns << 1), (unsigned long )(image->rows << 1),
                            1, exception);
  }
#line 4738
  if ((unsigned long )random_image == (unsigned long )((Image *)((void *)0))) {
#line 4739
    return ((Image *)((void *)0));
  }
  {
#line 4740
  status = 1;
#line 4741
  GetMagickPixelPacket((Image const   *)random_image, & zero);
#line 4742
  random_view = AcquireCacheView((Image const   *)random_image);
#line 4743
  y = 0L;
  }
#line 4743
  while (y < (long )random_image->rows) {
    {
#line 4757
    tmp = QueueCacheViewAuthenticPixels(random_view, 0L, y, random_image->columns,
                                        1UL, exception);
#line 4757
    q = (PixelPacket */* __restrict  */)tmp;
    }
#line 4759
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 4761
      status = 0;
      goto __Cont;
    }
    {
#line 4764
    tmp___0 = GetCacheViewAuthenticIndexQueue(random_view);
#line 4764
    indexes = (IndexPacket */* __restrict  */)tmp___0;
#line 4765
    pixel = zero;
#line 4766
    x = 0L;
    }
#line 4766
    while (x < (long )random_image->columns) {
      {
#line 4768
      tmp___1 = GetPseudoRandomValue();
#line 4768
      pixel.red = (double )65535UL * tmp___1;
#line 4769
      pixel.green = pixel.red;
#line 4770
      pixel.blue = pixel.red;
      }
#line 4771
      if ((int const   )image->colorspace == 12) {
#line 4772
        pixel.index = pixel.red;
      }
      {
#line 4773
      SetPixelPacket((Image const   *)random_image, (MagickPixelPacket const   *)(& pixel),
                     (PixelPacket *)q, (IndexPacket *)(indexes + x));
#line 4774
      q ++;
#line 4766
      x ++;
      }
    }
    {
#line 4776
    tmp___2 = SyncCacheViewAuthenticPixels(random_view, exception);
    }
#line 4776
    if ((int )tmp___2 == 0) {
#line 4777
      status = 0;
    }
#line 4778
    if ((int )status == 0) {
#line 4779
      break;
    }
    __Cont: /* CIL Label */ 
#line 4743
    y ++;
  }
  {
#line 4781
  random_view = DestroyCacheView(random_view);
  }
#line 4782
  if ((int )status == 0) {
    {
#line 4784
    random_image = DestroyImage(random_image);
    }
#line 4785
    return (random_image);
  }
  {
#line 4787
  blur_image = MotionBlurImage((Image const   *)random_image, radius, sigma, angle,
                               exception);
#line 4788
  random_image = DestroyImage(random_image);
  }
#line 4789
  if ((unsigned long )blur_image == (unsigned long )((Image *)((void *)0))) {
#line 4790
    return ((Image *)((void *)0));
  }
  {
#line 4791
  dodge_image = EdgeImage((Image const   *)blur_image, radius, exception);
#line 4792
  blur_image = DestroyImage(blur_image);
  }
#line 4793
  if ((unsigned long )dodge_image == (unsigned long )((Image *)((void *)0))) {
#line 4794
    return ((Image *)((void *)0));
  }
  {
#line 4795
  NormalizeImage(dodge_image);
#line 4796
  NegateImage(dodge_image, 0);
#line 4797
  TransformImage(& dodge_image, (char const   *)((char *)((void *)0)), "50%");
#line 4798
  sketch_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 4799
  if ((unsigned long )sketch_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 4801
    dodge_image = DestroyImage(dodge_image);
    }
#line 4802
    return ((Image *)((void *)0));
  }
  {
#line 4804
  CompositeImage(sketch_image, 9, (Image const   *)dodge_image, 0L, 0L);
#line 4805
  dodge_image = DestroyImage(dodge_image);
#line 4806
  blend_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 4807
  if ((unsigned long )blend_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 4809
    sketch_image = DestroyImage(sketch_image);
    }
#line 4810
    return ((Image *)((void *)0));
  }
  {
#line 4812
  blend_image->geometry = AcquireString("20x80");
#line 4813
  CompositeImage(sketch_image, 4, (Image const   *)blend_image, 0L, 0L);
#line 4814
  blend_image = DestroyImage(blend_image);
  }
#line 4815
  return (sketch_image);
}
}
#line 4845 "magick/fx.c"
MagickBooleanType SolarizeImage(Image *image , double threshold ) 
{ ExceptionInfo *exception ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  ViewInfo *image_view ;
  register long i ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp ;
  MagickBooleanType tmp___0 ;
  MagickBooleanType proceed ;
  long tmp___1 ;

  {
#line 4863
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 4863
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 4863U, "SolarizeImage");
    }
  }
#line 4864
  if (! (image->signature == 2880220587UL)) {
    {
#line 4864
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 4864U, "SolarizeImage");
    }
  }
#line 4865
  if ((int )image->debug != 0) {
    {
#line 4866
    LogMagickEvent(1, "magick/fx.c", "SolarizeImage", 4866UL, "%s", image->filename);
    }
  }
#line 4867
  if ((int )image->storage_class == 2) {
#line 4875
    i = 0L;
#line 4875
    while (i < (long )image->colors) {
#line 4877
      if ((double )(image->colormap + i)->red > threshold) {
#line 4878
        (image->colormap + i)->red = (unsigned short )(65535 - (int )(image->colormap + i)->red);
      }
#line 4879
      if ((double )(image->colormap + i)->green > threshold) {
#line 4880
        (image->colormap + i)->green = (unsigned short )(65535 - (int )(image->colormap + i)->green);
      }
#line 4882
      if ((double )(image->colormap + i)->blue > threshold) {
#line 4883
        (image->colormap + i)->blue = (unsigned short )(65535 - (int )(image->colormap + i)->blue);
      }
#line 4875
      i ++;
    }
  }
  {
#line 4890
  status = 1;
#line 4891
  progress = 0L;
#line 4892
  exception = & image->exception;
#line 4893
  image_view = AcquireCacheView((Image const   *)image);
#line 4897
  y = 0L;
  }
#line 4897
  while (y < (long )image->rows) {
#line 4905
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 4907
    tmp = GetCacheViewAuthenticPixels(image_view, 0L, y, image->columns, 1UL, exception);
#line 4907
    q = (PixelPacket */* __restrict  */)tmp;
    }
#line 4909
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 4911
      status = 0;
      goto __Cont;
    }
#line 4914
    x = 0L;
#line 4914
    while (x < (long )image->columns) {
#line 4916
      if ((double )q->red > threshold) {
#line 4917
        q->red = (unsigned short )(65535 - (int )q->red);
      }
#line 4918
      if ((double )q->green > threshold) {
#line 4919
        q->green = (unsigned short )(65535 - (int )q->green);
      }
#line 4920
      if ((double )q->blue > threshold) {
#line 4921
        q->blue = (unsigned short )(65535 - (int )q->blue);
      }
#line 4922
      q ++;
#line 4914
      x ++;
    }
    {
#line 4924
    tmp___0 = SyncCacheViewAuthenticPixels(image_view, exception);
    }
#line 4924
    if ((int )tmp___0 == 0) {
#line 4925
      status = 0;
    }
#line 4926
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 4934
      tmp___1 = progress;
#line 4934
      progress ++;
#line 4934
      proceed = SetImageProgress((Image const   *)image, "Solarize/Image", (long long )tmp___1,
                                 (unsigned long long )image->rows);
      }
#line 4935
      if ((int )proceed == 0) {
#line 4936
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 4897
    y ++;
  }
  {
#line 4939
  image_view = DestroyCacheView(image_view);
  }
#line 4940
  return (status);
}
}
#line 4972 "magick/fx.c"
Image *SteganoImage(Image const   *image , Image const   *watermark , ExceptionInfo *exception ) 
{ Image *stegano_image ;
  int c ;
  long i ;
  long j ;
  long k ;
  long y ;
  MagickBooleanType status ;
  PixelPacket pixel ;
  register long x ;
  register PixelPacket *q ;
  unsigned long depth ;
  MagickBooleanType tmp ;
  Quantum tmp___0 ;
  unsigned long tmp___1 ;
  Quantum tmp___2 ;
  Quantum tmp___3 ;
  unsigned long tmp___4 ;
  Quantum tmp___5 ;
  Quantum tmp___6 ;
  unsigned long tmp___7 ;
  Quantum tmp___8 ;
  MagickBooleanType tmp___9 ;
  MagickBooleanType tmp___10 ;

  {
#line 5012
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5012
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 5012U, "SteganoImage");
    }
  }
#line 5013
  if (! (image->signature == 2880220587UL)) {
    {
#line 5013
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 5013U, "SteganoImage");
    }
  }
#line 5014
  if ((int const   )image->debug != 0) {
    {
#line 5015
    LogMagickEvent(1, "magick/fx.c", "SteganoImage", 5015UL, "%s", image->filename);
    }
  }
#line 5016
  if (! ((unsigned long )watermark != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5016
    __assert_fail("watermark != (const Image *) ((void *)0)", "magick/fx.c", 5016U,
                  "SteganoImage");
    }
  }
#line 5017
  if (! (watermark->signature == 2880220587UL)) {
    {
#line 5017
    __assert_fail("watermark->signature == 0xabacadabUL", "magick/fx.c", 5017U, "SteganoImage");
    }
  }
#line 5018
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5018
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5018U,
                  "SteganoImage");
    }
  }
#line 5019
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5019
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5019U, "SteganoImage");
    }
  }
  {
#line 5020
  stegano_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 5021
  if ((unsigned long )stegano_image == (unsigned long )((Image *)((void *)0))) {
#line 5022
    return ((Image *)((void *)0));
  }
  {
#line 5023
  tmp = SetImageStorageClass(stegano_image, 1);
  }
#line 5023
  if ((int )tmp == 0) {
    {
#line 5025
    InheritException(exception, (ExceptionInfo const   *)(& stegano_image->exception));
#line 5026
    stegano_image = DestroyImage(stegano_image);
    }
#line 5027
    return ((Image *)((void *)0));
  }
#line 5029
  stegano_image->depth = 16UL;
#line 5033
  c = 0;
#line 5034
  i = 0L;
#line 5035
  j = 0L;
#line 5036
  depth = stegano_image->depth;
#line 5037
  k = (long )image->offset;
#line 5038
  i = (long )(depth - 1UL);
#line 5038
  while (1) {
#line 5038
    if (i >= 0L) {
#line 5038
      if (! (j < (long )depth)) {
#line 5038
        break;
      }
    } else {
#line 5038
      break;
    }
#line 5040
    y = 0L;
#line 5040
    while (1) {
#line 5040
      if (y < (long )watermark->rows) {
#line 5040
        if (! (j < (long )depth)) {
#line 5040
          break;
        }
      } else {
#line 5040
        break;
      }
#line 5042
      x = 0L;
#line 5042
      while (1) {
#line 5042
        if (x < (long )watermark->columns) {
#line 5042
          if (! (j < (long )depth)) {
#line 5042
            break;
          }
        } else {
#line 5042
          break;
        }
        {
#line 5044
        GetOneVirtualPixel(watermark, x, y, & pixel, exception);
        }
#line 5045
        if (k / (long )stegano_image->columns >= (long )stegano_image->rows) {
#line 5046
          break;
        }
        {
#line 5047
        q = GetAuthenticPixels(stegano_image, k % (long )stegano_image->columns, k / (long )stegano_image->columns,
                               1UL, 1UL, exception);
        }
#line 5049
        if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5050
          break;
        }
#line 5051
        switch (c) {
        case 0: 
        {
#line 5055
        tmp___2 = PixelIntensityToQuantum((PixelPacket const   *)(& pixel));
        }
#line 5055
        if ((((unsigned long )tmp___2 >> (unsigned long )i) & 1UL) != 0UL) {
#line 5055
          tmp___1 = (unsigned long )q->red | (1UL << (unsigned long )j);
        } else {
#line 5055
          tmp___1 = (unsigned long )q->red & ~ (1UL << (unsigned long )j);
        }
#line 5055
        q->red = (unsigned short )tmp___1;
#line 5056
        break;
        case 1: 
        {
#line 5060
        tmp___5 = PixelIntensityToQuantum((PixelPacket const   *)(& pixel));
        }
#line 5060
        if ((((unsigned long )tmp___5 >> (unsigned long )i) & 1UL) != 0UL) {
#line 5060
          tmp___4 = (unsigned long )q->green | (1UL << (unsigned long )j);
        } else {
#line 5060
          tmp___4 = (unsigned long )q->green & ~ (1UL << (unsigned long )j);
        }
#line 5060
        q->green = (unsigned short )tmp___4;
#line 5061
        break;
        case 2: 
        {
#line 5065
        tmp___8 = PixelIntensityToQuantum((PixelPacket const   *)(& pixel));
        }
#line 5065
        if ((((unsigned long )tmp___8 >> (unsigned long )i) & 1UL) != 0UL) {
#line 5065
          tmp___7 = (unsigned long )q->blue | (1UL << (unsigned long )j);
        } else {
#line 5065
          tmp___7 = (unsigned long )q->blue & ~ (1UL << (unsigned long )j);
        }
#line 5065
        q->blue = (unsigned short )tmp___7;
#line 5066
        break;
        }
        {
#line 5069
        tmp___9 = SyncAuthenticPixels(stegano_image, exception);
        }
#line 5069
        if ((int )tmp___9 == 0) {
#line 5070
          break;
        }
#line 5071
        c ++;
#line 5072
        if (c == 3) {
#line 5073
          c = 0;
        }
#line 5074
        k ++;
#line 5075
        if (k == (long )(stegano_image->columns * stegano_image->columns)) {
#line 5076
          k = 0L;
        }
#line 5077
        if (k == (long )image->offset) {
#line 5078
          j ++;
        }
#line 5042
        x ++;
      }
#line 5040
      y ++;
    }
#line 5081
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 5081
      tmp___10 = QuantumTick((long long )(depth - (unsigned long )i), (unsigned long long )depth);
      }
#line 5081
      if ((int )tmp___10 != 0) {
        {
#line 5084
        status = (*(image->progress_monitor))("Stegano/Image", (long long )(depth - (unsigned long )i),
                                              (unsigned long long )depth, (void *)image->client_data);
        }
#line 5086
        if ((int )status == 0) {
#line 5087
          break;
        }
      }
    }
#line 5038
    i --;
  }
#line 5090
  if ((int )stegano_image->storage_class == 2) {
    {
#line 5091
    SyncImage(stegano_image);
    }
  }
#line 5092
  return (stegano_image);
}
}
#line 5134 "magick/fx.c"
Image *StereoImage(Image const   *left_image , Image const   *right_image , ExceptionInfo *exception ) 
{ Image *tmp ;

  {
  {
#line 5137
  tmp = StereoAnaglyphImage(left_image, right_image, 0L, 0L, exception);
  }
#line 5137
  return (tmp);
}
}
#line 5140 "magick/fx.c"
Image *StereoAnaglyphImage(Image const   *left_image , Image const   *right_image ,
                           long x_offset , long y_offset , ExceptionInfo *exception ) 
{ Image const   *image ;
  Image *stereo_image ;
  long y ;
  MagickBooleanType status ;
  char const   *tmp ;
  MagickBooleanType tmp___0 ;
  register PixelPacket const   * __restrict  p ;
  register PixelPacket const   * __restrict  q ;
  register long x ;
  register PixelPacket * __restrict  r ;
  PixelPacket const   *tmp___1 ;
  PixelPacket const   *tmp___2 ;
  PixelPacket *tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType tmp___5 ;

  {
#line 5158
  if (! ((unsigned long )left_image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5158
    __assert_fail("left_image != (const Image *) ((void *)0)", "magick/fx.c", 5158U,
                  "StereoAnaglyphImage");
    }
  }
#line 5159
  if (! (left_image->signature == 2880220587UL)) {
    {
#line 5159
    __assert_fail("left_image->signature == 0xabacadabUL", "magick/fx.c", 5159U, "StereoAnaglyphImage");
    }
  }
#line 5160
  if ((int const   )left_image->debug != 0) {
    {
#line 5161
    LogMagickEvent(1, "magick/fx.c", "StereoAnaglyphImage", 5161UL, "%s", left_image->filename);
    }
  }
#line 5163
  if (! ((unsigned long )right_image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5163
    __assert_fail("right_image != (const Image *) ((void *)0)", "magick/fx.c", 5163U,
                  "StereoAnaglyphImage");
    }
  }
#line 5164
  if (! (right_image->signature == 2880220587UL)) {
    {
#line 5164
    __assert_fail("right_image->signature == 0xabacadabUL", "magick/fx.c", 5164U,
                  "StereoAnaglyphImage");
    }
  }
#line 5165
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5165
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5165U,
                  "StereoAnaglyphImage");
    }
  }
#line 5166
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5166
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5166U, "StereoAnaglyphImage");
    }
  }
#line 5167
  if (! ((unsigned long )right_image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5167
    __assert_fail("right_image != (const Image *) ((void *)0)", "magick/fx.c", 5167U,
                  "StereoAnaglyphImage");
    }
  }
#line 5168
  image = left_image;
#line 5169
  if (left_image->columns != right_image->columns) {
    goto _L;
  } else {
#line 5169
    if (left_image->rows != right_image->rows) {
      _L: /* CIL Label */ 
#line 5171
      if ((unsigned long )"LeftAndRightImageSizesDiffer" == (unsigned long )((char const   *)((void *)0))) {
#line 5171
        tmp = "unknown";
      } else {
#line 5171
        tmp = "LeftAndRightImageSizesDiffer";
      }
      {
#line 5171
      ThrowMagickException(exception, "magick/fx.c", "StereoAnaglyphImage", 5171UL,
                           465, tmp, "`%s\'", image->filename);
      }
#line 5171
      return ((Image *)((void *)0));
    }
  }
  {
#line 5175
  stereo_image = CloneImage(left_image, (unsigned long )left_image->columns, (unsigned long )left_image->rows,
                            1, exception);
  }
#line 5177
  if ((unsigned long )stereo_image == (unsigned long )((Image *)((void *)0))) {
#line 5178
    return ((Image *)((void *)0));
  }
  {
#line 5179
  tmp___0 = SetImageStorageClass(stereo_image, 1);
  }
#line 5179
  if ((int )tmp___0 == 0) {
    {
#line 5181
    InheritException(exception, (ExceptionInfo const   *)(& stereo_image->exception));
#line 5182
    stereo_image = DestroyImage(stereo_image);
    }
#line 5183
    return ((Image *)((void *)0));
  }
#line 5188
  y = 0L;
#line 5188
  while (y < (long )stereo_image->rows) {
    {
#line 5200
    tmp___1 = GetVirtualPixels(left_image, - x_offset, y - y_offset, (unsigned long )image->columns,
                               1UL, exception);
#line 5200
    p = (PixelPacket const   */* __restrict  */)tmp___1;
#line 5202
    tmp___2 = GetVirtualPixels(right_image, 0L, y, (unsigned long )right_image->columns,
                               1UL, exception);
#line 5202
    q = (PixelPacket const   */* __restrict  */)tmp___2;
#line 5203
    tmp___3 = QueueAuthenticPixels(stereo_image, 0L, y, stereo_image->columns, 1UL,
                                   exception);
#line 5203
    r = (PixelPacket */* __restrict  */)tmp___3;
    }
#line 5204
    if ((unsigned long )p == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5206
      break;
    } else {
#line 5204
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5206
        break;
      } else {
#line 5204
        if ((unsigned long )r == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5206
          break;
        }
      }
    }
#line 5207
    x = 0L;
#line 5207
    while (x < (long )stereo_image->columns) {
#line 5209
      r->red = (unsigned short )p->red;
#line 5210
      r->green = (unsigned short )q->green;
#line 5211
      r->blue = (unsigned short )q->blue;
#line 5212
      r->opacity = (unsigned short )(((int const   )p->opacity + (int const   )q->opacity) / 2);
#line 5213
      p ++;
#line 5214
      q ++;
#line 5215
      r ++;
#line 5207
      x ++;
    }
    {
#line 5217
    tmp___4 = SyncAuthenticPixels(stereo_image, exception);
    }
#line 5217
    if ((int )tmp___4 == 0) {
#line 5218
      break;
    }
#line 5219
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 5219
      tmp___5 = QuantumTick((long long )y, (unsigned long long )image->rows);
      }
#line 5219
      if ((int )tmp___5 != 0) {
        {
#line 5222
        status = (*(image->progress_monitor))("Stereo/Image", (long long )y, (unsigned long long )stereo_image->rows,
                                              stereo_image->client_data);
        }
#line 5224
        if ((int )status == 0) {
#line 5225
          break;
        }
      }
    }
#line 5188
    y ++;
  }
#line 5228
  return (stereo_image);
}
}
#line 5260 "magick/fx.c"
Image *SwirlImage(Image const   *image , double degrees , ExceptionInfo *exception ) 
{ Image *swirl_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  MagickRealType radius ;
  PointInfo center ;
  PointInfo scale ;
  ResampleFilter **resample_filter ;
  ViewInfo *image_view ;
  ViewInfo *swirl_view ;
  MagickBooleanType tmp ;
  double tmp___0 ;
  MagickPixelPacket pixel ;
  MagickRealType distance ;
  PointInfo delta ;
  register IndexPacket * __restrict  swirl_indexes ;
  register long id ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___1 ;
  IndexPacket *tmp___2 ;
  MagickRealType cosine ;
  MagickRealType factor ;
  MagickRealType sine ;
  double tmp___3 ;
  MagickBooleanType tmp___4 ;
  MagickBooleanType proceed ;
  long tmp___5 ;

  {
#line 5295
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5295
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 5295U, "SwirlImage");
    }
  }
#line 5296
  if (! (image->signature == 2880220587UL)) {
    {
#line 5296
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 5296U, "SwirlImage");
    }
  }
#line 5297
  if ((int const   )image->debug != 0) {
    {
#line 5298
    LogMagickEvent(1, "magick/fx.c", "SwirlImage", 5298UL, "%s", image->filename);
    }
  }
#line 5299
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5299
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5299U,
                  "SwirlImage");
    }
  }
#line 5300
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5300
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5300U, "SwirlImage");
    }
  }
  {
#line 5301
  swirl_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 5302
  if ((unsigned long )swirl_image == (unsigned long )((Image *)((void *)0))) {
#line 5303
    return ((Image *)((void *)0));
  }
  {
#line 5304
  tmp = SetImageStorageClass(swirl_image, 1);
  }
#line 5304
  if ((int )tmp == 0) {
    {
#line 5306
    InheritException(exception, (ExceptionInfo const   *)(& swirl_image->exception));
#line 5307
    swirl_image = DestroyImage(swirl_image);
    }
#line 5308
    return ((Image *)((void *)0));
  }
#line 5310
  if ((int )swirl_image->background_color.opacity != 0) {
#line 5311
    swirl_image->matte = 1;
  }
  {
#line 5315
  center.x = (double )image->columns / 2.0;
#line 5316
  center.y = (double )image->rows / 2.0;
#line 5317
  radius = MagickMax(center.x, center.y);
#line 5318
  scale.x = 1.0;
#line 5319
  scale.y = 1.0;
  }
#line 5320
  if (image->columns > image->rows) {
#line 5321
    scale.y = (double )image->columns / (double )image->rows;
  } else {
#line 5323
    if (image->columns < image->rows) {
#line 5324
      scale.x = (double )image->rows / (double )image->columns;
    }
  }
  {
#line 5325
  tmp___0 = DegreesToRadians(degrees);
#line 5325
  degrees = tmp___0;
#line 5329
  status = 1;
#line 5330
  progress = 0L;
#line 5331
  GetMagickPixelPacket((Image const   *)swirl_image, & zero);
#line 5332
  resample_filter = AcquireResampleFilterThreadSet(image, 1, exception);
#line 5333
  image_view = AcquireCacheView(image);
#line 5334
  swirl_view = AcquireCacheView((Image const   *)swirl_image);
#line 5338
  y = 0L;
  }
#line 5338
  while (y < (long )image->rows) {
#line 5359
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 5361
    tmp___1 = GetCacheViewAuthenticPixels(swirl_view, 0L, y, swirl_image->columns,
                                          1UL, exception);
#line 5361
    q = (PixelPacket */* __restrict  */)tmp___1;
    }
#line 5363
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5365
      status = 0;
      goto __Cont;
    }
    {
#line 5368
    tmp___2 = GetCacheViewAuthenticIndexQueue(swirl_view);
#line 5368
    swirl_indexes = (IndexPacket */* __restrict  */)tmp___2;
#line 5369
    delta.y = scale.y * ((double )y - center.y);
#line 5370
    pixel = zero;
#line 5371
    id = GetPixelCacheThreadId();
#line 5372
    x = 0L;
    }
#line 5372
    while (x < (long )image->columns) {
#line 5377
      delta.x = scale.x * ((double )x - center.x);
#line 5378
      distance = delta.x * delta.x + delta.y * delta.y;
#line 5379
      if (distance < radius * radius) {
        {
#line 5389
        tmp___3 = sqrt(distance);
#line 5389
        factor = 1.0 - tmp___3 / radius;
#line 5390
        sine = sin((degrees * factor) * factor);
#line 5391
        cosine = cos((degrees * factor) * factor);
#line 5392
        ResamplePixelColor(*(resample_filter + id), (cosine * delta.x - sine * delta.y) / scale.x + center.x,
                           (sine * delta.x + cosine * delta.y) / scale.y + center.y,
                           & pixel);
#line 5395
        SetPixelPacket((Image const   *)swirl_image, (MagickPixelPacket const   *)(& pixel),
                       (PixelPacket *)q, (IndexPacket *)(swirl_indexes + x));
        }
      }
#line 5397
      q ++;
#line 5372
      x ++;
    }
    {
#line 5399
    tmp___4 = SyncCacheViewAuthenticPixels(swirl_view, exception);
    }
#line 5399
    if ((int )tmp___4 == 0) {
#line 5400
      status = 0;
    }
#line 5401
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 5409
      tmp___5 = progress;
#line 5409
      progress ++;
#line 5409
      proceed = SetImageProgress(image, "Swirl/Image", (long long )tmp___5, (unsigned long long )image->rows);
      }
#line 5410
      if ((int )proceed == 0) {
#line 5411
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 5338
    y ++;
  }
  {
#line 5414
  swirl_view = DestroyCacheView(swirl_view);
#line 5415
  image_view = DestroyCacheView(image_view);
#line 5416
  resample_filter = DestroyResampleFilterThreadSet(resample_filter);
  }
#line 5417
  if ((int )status == 0) {
    {
#line 5418
    swirl_image = DestroyImage(swirl_image);
    }
  }
#line 5419
  return (swirl_image);
}
}
#line 5453 "magick/fx.c"
Image *TintImage(Image const   *image , char const   *opacity , PixelPacket tint ,
                 ExceptionInfo *exception ) 
{ GeometryInfo geometry_info ;
  Image *tint_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickStatusType flags ;
  MagickPixelPacket color_vector ;
  MagickPixelPacket pixel ;
  ViewInfo *image_view ;
  ViewInfo *tint_view ;
  MagickBooleanType tmp ;
  MagickRealType tmp___0 ;
  MagickRealType tmp___1 ;
  MagickRealType tmp___2 ;
  register PixelPacket const   * __restrict  p ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket const   *tmp___3 ;
  PixelPacket *tmp___4 ;
  MagickPixelPacket pixel___0 ;
  MagickRealType weight ;
  MagickBooleanType tmp___5 ;
  MagickBooleanType proceed ;
  long tmp___6 ;

  {
#line 5485
  if (! ((unsigned long )image != (unsigned long )((Image const   *)((void *)0)))) {
    {
#line 5485
    __assert_fail("image != (const Image *) ((void *)0)", "magick/fx.c", 5485U, "TintImage");
    }
  }
#line 5486
  if (! (image->signature == 2880220587UL)) {
    {
#line 5486
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 5486U, "TintImage");
    }
  }
#line 5487
  if ((int const   )image->debug != 0) {
    {
#line 5488
    LogMagickEvent(1, "magick/fx.c", "TintImage", 5488UL, "%s", image->filename);
    }
  }
#line 5489
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5489
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5489U,
                  "TintImage");
    }
  }
#line 5490
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5490
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5490U, "TintImage");
    }
  }
  {
#line 5491
  tint_image = CloneImage(image, (unsigned long )image->columns, (unsigned long )image->rows,
                          1, exception);
  }
#line 5492
  if ((unsigned long )tint_image == (unsigned long )((Image *)((void *)0))) {
#line 5493
    return ((Image *)((void *)0));
  }
  {
#line 5494
  tmp = SetImageStorageClass(tint_image, 1);
  }
#line 5494
  if ((int )tmp == 0) {
    {
#line 5496
    InheritException(exception, (ExceptionInfo const   *)(& tint_image->exception));
#line 5497
    tint_image = DestroyImage(tint_image);
    }
#line 5498
    return ((Image *)((void *)0));
  }
#line 5500
  if ((unsigned long )opacity == (unsigned long )((char const   *)((void *)0))) {
#line 5501
    return (tint_image);
  }
  {
#line 5505
  flags = ParseGeometry(opacity, & geometry_info);
#line 5506
  pixel.red = geometry_info.rho;
  }
#line 5507
  if ((flags & 8U) != 0U) {
#line 5508
    pixel.green = geometry_info.sigma;
  } else {
#line 5510
    pixel.green = pixel.red;
  }
#line 5511
  if ((flags & 1U) != 0U) {
#line 5512
    pixel.blue = geometry_info.xi;
  } else {
#line 5514
    pixel.blue = pixel.red;
  }
#line 5515
  if ((flags & 2U) != 0U) {
#line 5516
    pixel.opacity = geometry_info.psi;
  } else {
#line 5518
    pixel.opacity = (double )(unsigned short)0;
  }
  {
#line 5519
  tmp___0 = PixelIntensity((PixelPacket const   *)(& tint));
#line 5519
  color_vector.red = (pixel.red * (MagickRealType )tint.red) / 100.0 - tmp___0;
#line 5521
  tmp___1 = PixelIntensity((PixelPacket const   *)(& tint));
#line 5521
  color_vector.green = (pixel.green * (MagickRealType )tint.green) / 100.0 - tmp___1;
#line 5523
  tmp___2 = PixelIntensity((PixelPacket const   *)(& tint));
#line 5523
  color_vector.blue = (pixel.blue * (MagickRealType )tint.blue) / 100.0 - tmp___2;
#line 5528
  status = 1;
#line 5529
  progress = 0L;
#line 5530
  image_view = AcquireCacheView(image);
#line 5531
  tint_view = AcquireCacheView((Image const   *)tint_image);
#line 5535
  y = 0L;
  }
#line 5535
  while (y < (long )image->rows) {
#line 5546
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 5548
    tmp___3 = GetCacheViewVirtualPixels((ViewInfo const   *)image_view, 0L, y, (unsigned long )image->columns,
                                        1UL, exception);
#line 5548
    p = (PixelPacket const   */* __restrict  */)tmp___3;
#line 5549
    tmp___4 = QueueCacheViewAuthenticPixels(tint_view, 0L, y, tint_image->columns,
                                            1UL, exception);
#line 5549
    q = (PixelPacket */* __restrict  */)tmp___4;
    }
#line 5551
    if ((unsigned long )p == (unsigned long )((PixelPacket const   *)((void *)0))) {
#line 5553
      status = 0;
      goto __Cont;
    } else {
#line 5551
      if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5553
        status = 0;
        goto __Cont;
      }
    }
#line 5556
    x = 0L;
#line 5556
    while (x < (long )image->columns) {
      {
#line 5564
      weight = (1.0 / (double )65535UL) * (double )p->red - 0.5;
#line 5565
      pixel___0.red = (double )p->red + color_vector.red * (1.0 - 4.0 * (weight * weight));
#line 5567
      q->red = RoundToQuantum(pixel___0.red);
#line 5568
      weight = (1.0 / (double )65535UL) * (double )p->green - 0.5;
#line 5569
      pixel___0.green = (double )p->green + color_vector.green * (1.0 - 4.0 * (weight * weight));
#line 5571
      q->green = RoundToQuantum(pixel___0.green);
#line 5572
      weight = (1.0 / (double )65535UL) * (double )p->blue - 0.5;
#line 5573
      pixel___0.blue = (double )p->blue + color_vector.blue * (1.0 - 4.0 * (weight * weight));
#line 5575
      q->blue = RoundToQuantum(pixel___0.blue);
#line 5576
      q->opacity = (unsigned short )p->opacity;
#line 5577
      p ++;
#line 5578
      q ++;
#line 5556
      x ++;
      }
    }
    {
#line 5580
    tmp___5 = SyncCacheViewAuthenticPixels(tint_view, exception);
    }
#line 5580
    if ((int )tmp___5 == 0) {
#line 5581
      status = 0;
    }
#line 5582
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 5590
      tmp___6 = progress;
#line 5590
      progress ++;
#line 5590
      proceed = SetImageProgress(image, "Tint/Image", (long long )tmp___6, (unsigned long long )image->rows);
      }
#line 5591
      if ((int )proceed == 0) {
#line 5592
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 5535
    y ++;
  }
  {
#line 5595
  tint_view = DestroyCacheView(tint_view);
#line 5596
  image_view = DestroyCacheView(image_view);
  }
#line 5597
  if ((int )status == 0) {
    {
#line 5598
    tint_image = DestroyImage(tint_image);
    }
  }
#line 5599
  return (tint_image);
}
}
#line 5633 "magick/fx.c"
Image *VignetteImage(Image const   *image , double radius , double sigma , long x ,
                     long y , ExceptionInfo *exception ) 
{ char ellipse[4096] ;
  DrawInfo *draw_info ;
  Image *canvas_image ;
  Image *blur_image ;
  Image *oval_image ;
  Image *vignette_image ;
  MagickBooleanType tmp ;

  {
#line 5648
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 5648
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 5648U, "VignetteImage");
    }
  }
#line 5649
  if (! (image->signature == 2880220587UL)) {
    {
#line 5649
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 5649U, "VignetteImage");
    }
  }
#line 5650
  if ((int const   )image->debug != 0) {
    {
#line 5651
    LogMagickEvent(1, "magick/fx.c", "VignetteImage", 5651UL, "%s", image->filename);
    }
  }
#line 5652
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5652
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5652U,
                  "VignetteImage");
    }
  }
#line 5653
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5653
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5653U, "VignetteImage");
    }
  }
  {
#line 5654
  canvas_image = CloneImage(image, 0UL, 0UL, 1, exception);
  }
#line 5655
  if ((unsigned long )canvas_image == (unsigned long )((Image *)((void *)0))) {
#line 5656
    return ((Image *)((void *)0));
  }
  {
#line 5657
  tmp = SetImageStorageClass(canvas_image, 1);
  }
#line 5657
  if ((int )tmp == 0) {
    {
#line 5659
    InheritException(exception, (ExceptionInfo const   *)(& canvas_image->exception));
#line 5660
    canvas_image = DestroyImage(canvas_image);
    }
#line 5661
    return ((Image *)((void *)0));
  }
  {
#line 5663
  canvas_image->matte = 1;
#line 5664
  oval_image = CloneImage((Image const   *)canvas_image, canvas_image->columns, canvas_image->rows,
                          1, exception);
  }
#line 5666
  if ((unsigned long )oval_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 5668
    canvas_image = DestroyImage(canvas_image);
    }
#line 5669
    return ((Image *)((void *)0));
  }
  {
#line 5671
  QueryColorDatabase("#000000", & oval_image->background_color, exception);
#line 5672
  SetImageBackgroundColor(oval_image);
#line 5673
  draw_info = CloneDrawInfo((ImageInfo const   *)((void *)0), (DrawInfo const   *)((void *)0));
#line 5674
  QueryColorDatabase("#ffffff", & draw_info->fill, exception);
#line 5675
  QueryColorDatabase("#ffffff", & draw_info->stroke, exception);
#line 5676
  FormatMagickString(ellipse, 4096UL, "ellipse %g,%g,%g,%g,0.0,360.0", (double )image->columns / 2.0,
                     (double )image->rows / 2.0, (double )image->columns / 2.0 - (double )x,
                     (double )image->rows / 2.0 - (double )y);
#line 5679
  draw_info->primitive = AcquireString((char const   *)(ellipse));
#line 5680
  DrawImage(oval_image, (DrawInfo const   *)draw_info);
#line 5681
  draw_info = DestroyDrawInfo(draw_info);
#line 5682
  blur_image = BlurImage((Image const   *)oval_image, radius, sigma, exception);
#line 5683
  oval_image = DestroyImage(oval_image);
  }
#line 5684
  if ((unsigned long )blur_image == (unsigned long )((Image *)((void *)0))) {
    {
#line 5686
    canvas_image = DestroyImage(canvas_image);
    }
#line 5687
    return ((Image *)((void *)0));
  }
  {
#line 5689
  blur_image->matte = 0;
#line 5690
  CompositeImage(canvas_image, 17, (Image const   *)blur_image, 0L, 0L);
#line 5691
  blur_image = DestroyImage(blur_image);
#line 5692
  vignette_image = MergeImageLayers(canvas_image, 14, exception);
#line 5693
  canvas_image = DestroyImage(canvas_image);
  }
#line 5694
  return (vignette_image);
}
}
#line 5727 "magick/fx.c"
Image *WaveImage(Image const   *image , double amplitude , double wave_length , ExceptionInfo *exception ) 
{ Image *wave_image ;
  long progress ;
  long y ;
  MagickBooleanType status ;
  MagickPixelPacket zero ;
  MagickRealType *sine_map ;
  register long i ;
  ResampleFilter **resample_filter ;
  ViewInfo *wave_view ;
  double tmp ;
  MagickBooleanType tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  MagickPixelPacket pixel ;
  register IndexPacket * __restrict  indexes ;
  register long id ;
  register long x ;
  register PixelPacket * __restrict  q ;
  PixelPacket *tmp___5 ;
  IndexPacket *tmp___6 ;
  MagickBooleanType tmp___7 ;
  MagickBooleanType proceed ;
  long tmp___8 ;
  void *tmp___9 ;

  {
#line 5760
  if (! ((unsigned long )image != (unsigned long )((Image *)((void *)0)))) {
    {
#line 5760
    __assert_fail("image != (Image *) ((void *)0)", "magick/fx.c", 5760U, "WaveImage");
    }
  }
#line 5761
  if (! (image->signature == 2880220587UL)) {
    {
#line 5761
    __assert_fail("image->signature == 0xabacadabUL", "magick/fx.c", 5761U, "WaveImage");
    }
  }
#line 5762
  if ((int const   )image->debug != 0) {
    {
#line 5763
    LogMagickEvent(1, "magick/fx.c", "WaveImage", 5763UL, "%s", image->filename);
    }
  }
#line 5764
  if (! ((unsigned long )exception != (unsigned long )((ExceptionInfo *)((void *)0)))) {
    {
#line 5764
    __assert_fail("exception != (ExceptionInfo *) ((void *)0)", "magick/fx.c", 5764U,
                  "WaveImage");
    }
  }
#line 5765
  if (! (exception->signature == 2880220587UL)) {
    {
#line 5765
    __assert_fail("exception->signature == 0xabacadabUL", "magick/fx.c", 5765U, "WaveImage");
    }
  }
  {
#line 5766
  tmp = fabs(amplitude);
#line 5766
  wave_image = CloneImage(image, (unsigned long )image->columns, (unsigned long )((double )image->rows + 2.0 * tmp),
                          1, exception);
  }
#line 5768
  if ((unsigned long )wave_image == (unsigned long )((Image *)((void *)0))) {
#line 5769
    return ((Image *)((void *)0));
  }
  {
#line 5770
  tmp___0 = SetImageStorageClass(wave_image, 1);
  }
#line 5770
  if ((int )tmp___0 == 0) {
    {
#line 5772
    InheritException(exception, (ExceptionInfo const   *)(& wave_image->exception));
#line 5773
    wave_image = DestroyImage(wave_image);
    }
#line 5774
    return ((Image *)((void *)0));
  }
#line 5776
  if ((int )wave_image->background_color.opacity != 0) {
#line 5777
    wave_image->matte = 1;
  }
  {
#line 5781
  tmp___1 = AcquireQuantumMemory(wave_image->columns, sizeof(*sine_map));
#line 5781
  sine_map = (MagickRealType *)tmp___1;
  }
#line 5783
  if ((unsigned long )sine_map == (unsigned long )((MagickRealType *)((void *)0))) {
    {
#line 5785
    wave_image = DestroyImage(wave_image);
    }
#line 5786
    if ((unsigned long )"MemoryAllocationFailed" == (unsigned long )((char const   *)((void *)0))) {
#line 5786
      tmp___2 = "unknown";
    } else {
#line 5786
      tmp___2 = "MemoryAllocationFailed";
    }
    {
#line 5786
    ThrowMagickException(exception, "magick/fx.c", "WaveImage", 5786UL, 400, tmp___2,
                         "`%s\'", image->filename);
    }
#line 5786
    return ((Image *)((void *)0));
  }
#line 5788
  i = 0L;
#line 5788
  while (i < (long )wave_image->columns) {
    {
#line 5789
    tmp___3 = fabs(amplitude);
#line 5789
    tmp___4 = sin((((double )2 * 3.14159265358979323846264338327950288419716939937510) * (double )i) / wave_length);
#line 5789
    *(sine_map + i) = tmp___3 + amplitude * tmp___4;
#line 5788
    i ++;
    }
  }
  {
#line 5793
  status = 1;
#line 5794
  progress = 0L;
#line 5795
  GetMagickPixelPacket((Image const   *)wave_image, & zero);
#line 5796
  resample_filter = AcquireResampleFilterThreadSet(image, 1, exception);
#line 5797
  wave_view = AcquireCacheView((Image const   *)wave_image);
#line 5801
  y = 0L;
  }
#line 5801
  while (y < (long )wave_image->rows) {
#line 5816
    if ((int )status == 0) {
      goto __Cont;
    }
    {
#line 5818
    tmp___5 = QueueCacheViewAuthenticPixels(wave_view, 0L, y, wave_image->columns,
                                            1UL, exception);
#line 5818
    q = (PixelPacket */* __restrict  */)tmp___5;
    }
#line 5820
    if ((unsigned long )q == (unsigned long )((PixelPacket *)((void *)0))) {
#line 5822
      status = 0;
      goto __Cont;
    }
    {
#line 5825
    tmp___6 = GetCacheViewAuthenticIndexQueue(wave_view);
#line 5825
    indexes = (IndexPacket */* __restrict  */)tmp___6;
#line 5826
    pixel = zero;
#line 5827
    id = GetPixelCacheThreadId();
#line 5828
    SetResampleFilterVirtualPixelMethod(*(resample_filter + id), 1);
#line 5830
    x = 0L;
    }
#line 5830
    while (x < (long )wave_image->columns) {
      {
#line 5832
      ResamplePixelColor(*(resample_filter + id), (double )x, (MagickRealType )y - *(sine_map + x),
                         & pixel);
#line 5834
      SetPixelPacket((Image const   *)wave_image, (MagickPixelPacket const   *)(& pixel),
                     (PixelPacket *)q, (IndexPacket *)(indexes + x));
#line 5835
      q ++;
#line 5830
      x ++;
      }
    }
    {
#line 5837
    tmp___7 = SyncCacheViewAuthenticPixels(wave_view, exception);
    }
#line 5837
    if ((int )tmp___7 == 0) {
#line 5838
      status = 0;
    }
#line 5839
    if ((unsigned long )image->progress_monitor != (unsigned long )((MagickBooleanType (*)(char const   * ,
                                                                                           MagickOffsetType  ,
                                                                                           MagickSizeType  ,
                                                                                           void * ))((void *)0))) {
      {
#line 5847
      tmp___8 = progress;
#line 5847
      progress ++;
#line 5847
      proceed = SetImageProgress(image, "Wave/Image", (long long )tmp___8, (unsigned long long )image->rows);
      }
#line 5848
      if ((int )proceed == 0) {
#line 5849
        status = 0;
      }
    }
    __Cont: /* CIL Label */ 
#line 5801
    y ++;
  }
  {
#line 5852
  wave_view = DestroyCacheView(wave_view);
#line 5853
  resample_filter = DestroyResampleFilterThreadSet(resample_filter);
#line 5854
  tmp___9 = RelinquishMagickMemory((void *)sine_map);
#line 5854
  sine_map = (MagickRealType *)tmp___9;
  }
#line 5855
  if ((int )status == 0) {
    {
#line 5856
    wave_image = DestroyImage(wave_image);
    }
  }
#line 5857
  return (wave_image);
}
}
