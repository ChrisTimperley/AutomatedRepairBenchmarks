/* Generated by CIL v. 1.3.6 */
/* print_CIL_Input is false */

#line 31 "/usr/include/bits/types.h"
typedef unsigned char __u_char;
#line 56 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 57 "/usr/include/bits/types.h"
typedef unsigned long long __u_quad_t;
#line 134 "/usr/include/bits/types.h"
typedef __u_quad_t __dev_t;
#line 135 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 139 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 140 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 141 "/usr/include/bits/types.h"
typedef long __off_t;
#line 142 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 143 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 146 "/usr/include/bits/types.h"
typedef unsigned long __rlim_t;
#line 149 "/usr/include/bits/types.h"
typedef long __time_t;
#line 151 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 164 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 169 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 192 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 35 "/usr/include/sys/types.h"
typedef __u_char u_char;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 88 "/usr/include/sys/types.h"
typedef __off_t off_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 77 "/usr/include/time.h"
typedef __time_t time_t;
#line 214 "/usr/lib/gcc/i386-redhat-linux/4.3.2/include/stddef.h"
typedef unsigned int size_t;
#line 29 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
#line 29 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 121 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024U / (8U * sizeof(__fd_mask ))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 45 "/usr/include/stdio.h"
struct _IO_FILE;
#line 45
struct _IO_FILE;
#line 49 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 43 "/usr/lib/gcc/i386-redhat-linux/4.3.2/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 180 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 186 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 271 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
#line 341 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 245 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 162 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 75 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 127 "/usr/include/bits/resource.h"
typedef __rlim_t rlim_t;
#line 135 "/usr/include/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 43 "/usr/include/sys/resource.h"
typedef int __rlimit_resource_t;
#line 50 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 52 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 97 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 141 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 142 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 225 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 29 "/usr/include/bits/setjmp.h"
typedef int __jmp_buf[6];
#line 35 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 49 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 100 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 99 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 256 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 105 "/usr/lib/gcc/i386-redhat-linux/4.3.2/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 69 "proto.h"
struct aclmember;
#line 69
struct aclmember;
#line 31 "conversions.h"
struct convert {
   struct convert *next ;
   char *stripprefix ;
   char *stripfix ;
   char *prefix ;
   char *postfix ;
   char *external_cmd ;
   int types ;
   int options ;
   char *name ;
};
#line 41 "extensions.h"
struct aclmember {
   struct aclmember *next ;
   char keyword[20] ;
   char *arg[50] ;
};
#line 40 "/usr/include/shadow.h"
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 41 "/usr/include/bits/types.h"
typedef int __int32_t;
#line 134 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 139 "ftpcmd.y"
struct tab {
   char *name ;
   short token ;
   short state ;
   short implemented ;
   char *help ;
};
#line 182 "ftpcmd.y"
union __anonunion_YYSTYPE_52 {
   char *String ;
   int Number ;
};
#line 182 "ftpcmd.y"
typedef union __anonunion_YYSTYPE_52 YYSTYPE;
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 197 "/usr/include/sys/types.h"
typedef int int32_t;
#line 52 "/usr/include/bits/utmp.h"
struct exit_status {
   short e_termination ;
   short e_exit ;
};
#line 60 "/usr/include/bits/utmp.h"
struct utmp {
   short ut_type ;
   pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct exit_status ut_exit ;
   long ut_session ;
   struct timeval ut_tv ;
   int32_t ut_addr_v6[4] ;
   char __unused[20] ;
};
#line 38 "/usr/include/sys/select.h"
typedef __sigset_t sigset_t;
#line 63 "/usr/include/sys/wait.h"
union wait;
#line 63
union wait;
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_46 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_47 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 67 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_46 __wait_terminated ;
   struct __anonstruct___wait_stopped_47 __wait_stopped ;
};
#line 244 "popen.c"
union __anonunion_56 {
   int __in ;
   int __i ;
};
#line 244 "popen.c"
union __anonunion_57 {
   int __in ;
   int __i ;
};
#line 44 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 356 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 422 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 425 "/usr/include/regex.h"
typedef int regoff_t;
#line 451 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_53 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 451 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_53 regmatch_t;
#line 443 "extensions.c"
struct dirlist {
   struct dirlist *next ;
   int dircode ;
   char dirname[1] ;
};
#line 76 "private.c"
struct acgrp {
   char gname[100] ;
   char gpass[100] ;
   char gr_name[100] ;
   gid_t gr_gid ;
   struct acgrp *next ;
};
#line 58 "conversions.c"
struct str2int {
   char *string ;
   int value ;
};
#line 66 "hostacc.h"
struct __anonstruct_hacc_t_52 {
   short ha_type ;
   char *ha_login ;
   char *ha_hosts[12] ;
};
#line 66 "hostacc.h"
typedef struct __anonstruct_hacc_t_52 hacc_t;
#line 32 "/usr/include/bits/types.h"
typedef unsigned short __u_short;
#line 34 "/usr/include/bits/types.h"
typedef unsigned long __u_long;
#line 36 "/usr/include/sys/types.h"
typedef __u_short u_short;
#line 38 "/usr/include/sys/types.h"
typedef __u_long u_long;
#line 106 "routevector.c"
struct v_addr {
   u_long s_external_identity ;
   u_long s_vector ;
   unsigned short s_sig ;
};
#line 111 "routevector.c"
typedef struct v_addr v_addr;
#line 112 "routevector.c"
struct v_index {
   v_addr *memory ;
   v_addr **index ;
   unsigned short count ;
   unsigned short slots ;
};
#line 118 "routevector.c"
typedef struct v_index v_index;
#line 119 "routevector.c"
struct v_paddr {
   u_long s_address ;
   int minport ;
   int maxport ;
   unsigned short s_sig ;
};
#line 125 "routevector.c"
typedef struct v_paddr v_paddr;
#line 126 "routevector.c"
struct v_ports {
   v_paddr *memory ;
   v_paddr **index ;
   unsigned short count ;
   unsigned short slots ;
};
#line 132 "routevector.c"
typedef struct v_ports v_ports;
#line 33 "/usr/include/bits/types.h"
typedef unsigned int __u_int;
#line 37 "/usr/include/sys/types.h"
typedef __u_int u_int;
#line 202 "/usr/include/sys/types.h"
typedef unsigned short u_int16_t;
#line 203 "/usr/include/sys/types.h"
typedef unsigned int u_int32_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 198 "/usr/include/netinet/in.h"
union __anonunion___in6_u_51 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 198 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_51 __in6_u ;
};
#line 239 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
struct __anonstruct_HEADER_52 {
   unsigned int id : 16 ;
   unsigned int rd : 1 ;
   unsigned int tc : 1 ;
   unsigned int aa : 1 ;
   unsigned int opcode : 4 ;
   unsigned int qr : 1 ;
   unsigned int rcode : 4 ;
   unsigned int cd : 1 ;
   unsigned int ad : 1 ;
   unsigned int unused : 1 ;
   unsigned int ra : 1 ;
   unsigned int qdcount : 16 ;
   unsigned int ancount : 16 ;
   unsigned int nscount : 16 ;
   unsigned int arcount : 16 ;
};
#line 48 "/usr/include/arpa/nameser_compat.h"
typedef struct __anonstruct_HEADER_52 HEADER;
#line 71 "/usr/include/resolv.h"
enum __anonenum_res_sendhookact_53 {
    res_goahead = 0,
    res_nextns = 1,
    res_modified = 2,
    res_done = 3,
    res_error = 4
} ;
#line 71 "/usr/include/resolv.h"
typedef enum __anonenum_res_sendhookact_53 res_sendhookact;
#line 104 "/usr/include/resolv.h"
struct __anonstruct_sort_list_54 {
   struct in_addr addr ;
   u_int32_t mask ;
};
#line 104 "/usr/include/resolv.h"
struct __anonstruct__ext_56 {
   u_int16_t nscount ;
   u_int16_t nsmap[3] ;
   int nssocks[3] ;
   u_int16_t nscount6 ;
   u_int16_t nsinit ;
   struct sockaddr_in6 *nsaddrs[3] ;
   unsigned int _initstamp[2] ;
};
#line 104 "/usr/include/resolv.h"
union __anonunion__u_55 {
   char pad[52] ;
   struct __anonstruct__ext_56 _ext ;
};
#line 104 "/usr/include/resolv.h"
struct __res_state {
   int retrans ;
   int retry ;
   u_long options ;
   int nscount ;
   struct sockaddr_in nsaddr_list[3] ;
   u_short id ;
   char *dnsrch[7] ;
   char defdname[256] ;
   u_long pfcode ;
   unsigned int ndots : 4 ;
   unsigned int nsort : 4 ;
   unsigned int ipv6_unavail : 1 ;
   unsigned int unused : 23 ;
   struct __anonstruct_sort_list_54 sort_list[10] ;
   res_sendhookact (*qhook)(struct sockaddr_in * const  *ns , u_char const   **query ,
                            int *querylen , u_char *ans , int anssiz , int *resplen ) ;
   res_sendhookact (*rhook)(struct sockaddr_in  const  *ns , u_char const   *query ,
                            int querylen , u_char *ans , int anssiz , int *resplen ) ;
   int res_h_errno ;
   int _vcsock ;
   u_int _flags ;
   union __anonunion__u_55 _u ;
};
#line 80 "domain.c"
struct t_resolver_options {
   char *token ;
   int value ;
};
#line 191 "domain.c"
union __anonunion_querybuf_57 {
   HEADER qb1 ;
   u_char qb2[512] ;
};
#line 191 "domain.c"
typedef union __anonunion_querybuf_57 querybuf;
#line 36 "wu_fnmatch.c"
typedef int boolean;
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   * 
                                , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   * ,
                                 __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 1 "COPYRIGHT.o"
/* #pragma merger(0,"/tmp/cil-1ckvQozz.i","-g,-O2") */
#line 339 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 30 "COPYRIGHT.c"
void print_copyright(void) ;
#line 31
char version[48] ;
#line 33 "COPYRIGHT.c"
char *Copyright  =    (char *)"\n  Copyright (c) 1999 WU-FTPD Development Group.\n  All rights reserved.\n\n  Portions Copyright (c) 1980, 1985, 1988, 1989, 1990, 1991, 1993, 1994\n    The Regents of the University of California.\n  Portions Copyright (c) 1993, 1994 Washington University in Saint Louis.\n  Portions Copyright (c) 1996, 1998 Berkeley Software Design, Inc.\n  Portions Copyright (c) 1989 Massachusetts Institute of Technology.\n  Portions Copyright (c) 1998 Sendmail, Inc.\n  Portions Copyright (c) 1983, 1995, 1996, 1997 Eric P.  Allman.\n  Portions Copyright (c) 1997 by Stan Barber.\n  Portions Copyright (c) 1997 by Kent Landfield.\n  Portions Copyright (c) 1991, 1992, 1993, 1994, 1995, 1996, 1997\n    Free Software Foundation, Inc.  \n\n  Use and distribution of this software and its source code are governed \n  by the terms and conditions of the WU-FTPD Software License (\"LICENSE\").\n\n  If you did not receive a copy of the license, it may be obtained online\n  at http://www.wu-ftpd.org/license.html.\n";
#line 55 "COPYRIGHT.c"
void print_copyright(void) 
{ 

  {
  {
#line 57
  printf((char const   */* __restrict  */)"%s\n", Copyright);
#line 58
  printf((char const   */* __restrict  */)"%s\n", version);
  }
#line 59
  return;
}
}
#line 1 "vers.o"
/* #pragma merger(0,"/tmp/cil-_LAtKr1V.i","-g,-O2") */
#line 1 "vers.c"
char version[48]  = 
#line 1 "vers.c"
  {      (char )'V',      (char )'e',      (char )'r',      (char )'s', 
        (char )'i',      (char )'o',      (char )'n',      (char )' ', 
        (char )'w',      (char )'u',      (char )'-',      (char )'2', 
        (char )'.',      (char )'6',      (char )'.',      (char )'0', 
        (char )'(',      (char )'6',      (char )')',      (char )' ', 
        (char )'T',      (char )'h',      (char )'u',      (char )' ', 
        (char )'J',      (char )'a',      (char )'n',      (char )' ', 
        (char )'8',      (char )' ',      (char )'2',      (char )'2', 
        (char )':',      (char )'0',      (char )'2',      (char )':', 
        (char )'4',      (char )'6',      (char )' ',      (char )'E', 
        (char )'S',      (char )'T',      (char )' ',      (char )'2', 
        (char )'0',      (char )'0',      (char )'9',      (char )'\000'};
#line 1 "ftpd.o"
/* #pragma merger(0,"/tmp/cil-RS1CnmyL.i","-g,-O2") */
#line 109 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 458 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 459
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 145 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern struct _IO_FILE *stdout ;
#line 147
extern struct _IO_FILE *stderr ;
#line 159
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
#line 216
extern int fclose(FILE *__stream ) ;
#line 221
extern int fflush(FILE *__stream ) ;
#line 251
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 257
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 285
extern  __attribute__((__nothrow__)) FILE *fdopen(int __fd , char const   *__modes ) ;
#line 313
extern  __attribute__((__nothrow__)) int setvbuf(FILE * __restrict  __stream , char * __restrict  __buf ,
                                                 int __modes , size_t __n ) ;
#line 333
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 341
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 356
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 363
extern  __attribute__((__nothrow__)) int snprintf(char * __restrict  str , size_t count ,
                                                  char const   * __restrict  fmt 
                                                  , ...) ;
#line 367
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
#line 602
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 686
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 720
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 801
extern  __attribute__((__nothrow__)) int ferror(FILE *__stream ) ;
#line 829
extern  __attribute__((__nothrow__)) int fileno(FILE *__stream ) ;
#line 148 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 184
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
#line 188
extern  __attribute__((__nothrow__)) unsigned long strtoul(char const   * __restrict  __nptr ,
                                                           char ** __restrict  __endptr ,
                                                           int __base )  __attribute__((__nonnull__(1))) ;
#line 283
__inline static  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 283 "/usr/include/stdlib.h"
__inline static int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  {
#line 286
  tmp = strtol((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
  }
#line 286
  return ((int )tmp);
}
}
#line 380
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 382
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 471
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 473
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 488
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 531
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 301 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
#line 320
extern int close(int __fd ) ;
#line 327
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 333
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 399
extern  __attribute__((__nothrow__)) unsigned int alarm(unsigned int __seconds ) ;
#line 411
extern unsigned int sleep(unsigned int __seconds ) ;
#line 439
extern  __attribute__((__nothrow__)) int chown(char const   *__file , __uid_t __owner ,
                                               __gid_t __group )  __attribute__((__nonnull__(1))) ;
#line 444
extern  __attribute__((__nothrow__)) int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 463
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 499
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
#line 560
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 585
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
#line 646
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
#line 657
extern  __attribute__((__nothrow__)) __uid_t geteuid(void) ;
#line 689
extern  __attribute__((__nothrow__)) int seteuid(__uid_t __uid ) ;
#line 706
extern  __attribute__((__nothrow__)) int setegid(__gid_t __gid ) ;
#line 735
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 804
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 813
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 59 "/usr/include/getopt.h"
extern char *optarg ;
#line 82
extern int optopt ;
#line 152
extern  __attribute__((__nothrow__)) int getopt(int ___argc , char * const  *___argv ,
                                                char const   *__shortopts ) ;
#line 857 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
#line 907
extern  __attribute__((__nothrow__)) char *getusershell(void) ;
#line 908
extern  __attribute__((__nothrow__)) void endusershell(void) ;
#line 922
extern  __attribute__((__nothrow__)) int chroot(char const   *__path )  __attribute__((__nonnull__(1))) ;
#line 209 "/usr/include/sys/stat.h"
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 214
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 261
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 309
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
#line 318
extern  __attribute__((__nothrow__)) int mkdir(char const   *__path , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 397
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
#line 399
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 401
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
#line 450
__inline static  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 450 "/usr/include/sys/stat.h"
__inline static int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 453
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 453
  return (tmp);
}
}
#line 457
__inline static  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
#line 457 "/usr/include/sys/stat.h"
__inline static int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  {
#line 460
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  }
#line 460
  return (tmp);
}
}
#line 464
__inline static  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
#line 464 "/usr/include/sys/stat.h"
__inline static int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  {
#line 467
  tmp = __fxstat(3, __fd, __statbuf);
  }
#line 467
  return (tmp);
}
}
#line 105 "/usr/include/sys/socket.h"
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
#line 115
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  *__addr ,
                                              socklen_t __len ) ;
#line 119
extern  __attribute__((__nothrow__)) int getsockname(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 129
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 133
extern  __attribute__((__nothrow__)) int getpeername(int __fd , struct sockaddr * __restrict  __addr ,
                                                     socklen_t * __restrict  __len ) ;
#line 197
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
#line 204
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
#line 214
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 223
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
#line 76 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 85
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
#line 92 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 305
extern char const   * const  sys_siglist[65] ;
#line 51 "/usr/include/sys/resource.h"
extern  __attribute__((__nothrow__)) int getrlimit(__rlimit_resource_t __resource ,
                                                   struct rlimit *__rlimits ) ;
#line 139 "/usr/include/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 50 "../support/ftp.h"
char *typenames[5]  = {      (char *)"0",      (char *)"ASCII",      (char *)"EBCDIC",      (char *)"Image", 
        (char *)"Local"};
#line 61 "../support/ftp.h"
char *formnames[4]  = {      (char *)"0",      (char *)"Nonprint",      (char *)"Telnet",      (char *)"Carriage-control"};
#line 72 "../support/ftp.h"
char *strunames[4]  = {      (char *)"0",      (char *)"File",      (char *)"Record",      (char *)"Page"};
#line 83 "../support/ftp.h"
char *modenames[4]  = {      (char *)"0",      (char *)"Stream",      (char *)"Block",      (char *)"Compressed"};
#line 35 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t inet_addr(char const   *__cp ) ;
#line 54
extern  __attribute__((__nothrow__)) char *inet_ntoa(struct in_addr __in ) ;
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 111 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 117
extern struct passwd *getpwnam(char const   *__name ) ;
#line 109 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 199
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 60 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 65
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 110
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 43 "/usr/include/bits/errno.h"
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
#line 38 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 59
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
#line 84
extern  __attribute__((__nothrow__)) char *strcpy(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 92
extern  __attribute__((__nothrow__)) char *strcat(char * __restrict  __dest , char const   * __restrict  __src )  __attribute__((__nonnull__(1,2))) ;
#line 102
extern  __attribute__((__nothrow__)) int strncmp(char const   *__s1 , char const   *__s2 ,
                                                 size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 170
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 194
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 256
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
#line 331
extern  __attribute__((__nothrow__)) int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 335
extern  __attribute__((__nothrow__)) int strncasecmp(char const   *__s1 , char const   *__s2 ,
                                                     size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 1303 "/usr/include/bits/string2.h"
extern  __attribute__((__nothrow__)) char *__strdup(char const   *__string )  __attribute__((__malloc__)) ;
#line 136 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 143
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 289
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 46 "proto.h"
int hostmatch(char *addr , char *remoteaddr___0 , char *remotehost___0 ) ;
#line 47
int acl_guestgroup(struct passwd *pw___0 ) ;
#line 48
int acl_realgroup(struct passwd *pw___0 ) ;
#line 49
void acl_autogroup(struct passwd *pw___0 ) ;
#line 50
void acl_setfunctions(void) ;
#line 51
int acl_getclass(char *classbuf ) ;
#line 61
void acl_remove(void) ;
#line 62
void pr_mesg(int msgcode , char *msgfile ) ;
#line 63
void access_init(void) ;
#line 64
int access_ok(int msgcode ) ;
#line 69
struct aclmember *getaclentry(char *keyword , struct aclmember **next ) ;
#line 84
int wu_authenticate(void) ;
#line 89
void conv_init(void) ;
#line 98
void show_banner(int msgcode ) ;
#line 99
void show_message(int msgcode , int mode___0 ) ;
#line 100
void show_readme(int code , int mode___0 ) ;
#line 101
int deny_badasciixfer(int msgcode , char *filepath ) ;
#line 102
int is_shutdown(int quiet , int new___0 ) ;
#line 104
int type_match(char *typelist ) ;
#line 106
void expand_id(void) ;
#line 107
int fn_check(char *name ) ;
#line 108
int dir_check(char *name , uid_t *uid , gid_t *gid , int *d_mode , int *valid___0 ) ;
#line 109
int upl_check(char *name , uid_t *uid , gid_t *gid , int *f_mode , int *valid___0 ) ;
#line 110
int del_check(char *name ) ;
#line 111
int regexmatch(char *name , char *rgexp ) ;
#line 112
int checknoretrieve(char *name ) ;
#line 119
void throughput_calc(char *name , int *bps , double *bpsmult ) ;
#line 120
void throughput_adjust(char *name ) ;
#line 129
char *wu_getline(char *s , int n , FILE *iop ) ;
#line 130
int yyparse(void) ;
#line 131
void upper(char *s ) ;
#line 143
void randomsig(int sig ) ;
#line 144
void lostconn(int sig ) ;
#line 145
char *mapping_getwd(char *path ) ;
#line 146
void do_elem(char *dir ) ;
#line 147
int mapping_chdir(char *orig_path ) ;
#line 148
char *sgetsave(char *s ) ;
#line 149
struct passwd *sgetpwnam(char *name ) ;
#line 151
void user(char *name ) ;
#line 152
int checkuser(char *name ) ;
#line 153
int denieduid(uid_t uid ) ;
#line 154
int alloweduid(uid_t uid ) ;
#line 155
int deniedgid(gid_t gid ) ;
#line 156
int allowedgid(gid_t gid ) ;
#line 157
void end_login(void) ;
#line 158
int validate_eaddr(char *eaddr ) ;
#line 159
void pass(char *passwd ) ;
#line 160
int restricteduid(uid_t uid ) ;
#line 161
int unrestricteduid(uid_t uid ) ;
#line 162
int restrictedgid(gid_t gid ) ;
#line 163
int unrestrictedgid(gid_t gid ) ;
#line 164
char *opt_string(int options ) ;
#line 165
void retrieve(char *cmd , char *name ) ;
#line 166
void store(char *name , char *mode___0 , int unique ) ;
#line 167
FILE *getdatasock(char *mode___0 ) ;
#line 168
FILE *dataconn(char *name , off_t size , char *mode___0 ) ;
#line 170
int send_data(char *name , FILE *instr , FILE *outstr , off_t blksize ) ;
#line 174
int receive_data(FILE *instr , FILE *outstr ) ;
#line 175
void statfilecmd(char *filename ) ;
#line 176
void statcmd(void) ;
#line 177
void fatal(char *s ) ;
#line 178
void vreply(long flags , int n , char *fmt , va_list ap ) ;
#line 179
void reply(int n , char *fmt  , ...) ;
#line 180
void lreply(int n , char *fmt  , ...) ;
#line 181
void ack(char *s ) ;
#line 182
void nack(char *s ) ;
#line 183
void yyerror(char *s ) ;
#line 184
void delete(char *name ) ;
#line 185
void cwd(char *path ) ;
#line 186
void makedir(char *name ) ;
#line 187
void removedir(char *name ) ;
#line 188
void pwd(void) ;
#line 189
char *renamefrom(char *name ) ;
#line 190
void renamecmd(char *from , char *to ) ;
#line 191
void dologout(int status ) ;
#line 192
void myoob(int sig ) ;
#line 193
void passive(void) ;
#line 194
char *gunique(char *local ) ;
#line 195
void perror_reply(int code , char *string ) ;
#line 196
void send_file_list(char *whichfiles ) ;
#line 197
void initsetproctitle(int argc , char **argv , char **envp ) ;
#line 198
void setproctitle(char const   *fmt  , ...) ;
#line 201
void do_daemon(int argc , char **argv , char **envp ) ;
#line 210
void fixpath(char *path ) ;
#line 215
void blkfree(char **av0 ) ;
#line 216
char **ftpglob(char *v ) ;
#line 221
int rhost_ok(char *pcRuser , char *pcRhost , char *pcRaddr ) ;
#line 229
void wu_logwtmp(char *line___0 , char *name , char *host , int login___0 ) ;
#line 234
void setup_paths(void) ;
#line 239
FILE *ftpd_popen(char *program , char *type___0 , int closestderr ) ;
#line 240
int ftpd_pclose(FILE *iop ) ;
#line 259
char *fb_realpath(char const   *path , char *resolved ) ;
#line 260
char *wu_realpath(char const   *path , char *resolved_path , char *chroot_path___0 ) ;
#line 272
int routevector(void) ;
#line 273
void checkports(void) ;
#line 278
int enable_signaling(void) ;
#line 279
int delay_signaling(void) ;
#line 175 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void syslog(int __pri , char const   *__fmt  , ...) ;
#line 187 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
#line 257
extern  __attribute__((__nothrow__)) char *ctime(time_t const   *__timer ) ;
#line 43 "conversions.h"
struct convert *cvtptr  ;
#line 63 "/usr/include/shadow.h"
extern void setspent(void) ;
#line 71
extern void endspent(void) ;
#line 87
extern struct spwd *getspnam(char const   *__name ) ;
#line 150 "/usr/include/dirent.h"
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 196 "ftpd.c"
int mailservers  =    0;
#line 197 "ftpd.c"
char *mailserver[10]  ;
#line 198 "ftpd.c"
int incmails  =    0;
#line 199 "ftpd.c"
char *incmail[10]  ;
#line 200 "ftpd.c"
char *mailfrom  ;
#line 201
char *email(char *full_address ) ;
#line 202
FILE *SockOpen(char *host , int clientPort ) ;
#line 203
char *SockGets(FILE *sockfp , char *buf___2 , int len ) ;
#line 204
int SockWrite(char *buf___2 , int size , int len , FILE *sockfp ) ;
#line 205
int SockPrintf(FILE *sockfp , char *format  , ...) ;
#line 206
int SockPuts(FILE *sockfp , char *buf___2 ) ;
#line 207
int Reply(FILE *sockfp ) ;
#line 208
int Send(FILE *sockfp , char *format  , ...) ;
#line 222
extern char *crypt(char const   * , char const   * ) ;
#line 226 "ftpd.c"
char *home  ;
#line 227 "ftpd.c"
char cbuf[512]  ;
#line 228 "ftpd.c"
off_t restart_point  ;
#line 229 "ftpd.c"
int yyerrorcalled  ;
#line 231 "ftpd.c"
struct sockaddr_in ctrl_addr  ;
#line 232 "ftpd.c"
struct sockaddr_in data_source  ;
#line 233 "ftpd.c"
struct sockaddr_in data_dest  ;
#line 234 "ftpd.c"
struct sockaddr_in his_addr  ;
#line 235 "ftpd.c"
struct sockaddr_in pasv_addr  ;
#line 236 "ftpd.c"
struct sockaddr_in vect_addr  ;
#line 237 "ftpd.c"
int route_vectored  =    0;
#line 238 "ftpd.c"
int passive_port_min  =    -1;
#line 239 "ftpd.c"
int passive_port_max  =    -1;
#line 240 "ftpd.c"
int restricted_user  =    0;
#line 243 "ftpd.c"
char virtual_root[4096]  ;
#line 244 "ftpd.c"
char virtual_banner[4096]  ;
#line 245 "ftpd.c"
char virtual_email[4096]  ;
#line 247 "ftpd.c"
char virtual_hostname[64]  ;
#line 248 "ftpd.c"
char virtual_address[64]  ;
#line 250 "ftpd.c"
char hostaddress[32]  ;
#line 252
int virtual_mode ;
#line 260 "ftpd.c"
int data  ;
#line 261 "ftpd.c"
jmp_buf errcatch  ;
#line 262 "ftpd.c"
sigjmp_buf urgcatch  ;
#line 263 "ftpd.c"
int logged_in  =    0;
#line 264 "ftpd.c"
struct passwd *pw  ;
#line 265 "ftpd.c"
char chroot_path[4096]  ;
#line 266 "ftpd.c"
int debug  =    0;
#line 267 "ftpd.c"
int disable_rfc931  =    0;
#line 268
unsigned int timeout_idle ;
#line 269
unsigned int timeout_maxidle ;
#line 270
unsigned int timeout_data ;
#line 271
unsigned int timeout_accept ;
#line 272
unsigned int timeout_connect ;
#line 277 "ftpd.c"
int logging  =    0;
#line 278 "ftpd.c"
int log_commands  =    0;
#line 279 "ftpd.c"
int log_security  =    0;
#line 280 "ftpd.c"
int syslogmsg  =    0;
#line 281 "ftpd.c"
static int wtmp_logging  =    1;
#line 295 "ftpd.c"
int anonymous  =    1;
#line 296 "ftpd.c"
int guest  ;
#line 297 "ftpd.c"
int type  ;
#line 298 "ftpd.c"
int form  ;
#line 299 "ftpd.c"
int stru  ;
#line 300 "ftpd.c"
int mode  ;
#line 301 "ftpd.c"
int usedefault  =    1;
#line 302 "ftpd.c"
int pdata  =    -1;
#line 303 "ftpd.c"
int transflag  ;
#line 304 "ftpd.c"
int ftwflag  ;
#line 305 "ftpd.c"
off_t file_size  ;
#line 306 "ftpd.c"
off_t byte_count  ;
#line 307 "ftpd.c"
int TCPwindowsize  =    0;
#line 310 "ftpd.c"
int data_count_total  =    0;
#line 311 "ftpd.c"
int data_count_in  =    0;
#line 312 "ftpd.c"
int data_count_out  =    0;
#line 313 "ftpd.c"
int byte_count_total  =    0;
#line 314 "ftpd.c"
int byte_count_in  =    0;
#line 315 "ftpd.c"
int byte_count_out  =    0;
#line 316 "ftpd.c"
int file_count_total  =    0;
#line 317 "ftpd.c"
int file_count_in  =    0;
#line 318 "ftpd.c"
int file_count_out  =    0;
#line 319 "ftpd.c"
int xfer_count_total  =    0;
#line 320 "ftpd.c"
int xfer_count_in  =    0;
#line 321 "ftpd.c"
int xfer_count_out  =    0;
#line 323 "ftpd.c"
int file_limit_raw_in  =    0;
#line 324 "ftpd.c"
int file_limit_raw_out  =    0;
#line 325 "ftpd.c"
int file_limit_raw_total  =    0;
#line 326 "ftpd.c"
int file_limit_data_in  =    0;
#line 327 "ftpd.c"
int file_limit_data_out  =    0;
#line 328 "ftpd.c"
int file_limit_data_total  =    0;
#line 329 "ftpd.c"
int data_limit_raw_in  =    0;
#line 330 "ftpd.c"
int data_limit_raw_out  =    0;
#line 331 "ftpd.c"
int data_limit_raw_total  =    0;
#line 332 "ftpd.c"
int data_limit_data_in  =    0;
#line 333 "ftpd.c"
int data_limit_data_out  =    0;
#line 334 "ftpd.c"
int data_limit_data_total  =    0;
#line 338 "ftpd.c"
int retrieve_is_data  =    1;
#line 339 "ftpd.c"
char LastFileTransferred[4096]  = {      (char )'\000'};
#line 341 "ftpd.c"
static char *RootDirectory  =    (char *)((void *)0);
#line 347 "ftpd.c"
mode_t defumask  =    18U;
#line 349 "ftpd.c"
char defhome[2]  = {      (char )'/',      (char )'\000'};
#line 351 "ftpd.c"
char tmpline[7]  ;
#line 352 "ftpd.c"
char hostname[64]  ;
#line 353 "ftpd.c"
char remotehost[64]  ;
#line 354 "ftpd.c"
char remoteaddr[64]  ;
#line 355 "ftpd.c"
char *remoteident  =    (char *)"[nowhere yet]";
#line 360 "ftpd.c"
char the_user[256]  ;
#line 365 "ftpd.c"
int use_accessfile  =    0;
#line 366 "ftpd.c"
char guestpw[64]  ;
#line 367 "ftpd.c"
char privatepw[64]  ;
#line 368 "ftpd.c"
int nameserved  =    0;
#line 369 "ftpd.c"
char authuser[100]  ;
#line 370 "ftpd.c"
int authenticated  ;
#line 371
int keepalive ;
#line 374 "ftpd.c"
int xferlog  =    0;
#line 375 "ftpd.c"
int log_outbound_xfers  =    0;
#line 376 "ftpd.c"
int log_incoming_xfers  =    0;
#line 377 "ftpd.c"
char logfile[4096]  ;
#line 381 "ftpd.c"
int dolreplies  =    1;
#line 384 "ftpd.c"
char *autospout  =    (char *)((void *)0);
#line 385 "ftpd.c"
int autospout_free  =    0;
#line 388 "ftpd.c"
int mangleopts  =    0;
#line 391 "ftpd.c"
int lgi_failure_threshold  =    5;
#line 398 "ftpd.c"
int swaitmax  =    90;
#line 399 "ftpd.c"
int swaitint  =    5;
#line 420
int initialize_dns(struct sockaddr_in *remote_socket ) ;
#line 421
int check_reverse_dns(void) ;
#line 422
int check_matching_dns(void) ;
#line 429 "ftpd.c"
char proctitle[8192]  ;
#line 466 "ftpd.c"
char ls_long[1024]  ;
#line 467 "ftpd.c"
char ls_short[1024]  ;
#line 468 "ftpd.c"
char ls_plain[1024]  ;
#line 472 "ftpd.c"
int be_daemon  =    0;
#line 473 "ftpd.c"
int daemon_port  =    0;
#line 476 "ftpd.c"
int Bypass_PID_Files  =    0;
#line 480
char *mapping_getcwd(char *path , size_t size ) ;
#line 487
void dolog(struct sockaddr_in *sin ) ;
#line 504 "ftpd.c"
time_t login_time  ;
#line 505 "ftpd.c"
time_t limit_time  =    0L;
#line 509
int pasv_allowed(char *remoteaddr___0 ) ;
#line 510
int port_allowed(char *remoteaddr___0 ) ;
#line 516 "ftpd.c"
static void alarm_signal(int sig ) 
{ 

  {
#line 518
  return;
}
}
#line 520 "ftpd.c"
static FILE *draconian_FILE  =    (FILE *)((void *)0);
#line 522 "ftpd.c"
static void draconian_alarm_signal(int sig ) 
{ 

  {
#line 524
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 525
    fclose(draconian_FILE);
#line 526
    draconian_FILE = (FILE *)((void *)0);
    }
  }
#line 528
  return;
}
}
#line 530 "ftpd.c"
static void socket_flush_wait(FILE *file ) 
{ char c ;
  int fd___0 ;
  int tmp ;

  {
  {
#line 534
  tmp = fileno(file);
#line 534
  fd___0 = tmp;
  }
#line 535
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 536
    shutdown(fd___0, 1);
    }
  }
#line 537
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 538
    read(fd___0, (void *)(& c), 1U);
    }
  }
#line 545
  return;
}
}
#line 547 "ftpd.c"
int main(int argc , char **argv , char **envp ) 
{ int addrlen ;
  int on ;
  int tos ;
  int c ;
  int which ;
  struct hostent *shp ;
  struct aclmember *entry ;
  int virtual_len ;
  struct sockaddr_in *virtual_ptr ;
  struct sockaddr_in virtual_addr ;
  size_t tmp ;
  void *tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned int val ;
  char *tmp___4 ;
  void (*tmp___5)(int  ) ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  register unsigned short __v___1 ;
  register unsigned short __x___1 ;
  int tmp___10 ;
  __pid_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct aclmember *tmp___16 ;
  struct aclmember *tmp___17 ;
  struct aclmember *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  char *tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  struct aclmember *tmp___49 ;
  char *tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  char *tmp___71 ;
  int tmp___72 ;
  struct aclmember *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  struct aclmember *tmp___78 ;
  size_t tmp___79 ;
  struct aclmember *tmp___80 ;
  size_t tmp___81 ;
  struct aclmember *tmp___82 ;
  size_t tmp___83 ;
  int tmp___84 ;
  char *tmp___94 ;
  struct aclmember *tmp___95 ;
  int tmp___96 ;
  char *tmp___106 ;
  int tmp___107 ;
  char *tmp___117 ;
  struct aclmember *tmp___118 ;
  char *tmp___128 ;
  char *tmp___138 ;
  struct aclmember *tmp___139 ;
  int version_option ;
  char output_text[1025] ;
  int arg_count ;
  int output_len ;
  int tmp___140 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  struct aclmember *tmp___144 ;
  int arg_len ;
  size_t tmp___145 ;

  {
  {
#line 554
  on = 1;
#line 583
  closelog();
#line 585
  openlog("ftpd", 9, 11 << 3);
  }
#line 632
  while (1) {
    {
#line 632
    c = getopt(argc, (char * const  *)argv, ":aAvdlLiIop:P:qQr:sSt:T:u:VwWX");
    }
#line 632
    if (! (c != -1)) {
#line 632
      break;
    }
#line 634
    switch (c) {
    case 97: 
#line 637
    use_accessfile = 1;
#line 638
    break;
    case 65: 
#line 641
    use_accessfile = 0;
#line 642
    break;
    case 118: 
#line 645
    debug = 1;
#line 646
    break;
    case 100: 
#line 649
    debug = 1;
#line 650
    break;
    case 108: 
#line 653
    logging = 1;
#line 654
    break;
    case 76: 
#line 657
    log_commands = 1;
#line 658
    break;
    case 105: 
#line 661
    log_incoming_xfers = 1;
#line 662
    break;
    case 73: 
#line 665
    disable_rfc931 = 1;
#line 666
    break;
    case 111: 
#line 669
    log_outbound_xfers = 1;
#line 670
    break;
    case 113: 
#line 673
    Bypass_PID_Files = 0;
#line 674
    break;
    case 81: 
#line 677
    Bypass_PID_Files = 1;
#line 678
    break;
    case 114: 
#line 681
    if ((unsigned int )optarg != (unsigned int )((void *)0)) {
#line 681
      if ((int )*(optarg + 0) != 0) {
        {
#line 682
        tmp = strlen((char const   *)optarg);
#line 682
        tmp___0 = malloc(tmp + 1U);
#line 682
        RootDirectory = (char *)tmp___0;
        }
#line 683
        if ((unsigned int )RootDirectory != (unsigned int )((void *)0)) {
          {
#line 684
          strcpy((char */* __restrict  */)RootDirectory, (char const   */* __restrict  */)optarg);
          }
        }
      }
    }
#line 686
    break;
    case 80: 
    {
#line 689
    tmp___1 = atoi((char const   *)optarg);
#line 689
    __x = (unsigned short )tmp___1;
#line 689
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 689
    data_source.sin_port = __v;
    }
#line 690
    break;
    case 112: 
    {
#line 694
    daemon_port = atoi((char const   *)optarg);
    }
#line 695
    break;
    case 115: 
#line 698
    be_daemon = 1;
#line 699
    break;
    case 83: 
#line 702
    be_daemon = 2;
#line 703
    break;
    case 116: 
    {
#line 707
    tmp___2 = atoi((char const   *)optarg);
#line 707
    timeout_idle = (unsigned int )tmp___2;
    }
#line 708
    if (timeout_maxidle < timeout_idle) {
#line 709
      timeout_maxidle = timeout_idle;
    }
#line 710
    break;
    case 84: 
    {
#line 713
    tmp___3 = atoi((char const   *)optarg);
#line 713
    timeout_maxidle = (unsigned int )tmp___3;
    }
#line 714
    if (timeout_idle > timeout_maxidle) {
#line 715
      timeout_idle = timeout_maxidle;
    }
#line 716
    break;
    case 117: 
#line 720
    val = 0U;
#line 722
    while (1) {
#line 722
      if (*optarg) {
#line 722
        if ((int )*optarg >= 48) {
#line 722
          if (! ((int )*optarg <= 57)) {
#line 722
            break;
          }
        } else {
#line 722
          break;
        }
      } else {
#line 722
        break;
      }
#line 723
      tmp___4 = optarg;
#line 723
      optarg ++;
#line 723
      val = (val * 8U + (unsigned int )*tmp___4) - 48U;
    }
#line 724
    if (*optarg) {
      {
#line 725
      syslog(3, "bad value for -u");
      }
    } else {
#line 724
      if (val > 511U) {
        {
#line 725
        syslog(3, "bad value for -u");
        }
      } else {
#line 727
        defumask = val;
      }
    }
#line 728
    break;
    case 86: 
    {
#line 732
    print_copyright();
#line 733
    exit(0);
    }
    case 119: 
#line 736
    wtmp_logging = 1;
#line 737
    break;
    case 87: 
#line 740
    wtmp_logging = 0;
#line 741
    break;
    case 120: 
#line 744
    syslogmsg = 2;
#line 745
    break;
    case 88: 
#line 748
    syslogmsg = 1;
#line 749
    break;
    case 58: 
    {
#line 752
    syslog(3, "option -%c requires an argument", optopt);
    }
#line 753
    break;
    default: 
    {
#line 756
    syslog(3, "unknown option -%c ignored", optopt);
    }
#line 757
    break;
    }
  }
  {
#line 760
  initsetproctitle(argc, argv, envp);
#line 761
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
          (FILE */* __restrict  */)stderr);
#line 769
  signal(1, & randomsig);
#line 775
  signal(2, & randomsig);
#line 781
  signal(3, & randomsig);
#line 787
  signal(4, & randomsig);
#line 793
  signal(5, & randomsig);
#line 799
  signal(6, & randomsig);
#line 811
  signal(8, & randomsig);
#line 817
  signal(9, & randomsig);
#line 823
  signal(7, & randomsig);
#line 829
  signal(11, & randomsig);
#line 835
  signal(31, & randomsig);
#line 841
  signal(14, & randomsig);
#line 847
  signal(19, & randomsig);
#line 853
  signal(20, & randomsig);
#line 859
  signal(21, & randomsig);
#line 865
  signal(22, & randomsig);
#line 871
  signal(29, & randomsig);
#line 877
  signal(24, & randomsig);
#line 883
  signal(25, & randomsig);
#line 889
  signal(28, & randomsig);
#line 895
  signal(26, & randomsig);
#line 901
  signal(27, & randomsig);
#line 907
  signal(10, & randomsig);
#line 913
  signal(12, & randomsig);
#line 920
  signal(13, & lostconn);
#line 926
  signal(17, (void (*)(int  ))1);
#line 933
  tmp___5 = signal(23, & myoob);
  }
#line 933
  if ((unsigned int )tmp___5 == (unsigned int )((void (*)(int  ))-1)) {
    {
#line 934
    syslog(3, "signal: %m");
    }
  }
  {
#line 942
  virtual_root[0] = (char )'\000';
#line 943
  virtual_banner[0] = (char )'\000';
#line 946
  setup_paths();
#line 947
  access_init();
  }
#line 950
  if (be_daemon != 0) {
    {
#line 951
    do_daemon(argc, argv, envp);
    }
  }
  {
#line 952
  addrlen = (int )sizeof(his_addr);
#line 953
  tmp___6 = getpeername(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& his_addr)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 953
  if (tmp___6 < 0) {
    {
#line 954
    syslog(3, "getpeername (%s): %m", *(argv + 0));
#line 956
    exit(1);
    }
  }
  {
#line 959
  addrlen = (int )sizeof(ctrl_addr);
#line 960
  tmp___7 = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& ctrl_addr)),
                        (socklen_t */* __restrict  */)(& addrlen));
  }
#line 960
  if (tmp___7 < 0) {
    {
#line 961
    syslog(3, "getsockname (%s): %m", *(argv + 0));
#line 963
    exit(1);
    }
  }
  {
#line 967
  tos = 16;
#line 968
  tmp___8 = setsockopt(0, 0, 1, (void const   *)((char *)(& tos)), sizeof(int ));
  }
#line 968
  if (tmp___8 < 0) {
    {
#line 969
    syslog(4, "setsockopt (IP_TOS): %m");
    }
  }
#line 971
  if (keepalive) {
    {
#line 972
    tmp___9 = setsockopt(0, 1, 9, (void const   *)((char *)(& on)), sizeof(on));
    }
#line 972
    if (tmp___9 < 0) {
      {
#line 973
      syslog(3, "setsockopt SO_KEEPALIVE %m");
      }
    }
  }
  {
#line 975
  __x___1 = ctrl_addr.sin_port;
#line 975
  __asm__  ("rorw $8, %w0": "=r" (__v___1): "0" (__x___1): "cc");
#line 975
  __x___0 = (unsigned short )((int )__v___1 - 1);
#line 975
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 975
  data_source.sin_port = __v___0;
#line 980
  tmp___10 = setsockopt(0, 1, 10, (void const   *)((char *)(& on)), sizeof(int ));
  }
#line 980
  if (tmp___10 < 0) {
    {
#line 981
    syslog(3, "setsockopt (SO_OOBINLINE): %m");
    }
  }
  {
#line 985
  tmp___11 = getpid();
#line 985
  tmp___12 = fileno(stdin);
#line 985
  tmp___13 = fcntl(tmp___12, 8, tmp___11);
  }
#line 985
  if (tmp___13 == -1) {
    {
#line 986
    syslog(3, "fcntl F_SETOWN: %m");
    }
  }
#line 996
  if ((unsigned int )RootDirectory != (unsigned int )((void *)0)) {
    {
#line 997
    tmp___14 = chroot((char const   *)RootDirectory);
    }
#line 997
    if (tmp___14 < 0) {
      {
#line 999
      syslog(3, "Cannot chroot to initial directory, aborting.");
#line 1000
      exit(1);
      }
    } else {
      {
#line 997
      tmp___15 = chdir("/");
      }
#line 997
      if (tmp___15 < 0) {
        {
#line 999
        syslog(3, "Cannot chroot to initial directory, aborting.");
#line 1000
        exit(1);
        }
      }
    }
  }
  {
#line 1006
  initialize_dns(& his_addr);
#line 1009
  dolog(& his_addr);
#line 1011
  data = -1;
#line 1012
  type = 1;
#line 1013
  form = 1;
#line 1014
  stru = 1;
#line 1015
  mode = 1;
#line 1016
  tmpline[0] = (char )'\000';
#line 1017
  yyerrorcalled = 0;
#line 1019
  entry = (struct aclmember *)((void *)0);
#line 1020
  tmp___16 = getaclentry((char *)"hostname", & entry);
  }
#line 1020
  if (tmp___16) {
#line 1020
    if (entry->arg[0]) {
      {
#line 1021
      __builtin_strncpy(hostname, (char const   *)entry->arg[0], sizeof(hostname));
#line 1022
      hostname[sizeof(hostname) - 1U] = (char )'\000';
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    {
#line 1028
    gethostname(hostname, sizeof(hostname));
#line 1031
    shp = gethostbyname((char const   *)(hostname));
    }
#line 1032
    if ((unsigned int )shp != (unsigned int )((void *)0)) {
      {
#line 1033
      __builtin_strncpy(hostname, (char const   *)shp->h_name, sizeof(hostname));
#line 1034
      hostname[sizeof(hostname) - 1U] = (char )'\000';
      }
    }
  }
  {
#line 1037
  route_vectored = routevector();
#line 1038
  conv_init();
#line 1041
  incmails = 0;
#line 1042
  mailfrom = (char *)((void *)0);
  }
#line 1056
  if (virtual_mode) {
    {
#line 1058
    entry = (struct aclmember *)((void *)0);
#line 1059
    tmp___17 = getaclentry((char *)"root", & entry);
    }
#line 1059
    if (tmp___17) {
#line 1060
      if (entry->arg[0]) {
        {
#line 1061
        strcpy((char */* __restrict  */)(virtual_root), (char const   */* __restrict  */)entry->arg[0]);
        }
      }
    }
    {
#line 1065
    entry = (struct aclmember *)((void *)0);
#line 1066
    tmp___18 = getaclentry((char *)"logfile", & entry);
    }
#line 1066
    if (tmp___18) {
#line 1067
      if (entry->arg[0]) {
        {
#line 1068
        strcpy((char */* __restrict  */)(logfile), (char const   */* __restrict  */)entry->arg[0]);
        }
      }
    }
  } else {
    {
#line 1072
    virtual_hostname[0] = (char )'\000';
#line 1073
    virtual_address[0] = (char )'\000';
#line 1074
    virtual_len = (int )sizeof(virtual_addr);
#line 1075
    tmp___74 = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& virtual_addr)),
                           (socklen_t */* __restrict  */)(& virtual_len));
    }
#line 1075
    if (tmp___74 == 0) {
      {
#line 1076
      virtual_ptr = & virtual_addr;
#line 1077
      tmp___19 = inet_ntoa(virtual_ptr->sin_addr);
#line 1077
      strcpy((char */* __restrict  */)(virtual_address), (char const   */* __restrict  */)tmp___19);
#line 1078
      shp = gethostbyaddr((void const   *)((char *)(& virtual_ptr->sin_addr)), sizeof(struct in_addr ),
                          2);
      }
#line 1079
      if ((unsigned int )shp != (unsigned int )((void *)0)) {
        {
#line 1080
        __builtin_strncpy(virtual_hostname, (char const   *)shp->h_name, sizeof(virtual_hostname));
#line 1081
        virtual_hostname[sizeof(virtual_hostname) - 1U] = (char )'\000';
        }
      }
#line 1083
      entry = (struct aclmember *)((void *)0);
#line 1084
      while (1) {
        {
#line 1084
        tmp___49 = getaclentry((char *)"virtual", & entry);
        }
#line 1084
        if (! tmp___49) {
#line 1084
          break;
        }
#line 1085
        if (! entry->arg[0]) {
#line 1086
          continue;
        } else {
#line 1085
          if (! entry->arg[1]) {
#line 1086
            continue;
          } else {
#line 1085
            if (! entry->arg[2]) {
#line 1086
              continue;
            }
          }
        }
        {
#line 1087
        tmp___48 = hostmatch(entry->arg[0], virtual_address, virtual_hostname);
        }
#line 1087
        if (tmp___48) {
          {
#line 1088
          tmp___20 = strcasecmp((char const   *)entry->arg[1], "root");
          }
#line 1088
          if (! tmp___20) {
            {
#line 1089
            syslog(5, "VirtualFTP Connect to: %s [%s]", virtual_hostname, virtual_address);
#line 1091
            virtual_mode = 1;
#line 1092
            __builtin_strncpy(virtual_root, (char const   *)entry->arg[2], sizeof(virtual_root));
#line 1093
            virtual_root[sizeof(virtual_root) - 1U] = (char )'\000';
#line 1095
            strcpy((char */* __restrict  */)(hostname), (char const   */* __restrict  */)(virtual_hostname));
#line 1096
            virtual_email[0] = (char )'\000';
            }
          }
          {
#line 1098
          tmp___21 = strcasecmp((char const   *)entry->arg[1], "banner");
          }
#line 1098
          if (! tmp___21) {
            {
#line 1099
            __builtin_strncpy(virtual_banner, (char const   *)entry->arg[2], sizeof(virtual_banner));
#line 1100
            virtual_banner[sizeof(virtual_banner) - 1U] = (char )'\000';
            }
          }
          {
#line 1102
          tmp___22 = strcasecmp((char const   *)entry->arg[1], "logfile");
          }
#line 1102
          if (! tmp___22) {
            {
#line 1103
            __builtin_strncpy(logfile, (char const   *)entry->arg[2], sizeof(logfile));
#line 1104
            logfile[sizeof(logfile) - 1U] = (char )'\000';
            }
          }
          {
#line 1106
          tmp___23 = strcasecmp((char const   *)entry->arg[1], "hostname");
          }
#line 1106
          if (! tmp___23) {
            {
#line 1107
            __builtin_strncpy(hostname, (char const   *)entry->arg[2], sizeof(hostname));
#line 1108
            hostname[sizeof(hostname) - 1U] = (char )'\000';
            }
          }
          {
#line 1110
          tmp___24 = strcasecmp((char const   *)entry->arg[1], "email");
          }
#line 1110
          if (! tmp___24) {
            {
#line 1111
            __builtin_strncpy(virtual_email, (char const   *)entry->arg[2], sizeof(virtual_email));
#line 1112
            virtual_email[sizeof(virtual_email) - 1U] = (char )'\000';
            }
          }
#line 1115
          if ((unsigned int )mailfrom == (unsigned int )((void *)0)) {
            {
#line 1116
            tmp___35 = strcasecmp((char const   *)entry->arg[1], "mailfrom");
            }
#line 1116
            if (! tmp___35) {
              {
#line 1117
              tmp___34 = __strdup((char const   *)entry->arg[2]);
#line 1117
              mailfrom = tmp___34;
              }
            }
          }
          {
#line 1119
          tmp___47 = strcasecmp((char const   *)entry->arg[1], "incmail");
          }
#line 1119
          if (! tmp___47) {
#line 1120
            if (incmails < 10) {
              {
#line 1121
              tmp___36 = incmails;
#line 1121
              incmails ++;
#line 1121
              tmp___46 = __strdup((char const   *)entry->arg[2]);
#line 1121
              incmail[tmp___36] = tmp___46;
              }
            }
          }
        }
      }
#line 1126
      if (! virtual_mode) {
#line 1127
        entry = (struct aclmember *)((void *)0);
#line 1128
        while (1) {
          {
#line 1128
          tmp___73 = getaclentry((char *)"defaultserver", & entry);
          }
#line 1128
          if (! tmp___73) {
#line 1128
            break;
          }
#line 1129
          if (! entry->arg[0]) {
#line 1130
            continue;
          } else {
#line 1129
            if (! entry->arg[1]) {
#line 1130
              continue;
            }
          }
#line 1132
          if ((unsigned int )mailfrom == (unsigned int )((void *)0)) {
            {
#line 1133
            tmp___60 = strcasecmp((char const   *)entry->arg[0], "mailfrom");
            }
#line 1133
            if (! tmp___60) {
              {
#line 1134
              tmp___59 = __strdup((char const   *)entry->arg[1]);
#line 1134
              mailfrom = tmp___59;
              }
            }
          }
          {
#line 1136
          tmp___72 = strcasecmp((char const   *)entry->arg[0], "incmail");
          }
#line 1136
          if (! tmp___72) {
#line 1137
            if (incmails < 10) {
              {
#line 1138
              tmp___61 = incmails;
#line 1138
              incmails ++;
#line 1138
              tmp___71 = __strdup((char const   *)entry->arg[1]);
#line 1138
              incmail[tmp___61] = tmp___71;
              }
            }
          }
        }
      }
    }
  }
  {
#line 1168
  tmp___75 = is_shutdown(1, 1);
  }
#line 1168
  if (tmp___75 != 0) {
    {
#line 1169
    syslog(6, "connection refused (server shut down) from %s", remoteident);
#line 1171
    reply(500, (char *)"%s FTP server shut down -- please try again later.", hostname);
#line 1173
    exit(0);
    }
  }
  {
#line 1182
  tmp___76 = check_reverse_dns();
  }
#line 1182
  if (! tmp___76) {
    {
#line 1183
    exit(0);
    }
  }
  {
#line 1185
  tmp___77 = check_matching_dns();
  }
#line 1185
  if (! tmp___77) {
    {
#line 1186
    exit(0);
    }
  }
  {
#line 1190
  show_banner(220);
#line 1193
  entry = (struct aclmember *)((void *)0);
#line 1194
  tmp___78 = getaclentry((char *)"lslong", & entry);
  }
#line 1194
  if (tmp___78) {
#line 1194
    if (entry->arg[0]) {
      {
#line 1194
      tmp___79 = strlen((char const   *)entry->arg[0]);
      }
#line 1194
      if ((int )tmp___79 > 0) {
        {
#line 1195
        strcpy((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)entry->arg[0]);
#line 1196
        which = 1;
        }
#line 1196
        while (1) {
#line 1196
          if (which < 50) {
#line 1196
            if (! entry->arg[which]) {
#line 1196
              break;
            }
          } else {
#line 1196
            break;
          }
          {
#line 1197
          strcat((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)" ");
#line 1198
          strcat((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)entry->arg[which]);
#line 1196
          which ++;
          }
        }
      } else {
        {
#line 1209
        strcpy((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)"/bin/ls -lgA");
        }
      }
    } else {
      {
#line 1209
      strcpy((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)"/bin/ls -lgA");
      }
    }
  } else {
    {
#line 1209
    strcpy((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)"/bin/ls -lgA");
    }
  }
  {
#line 1212
  strcat((char */* __restrict  */)(ls_long), (char const   */* __restrict  */)" %s");
#line 1214
  entry = (struct aclmember *)((void *)0);
#line 1215
  tmp___80 = getaclentry((char *)"lsshort", & entry);
  }
#line 1215
  if (tmp___80) {
#line 1215
    if (entry->arg[0]) {
      {
#line 1215
      tmp___81 = strlen((char const   *)entry->arg[0]);
      }
#line 1215
      if ((int )tmp___81 > 0) {
        {
#line 1216
        strcpy((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)entry->arg[0]);
#line 1217
        which = 1;
        }
#line 1217
        while (1) {
#line 1217
          if (which < 50) {
#line 1217
            if (! entry->arg[which]) {
#line 1217
              break;
            }
          } else {
#line 1217
            break;
          }
          {
#line 1218
          strcat((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)" ");
#line 1219
          strcat((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)entry->arg[which]);
#line 1217
          which ++;
          }
        }
      } else {
        {
#line 1231
        strcpy((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)"/bin/ls -lgA");
        }
      }
    } else {
      {
#line 1231
      strcpy((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)"/bin/ls -lgA");
      }
    }
  } else {
    {
#line 1231
    strcpy((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)"/bin/ls -lgA");
    }
  }
  {
#line 1234
  strcat((char */* __restrict  */)(ls_short), (char const   */* __restrict  */)" %s");
#line 1236
  entry = (struct aclmember *)((void *)0);
#line 1237
  tmp___82 = getaclentry((char *)"lsplain", & entry);
  }
#line 1237
  if (tmp___82) {
#line 1237
    if (entry->arg[0]) {
      {
#line 1237
      tmp___83 = strlen((char const   *)entry->arg[0]);
      }
#line 1237
      if ((int )tmp___83 > 0) {
        {
#line 1238
        strcpy((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)entry->arg[0]);
#line 1239
        which = 1;
        }
#line 1239
        while (1) {
#line 1239
          if (which < 50) {
#line 1239
            if (! entry->arg[which]) {
#line 1239
              break;
            }
          } else {
#line 1239
            break;
          }
          {
#line 1240
          strcat((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)" ");
#line 1241
          strcat((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)entry->arg[which]);
#line 1239
          which ++;
          }
        }
      } else {
        {
#line 1245
        strcpy((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)"/bin/ls");
        }
      }
    } else {
      {
#line 1245
      strcpy((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)"/bin/ls");
      }
    }
  } else {
    {
#line 1245
    strcpy((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)"/bin/ls");
    }
  }
  {
#line 1246
  strcat((char */* __restrict  */)(ls_plain), (char const   */* __restrict  */)" %s");
#line 1249
  mailservers = 0;
#line 1250
  entry = (struct aclmember *)((void *)0);
  }
#line 1251
  while (1) {
    {
#line 1251
    tmp___95 = getaclentry((char *)"mailserver", & entry);
    }
#line 1251
    if (tmp___95) {
#line 1251
      if (entry->arg[0]) {
#line 1251
        if (! (mailservers < 10)) {
#line 1251
          break;
        }
      } else {
#line 1251
        break;
      }
    } else {
#line 1251
      break;
    }
    {
#line 1252
    tmp___84 = mailservers;
#line 1252
    mailservers ++;
#line 1252
    tmp___94 = __strdup((char const   *)entry->arg[0]);
#line 1252
    mailserver[tmp___84] = tmp___94;
    }
  }
#line 1253
  if (mailservers == 0) {
    {
#line 1254
    tmp___96 = mailservers;
#line 1254
    mailservers ++;
#line 1254
    tmp___106 = __strdup("localhost");
#line 1254
    mailserver[tmp___96] = tmp___106;
    }
  }
#line 1255
  if (incmails == 0) {
#line 1256
    entry = (struct aclmember *)((void *)0);
#line 1257
    while (1) {
      {
#line 1257
      tmp___118 = getaclentry((char *)"incmail", & entry);
      }
#line 1257
      if (tmp___118) {
#line 1257
        if (entry->arg[0]) {
#line 1257
          if (! (incmails < 10)) {
#line 1257
            break;
          }
        } else {
#line 1257
          break;
        }
      } else {
#line 1257
        break;
      }
      {
#line 1258
      tmp___107 = incmails;
#line 1258
      incmails ++;
#line 1258
      tmp___117 = __strdup((char const   *)entry->arg[0]);
#line 1258
      incmail[tmp___107] = tmp___117;
      }
    }
  }
#line 1260
  if ((unsigned int )mailfrom == (unsigned int )((void *)0)) {
    {
#line 1261
    entry = (struct aclmember *)((void *)0);
#line 1262
    tmp___139 = getaclentry((char *)"mailfrom", & entry);
    }
#line 1262
    if (tmp___139) {
#line 1262
      if (entry->arg[0]) {
        {
#line 1263
        tmp___128 = __strdup((char const   *)entry->arg[0]);
#line 1263
        mailfrom = tmp___128;
        }
      } else {
        {
#line 1265
        tmp___138 = __strdup("wu-ftpd");
#line 1265
        mailfrom = tmp___138;
        }
      }
    } else {
      {
#line 1265
      tmp___138 = __strdup("wu-ftpd");
#line 1265
      mailfrom = tmp___138;
      }
    }
  }
  {
#line 1270
  version_option = 0;
#line 1274
  entry = (struct aclmember *)((void *)0);
#line 1275
  tmp___144 = getaclentry((char *)"greeting", & entry);
  }
#line 1275
  if (tmp___144) {
#line 1275
    if (entry->arg[0]) {
      {
#line 1276
      tmp___143 = strcasecmp((char const   *)entry->arg[0], "full");
      }
#line 1276
      if (tmp___143) {
        {
#line 1278
        tmp___142 = strcasecmp((char const   *)entry->arg[0], "text");
        }
#line 1278
        if (tmp___142) {
          _L___0: 
          {
#line 1280
          tmp___141 = strcasecmp((char const   *)entry->arg[0], "terse");
          }
#line 1280
          if (tmp___141) {
            {
#line 1282
            tmp___140 = strcasecmp((char const   *)entry->arg[0], "brief");
            }
#line 1282
            if (! tmp___140) {
#line 1283
              version_option = 1;
            }
          } else {
#line 1281
            version_option = 2;
          }
        } else {
#line 1278
          if (entry->arg[1]) {
#line 1279
            version_option = 3;
          } else {
            goto _L___0;
          }
        }
      } else {
#line 1277
        version_option = 0;
      }
    }
  }
#line 1285
  switch (version_option) {
  default: 
  {
#line 1287
  reply(220, (char *)"%s FTP server (%s) ready.", hostname, version);
  }
#line 1288
  break;
  case 1: 
  {
#line 1290
  reply(220, (char *)"%s FTP server ready.", hostname);
  }
#line 1291
  break;
  case 2: 
  {
#line 1293
  reply(220, (char *)"FTP server ready.");
  }
#line 1294
  break;
  case 3: 
#line 1296
  output_text[0] = (char )'\000';
#line 1297
  output_len = 0;
#line 1298
  arg_count = 1;
#line 1298
  while ((unsigned int )entry->arg[arg_count] != (unsigned int )((void *)0)) {
    {
#line 1301
    tmp___145 = strlen((char const   *)entry->arg[arg_count]);
#line 1301
    arg_len = (int )tmp___145;
    }
#line 1303
    if (output_len + arg_len > 1024) {
#line 1305
      break;
    }
    {
#line 1309
    strcat((char */* __restrict  */)(output_text), (char const   */* __restrict  */)entry->arg[arg_count]);
#line 1310
    output_len += arg_len;
    }
#line 1312
    if ((unsigned int )entry->arg[arg_count + 1] != (unsigned int )((void *)0)) {
#line 1313
      if (output_len + 2 > 1024) {
#line 1315
        break;
      }
      {
#line 1318
      strcat((char */* __restrict  */)(output_text), (char const   */* __restrict  */)" ");
#line 1319
      output_len ++;
      }
    }
#line 1298
    arg_count ++;
  }
  {
#line 1322
  reply(220, (char *)"%s", output_text);
  }
#line 1323
  break;
  }
  {
#line 1326
  _setjmp(errcatch);
  }
#line 1328
  while (1) {
    {
#line 1329
    yyparse();
    }
  }
}
}
#line 1334 "ftpd.c"
void randomsig(int sig ) 
{ 

  {
  {
#line 1337
  syslog(3, "exiting on signal %d: %s", sig, sys_siglist[sig]);
#line 1341
  chdir("/");
#line 1342
  signal(6, (void (*)(int  ))0);
#line 1343
  signal(4, (void (*)(int  ))0);
#line 1344
  exit(1);
  }
}
}
#line 1348 "ftpd.c"
void lostconn(int sig ) 
{ 

  {
  {
#line 1351
  syslog(6, "lost connection to %s", remoteident);
#line 1356
  dologout(-1);
  }
#line 1357
  return;
}
}
#line 1359 "ftpd.c"
static char ttyline[20]  ;
#line 1366 "ftpd.c"
char mapped_path[4096]  = {      (char )'/',      (char )'\000'};
#line 1368 "ftpd.c"
char *mapping_getwd(char *path ) 
{ 

  {
  {
#line 1370
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)(mapped_path));
  }
#line 1371
  return (path);
}
}
#line 1374 "ftpd.c"
char *mapping_getcwd(char *path , size_t size ) 
{ 

  {
  {
#line 1376
  __builtin_strncpy(path, (char const   *)(mapped_path), size);
#line 1377
  *(path + (size - 1U)) = (char )'\000';
  }
#line 1378
  return (path);
}
}
#line 1382 "ftpd.c"
char pathspace[4096]  ;
#line 1383 "ftpd.c"
char old_mapped_path[4096]  ;
#line 1385 "ftpd.c"
void do_elem(char *dir ) 
{ char *last___0 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 1388
  if ((int )*(dir + 0) == 46) {
#line 1388
    if ((int )*(dir + 1) == 0) {
#line 1390
      return;
    }
  }
#line 1394
  if ((int )*(dir + 0) == 46) {
#line 1394
    if ((int )*(dir + 1) == 46) {
#line 1394
      if ((int )*(dir + 2) == 0) {
        {
#line 1397
        last___0 = strrchr((char const   *)(mapped_path), '/');
        }
#line 1397
        if (last___0) {
#line 1399
          if ((unsigned int )last___0 == (unsigned int )(mapped_path)) {
#line 1400
            last___0 ++;
          }
#line 1401
          *last___0 = (char )'\000';
        }
#line 1403
        return;
      }
    }
  }
#line 1407
  if ((int )mapped_path[0] == 47) {
#line 1407
    if (! ((int )mapped_path[1] == 0)) {
      goto _L;
    }
  } else {
    _L: 
    {
#line 1408
    tmp = strlen((char const   *)(mapped_path));
    }
#line 1408
    if (tmp < sizeof(mapped_path) - 1U) {
      {
#line 1409
      strcat((char */* __restrict  */)(mapped_path), (char const   */* __restrict  */)"/");
      }
    }
  }
  {
#line 1410
  tmp___1 = strlen((char const   *)(mapped_path));
  }
#line 1410
  if (sizeof(mapped_path) - tmp___1 > 1U) {
    {
#line 1411
    tmp___0 = strlen((char const   *)(mapped_path));
#line 1411
    __builtin_strncat(mapped_path, (char const   *)dir, (sizeof(mapped_path) - tmp___0) - 1U);
    }
  }
#line 1412
  return;
}
}
#line 1414 "ftpd.c"
int mapping_chdir(char *orig_path ) 
{ int ret ;
  char *sl ;
  char *path ;
  char *dir ;
  char *tmp___0 ;

  {
  {
#line 1419
  strcpy((char */* __restrict  */)(old_mapped_path), (char const   */* __restrict  */)(mapped_path));
#line 1420
  path = pathspace;
#line 1421
  strcpy((char */* __restrict  */)path, (char const   */* __restrict  */)orig_path);
  }
#line 1424
  if ((int )*(path + 0) == 47) {
#line 1425
    mapped_path[0] = (char )'/';
#line 1426
    mapped_path[1] = (char )'\000';
#line 1427
    path ++;
  }
#line 1430
  while (1) {
    {
#line 1430
    tmp___0 = __builtin_strchr(path, '/');
#line 1430
    sl = tmp___0;
    }
#line 1430
    if (! sl) {
#line 1430
      break;
    }
#line 1432
    dir = path;
#line 1433
    *sl = (char )'\000';
#line 1434
    path = sl + 1;
#line 1435
    if (*dir) {
      {
#line 1436
      do_elem(dir);
      }
    }
#line 1437
    if ((int )*path == 0) {
#line 1438
      break;
    }
  }
#line 1440
  if (*path) {
    {
#line 1441
    do_elem(path);
    }
  }
  {
#line 1443
  ret = chdir((char const   *)(mapped_path));
  }
#line 1443
  if (ret < 0) {
    {
#line 1444
    strcpy((char */* __restrict  */)(mapped_path), (char const   */* __restrict  */)(old_mapped_path));
    }
  }
#line 1447
  return (ret);
}
}
#line 1458 "ftpd.c"
char *sgetsave(char *s ) 
{ char *new___0 ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1462
  tmp = strlen((char const   *)s);
#line 1462
  tmp___0 = malloc(tmp + 1U);
#line 1462
  new___0 = (char *)tmp___0;
  }
#line 1464
  if ((unsigned int )new___0 == (unsigned int )((void *)0)) {
    {
#line 1465
    perror_reply(421, (char *)"Local resource failure: malloc");
#line 1466
    dologout(1);
    }
  }
  {
#line 1469
  strcpy((char */* __restrict  */)new___0, (char const   */* __restrict  */)s);
  }
#line 1470
  return (new___0);
}
}
#line 1477 "ftpd.c"
static struct passwd save  ;
#line 1475 "ftpd.c"
struct passwd *sgetpwnam(char *name ) 
{ register struct passwd *p ;
  struct spwd *spw ;
  int expired ;
  time_t now ;
  long today ;
  char const   *tmp ;

  {
  {
#line 1509
  p = getpwnam((char const   *)name);
  }
#line 1509
  if ((unsigned int )p == (unsigned int )((void *)0)) {
#line 1510
    return (p);
  }
#line 1513
  if (save.pw_name) {
    {
#line 1514
    free((void *)save.pw_name);
    }
  }
#line 1515
  if (save.pw_gecos) {
    {
#line 1516
    free((void *)save.pw_gecos);
    }
  }
#line 1517
  if (save.pw_dir) {
    {
#line 1518
    free((void *)save.pw_dir);
    }
  }
#line 1519
  if (save.pw_shell) {
    {
#line 1520
    free((void *)save.pw_shell);
    }
  }
#line 1521
  if (save.pw_passwd) {
    {
#line 1522
    free((void *)save.pw_passwd);
    }
  }
  {
#line 1524
  save = *p;
#line 1526
  save.pw_name = sgetsave(p->pw_name);
#line 1536
  save.pw_passwd = sgetsave(p->pw_passwd);
  }
#line 1539
  if (p) {
    {
#line 1541
    setspent();
#line 1542
    spw = getspnam((char const   *)p->pw_name);
    }
#line 1542
    if ((unsigned int )spw != (unsigned int )((void *)0)) {
      {
#line 1543
      expired = 0;
#line 1549
      now = time((time_t *)0);
#line 1550
      today = now / 86400L;
      }
#line 1552
      if (spw->sp_expire > 0L) {
#line 1552
        if (spw->sp_expire < today) {
#line 1553
          expired ++;
        }
      }
#line 1554
      if (spw->sp_max > 0L) {
#line 1554
        if (spw->sp_lstchg > 0L) {
#line 1554
          if (spw->sp_lstchg + spw->sp_max < today) {
#line 1556
            expired ++;
          }
        }
      }
      {
#line 1557
      free((void *)save.pw_passwd);
      }
#line 1558
      if (expired) {
#line 1558
        tmp = "";
      } else {
#line 1558
        tmp = (char const   *)spw->sp_pwdp;
      }
      {
#line 1558
      save.pw_passwd = sgetsave((char *)tmp);
      }
    } else {
      {
#line 1565
      free((void *)save.pw_passwd);
#line 1566
      save.pw_passwd = sgetsave((char *)"");
      }
    }
    {
#line 1570
    endspent();
    }
  }
  {
#line 1573
  save.pw_gecos = sgetsave(p->pw_gecos);
#line 1574
  save.pw_dir = sgetsave(p->pw_dir);
#line 1575
  save.pw_shell = sgetsave(p->pw_shell);
  }
#line 1587
  return (& save);
}
}
#line 1613 "ftpd.c"
int login_attempts  ;
#line 1614 "ftpd.c"
int askpasswd  ;
#line 1616 "ftpd.c"
int DenyLoginAfterPassword  ;
#line 1617 "ftpd.c"
char DelayedMessageFile[4096]  ;
#line 1622 "ftpd.c"
static int defaultserver_allow(char const   *username ) 
{ struct aclmember *entry ;
  int which ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct aclmember *tmp___11 ;

  {
#line 1624
  entry = (struct aclmember *)((void *)0);
#line 1627
  while (1) {
    {
#line 1627
    tmp___11 = getaclentry((char *)"defaultserver", & entry);
    }
#line 1627
    if (! tmp___11) {
#line 1627
      break;
    }
#line 1628
    if (entry->arg[0]) {
      {
#line 1628
      tmp___10 = strcasecmp((char const   *)entry->arg[0], "allow");
      }
#line 1628
      if (! tmp___10) {
#line 1629
        which = 1;
#line 1629
        while (1) {
#line 1629
          if (which < 50) {
#line 1629
            if (! entry->arg[which]) {
#line 1629
              break;
            }
          } else {
#line 1629
            break;
          }
          {
#line 1630
          tmp = strcasecmp(username, (char const   *)entry->arg[which]);
          }
#line 1630
          if (tmp) {
#line 1630
            if (0) {
              {
#line 1630
              __s1_len = strlen("*");
#line 1630
              __s2_len = strlen((char const   *)entry->arg[which]);
              }
#line 1630
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
                goto _L___0;
              } else {
#line 1630
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1630
                  if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
#line 1630
                    tmp___9 = 1;
                  } else {
#line 1630
                    if (__s2_len >= 4U) {
#line 1630
                      tmp___9 = 1;
                    } else {
#line 1630
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1630
                  tmp___9 = 0;
                }
              }
#line 1630
              if (tmp___9) {
                {
#line 1630
                tmp___5 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
                }
              } else {
                {
#line 1630
                tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 1630
                tmp___5 = tmp___8;
                }
              }
            } else {
              {
#line 1630
              tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 1630
              tmp___5 = tmp___8;
              }
            }
#line 1630
            if (! tmp___5) {
#line 1631
              return (1);
            }
          } else {
#line 1631
            return (1);
          }
#line 1629
          which ++;
        }
      }
    }
  }
#line 1632
  return (0);
}
}
#line 1635 "ftpd.c"
static int defaultserver_deny(char const   *username ) 
{ struct aclmember *entry ;
  int which ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct aclmember *tmp___11 ;

  {
#line 1637
  entry = (struct aclmember *)((void *)0);
#line 1640
  while (1) {
    {
#line 1640
    tmp___11 = getaclentry((char *)"defaultserver", & entry);
    }
#line 1640
    if (! tmp___11) {
#line 1640
      break;
    }
#line 1641
    if (entry->arg[0]) {
      {
#line 1641
      tmp___10 = strcasecmp((char const   *)entry->arg[0], "deny");
      }
#line 1641
      if (! tmp___10) {
#line 1642
        which = 1;
#line 1642
        while (1) {
#line 1642
          if (which < 50) {
#line 1642
            if (! entry->arg[which]) {
#line 1642
              break;
            }
          } else {
#line 1642
            break;
          }
          {
#line 1643
          tmp = strcasecmp(username, (char const   *)entry->arg[which]);
          }
#line 1643
          if (tmp) {
#line 1643
            if (0) {
              {
#line 1643
              __s1_len = strlen("*");
#line 1643
              __s2_len = strlen((char const   *)entry->arg[which]);
              }
#line 1643
              if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
                goto _L___0;
              } else {
#line 1643
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1643
                  if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
#line 1643
                    tmp___9 = 1;
                  } else {
#line 1643
                    if (__s2_len >= 4U) {
#line 1643
                      tmp___9 = 1;
                    } else {
#line 1643
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1643
                  tmp___9 = 0;
                }
              }
#line 1643
              if (tmp___9) {
                {
#line 1643
                tmp___5 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
                }
              } else {
                {
#line 1643
                tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 1643
                tmp___5 = tmp___8;
                }
              }
            } else {
              {
#line 1643
              tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 1643
              tmp___5 = tmp___8;
              }
            }
#line 1643
            if (! tmp___5) {
#line 1644
              return (1);
            }
          } else {
#line 1644
            return (1);
          }
#line 1642
          which ++;
        }
      }
    }
  }
#line 1645
  return (0);
}
}
#line 1648 "ftpd.c"
static int defaultserver_private(void) 
{ struct aclmember *entry ;
  int tmp ;
  struct aclmember *tmp___0 ;

  {
#line 1650
  entry = (struct aclmember *)((void *)0);
#line 1652
  while (1) {
    {
#line 1652
    tmp___0 = getaclentry((char *)"defaultserver", & entry);
    }
#line 1652
    if (! tmp___0) {
#line 1652
      break;
    }
#line 1653
    if (entry->arg[0]) {
      {
#line 1653
      tmp = strcasecmp((char const   *)entry->arg[0], "private");
      }
#line 1653
      if (! tmp) {
#line 1654
        return (1);
      }
    }
  }
#line 1655
  return (0);
}
}
#line 1672 "ftpd.c"
void user(char *name ) 
{ char *cp ;
  char *shell ;
  int tmp ;
  struct aclmember *entry ;
  int machineok ;
  char guestservername[64] ;
  int tmp___0 ;
  struct hostent *tmphostent ;
  char dns_localhost[64] ;
  int machinecount ;
  int tmp___1 ;
  struct aclmember *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___20 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;

  {
#line 1681
  if (logged_in) {
    {
#line 1683
    syslog(5, "FTP LOGIN REFUSED (already logged in as %s) FROM %s, %s", pw->pw_name,
           remoteident, name);
#line 1686
    reply(530, (char *)"Already logged in.");
    }
#line 1687
    return;
  }
  {
#line 1690
  askpasswd = 1;
#line 1691
  DenyLoginAfterPassword = 0;
#line 1692
  DelayedMessageFile[0] = (char )'\000';
#line 1700
  tmp = rhost_ok(name, remotehost, remoteaddr);
  }
#line 1700
  if (! tmp) {
    {
#line 1702
    DenyLoginAfterPassword = 1;
#line 1703
    syslog(5, "FTP LOGIN REFUSED (name in %s) FROM %s, %s", "/etc/ftphosts", remoteident,
           name);
    }
  }
  {
#line 1716
  __builtin_strncpy(the_user, (char const   *)name, 255U);
#line 1719
  anonymous = 0;
#line 1720
  acl_remove();
#line 1722
  tmp___7 = strcasecmp((char const   *)name, "ftp");
  }
#line 1722
  if (tmp___7) {
    {
#line 1722
    tmp___8 = strcasecmp((char const   *)name, "anonymous");
    }
#line 1722
    if (! tmp___8) {
      _L: 
#line 1723
      entry = (struct aclmember *)((void *)0);
#line 1724
      machineok = 1;
#line 1726
      guestservername[0] = (char )'\000';
#line 1735
      if (! virtual_mode) {
        {
#line 1735
        tmp___0 = defaultserver_private();
        }
#line 1735
        if (tmp___0) {
          {
#line 1737
          DenyLoginAfterPassword = 1;
#line 1738
          syslog(5, "FTP LOGIN REFUSED (anonymous ftp denied on default server) FROM %s, %s",
                 remoteident, name);
          }
        }
      }
      {
#line 1749
      tmp___4 = checkuser((char *)"ftp");
      }
#line 1749
      if (tmp___4) {
        {
#line 1751
        DenyLoginAfterPassword = 1;
#line 1752
        syslog(5, "FTP LOGIN REFUSED (ftp in %s) FROM %s, %s", "/etc/ftpusers", remoteident,
               name);
        }
      } else {
        {
#line 1749
        tmp___5 = checkuser((char *)"anonymous");
        }
#line 1749
        if (tmp___5) {
          {
#line 1751
          DenyLoginAfterPassword = 1;
#line 1752
          syslog(5, "FTP LOGIN REFUSED (ftp in %s) FROM %s, %s", "/etc/ftpusers",
                 remoteident, name);
          }
        } else {
          {
#line 1786
          tmp___2 = getaclentry((char *)"guestserver", & entry);
          }
#line 1786
          if (tmp___2) {
#line 1786
            if (entry->arg[0]) {
              {
#line 1786
              tmp___3 = strlen((char const   *)entry->arg[0]);
              }
#line 1786
              if ((int )tmp___3 > 0) {
#line 1794
                machineok = 0;
#line 1796
                if (hostname[0]) {
                  {
#line 1796
                  tmphostent = gethostbyname((char const   *)(hostname));
                  }
#line 1796
                  if (tmphostent) {
                    {
#line 1813
                    __builtin_strncpy(dns_localhost, (char const   *)tmphostent->h_name,
                                      sizeof(dns_localhost));
#line 1816
                    dns_localhost[sizeof(dns_localhost) - 1U] = (char )'\000';
#line 1818
                    machinecount = 0;
                    }
#line 1818
                    while (1) {
#line 1818
                      if (entry->arg[machinecount]) {
#line 1818
                        if (! *(entry->arg[machinecount] + 0)) {
#line 1818
                          break;
                        }
                      } else {
#line 1818
                        break;
                      }
                      {
#line 1822
                      tmphostent = gethostbyname((char const   *)entry->arg[machinecount]);
                      }
#line 1822
                      if (tmphostent) {
#line 1827
                        if (! machinecount) {
#line 1827
                          if (tmphostent->h_name) {
                            {
#line 1828
                            __builtin_strncpy(guestservername, (char const   *)entry->arg[machinecount],
                                              sizeof(guestservername));
#line 1830
                            guestservername[sizeof(guestservername) - 1U] = (char )'\000';
                            }
                          }
                        }
                        {
#line 1833
                        tmp___1 = strcasecmp((char const   *)tmphostent->h_name, (char const   *)(dns_localhost));
                        }
#line 1833
                        if (! tmp___1) {
#line 1834
                          machineok ++;
#line 1835
                          break;
                        }
                      }
#line 1818
                      machinecount ++;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 1841
      if (! machineok) {
#line 1842
        if (guestservername[0]) {
          {
#line 1843
          reply(530, (char *)"Guest login not allowed on this machine, connect to %s instead.",
                guestservername);
          }
        } else {
          {
#line 1847
          reply(530, (char *)"Guest login not allowed on this machine.");
          }
        }
        {
#line 1849
        syslog(5, "FTP LOGIN REFUSED (localhost not in guestservers) FROM %s, %s",
               remoteident, name);
        }
      } else {
        {
#line 1855
        pw = sgetpwnam((char *)"ftp");
        }
#line 1855
        if ((unsigned int )pw != (unsigned int )((void *)0)) {
          {
#line 1856
          anonymous = 1;
#line 1857
          tmp___6 = access_ok(530);
          }
#line 1857
          if (tmp___6 < 1) {
            {
#line 1859
            DenyLoginAfterPassword = 1;
#line 1860
            syslog(5, "FTP LOGIN REFUSED (access denied) FROM %s, %s", remoteident,
                   name);
#line 1862
            reply(331, (char *)"Guest login ok, send your complete e-mail address as password.");
            }
          } else {
#line 1872
            askpasswd = 1;
#line 1876
            if (use_accessfile) {
              {
#line 1877
              acl_setfunctions();
              }
            }
            {
#line 1878
            reply(331, (char *)"Guest login ok, send your complete e-mail address as password.");
            }
          }
        } else {
          {
#line 1883
          DenyLoginAfterPassword = 1;
#line 1884
          reply(331, (char *)"Guest login ok, send your complete e-mail address as password.");
#line 1885
          syslog(5, "FTP LOGIN REFUSED (ftp not in /etc/passwd) FROM %s, %s", remoteident,
                 name);
          }
        }
      }
#line 1894
      return;
    }
  } else {
    goto _L;
  }
#line 1920
  if (! virtual_mode) {
    {
#line 1920
    tmp___9 = defaultserver_deny((char const   *)name);
    }
#line 1920
    if (tmp___9) {
      {
#line 1920
      tmp___10 = defaultserver_allow((char const   *)name);
      }
#line 1920
      if (! tmp___10) {
        {
#line 1922
        DenyLoginAfterPassword = 1;
#line 1923
        syslog(5, "FTP LOGIN REFUSED (ftp denied on default server) FROM %s, %s",
               remoteident, name);
        }
      }
    }
  }
  {
#line 1935
  pw = sgetpwnam(name);
  }
#line 1935
  if ((unsigned int )pw != (unsigned int )((void *)0)) {
    {
#line 1937
    tmp___11 = denieduid(pw->pw_uid);
    }
#line 1937
    if (tmp___11) {
      {
#line 1937
      tmp___12 = alloweduid(pw->pw_uid);
      }
#line 1937
      if (tmp___12) {
        goto _L___0;
      } else {
        {
#line 1940
        DenyLoginAfterPassword = 1;
#line 1941
        syslog(5, "FTP LOGIN REFUSED (username in denied-uid) FROM %s, %s", remoteident,
               name);
#line 1943
        reply(331, (char *)"Password required for %s.", name);
        }
#line 1950
        return;
      }
    } else {
      _L___0: 
      {
#line 1937
      tmp___13 = deniedgid(pw->pw_gid);
      }
#line 1937
      if (tmp___13) {
        {
#line 1937
        tmp___14 = allowedgid(pw->pw_gid);
        }
#line 1937
        if (! tmp___14) {
          {
#line 1940
          DenyLoginAfterPassword = 1;
#line 1941
          syslog(5, "FTP LOGIN REFUSED (username in denied-uid) FROM %s, %s", remoteident,
                 name);
#line 1943
          reply(331, (char *)"Password required for %s.", name);
          }
#line 1950
          return;
        }
      }
    }
#line 1954
    shell = pw->pw_shell;
#line 1954
    if ((unsigned int )shell == (unsigned int )((void *)0)) {
#line 1955
      shell = (char *)"/bin/sh";
    } else {
#line 1954
      if ((int )*shell == 0) {
#line 1955
        shell = (char *)"/bin/sh";
      }
    }
#line 1956
    while (1) {
      {
#line 1956
      cp = getusershell();
      }
#line 1956
      if (! ((unsigned int )cp != (unsigned int )((void *)0))) {
#line 1956
        break;
      }
#line 1957
      if (0) {
        {
#line 1957
        __s1_len = strlen((char const   *)cp);
#line 1957
        __s2_len = strlen((char const   *)shell);
        }
#line 1957
        if (! ((unsigned int )((void const   *)(cp + 1)) - (unsigned int )((void const   *)cp) == 1U)) {
          goto _L___2;
        } else {
#line 1957
          if (__s1_len >= 4U) {
            _L___2: 
#line 1957
            if (! ((unsigned int )((void const   *)(shell + 1)) - (unsigned int )((void const   *)shell) == 1U)) {
#line 1957
              tmp___24 = 1;
            } else {
#line 1957
              if (__s2_len >= 4U) {
#line 1957
                tmp___24 = 1;
              } else {
#line 1957
                tmp___24 = 0;
              }
            }
          } else {
#line 1957
            tmp___24 = 0;
          }
        }
#line 1957
        if (tmp___24) {
          {
#line 1957
          tmp___20 = __builtin_strcmp((char const   *)cp, (char const   *)shell);
          }
        } else {
          {
#line 1957
          tmp___23 = __builtin_strcmp((char const   *)cp, (char const   *)shell);
#line 1957
          tmp___20 = tmp___23;
          }
        }
      } else {
        {
#line 1957
        tmp___23 = __builtin_strcmp((char const   *)cp, (char const   *)shell);
#line 1957
        tmp___20 = tmp___23;
        }
      }
#line 1957
      if (tmp___20 == 0) {
#line 1958
        break;
      }
    }
    {
#line 1959
    endusershell();
    }
#line 1960
    if ((unsigned int )cp == (unsigned int )((void *)0)) {
      goto _L___3;
    } else {
      {
#line 1960
      tmp___25 = checkuser(name);
      }
#line 1960
      if (tmp___25) {
        _L___3: 
#line 1962
        DenyLoginAfterPassword = 1;
#line 1963
        if ((unsigned int )cp == (unsigned int )((void *)0)) {
          {
#line 1964
          syslog(5, "FTP LOGIN REFUSED (shell not in /etc/shells) FROM %s, %s", remoteident,
                 name);
          }
        } else {
          {
#line 1966
          syslog(5, "FTP LOGIN REFUSED (username in %s) FROM %s, %s", "/etc/ftpusers",
                 remoteident, name);
          }
        }
        {
#line 1967
        reply(331, (char *)"Password required for %s.", name);
#line 1975
        pw = (struct passwd *)((void *)0);
        }
#line 1976
        return;
      }
    }
#line 1981
    if (use_accessfile) {
      {
#line 1982
      guest = acl_guestgroup(pw);
      }
#line 1983
      if (guest) {
        {
#line 1983
        tmp___26 = acl_realgroup(pw);
        }
#line 1983
        if (tmp___26) {
#line 1984
          guest = 0;
        }
      }
    }
  }
  {
#line 1987
  tmp___27 = access_ok(530);
  }
#line 1987
  if (tmp___27 < 1) {
    {
#line 1989
    DenyLoginAfterPassword = 1;
#line 1990
    syslog(5, "FTP LOGIN REFUSED (access denied) FROM %s, %s", remoteident, name);
#line 1992
    reply(331, (char *)"Password required for %s.", name);
    }
#line 1998
    return;
  } else {
#line 2000
    if (use_accessfile) {
      {
#line 2001
      acl_setfunctions();
      }
    }
  }
  {
#line 2054
  reply(331, (char *)"Password required for %s.", name);
#line 2060
  askpasswd = 1;
  }
#line 2063
  if (login_attempts) {
    {
#line 2064
    enable_signaling();
#line 2065
    sleep((unsigned int )login_attempts);
    }
  }
#line 2067
  return;
}
}
#line 2072 "ftpd.c"
int checkuser(char *name ) 
{ register FILE *fd___0 ;
  register char *p ;
  char line___0[8192] ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2078
  fd___0 = fopen((char const   */* __restrict  */)"/etc/ftpusers", (char const   */* __restrict  */)"r");
  }
#line 2078
  if ((unsigned int )fd___0 != (unsigned int )((void *)0)) {
#line 2079
    while (1) {
      {
#line 2079
      tmp___2 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0),
                      (FILE */* __restrict  */)fd___0);
      }
#line 2079
      if (! ((unsigned int )tmp___2 != (unsigned int )((void *)0))) {
#line 2079
        break;
      }
      {
#line 2080
      tmp___1 = __builtin_strchr(line___0, '\n');
#line 2080
      p = tmp___1;
      }
#line 2080
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 2081
        *p = (char )'\000';
#line 2082
        if ((int )line___0[0] == 35) {
#line 2083
          continue;
        }
        {
#line 2084
        tmp = strcasecmp((char const   *)(line___0), (char const   *)name);
        }
#line 2084
        if (tmp == 0) {
          {
#line 2085
          fclose(fd___0);
          }
#line 2086
          return (1);
        }
      }
    }
    {
#line 2089
    fclose(fd___0);
    }
  }
#line 2091
  return (0);
}
}
#line 2094 "ftpd.c"
int denieduid(uid_t uid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct passwd *pw___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 2096
  entry = (struct aclmember *)((void *)0);
#line 2101
  while (1) {
    {
#line 2101
    tmp___19 = getaclentry((char *)"deny-uid", & entry);
    }
#line 2101
    if (! tmp___19) {
#line 2101
      break;
    }
#line 2102
    which = 0;
#line 2102
    while (1) {
#line 2102
      if (which < 50) {
#line 2102
        if (! entry->arg[which]) {
#line 2102
          break;
        }
      } else {
#line 2102
        break;
      }
#line 2103
      if (0) {
        {
#line 2103
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 2103
        __s2_len = strlen("*");
        }
#line 2103
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 2103
          if (__s1_len >= 4U) {
            _L___0: 
#line 2103
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2103
              tmp___8 = 1;
            } else {
#line 2103
              if (__s2_len >= 4U) {
#line 2103
                tmp___8 = 1;
              } else {
#line 2103
                tmp___8 = 0;
              }
            }
          } else {
#line 2103
            tmp___8 = 0;
          }
        }
#line 2103
        if (tmp___8) {
          {
#line 2103
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 2103
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2103
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 2103
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2103
        tmp___4 = tmp___7;
        }
      }
#line 2103
      if (! tmp___4) {
#line 2104
        return (1);
      }
#line 2105
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 2106
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 2106
        ptr = tmp___18;
        }
#line 2106
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 2107
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 2107
          ptr = tmp___13;
          }
#line 2107
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 2108
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 2108
            if ((unsigned long )uid == tmp___9) {
#line 2109
              return (1);
            }
          } else {
#line 2112
            tmp___10 = ptr;
#line 2112
            ptr ++;
#line 2112
            *tmp___10 = (char )'\000';
#line 2113
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 2115
              ptr --;
#line 2115
              *ptr = (char )'+';
#line 2116
              return (1);
            } else {
              {
#line 2113
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 2113
              if ((unsigned long )uid >= tmp___11) {
#line 2115
                ptr --;
#line 2115
                *ptr = (char )'+';
#line 2116
                return (1);
              }
            }
#line 2118
            ptr --;
#line 2118
            *ptr = (char )'+';
          }
        } else {
#line 2122
          tmp___14 = ptr;
#line 2122
          ptr ++;
#line 2122
          *tmp___14 = (char )'\000';
#line 2123
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 2123
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 2123
            if ((unsigned long )uid >= tmp___15) {
              _L___1: 
#line 2123
              if ((int )*ptr == 0) {
#line 2127
                ptr --;
#line 2127
                *ptr = (char )'-';
#line 2128
                return (1);
              } else {
                {
#line 2123
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 2123
                if ((unsigned long )uid <= tmp___16) {
#line 2127
                  ptr --;
#line 2127
                  *ptr = (char )'-';
#line 2128
                  return (1);
                }
              }
            }
          }
#line 2130
          ptr --;
#line 2130
          *ptr = (char )'-';
        }
      } else {
        {
#line 2134
        pw___0 = getpwnam((char const   *)entry->arg[which]);
        }
#line 2135
        if (pw___0) {
#line 2135
          if (uid == pw___0->pw_uid) {
#line 2136
            return (1);
          }
        }
      }
#line 2102
      which ++;
    }
  }
#line 2140
  return (0);
}
}
#line 2143 "ftpd.c"
int alloweduid(uid_t uid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct passwd *pw___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 2145
  entry = (struct aclmember *)((void *)0);
#line 2150
  while (1) {
    {
#line 2150
    tmp___19 = getaclentry((char *)"allow-uid", & entry);
    }
#line 2150
    if (! tmp___19) {
#line 2150
      break;
    }
#line 2151
    which = 0;
#line 2151
    while (1) {
#line 2151
      if (which < 50) {
#line 2151
        if (! entry->arg[which]) {
#line 2151
          break;
        }
      } else {
#line 2151
        break;
      }
#line 2152
      if (0) {
        {
#line 2152
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 2152
        __s2_len = strlen("*");
        }
#line 2152
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 2152
          if (__s1_len >= 4U) {
            _L___0: 
#line 2152
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2152
              tmp___8 = 1;
            } else {
#line 2152
              if (__s2_len >= 4U) {
#line 2152
                tmp___8 = 1;
              } else {
#line 2152
                tmp___8 = 0;
              }
            }
          } else {
#line 2152
            tmp___8 = 0;
          }
        }
#line 2152
        if (tmp___8) {
          {
#line 2152
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 2152
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2152
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 2152
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2152
        tmp___4 = tmp___7;
        }
      }
#line 2152
      if (! tmp___4) {
#line 2153
        return (1);
      }
#line 2154
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 2155
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 2155
        ptr = tmp___18;
        }
#line 2155
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 2156
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 2156
          ptr = tmp___13;
          }
#line 2156
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 2157
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 2157
            if ((unsigned long )uid == tmp___9) {
#line 2158
              return (1);
            }
          } else {
#line 2161
            tmp___10 = ptr;
#line 2161
            ptr ++;
#line 2161
            *tmp___10 = (char )'\000';
#line 2162
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 2164
              ptr --;
#line 2164
              *ptr = (char )'+';
#line 2165
              return (1);
            } else {
              {
#line 2162
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 2162
              if ((unsigned long )uid >= tmp___11) {
#line 2164
                ptr --;
#line 2164
                *ptr = (char )'+';
#line 2165
                return (1);
              }
            }
#line 2167
            ptr --;
#line 2167
            *ptr = (char )'+';
          }
        } else {
#line 2171
          tmp___14 = ptr;
#line 2171
          ptr ++;
#line 2171
          *tmp___14 = (char )'\000';
#line 2172
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 2172
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 2172
            if ((unsigned long )uid >= tmp___15) {
              _L___1: 
#line 2172
              if ((int )*ptr == 0) {
#line 2176
                ptr --;
#line 2176
                *ptr = (char )'-';
#line 2177
                return (1);
              } else {
                {
#line 2172
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 2172
                if ((unsigned long )uid <= tmp___16) {
#line 2176
                  ptr --;
#line 2176
                  *ptr = (char )'-';
#line 2177
                  return (1);
                }
              }
            }
          }
#line 2179
          ptr --;
#line 2179
          *ptr = (char )'-';
        }
      } else {
        {
#line 2183
        pw___0 = getpwnam((char const   *)entry->arg[which]);
        }
#line 2184
        if (pw___0) {
#line 2184
          if (uid == pw___0->pw_uid) {
#line 2185
            return (1);
          }
        }
      }
#line 2151
      which ++;
    }
  }
#line 2189
  return (0);
}
}
#line 2192 "ftpd.c"
int deniedgid(gid_t gid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct group *grp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 2194
  entry = (struct aclmember *)((void *)0);
#line 2199
  while (1) {
    {
#line 2199
    tmp___19 = getaclentry((char *)"deny-gid", & entry);
    }
#line 2199
    if (! tmp___19) {
#line 2199
      break;
    }
#line 2200
    which = 0;
#line 2200
    while (1) {
#line 2200
      if (which < 50) {
#line 2200
        if (! entry->arg[which]) {
#line 2200
          break;
        }
      } else {
#line 2200
        break;
      }
#line 2201
      if (0) {
        {
#line 2201
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 2201
        __s2_len = strlen("*");
        }
#line 2201
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 2201
          if (__s1_len >= 4U) {
            _L___0: 
#line 2201
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2201
              tmp___8 = 1;
            } else {
#line 2201
              if (__s2_len >= 4U) {
#line 2201
                tmp___8 = 1;
              } else {
#line 2201
                tmp___8 = 0;
              }
            }
          } else {
#line 2201
            tmp___8 = 0;
          }
        }
#line 2201
        if (tmp___8) {
          {
#line 2201
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 2201
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2201
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 2201
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2201
        tmp___4 = tmp___7;
        }
      }
#line 2201
      if (! tmp___4) {
#line 2202
        return (1);
      }
#line 2203
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 2204
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 2204
        ptr = tmp___18;
        }
#line 2204
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 2205
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 2205
          ptr = tmp___13;
          }
#line 2205
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 2206
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 2206
            if ((unsigned long )gid == tmp___9) {
#line 2207
              return (1);
            }
          } else {
#line 2210
            tmp___10 = ptr;
#line 2210
            ptr ++;
#line 2210
            *tmp___10 = (char )'\000';
#line 2211
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 2213
              ptr --;
#line 2213
              *ptr = (char )'+';
#line 2214
              return (1);
            } else {
              {
#line 2211
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 2211
              if ((unsigned long )gid >= tmp___11) {
#line 2213
                ptr --;
#line 2213
                *ptr = (char )'+';
#line 2214
                return (1);
              }
            }
#line 2216
            ptr --;
#line 2216
            *ptr = (char )'+';
          }
        } else {
#line 2220
          tmp___14 = ptr;
#line 2220
          ptr ++;
#line 2220
          *tmp___14 = (char )'\000';
#line 2221
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 2221
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 2221
            if ((unsigned long )gid >= tmp___15) {
              _L___1: 
#line 2221
              if ((int )*ptr == 0) {
#line 2225
                ptr --;
#line 2225
                *ptr = (char )'-';
#line 2226
                return (1);
              } else {
                {
#line 2221
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 2221
                if ((unsigned long )gid <= tmp___16) {
#line 2225
                  ptr --;
#line 2225
                  *ptr = (char )'-';
#line 2226
                  return (1);
                }
              }
            }
          }
#line 2228
          ptr --;
#line 2228
          *ptr = (char )'-';
        }
      } else {
        {
#line 2232
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 2233
        if (grp) {
#line 2233
          if (gid == grp->gr_gid) {
#line 2234
            return (1);
          }
        }
      }
#line 2200
      which ++;
    }
  }
#line 2238
  return (0);
}
}
#line 2241 "ftpd.c"
int allowedgid(gid_t gid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct group *grp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 2243
  entry = (struct aclmember *)((void *)0);
#line 2248
  while (1) {
    {
#line 2248
    tmp___19 = getaclentry((char *)"allow-gid", & entry);
    }
#line 2248
    if (! tmp___19) {
#line 2248
      break;
    }
#line 2249
    which = 0;
#line 2249
    while (1) {
#line 2249
      if (which < 50) {
#line 2249
        if (! entry->arg[which]) {
#line 2249
          break;
        }
      } else {
#line 2249
        break;
      }
#line 2250
      if (0) {
        {
#line 2250
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 2250
        __s2_len = strlen("*");
        }
#line 2250
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 2250
          if (__s1_len >= 4U) {
            _L___0: 
#line 2250
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2250
              tmp___8 = 1;
            } else {
#line 2250
              if (__s2_len >= 4U) {
#line 2250
                tmp___8 = 1;
              } else {
#line 2250
                tmp___8 = 0;
              }
            }
          } else {
#line 2250
            tmp___8 = 0;
          }
        }
#line 2250
        if (tmp___8) {
          {
#line 2250
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 2250
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2250
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 2250
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 2250
        tmp___4 = tmp___7;
        }
      }
#line 2250
      if (! tmp___4) {
#line 2251
        return (1);
      }
#line 2252
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 2253
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 2253
        ptr = tmp___18;
        }
#line 2253
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 2254
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 2254
          ptr = tmp___13;
          }
#line 2254
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 2255
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 2255
            if ((unsigned long )gid == tmp___9) {
#line 2256
              return (1);
            }
          } else {
#line 2259
            tmp___10 = ptr;
#line 2259
            ptr ++;
#line 2259
            *tmp___10 = (char )'\000';
#line 2260
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 2262
              ptr --;
#line 2262
              *ptr = (char )'+';
#line 2263
              return (1);
            } else {
              {
#line 2260
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 2260
              if ((unsigned long )gid >= tmp___11) {
#line 2262
                ptr --;
#line 2262
                *ptr = (char )'+';
#line 2263
                return (1);
              }
            }
#line 2265
            ptr --;
#line 2265
            *ptr = (char )'+';
          }
        } else {
#line 2269
          tmp___14 = ptr;
#line 2269
          ptr ++;
#line 2269
          *tmp___14 = (char )'\000';
#line 2270
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 2270
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 2270
            if ((unsigned long )gid >= tmp___15) {
              _L___1: 
#line 2270
              if ((int )*ptr == 0) {
#line 2274
                ptr --;
#line 2274
                *ptr = (char )'-';
#line 2275
                return (1);
              } else {
                {
#line 2270
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 2270
                if ((unsigned long )gid <= tmp___16) {
#line 2274
                  ptr --;
#line 2274
                  *ptr = (char )'-';
#line 2275
                  return (1);
                }
              }
            }
          }
#line 2277
          ptr --;
#line 2277
          *ptr = (char )'-';
        }
      } else {
        {
#line 2281
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 2282
        if (grp) {
#line 2282
          if (gid == grp->gr_gid) {
#line 2283
            return (1);
          }
        }
      }
#line 2249
      which ++;
    }
  }
#line 2287
  return (0);
}
}
#line 2293 "ftpd.c"
void end_login(void) 
{ 

  {
  {
#line 2295
  delay_signaling();
#line 2296
  seteuid(0U);
  }
#line 2297
  if (logged_in) {
#line 2298
    if (wtmp_logging) {
      {
#line 2299
      wu_logwtmp(ttyline, pw->pw_name, remotehost, 0);
      }
    }
  }
#line 2300
  pw = (struct passwd *)((void *)0);
#line 2304
  logged_in = 0;
#line 2305
  anonymous = 0;
#line 2306
  guest = 0;
#line 2307
  return;
}
}
#line 2309 "ftpd.c"
int validate_eaddr(char *eaddr ) 
{ int i ;
  int host ;
  int state___0 ;
  int tmp ;

  {
#line 2313
  state___0 = 0;
#line 2313
  host = state___0;
#line 2313
  i = host;
#line 2313
  while ((int )*(eaddr + i) != 0) {
#line 2314
    switch ((int )*(eaddr + i)) {
    case 46: 
#line 2316
    if (! host) {
#line 2317
      return (0);
    }
#line 2318
    if (state___0 == 2) {
#line 2319
      state___0 = 3;
    }
#line 2320
    host = 0;
#line 2321
    break;
    case 64: 
#line 2323
    if (! host) {
#line 2324
      return (0);
    } else {
#line 2323
      if (state___0 > 1) {
#line 2324
        return (0);
      } else {
        {
#line 2323
        tmp = strncasecmp("ftp", (char const   *)((eaddr + i) - host), (unsigned int )host);
        }
#line 2323
        if (! tmp) {
#line 2324
          return (0);
        }
      }
    }
#line 2325
    state___0 = 2;
#line 2326
    host = 0;
#line 2327
    break;
    case 33: 
    case 37: 
#line 2330
    if (! host) {
#line 2331
      return (0);
    } else {
#line 2330
      if (state___0 > 1) {
#line 2331
        return (0);
      }
    }
#line 2332
    state___0 = 1;
#line 2333
    host = 0;
#line 2334
    break;
    case 45: 
#line 2336
    break;
    default: 
#line 2338
    host ++;
    }
#line 2313
    i ++;
  }
#line 2341
  if (state___0 == 3) {
#line 2341
    if (host > 1) {
#line 2343
      return (1);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
#line 2341
    if (state___0 == 2) {
#line 2341
      if (! host) {
#line 2343
        return (1);
      } else {
        goto _L;
      }
    } else {
      _L: 
#line 2341
      if (state___0 == 1) {
#line 2341
        if (host > 1) {
#line 2343
          return (1);
        } else {
#line 2345
          return (0);
        }
      } else {
#line 2345
        return (0);
      }
    }
  }
}
}
#line 2350 "ftpd.c"
static int AllowVirtualUser(char const   *username ) 
{ struct aclmember *entry ;
  int which ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct aclmember *tmp___12 ;

  {
#line 2352
  entry = (struct aclmember *)((void *)0);
#line 2355
  while (1) {
    {
#line 2355
    tmp___12 = getaclentry((char *)"virtual", & entry);
    }
#line 2355
    if (! tmp___12) {
#line 2355
      break;
    }
#line 2356
    if (entry->arg[0]) {
      {
#line 2356
      tmp___10 = hostmatch(entry->arg[0], virtual_address, virtual_hostname);
      }
#line 2356
      if (tmp___10) {
#line 2356
        if (entry->arg[1]) {
          {
#line 2356
          tmp___11 = strcasecmp((char const   *)entry->arg[1], "allow");
          }
#line 2356
          if (! tmp___11) {
#line 2358
            which = 2;
#line 2358
            while (1) {
#line 2358
              if (which < 50) {
#line 2358
                if (! entry->arg[which]) {
#line 2358
                  break;
                }
              } else {
#line 2358
                break;
              }
              {
#line 2359
              tmp = strcasecmp(username, (char const   *)entry->arg[which]);
              }
#line 2359
              if (tmp) {
#line 2359
                if (0) {
                  {
#line 2359
                  __s1_len = strlen("*");
#line 2359
                  __s2_len = strlen((char const   *)entry->arg[which]);
                  }
#line 2359
                  if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
                    goto _L___0;
                  } else {
#line 2359
                    if (__s1_len >= 4U) {
                      _L___0: 
#line 2359
                      if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
#line 2359
                        tmp___9 = 1;
                      } else {
#line 2359
                        if (__s2_len >= 4U) {
#line 2359
                          tmp___9 = 1;
                        } else {
#line 2359
                          tmp___9 = 0;
                        }
                      }
                    } else {
#line 2359
                      tmp___9 = 0;
                    }
                  }
#line 2359
                  if (tmp___9) {
                    {
#line 2359
                    tmp___5 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
                    }
                  } else {
                    {
#line 2359
                    tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 2359
                    tmp___5 = tmp___8;
                    }
                  }
                } else {
                  {
#line 2359
                  tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 2359
                  tmp___5 = tmp___8;
                  }
                }
#line 2359
                if (! tmp___5) {
#line 2360
                  return (1);
                }
              } else {
#line 2360
                return (1);
              }
#line 2358
              which ++;
            }
          }
        }
      }
    }
  }
#line 2361
  return (0);
}
}
#line 2364 "ftpd.c"
static int DenyVirtualUser(char const   *username ) 
{ struct aclmember *entry ;
  int which ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct aclmember *tmp___12 ;

  {
#line 2366
  entry = (struct aclmember *)((void *)0);
#line 2369
  while (1) {
    {
#line 2369
    tmp___12 = getaclentry((char *)"virtual", & entry);
    }
#line 2369
    if (! tmp___12) {
#line 2369
      break;
    }
#line 2370
    if (entry->arg[0]) {
      {
#line 2370
      tmp___10 = hostmatch(entry->arg[0], virtual_address, virtual_hostname);
      }
#line 2370
      if (tmp___10) {
#line 2370
        if (entry->arg[1]) {
          {
#line 2370
          tmp___11 = strcasecmp((char const   *)entry->arg[1], "deny");
          }
#line 2370
          if (! tmp___11) {
#line 2372
            which = 2;
#line 2372
            while (1) {
#line 2372
              if (which < 50) {
#line 2372
                if (! entry->arg[which]) {
#line 2372
                  break;
                }
              } else {
#line 2372
                break;
              }
              {
#line 2373
              tmp = strcasecmp(username, (char const   *)entry->arg[which]);
              }
#line 2373
              if (tmp) {
#line 2373
                if (0) {
                  {
#line 2373
                  __s1_len = strlen("*");
#line 2373
                  __s2_len = strlen((char const   *)entry->arg[which]);
                  }
#line 2373
                  if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
                    goto _L___0;
                  } else {
#line 2373
                    if (__s1_len >= 4U) {
                      _L___0: 
#line 2373
                      if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
#line 2373
                        tmp___9 = 1;
                      } else {
#line 2373
                        if (__s2_len >= 4U) {
#line 2373
                          tmp___9 = 1;
                        } else {
#line 2373
                          tmp___9 = 0;
                        }
                      }
                    } else {
#line 2373
                      tmp___9 = 0;
                    }
                  }
#line 2373
                  if (tmp___9) {
                    {
#line 2373
                    tmp___5 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
                    }
                  } else {
                    {
#line 2373
                    tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 2373
                    tmp___5 = tmp___8;
                    }
                  }
                } else {
                  {
#line 2373
                  tmp___8 = __builtin_strcmp("*", (char const   *)entry->arg[which]);
#line 2373
                  tmp___5 = tmp___8;
                  }
                }
#line 2373
                if (! tmp___5) {
#line 2374
                  return (1);
                }
              } else {
#line 2374
                return (1);
              }
#line 2372
              which ++;
            }
          }
        }
      }
    }
  }
#line 2375
  return (0);
}
}
#line 2378 "ftpd.c"
static int DenyVirtualAnonymous(void) 
{ struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
#line 2380
  entry = (struct aclmember *)((void *)0);
#line 2382
  while (1) {
    {
#line 2382
    tmp___1 = getaclentry((char *)"virtual", & entry);
    }
#line 2382
    if (! tmp___1) {
#line 2382
      break;
    }
#line 2383
    if (entry->arg[0]) {
      {
#line 2383
      tmp = hostmatch(entry->arg[0], virtual_address, virtual_hostname);
      }
#line 2383
      if (tmp) {
#line 2383
        if (entry->arg[1]) {
          {
#line 2383
          tmp___0 = strcasecmp((char const   *)entry->arg[1], "private");
          }
#line 2383
          if (! tmp___0) {
#line 2385
            return (1);
          }
        }
      }
    }
  }
#line 2386
  return (0);
}
}
#line 2390 "ftpd.c"
void pass(char *passwd ) 
{ char *xpasswd ;
  char *salt ;
  int passwarn ;
  int rval ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *pwin ;
  char *pwout ;
  struct aclmember *entry ;
  int valid___0 ;
  int enforce ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct aclmember *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  struct aclmember *tmp___24 ;
  int tmp___25 ;
  int cnt ;
  char *tmp___26 ;
  char *tmp___27 ;
  unsigned short const   **tmp___28 ;
  int tmp___29 ;
  mode_t oldmask ;
  int *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  __pid_t tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *sp ;
  int tmp___38 ;
  struct aclmember *entry___0 ;
  char *root_path ;
  char class[1024] ;
  int which ;
  int tmp___39 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  struct aclmember *tmp___50 ;
  int which___0 ;
  char *ptr ;
  unsigned long tmp___51 ;
  char *tmp___52 ;
  unsigned long tmp___53 ;
  char *tmp___55 ;
  char *tmp___56 ;
  unsigned long tmp___57 ;
  unsigned long tmp___58 ;
  char *tmp___60 ;
  struct passwd *guest_pw ;
  struct passwd *tmp___61 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  struct aclmember *tmp___72 ;
  struct passwd *chroot_pw ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___93 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  char *tmp___100 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___106 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int i ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  char const   *tmp___119 ;
  char const   *tmp___120 ;
  struct aclmember *entry___1 ;
  unsigned long tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___129 ;
  int tmp___132 ;
  int tmp___133 ;
  struct aclmember *tmp___134 ;

  {
#line 2397
  passwarn = 0;
#line 2398
  rval = 1;
#line 2430
  if (logged_in) {
    {
#line 2432
    syslog(5, "FTP LOGIN REFUSED (PASS before USER) FROM %s", remoteident);
#line 2435
    reply(503, (char *)"Login with USER first.");
    }
#line 2436
    return;
  } else {
#line 2430
    if (askpasswd == 0) {
      {
#line 2432
      syslog(5, "FTP LOGIN REFUSED (PASS before USER) FROM %s", remoteident);
#line 2435
      reply(503, (char *)"Login with USER first.");
      }
#line 2436
      return;
    }
  }
#line 2438
  askpasswd = 0;
#line 2443
  if ((int )*passwd == 45) {
#line 2444
    dolreplies = 0;
  } else {
#line 2446
    dolreplies = 1;
  }
#line 2448
  if (! anonymous) {
#line 2450
    if (DenyLoginAfterPassword) {
      {
#line 2451
      pr_mesg(530, DelayedMessageFile);
#line 2452
      reply(530, (char *)"Login incorrect.");
#line 2453
      acl_remove();
#line 2454
      pw = (struct passwd *)((void *)0);
#line 2455
      login_attempts ++;
      }
#line 2455
      if (login_attempts >= lgi_failure_threshold) {
        {
#line 2456
        syslog(5, "repeated login failures from %s", remoteident);
#line 2458
        exit(0);
        }
      }
#line 2460
      return;
    }
#line 2463
    if ((int )*passwd == 45) {
#line 2464
      passwd ++;
    }
#line 2511
    guestpw[0] = (char )'\000';
#line 2512
    if ((unsigned int )pw == (unsigned int )((void *)0)) {
#line 2513
      salt = (char *)"xx";
    } else {
#line 2516
      salt = pw->pw_passwd;
    }
    {
#line 2546
    xpasswd = crypt((char const   *)passwd, (char const   *)salt);
    }
#line 2556
    if ((unsigned int )pw != (unsigned int )((void *)0)) {
#line 2578
      if ((int )*(pw->pw_passwd) != 0) {
#line 2578
        if (0) {
          {
#line 2578
          __s1_len = strlen((char const   *)xpasswd);
#line 2578
          __s2_len = strlen((char const   *)pw->pw_passwd);
          }
#line 2578
          if (! ((unsigned int )((void const   *)(xpasswd + 1)) - (unsigned int )((void const   *)xpasswd) == 1U)) {
            goto _L___0;
          } else {
#line 2578
            if (__s1_len >= 4U) {
              _L___0: 
#line 2578
              if (! ((unsigned int )((void const   *)(pw->pw_passwd + 1)) - (unsigned int )((void const   *)pw->pw_passwd) == 1U)) {
#line 2578
                tmp___8 = 1;
              } else {
#line 2578
                if (__s2_len >= 4U) {
#line 2578
                  tmp___8 = 1;
                } else {
#line 2578
                  tmp___8 = 0;
                }
              }
            } else {
#line 2578
              tmp___8 = 0;
            }
          }
#line 2578
          if (tmp___8) {
            {
#line 2578
            tmp___4 = __builtin_strcmp((char const   *)xpasswd, (char const   *)pw->pw_passwd);
            }
          } else {
            {
#line 2578
            tmp___7 = __builtin_strcmp((char const   *)xpasswd, (char const   *)pw->pw_passwd);
#line 2578
            tmp___4 = tmp___7;
            }
          }
        } else {
          {
#line 2578
          tmp___7 = __builtin_strcmp((char const   *)xpasswd, (char const   *)pw->pw_passwd);
#line 2578
          tmp___4 = tmp___7;
          }
        }
#line 2578
        if (tmp___4 == 0) {
#line 2580
          rval = 0;
        }
      }
    }
#line 2619
    if (rval) {
      {
#line 2620
      reply(530, (char *)"Login incorrect.");
#line 2626
      tmp___9 = strcasecmp((char const   *)passwd, "NULL");
      }
#line 2626
      if (tmp___9) {
        {
#line 2630
        syslog(6, "failed login from %s", remoteident);
        }
      } else {
        {
#line 2627
        syslog(5, "REFUSED \"NULL\" from %s, %s", remoteident, the_user);
        }
      }
      {
#line 2633
      acl_remove();
#line 2635
      pw = (struct passwd *)((void *)0);
#line 2636
      login_attempts ++;
      }
#line 2636
      if (login_attempts >= lgi_failure_threshold) {
        {
#line 2637
        syslog(5, "repeated login failures from %s", remoteident);
#line 2639
        exit(0);
        }
      }
#line 2641
      return;
    }
  } else {
    {
#line 2649
    pwout = guestpw;
#line 2650
    entry = (struct aclmember *)((void *)0);
#line 2652
    enforce = 0;
#line 2654
    tmp___24 = getaclentry((char *)"passwd-check", & entry);
    }
#line 2654
    if (tmp___24) {
#line 2654
      if (entry->arg[0]) {
        {
#line 2654
        tmp___25 = strcasecmp((char const   *)entry->arg[0], "none");
        }
#line 2654
        if (tmp___25) {
          {
#line 2657
          tmp___15 = strcasecmp((char const   *)entry->arg[0], "rfc822");
          }
#line 2657
          if (tmp___15) {
            {
#line 2659
            tmp___14 = strcasecmp((char const   *)entry->arg[0], "trivial");
            }
#line 2659
            if (tmp___14) {
#line 2662
              valid___0 = 1;
            } else {
              {
#line 2660
              tmp___13 = __builtin_strchr(passwd, '@');
              }
#line 2660
              if ((unsigned int )tmp___13 == (unsigned int )((void *)0)) {
#line 2660
                valid___0 = 0;
              } else {
#line 2660
                valid___0 = 1;
              }
            }
          } else {
            {
#line 2658
            valid___0 = validate_eaddr(passwd);
            }
          }
#line 2663
          if (entry->arg[1]) {
            {
#line 2663
            tmp___16 = strcasecmp((char const   *)entry->arg[1], "enforce");
            }
#line 2663
            if (! tmp___16) {
#line 2664
              enforce = 1;
            }
          }
#line 2668
          entry = (struct aclmember *)((void *)0);
#line 2669
          while (1) {
            {
#line 2669
            tmp___21 = getaclentry((char *)"deny-email", & entry);
            }
#line 2669
            if (! tmp___21) {
#line 2669
              break;
            }
#line 2670
            if (entry->arg[0]) {
              {
#line 2670
              tmp___17 = strcasecmp((char const   *)passwd, (char const   *)entry->arg[0]);
              }
#line 2670
              if (tmp___17 == 0) {
#line 2676
                valid___0 = 0;
#line 2677
                break;
              } else {
                {
#line 2670
                tmp___18 = regexmatch(passwd, entry->arg[0]);
                }
#line 2670
                if (tmp___18) {
#line 2676
                  valid___0 = 0;
#line 2677
                  break;
                } else {
#line 2670
                  if ((int )*passwd == 45) {
                    {
#line 2670
                    tmp___19 = strcasecmp((char const   *)(passwd + 1), (char const   *)entry->arg[0]);
                    }
#line 2670
                    if (tmp___19 == 0) {
#line 2676
                      valid___0 = 0;
#line 2677
                      break;
                    } else {
                      {
#line 2670
                      tmp___20 = regexmatch(passwd + 1, entry->arg[0]);
                      }
#line 2670
                      if (tmp___20) {
#line 2676
                        valid___0 = 0;
#line 2677
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
#line 2680
          if (! valid___0) {
#line 2680
            if (enforce) {
              {
#line 2681
              lreply(530, (char *)"The response \'%s\' is not valid", passwd);
#line 2682
              lreply(530, (char *)"Please use your e-mail address as your password");
              }
#line 2683
              if (authenticated) {
#line 2683
                tmp___22 = (char const   *)(authuser);
              } else {
#line 2683
                tmp___22 = "joe";
              }
#line 2683
              if (authenticated) {
#line 2683
                tmp___23 = (char const   *)(authuser);
              } else {
#line 2683
                tmp___23 = "joe";
              }
              {
#line 2683
              lreply(530, (char *)"   for example: %s@%s or %s@", tmp___23, remotehost,
                     tmp___22);
#line 2686
              lreply(530, (char *)"[%s will be added if password ends with @]", remotehost);
#line 2688
              reply(530, (char *)"Login incorrect.");
#line 2690
              syslog(5, "FTP ACCESS REFUSED (anonymous password not rfc822) from %s",
                     remoteident);
#line 2693
              acl_remove();
#line 2694
              login_attempts ++;
              }
#line 2694
              if (login_attempts >= lgi_failure_threshold) {
                {
#line 2695
                syslog(5, "repeated login failures from %s", remoteident);
#line 2697
                exit(0);
                }
              }
#line 2699
              return;
            } else {
              goto _L___1;
            }
          } else {
            _L___1: 
#line 2701
            if (! valid___0) {
#line 2702
              passwarn = 1;
            }
          }
        }
      }
    }
#line 2704
    if (! *passwd) {
      {
#line 2705
      strcpy((char */* __restrict  */)(guestpw), (char const   */* __restrict  */)"[none_given]");
      }
    } else {
#line 2708
      cnt = (int )(sizeof(guestpw) - 2U);
#line 2710
      pwin = passwd;
#line 2710
      while (1) {
#line 2710
        if (*pwin) {
#line 2710
          tmp___29 = cnt;
#line 2710
          cnt --;
#line 2710
          if (! tmp___29) {
#line 2710
            break;
          }
        } else {
#line 2710
          break;
        }
        {
#line 2711
        tmp___28 = __ctype_b_loc();
        }
#line 2711
        if ((int const   )*(*tmp___28 + (int )*pwin) & 32768) {
#line 2714
          tmp___27 = pwout;
#line 2714
          pwout ++;
#line 2714
          *tmp___27 = *pwin;
        } else {
#line 2712
          tmp___26 = pwout;
#line 2712
          pwout ++;
#line 2712
          *tmp___26 = (char )'_';
        }
#line 2710
        pwin ++;
      }
    }
#line 2717
    if (DenyLoginAfterPassword) {
      {
#line 2718
      pr_mesg(530, DelayedMessageFile);
#line 2719
      reply(530, (char *)"Login incorrect.");
#line 2720
      acl_remove();
#line 2721
      pw = (struct passwd *)((void *)0);
#line 2722
      login_attempts ++;
      }
#line 2722
      if (login_attempts >= lgi_failure_threshold) {
        {
#line 2723
        syslog(5, "repeated login failures from %s", remoteident);
#line 2725
        exit(0);
        }
      }
#line 2727
      return;
    }
  }
#line 2733
  if (log_outbound_xfers) {
    goto _L___2;
  } else {
#line 2733
    if (log_incoming_xfers) {
      _L___2: 
#line 2733
      if (syslogmsg != 1) {
        {
#line 2735
        oldmask = umask(0U);
#line 2736
        xferlog = open((char const   *)(logfile), 1089, 416);
#line 2737
        umask(oldmask);
        }
#line 2738
        if (xferlog < 0) {
          {
#line 2739
          tmp___30 = __errno_location();
#line 2739
          tmp___31 = strerror(*tmp___30);
#line 2739
          syslog(3, "cannot open logfile %s: %s", logfile, tmp___31);
#line 2741
          xferlog = 0;
          }
        }
      }
    }
  }
  {
#line 2756
  enable_signaling();
  }
#line 2758
  if (anonymous) {
#line 2758
    if (use_accessfile) {
      {
#line 2759
      acl_autogroup(pw);
#line 2760
      guest = acl_guestgroup(pw);
      }
#line 2761
      if (guest) {
        {
#line 2761
        tmp___32 = acl_realgroup(pw);
        }
#line 2761
        if (tmp___32) {
#line 2762
          guest = 0;
        }
      }
#line 2763
      anonymous = ! guest;
    }
  }
  {
#line 2766
  login_attempts = 0;
#line 2769
  setegid(pw->pw_gid);
#line 2773
  initgroups((char const   *)pw->pw_name, pw->pw_gid);
  }
#line 2778
  if (wtmp_logging) {
    {
#line 2783
    tmp___33 = getpid();
#line 2783
    sprintf((char */* __restrict  */)(ttyline), (char const   */* __restrict  */)"ftpd%d",
            tmp___33);
#line 2788
    wu_logwtmp(ttyline, pw->pw_name, remotehost, 1);
    }
  }
  {
#line 2790
  logged_in = 1;
#line 2792
  expand_id();
#line 2799
  restricted_user = 0;
  }
#line 2800
  if (! anonymous) {
    {
#line 2801
    tmp___34 = restricteduid(pw->pw_uid);
    }
#line 2801
    if (tmp___34) {
      {
#line 2801
      tmp___35 = unrestricteduid(pw->pw_uid);
      }
#line 2801
      if (tmp___35) {
        goto _L___3;
      } else {
#line 2803
        restricted_user = 1;
      }
    } else {
      _L___3: 
      {
#line 2801
      tmp___36 = restrictedgid(pw->pw_gid);
      }
#line 2801
      if (tmp___36) {
        {
#line 2801
        tmp___37 = unrestrictedgid(pw->pw_gid);
        }
#line 2801
        if (! tmp___37) {
#line 2803
          restricted_user = 1;
        }
      }
    }
  }
#line 2804
  if (anonymous) {
    goto _L___20;
  } else {
#line 2804
    if (guest) {
      _L___20: 
#line 2809
      home = defhome;
#line 2812
      if (virtual_mode) {
#line 2812
        if (! guest) {
          {
#line 2814
          tmp___38 = DenyVirtualAnonymous();
          }
#line 2814
          if (tmp___38) {
            {
#line 2816
            syslog(5, "FTP LOGIN FAILED (virtual host anonymous access denied) for %s",
                   remoteident);
#line 2819
            reply(530, (char *)"Login incorrect.");
#line 2820
            login_attempts ++;
            }
#line 2820
            if (login_attempts >= lgi_failure_threshold) {
              {
#line 2821
              syslog(5, "repeated login failures from %s", remoteident);
#line 2822
              exit(0);
              }
            }
            goto bad;
          }
#line 2828
          if (pw->pw_dir) {
            {
#line 2829
            free((void *)pw->pw_dir);
            }
          }
          {
#line 2830
          pw->pw_dir = sgetsave(virtual_root);
          }
        } else {
          goto _L___12;
        }
      } else {
        _L___12: 
#line 2857
        entry___0 = (struct aclmember *)((void *)0);
#line 2858
        root_path = (char *)((void *)0);
#line 2860
        if (anonymous) {
          {
#line 2863
          acl_getclass(class);
          }
#line 2864
          while (1) {
            {
#line 2864
            tmp___50 = getaclentry((char *)"anonymous-root", & entry___0);
            }
#line 2864
            if (tmp___50) {
#line 2864
              if (! entry___0->arg[0]) {
#line 2864
                break;
              }
            } else {
#line 2864
              break;
            }
#line 2865
            if (! entry___0->arg[1]) {
#line 2866
              if (! root_path) {
#line 2867
                root_path = entry___0->arg[0];
              }
            } else {
#line 2872
              which = 1;
#line 2872
              while (1) {
#line 2872
                if (which < 50) {
#line 2872
                  if (! entry___0->arg[which]) {
#line 2872
                    break;
                  }
                } else {
#line 2872
                  break;
                }
#line 2873
                if (0) {
                  {
#line 2873
                  __s1_len___0 = strlen((char const   *)entry___0->arg[which]);
#line 2873
                  __s2_len___0 = strlen("*");
                  }
#line 2873
                  if (! ((unsigned int )((void const   *)(entry___0->arg[which] + 1)) - (unsigned int )((void const   *)entry___0->arg[which]) == 1U)) {
                    goto _L___5;
                  } else {
#line 2873
                    if (__s1_len___0 >= 4U) {
                      _L___5: 
#line 2873
                      if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2873
                        tmp___49 = 1;
                      } else {
#line 2873
                        if (__s2_len___0 >= 4U) {
#line 2873
                          tmp___49 = 1;
                        } else {
#line 2873
                          tmp___49 = 0;
                        }
                      }
                    } else {
#line 2873
                      tmp___49 = 0;
                    }
                  }
#line 2873
                  if (tmp___49) {
                    {
#line 2873
                    tmp___45 = __builtin_strcmp((char const   *)entry___0->arg[which],
                                                "*");
                    }
                  } else {
                    {
#line 2873
                    tmp___48 = __builtin_strcmp((char const   *)entry___0->arg[which],
                                                "*");
#line 2873
                    tmp___45 = tmp___48;
                    }
                  }
                } else {
                  {
#line 2873
                  tmp___48 = __builtin_strcmp((char const   *)entry___0->arg[which],
                                              "*");
#line 2873
                  tmp___45 = tmp___48;
                  }
                }
#line 2873
                if (tmp___45) {
                  {
#line 2878
                  tmp___39 = strcasecmp((char const   *)entry___0->arg[which], (char const   *)(class));
                  }
#line 2878
                  if (! tmp___39) {
#line 2879
                    root_path = entry___0->arg[0];
                  }
                } else {
#line 2874
                  if (! root_path) {
#line 2875
                    root_path = entry___0->arg[0];
                  }
                }
#line 2872
                which ++;
              }
            }
          }
        } else {
#line 2886
          while (1) {
            {
#line 2886
            tmp___72 = getaclentry((char *)"guest-root", & entry___0);
            }
#line 2886
            if (tmp___72) {
#line 2886
              if (! entry___0->arg[0]) {
#line 2886
                break;
              }
            } else {
#line 2886
              break;
            }
#line 2887
            if (! entry___0->arg[1]) {
#line 2888
              if (! root_path) {
#line 2889
                root_path = entry___0->arg[0];
              }
            } else {
#line 2895
              which___0 = 1;
#line 2895
              while (1) {
#line 2895
                if (which___0 < 50) {
#line 2895
                  if (! entry___0->arg[which___0]) {
#line 2895
                    break;
                  }
                } else {
#line 2895
                  break;
                }
#line 2896
                if (0) {
                  {
#line 2896
                  __s1_len___1 = strlen((char const   *)entry___0->arg[which___0]);
#line 2896
                  __s2_len___1 = strlen("*");
                  }
#line 2896
                  if (! ((unsigned int )((void const   *)(entry___0->arg[which___0] + 1)) - (unsigned int )((void const   *)entry___0->arg[which___0]) == 1U)) {
                    goto _L___8;
                  } else {
#line 2896
                    if (__s1_len___1 >= 4U) {
                      _L___8: 
#line 2896
                      if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 2896
                        tmp___71 = 1;
                      } else {
#line 2896
                        if (__s2_len___1 >= 4U) {
#line 2896
                          tmp___71 = 1;
                        } else {
#line 2896
                          tmp___71 = 0;
                        }
                      }
                    } else {
#line 2896
                      tmp___71 = 0;
                    }
                  }
#line 2896
                  if (tmp___71) {
                    {
#line 2896
                    tmp___67 = __builtin_strcmp((char const   *)entry___0->arg[which___0],
                                                "*");
                    }
                  } else {
                    {
#line 2896
                    tmp___70 = __builtin_strcmp((char const   *)entry___0->arg[which___0],
                                                "*");
#line 2896
                    tmp___67 = tmp___70;
                    }
                  }
                } else {
                  {
#line 2896
                  tmp___70 = __builtin_strcmp((char const   *)entry___0->arg[which___0],
                                              "*");
#line 2896
                  tmp___67 = tmp___70;
                  }
                }
#line 2896
                if (tmp___67) {
#line 2901
                  if ((int )*(entry___0->arg[which___0] + 0) == 37) {
                    {
#line 2902
                    tmp___60 = __builtin_strchr(entry___0->arg[which___0] + 1, '-');
#line 2902
                    ptr = tmp___60;
                    }
#line 2902
                    if ((unsigned int )ptr == (unsigned int )((void *)0)) {
                      {
#line 2903
                      tmp___55 = __builtin_strchr(entry___0->arg[which___0] + 1, '+');
#line 2903
                      ptr = tmp___55;
                      }
#line 2903
                      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
                        {
#line 2904
                        tmp___51 = strtoul((char const   */* __restrict  */)(entry___0->arg[which___0] + 1),
                                           (char **/* __restrict  */)((void *)0),
                                           0);
                        }
#line 2904
                        if ((unsigned long )pw->pw_uid == tmp___51) {
#line 2905
                          root_path = entry___0->arg[0];
                        }
                      } else {
#line 2908
                        tmp___52 = ptr;
#line 2908
                        ptr ++;
#line 2908
                        *tmp___52 = (char )'\000';
#line 2909
                        if ((int )*(entry___0->arg[which___0] + 1) == 0) {
#line 2911
                          root_path = entry___0->arg[0];
                        } else {
                          {
#line 2909
                          tmp___53 = strtoul((char const   */* __restrict  */)(entry___0->arg[which___0] + 1),
                                             (char **/* __restrict  */)((void *)0),
                                             0);
                          }
#line 2909
                          if ((unsigned long )pw->pw_uid >= tmp___53) {
#line 2911
                            root_path = entry___0->arg[0];
                          }
                        }
#line 2912
                        ptr --;
#line 2912
                        *ptr = (char )'+';
                      }
                    } else {
#line 2916
                      tmp___56 = ptr;
#line 2916
                      ptr ++;
#line 2916
                      *tmp___56 = (char )'\000';
#line 2917
                      if ((int )*(entry___0->arg[which___0] + 1) == 0) {
                        goto _L___6;
                      } else {
                        {
#line 2917
                        tmp___57 = strtoul((char const   */* __restrict  */)(entry___0->arg[which___0] + 1),
                                           (char **/* __restrict  */)((void *)0),
                                           0);
                        }
#line 2917
                        if ((unsigned long )pw->pw_uid >= tmp___57) {
                          _L___6: 
#line 2917
                          if ((int )*ptr == 0) {
#line 2921
                            root_path = entry___0->arg[0];
                          } else {
                            {
#line 2917
                            tmp___58 = strtoul((char const   */* __restrict  */)ptr,
                                               (char **/* __restrict  */)((void *)0),
                                               0);
                            }
#line 2917
                            if ((unsigned long )pw->pw_uid <= tmp___58) {
#line 2921
                              root_path = entry___0->arg[0];
                            }
                          }
                        }
                      }
#line 2922
                      ptr --;
#line 2922
                      *ptr = (char )'-';
                    }
                  } else {
                    {
#line 2926
                    tmp___61 = getpwnam((char const   *)entry___0->arg[which___0]);
#line 2926
                    guest_pw = tmp___61;
                    }
#line 2927
                    if (guest_pw) {
#line 2927
                      if (pw->pw_uid == guest_pw->pw_uid) {
#line 2928
                        root_path = entry___0->arg[0];
                      }
                    }
                  }
                } else {
#line 2897
                  if (! root_path) {
#line 2898
                    root_path = entry___0->arg[0];
                  }
                }
#line 2895
                which___0 ++;
              }
            }
          }
        }
#line 2936
        if (root_path) {
#line 2937
          chroot_pw = (struct passwd *)((void *)0);
#line 2940
          if (virtual_mode) {
#line 2940
            if (0) {
              {
#line 2940
              __s1_len___2 = strlen((char const   *)root_path);
#line 2940
              __s2_len___2 = strlen((char const   *)(virtual_root));
              }
#line 2940
              if (! ((unsigned int )((void const   *)(root_path + 1)) - (unsigned int )((void const   *)root_path) == 1U)) {
                goto _L___10;
              } else {
#line 2940
                if (__s1_len___2 >= 4U) {
                  _L___10: 
#line 2940
                  if (! ((unsigned int )((void const   *)(virtual_root + 1)) - (unsigned int )((void const   *)(virtual_root)) == 1U)) {
#line 2940
                    tmp___82 = 1;
                  } else {
#line 2940
                    if (__s2_len___2 >= 4U) {
#line 2940
                      tmp___82 = 1;
                    } else {
#line 2940
                      tmp___82 = 0;
                    }
                  }
                } else {
#line 2940
                  tmp___82 = 0;
                }
              }
#line 2940
              if (tmp___82) {
                {
#line 2940
                tmp___78 = __builtin_strcmp((char const   *)root_path, (char const   *)(virtual_root));
                }
              } else {
                {
#line 2940
                tmp___81 = __builtin_strcmp((char const   *)root_path, (char const   *)(virtual_root));
#line 2940
                tmp___78 = tmp___81;
                }
              }
            } else {
              {
#line 2940
              tmp___81 = __builtin_strcmp((char const   *)root_path, (char const   *)(virtual_root));
#line 2940
              tmp___78 = tmp___81;
              }
            }
#line 2940
            if (tmp___78) {
              {
#line 2940
              tmp___83 = AllowVirtualUser((char const   *)pw->pw_name);
              }
#line 2940
              if (tmp___83) {
                {
#line 2940
                tmp___84 = DenyVirtualUser((char const   *)pw->pw_name);
                }
#line 2940
                if (tmp___84) {
                  goto _L___11;
                }
              } else {
                _L___11: 
                {
#line 2942
                syslog(5, "FTP LOGIN FAILED (virtual host access denied) for %s, %s",
                       remoteident, pw->pw_name);
#line 2945
                reply(530, (char *)"Login incorrect.");
#line 2946
                login_attempts ++;
                }
#line 2946
                if (login_attempts >= lgi_failure_threshold) {
                  {
#line 2947
                  syslog(5, "repeated login failures from %s", remoteident);
#line 2948
                  exit(0);
                  }
                }
                goto bad;
              }
            }
          }
          {
#line 2953
          __builtin_strncpy(chroot_path, (char const   *)root_path, sizeof(chroot_path));
#line 2954
          chroot_path[sizeof(chroot_path) - 1U] = (char )'\000';
#line 2955
          pw->pw_dir = sgetsave(chroot_path);
#line 2956
          tmp___85 = chroot((char const   *)root_path);
          }
#line 2956
          if (tmp___85 < 0) {
            {
#line 2958
            syslog(5, "FTP LOGIN FAILED (cannot set guest privileges) for %s, %s",
                   remoteident, pw->pw_name);
#line 2961
            reply(530, (char *)"Can\'t set guest privileges. 1");
            }
            goto bad;
          } else {
            {
#line 2956
            tmp___86 = mapping_chdir((char *)"/");
            }
#line 2956
            if (tmp___86 < 0) {
              {
#line 2958
              syslog(5, "FTP LOGIN FAILED (cannot set guest privileges) for %s, %s",
                     remoteident, pw->pw_name);
#line 2961
              reply(530, (char *)"Can\'t set guest privileges. 1");
              }
              goto bad;
            }
          }
          {
#line 2964
          chroot_pw = getpwuid(pw->pw_uid);
          }
#line 2964
          if ((unsigned int )chroot_pw != (unsigned int )((void *)0)) {
            {
#line 2965
            tmp___87 = mapping_chdir(chroot_pw->pw_dir);
            }
#line 2965
            if (tmp___87 >= 0) {
              {
#line 2966
              home = sgetsave(chroot_pw->pw_dir);
              }
            }
          }
          goto slimy_hack;
        }
      }
      {
#line 2973
      sp = strstr((char const   *)pw->pw_dir, "/./");
      }
#line 2973
      if ((unsigned int )sp == (unsigned int )((void *)0)) {
        {
#line 2974
        __builtin_strncpy(chroot_path, (char const   *)pw->pw_dir, sizeof(chroot_path));
#line 2975
        chroot_path[sizeof(chroot_path) - 1U] = (char )'\000';
        }
#line 2977
        if (virtual_mode) {
#line 2977
          if (0) {
            {
#line 2977
            __s1_len___3 = strlen((char const   *)(chroot_path));
#line 2977
            __s2_len___3 = strlen((char const   *)(virtual_root));
            }
#line 2977
            if (! ((unsigned int )((void const   *)(chroot_path + 1)) - (unsigned int )((void const   *)(chroot_path)) == 1U)) {
              goto _L___14;
            } else {
#line 2977
              if (__s1_len___3 >= 4U) {
                _L___14: 
#line 2977
                if (! ((unsigned int )((void const   *)(virtual_root + 1)) - (unsigned int )((void const   *)(virtual_root)) == 1U)) {
#line 2977
                  tmp___97 = 1;
                } else {
#line 2977
                  if (__s2_len___3 >= 4U) {
#line 2977
                    tmp___97 = 1;
                  } else {
#line 2977
                    tmp___97 = 0;
                  }
                }
              } else {
#line 2977
                tmp___97 = 0;
              }
            }
#line 2977
            if (tmp___97) {
              {
#line 2977
              tmp___93 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
              }
            } else {
              {
#line 2977
              tmp___96 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
#line 2977
              tmp___93 = tmp___96;
              }
            }
          } else {
            {
#line 2977
            tmp___96 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
#line 2977
            tmp___93 = tmp___96;
            }
          }
#line 2977
          if (tmp___93) {
            {
#line 2977
            tmp___98 = AllowVirtualUser((char const   *)pw->pw_name);
            }
#line 2977
            if (tmp___98) {
              {
#line 2977
              tmp___99 = DenyVirtualUser((char const   *)pw->pw_name);
              }
#line 2977
              if (tmp___99) {
                goto _L___15;
              }
            } else {
              _L___15: 
              {
#line 2979
              syslog(5, "FTP LOGIN FAILED (virtual host access denied) for %s, %s",
                     remoteident, pw->pw_name);
#line 2982
              reply(530, (char *)"Login incorrect.");
#line 2983
              login_attempts ++;
              }
#line 2983
              if (login_attempts >= lgi_failure_threshold) {
                {
#line 2984
                syslog(5, "repeated login failures from %s", remoteident);
#line 2985
                exit(0);
                }
              }
              goto bad;
            }
          }
        }
      } else {
        {
#line 3001
        tmp___100 = sp;
#line 3001
        sp ++;
#line 3001
        *tmp___100 = (char )'\000';
#line 3002
        __builtin_strncpy(chroot_path, (char const   *)pw->pw_dir, sizeof(chroot_path));
#line 3003
        chroot_path[sizeof(chroot_path) - 1U] = (char )'\000';
        }
#line 3005
        if (virtual_mode) {
#line 3005
          if (0) {
            {
#line 3005
            __s1_len___4 = strlen((char const   *)(chroot_path));
#line 3005
            __s2_len___4 = strlen((char const   *)(virtual_root));
            }
#line 3005
            if (! ((unsigned int )((void const   *)(chroot_path + 1)) - (unsigned int )((void const   *)(chroot_path)) == 1U)) {
              goto _L___17;
            } else {
#line 3005
              if (__s1_len___4 >= 4U) {
                _L___17: 
#line 3005
                if (! ((unsigned int )((void const   *)(virtual_root + 1)) - (unsigned int )((void const   *)(virtual_root)) == 1U)) {
#line 3005
                  tmp___110 = 1;
                } else {
#line 3005
                  if (__s2_len___4 >= 4U) {
#line 3005
                    tmp___110 = 1;
                  } else {
#line 3005
                    tmp___110 = 0;
                  }
                }
              } else {
#line 3005
                tmp___110 = 0;
              }
            }
#line 3005
            if (tmp___110) {
              {
#line 3005
              tmp___106 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
              }
            } else {
              {
#line 3005
              tmp___109 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
#line 3005
              tmp___106 = tmp___109;
              }
            }
          } else {
            {
#line 3005
            tmp___109 = __builtin_strcmp((char const   *)(chroot_path), (char const   *)(virtual_root));
#line 3005
            tmp___106 = tmp___109;
            }
          }
#line 3005
          if (tmp___106) {
            {
#line 3005
            tmp___111 = AllowVirtualUser((char const   *)pw->pw_name);
            }
#line 3005
            if (tmp___111) {
              {
#line 3005
              tmp___112 = DenyVirtualUser((char const   *)pw->pw_name);
              }
#line 3005
              if (tmp___112) {
                goto _L___18;
              }
            } else {
              _L___18: 
              {
#line 3007
              syslog(5, "FTP LOGIN FAILED (virtual host access denied) for %s, %s",
                     remoteident, pw->pw_name);
#line 3010
              reply(530, (char *)"Login incorrect.");
#line 3011
              login_attempts ++;
              }
#line 3011
              if (login_attempts >= lgi_failure_threshold) {
                {
#line 3012
                syslog(5, "repeated login failures from %s", remoteident);
#line 3013
                exit(0);
                }
              }
              goto bad;
            }
          }
        }
        {
#line 3018
        tmp___113 = chroot((char const   *)pw->pw_dir);
        }
#line 3018
        if (tmp___113 < 0) {
          {
#line 3020
          syslog(5, "FTP LOGIN FAILED (cannot set guest privileges) for %s, %s", remoteident,
                 pw->pw_name);
#line 3023
          reply(550, (char *)"Can\'t set guest privileges. 3");
          }
          goto bad;
        } else {
          {
#line 3018
          sp ++;
#line 3018
          tmp___114 = mapping_chdir(sp);
          }
#line 3018
          if (tmp___114 < 0) {
            {
#line 3020
            syslog(5, "FTP LOGIN FAILED (cannot set guest privileges) for %s, %s",
                   remoteident, pw->pw_name);
#line 3023
            reply(550, (char *)"Can\'t set guest privileges. 3");
            }
            goto bad;
          }
        }
#line 3027
        home = sp;
      }
      slimy_hack: 
#line 3032
      i = 0;
#line 3033
      i ++;
    } else {
#line 3037
      if (virtual_mode) {
        {
#line 3037
        tmp___115 = AllowVirtualUser((char const   *)pw->pw_name);
        }
#line 3037
        if (tmp___115) {
          {
#line 3037
          tmp___116 = DenyVirtualUser((char const   *)pw->pw_name);
          }
#line 3037
          if (tmp___116) {
            goto _L___19;
          }
        } else {
          _L___19: 
          {
#line 3039
          syslog(5, "FTP LOGIN FAILED (virtual host access denied) for %s, %s", remoteident,
                 pw->pw_name);
#line 3042
          reply(530, (char *)"Login incorrect.");
#line 3043
          login_attempts ++;
          }
#line 3043
          if (login_attempts >= lgi_failure_threshold) {
            {
#line 3044
            syslog(5, "repeated login failures from %s", remoteident);
#line 3045
            exit(0);
            }
          }
          goto bad;
        }
      }
    }
  }
#line 3092
  if (! anonymous) {
#line 3092
    if (! guest) {
      {
#line 3093
      tmp___118 = mapping_chdir(pw->pw_dir);
      }
#line 3093
      if (tmp___118 < 0) {
        {
#line 3103
        tmp___117 = mapping_chdir((char *)"/");
        }
#line 3103
        if (tmp___117 < 0) {
          {
#line 3105
          syslog(5, "FTP LOGIN FAILED (cannot chdir) for %s, %s", remoteident, pw->pw_name);
#line 3108
          reply(530, (char *)"User %s: can\'t change directory to %s.", pw->pw_name,
                pw->pw_dir);
          }
          goto bad;
        } else {
          {
#line 3113
          lreply(230, (char *)"No directory! Logging in with home=/");
#line 3115
          home = defhome;
          }
        }
      }
    }
  }
#line 3122
  if (passwarn) {
    {
#line 3123
    lreply(230, (char *)"The response \'%s\' is not valid", passwd);
#line 3124
    lreply(230, (char *)"Next time please use your e-mail address as your password");
    }
#line 3126
    if (authenticated) {
#line 3126
      tmp___119 = (char const   *)(authuser);
    } else {
#line 3126
      tmp___119 = "joe";
    }
    {
#line 3126
    lreply(230, (char *)"        for example: %s@%s", tmp___119, remotehost);
    }
  }
  {
#line 3132
  show_message(230, 0);
#line 3133
  show_message(230, 1);
#line 3134
  show_readme(230, 0);
#line 3135
  show_readme(230, 1);
#line 3145
  is_shutdown(0, 0);
  }
#line 3147
  if (anonymous) {
    {
#line 3149
    reply(230, (char *)"Guest login ok, access restrictions apply.");
#line 3150
    sprintf((char */* __restrict  */)(proctitle), (char const   */* __restrict  */)"%s: anonymous/%.*s",
            remotehost, (int )((sizeof(proctitle) - sizeof(remotehost)) - sizeof(": anonymous/")),
            passwd);
#line 3153
    setproctitle("%s", proctitle);
    }
#line 3154
    if (logging) {
      {
#line 3155
      syslog(6, "ANONYMOUS FTP LOGIN FROM %s, %s", remoteident, passwd);
      }
    }
  } else {
#line 3159
    if (guest) {
#line 3159
      tmp___120 = "  Access restrictions apply.";
    } else {
#line 3159
      tmp___120 = "";
    }
    {
#line 3159
    reply(230, (char *)"User %s logged in.%s", pw->pw_name, tmp___120);
#line 3161
    sprintf((char */* __restrict  */)(proctitle), (char const   */* __restrict  */)"%s: %s",
            remotehost, pw->pw_name);
#line 3162
    setproctitle((char const   *)(proctitle));
    }
#line 3163
    if (logging) {
      {
#line 3164
      syslog(6, "FTP LOGIN FROM %s, %s", remoteident, pw->pw_name);
      }
    }
  }
#line 3172
  if (! home) {
#line 3174
    home = pw->pw_dir;
  }
  {
#line 3175
  umask(defumask);
#line 3176
  time(& login_time);
#line 3179
  entry___1 = (struct aclmember *)((void *)0);
  }
#line 3180
  while (1) {
    {
#line 3180
    tmp___134 = getaclentry((char *)"limit-time", & entry___1);
    }
#line 3180
    if (tmp___134) {
#line 3180
      if (entry___1->arg[0]) {
#line 3180
        if (! entry___1->arg[1]) {
#line 3180
          break;
        }
      } else {
#line 3180
        break;
      }
    } else {
#line 3180
      break;
    }
#line 3183
    if (anonymous) {
      {
#line 3181
      tmp___122 = strcasecmp((char const   *)entry___1->arg[0], "anonymous");
      }
#line 3183
      if (tmp___122 == 0) {
        {
#line 3184
        tmp___121 = strtoul((char const   */* __restrict  */)entry___1->arg[1], (char **/* __restrict  */)((void *)0),
                            0);
#line 3184
        limit_time = (long )tmp___121;
        }
      } else {
        goto _L___24;
      }
    } else {
      _L___24: 
#line 3183
      if (guest) {
        {
#line 3181
        tmp___123 = strcasecmp((char const   *)entry___1->arg[0], "guest");
        }
#line 3183
        if (tmp___123 == 0) {
          {
#line 3184
          tmp___121 = strtoul((char const   */* __restrict  */)entry___1->arg[1],
                              (char **/* __restrict  */)((void *)0), 0);
#line 3184
          limit_time = (long )tmp___121;
          }
        } else {
          goto _L___23;
        }
      } else {
        _L___23: 
#line 3183
        if (guest | anonymous) {
#line 3183
          if (0) {
            {
#line 3183
            __s1_len___5 = strlen((char const   *)entry___1->arg[0]);
#line 3183
            __s2_len___5 = strlen("*");
            }
#line 3183
            if (! ((unsigned int )((void const   *)(entry___1->arg[0] + 1)) - (unsigned int )((void const   *)entry___1->arg[0]) == 1U)) {
              goto _L___22;
            } else {
#line 3183
              if (__s1_len___5 >= 4U) {
                _L___22: 
#line 3183
                if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 3183
                  tmp___133 = 1;
                } else {
#line 3183
                  if (__s2_len___5 >= 4U) {
#line 3183
                    tmp___133 = 1;
                  } else {
#line 3183
                    tmp___133 = 0;
                  }
                }
              } else {
#line 3183
                tmp___133 = 0;
              }
            }
#line 3183
            if (tmp___133) {
              {
#line 3183
              tmp___129 = __builtin_strcmp((char const   *)entry___1->arg[0], "*");
              }
            } else {
              {
#line 3183
              tmp___132 = __builtin_strcmp((char const   *)entry___1->arg[0], "*");
#line 3183
              tmp___129 = tmp___132;
              }
            }
          } else {
            {
#line 3183
            tmp___132 = __builtin_strcmp((char const   *)entry___1->arg[0], "*");
#line 3183
            tmp___129 = tmp___132;
            }
          }
#line 3183
          if (tmp___129 == 0) {
            {
#line 3184
            tmp___121 = strtoul((char const   */* __restrict  */)entry___1->arg[1],
                                (char **/* __restrict  */)((void *)0), 0);
#line 3184
            limit_time = (long )tmp___121;
            }
          }
        }
      }
    }
  }
#line 3186
  return;
  bad: 
#line 3189
  if (xferlog) {
    {
#line 3190
    close(xferlog);
    }
  }
  {
#line 3191
  xferlog = 0;
#line 3192
  end_login();
  }
#line 3193
  return;
}
}
#line 3196 "ftpd.c"
int restricteduid(uid_t uid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct passwd *pw___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 3198
  entry = (struct aclmember *)((void *)0);
#line 3203
  while (1) {
    {
#line 3203
    tmp___19 = getaclentry((char *)"restricted-uid", & entry);
    }
#line 3203
    if (! tmp___19) {
#line 3203
      break;
    }
#line 3204
    which = 0;
#line 3204
    while (1) {
#line 3204
      if (which < 50) {
#line 3204
        if (! entry->arg[which]) {
#line 3204
          break;
        }
      } else {
#line 3204
        break;
      }
#line 3205
      if (0) {
        {
#line 3205
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 3205
        __s2_len = strlen("*");
        }
#line 3205
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 3205
          if (__s1_len >= 4U) {
            _L___0: 
#line 3205
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 3205
              tmp___8 = 1;
            } else {
#line 3205
              if (__s2_len >= 4U) {
#line 3205
                tmp___8 = 1;
              } else {
#line 3205
                tmp___8 = 0;
              }
            }
          } else {
#line 3205
            tmp___8 = 0;
          }
        }
#line 3205
        if (tmp___8) {
          {
#line 3205
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 3205
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3205
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 3205
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3205
        tmp___4 = tmp___7;
        }
      }
#line 3205
      if (! tmp___4) {
#line 3206
        return (1);
      }
#line 3207
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 3208
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 3208
        ptr = tmp___18;
        }
#line 3208
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 3209
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 3209
          ptr = tmp___13;
          }
#line 3209
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 3210
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 3210
            if ((unsigned long )uid == tmp___9) {
#line 3211
              return (1);
            }
          } else {
#line 3214
            tmp___10 = ptr;
#line 3214
            ptr ++;
#line 3214
            *tmp___10 = (char )'\000';
#line 3215
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 3217
              ptr --;
#line 3217
              *ptr = (char )'+';
#line 3218
              return (1);
            } else {
              {
#line 3215
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 3215
              if ((unsigned long )uid >= tmp___11) {
#line 3217
                ptr --;
#line 3217
                *ptr = (char )'+';
#line 3218
                return (1);
              }
            }
#line 3220
            ptr --;
#line 3220
            *ptr = (char )'+';
          }
        } else {
#line 3224
          tmp___14 = ptr;
#line 3224
          ptr ++;
#line 3224
          *tmp___14 = (char )'\000';
#line 3225
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 3225
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 3225
            if ((unsigned long )uid >= tmp___15) {
              _L___1: 
#line 3225
              if ((int )*ptr == 0) {
#line 3229
                ptr --;
#line 3229
                *ptr = (char )'-';
#line 3230
                return (1);
              } else {
                {
#line 3225
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 3225
                if ((unsigned long )uid <= tmp___16) {
#line 3229
                  ptr --;
#line 3229
                  *ptr = (char )'-';
#line 3230
                  return (1);
                }
              }
            }
          }
#line 3232
          ptr --;
#line 3232
          *ptr = (char )'-';
        }
      } else {
        {
#line 3236
        pw___0 = getpwnam((char const   *)entry->arg[which]);
        }
#line 3237
        if (pw___0) {
#line 3237
          if (uid == pw___0->pw_uid) {
#line 3238
            return (1);
          }
        }
      }
#line 3204
      which ++;
    }
  }
#line 3242
  return (0);
}
}
#line 3245 "ftpd.c"
int unrestricteduid(uid_t uid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct passwd *pw___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 3247
  entry = (struct aclmember *)((void *)0);
#line 3252
  while (1) {
    {
#line 3252
    tmp___19 = getaclentry((char *)"unrestricted-uid", & entry);
    }
#line 3252
    if (! tmp___19) {
#line 3252
      break;
    }
#line 3253
    which = 0;
#line 3253
    while (1) {
#line 3253
      if (which < 50) {
#line 3253
        if (! entry->arg[which]) {
#line 3253
          break;
        }
      } else {
#line 3253
        break;
      }
#line 3254
      if (0) {
        {
#line 3254
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 3254
        __s2_len = strlen("*");
        }
#line 3254
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 3254
          if (__s1_len >= 4U) {
            _L___0: 
#line 3254
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 3254
              tmp___8 = 1;
            } else {
#line 3254
              if (__s2_len >= 4U) {
#line 3254
                tmp___8 = 1;
              } else {
#line 3254
                tmp___8 = 0;
              }
            }
          } else {
#line 3254
            tmp___8 = 0;
          }
        }
#line 3254
        if (tmp___8) {
          {
#line 3254
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 3254
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3254
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 3254
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3254
        tmp___4 = tmp___7;
        }
      }
#line 3254
      if (! tmp___4) {
#line 3255
        return (1);
      }
#line 3256
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 3257
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 3257
        ptr = tmp___18;
        }
#line 3257
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 3258
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 3258
          ptr = tmp___13;
          }
#line 3258
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 3259
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 3259
            if ((unsigned long )uid == tmp___9) {
#line 3260
              return (1);
            }
          } else {
#line 3263
            tmp___10 = ptr;
#line 3263
            ptr ++;
#line 3263
            *tmp___10 = (char )'\000';
#line 3264
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 3266
              ptr --;
#line 3266
              *ptr = (char )'+';
#line 3267
              return (1);
            } else {
              {
#line 3264
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 3264
              if ((unsigned long )uid >= tmp___11) {
#line 3266
                ptr --;
#line 3266
                *ptr = (char )'+';
#line 3267
                return (1);
              }
            }
#line 3269
            ptr --;
#line 3269
            *ptr = (char )'+';
          }
        } else {
#line 3273
          tmp___14 = ptr;
#line 3273
          ptr ++;
#line 3273
          *tmp___14 = (char )'\000';
#line 3274
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 3274
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 3274
            if ((unsigned long )uid >= tmp___15) {
              _L___1: 
#line 3274
              if ((int )*ptr == 0) {
#line 3278
                ptr --;
#line 3278
                *ptr = (char )'-';
#line 3279
                return (1);
              } else {
                {
#line 3274
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 3274
                if ((unsigned long )uid <= tmp___16) {
#line 3278
                  ptr --;
#line 3278
                  *ptr = (char )'-';
#line 3279
                  return (1);
                }
              }
            }
          }
#line 3281
          ptr --;
#line 3281
          *ptr = (char )'-';
        }
      } else {
        {
#line 3285
        pw___0 = getpwnam((char const   *)entry->arg[which]);
        }
#line 3286
        if (pw___0) {
#line 3286
          if (uid == pw___0->pw_uid) {
#line 3287
            return (1);
          }
        }
      }
#line 3253
      which ++;
    }
  }
#line 3291
  return (0);
}
}
#line 3294 "ftpd.c"
int restrictedgid(gid_t gid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct group *grp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 3296
  entry = (struct aclmember *)((void *)0);
#line 3301
  while (1) {
    {
#line 3301
    tmp___19 = getaclentry((char *)"restricted-gid", & entry);
    }
#line 3301
    if (! tmp___19) {
#line 3301
      break;
    }
#line 3302
    which = 0;
#line 3302
    while (1) {
#line 3302
      if (which < 50) {
#line 3302
        if (! entry->arg[which]) {
#line 3302
          break;
        }
      } else {
#line 3302
        break;
      }
#line 3303
      if (0) {
        {
#line 3303
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 3303
        __s2_len = strlen("*");
        }
#line 3303
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 3303
          if (__s1_len >= 4U) {
            _L___0: 
#line 3303
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 3303
              tmp___8 = 1;
            } else {
#line 3303
              if (__s2_len >= 4U) {
#line 3303
                tmp___8 = 1;
              } else {
#line 3303
                tmp___8 = 0;
              }
            }
          } else {
#line 3303
            tmp___8 = 0;
          }
        }
#line 3303
        if (tmp___8) {
          {
#line 3303
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 3303
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3303
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 3303
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3303
        tmp___4 = tmp___7;
        }
      }
#line 3303
      if (! tmp___4) {
#line 3304
        return (1);
      }
#line 3305
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 3306
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 3306
        ptr = tmp___18;
        }
#line 3306
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 3307
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 3307
          ptr = tmp___13;
          }
#line 3307
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 3308
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 3308
            if ((unsigned long )gid == tmp___9) {
#line 3309
              return (1);
            }
          } else {
#line 3312
            tmp___10 = ptr;
#line 3312
            ptr ++;
#line 3312
            *tmp___10 = (char )'\000';
#line 3313
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 3315
              ptr --;
#line 3315
              *ptr = (char )'+';
#line 3316
              return (1);
            } else {
              {
#line 3313
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 3313
              if ((unsigned long )gid >= tmp___11) {
#line 3315
                ptr --;
#line 3315
                *ptr = (char )'+';
#line 3316
                return (1);
              }
            }
#line 3318
            ptr --;
#line 3318
            *ptr = (char )'+';
          }
        } else {
#line 3322
          tmp___14 = ptr;
#line 3322
          ptr ++;
#line 3322
          *tmp___14 = (char )'\000';
#line 3323
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 3323
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 3323
            if ((unsigned long )gid >= tmp___15) {
              _L___1: 
#line 3323
              if ((int )*ptr == 0) {
#line 3327
                ptr --;
#line 3327
                *ptr = (char )'-';
#line 3328
                return (1);
              } else {
                {
#line 3323
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 3323
                if ((unsigned long )gid <= tmp___16) {
#line 3327
                  ptr --;
#line 3327
                  *ptr = (char )'-';
#line 3328
                  return (1);
                }
              }
            }
          }
#line 3330
          ptr --;
#line 3330
          *ptr = (char )'-';
        }
      } else {
        {
#line 3334
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 3335
        if (grp) {
#line 3335
          if (gid == grp->gr_gid) {
#line 3336
            return (1);
          }
        }
      }
#line 3302
      which ++;
    }
  }
#line 3340
  return (0);
}
}
#line 3343 "ftpd.c"
int unrestrictedgid(gid_t gid ) 
{ struct aclmember *entry ;
  int which ;
  char *ptr ;
  struct group *grp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  unsigned long tmp___9 ;
  char *tmp___10 ;
  unsigned long tmp___11 ;
  char *tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 3345
  entry = (struct aclmember *)((void *)0);
#line 3350
  while (1) {
    {
#line 3350
    tmp___19 = getaclentry((char *)"unrestricted-gid", & entry);
    }
#line 3350
    if (! tmp___19) {
#line 3350
      break;
    }
#line 3351
    which = 0;
#line 3351
    while (1) {
#line 3351
      if (which < 50) {
#line 3351
        if (! entry->arg[which]) {
#line 3351
          break;
        }
      } else {
#line 3351
        break;
      }
#line 3352
      if (0) {
        {
#line 3352
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 3352
        __s2_len = strlen("*");
        }
#line 3352
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 3352
          if (__s1_len >= 4U) {
            _L___0: 
#line 3352
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 3352
              tmp___8 = 1;
            } else {
#line 3352
              if (__s2_len >= 4U) {
#line 3352
                tmp___8 = 1;
              } else {
#line 3352
                tmp___8 = 0;
              }
            }
          } else {
#line 3352
            tmp___8 = 0;
          }
        }
#line 3352
        if (tmp___8) {
          {
#line 3352
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 3352
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3352
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 3352
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 3352
        tmp___4 = tmp___7;
        }
      }
#line 3352
      if (! tmp___4) {
#line 3353
        return (1);
      }
#line 3354
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 3355
        tmp___18 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 3355
        ptr = tmp___18;
        }
#line 3355
        if ((unsigned int )ptr == (unsigned int )((void *)0)) {
          {
#line 3356
          tmp___13 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 3356
          ptr = tmp___13;
          }
#line 3356
          if ((unsigned int )ptr == (unsigned int )((void *)0)) {
            {
#line 3357
            tmp___9 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                              (char **/* __restrict  */)((void *)0), 0);
            }
#line 3357
            if ((unsigned long )gid == tmp___9) {
#line 3358
              return (1);
            }
          } else {
#line 3361
            tmp___10 = ptr;
#line 3361
            ptr ++;
#line 3361
            *tmp___10 = (char )'\000';
#line 3362
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 3364
              ptr --;
#line 3364
              *ptr = (char )'+';
#line 3365
              return (1);
            } else {
              {
#line 3362
              tmp___11 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 3362
              if ((unsigned long )gid >= tmp___11) {
#line 3364
                ptr --;
#line 3364
                *ptr = (char )'+';
#line 3365
                return (1);
              }
            }
#line 3367
            ptr --;
#line 3367
            *ptr = (char )'+';
          }
        } else {
#line 3371
          tmp___14 = ptr;
#line 3371
          ptr ++;
#line 3371
          *tmp___14 = (char )'\000';
#line 3372
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 3372
            tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 3372
            if ((unsigned long )gid >= tmp___15) {
              _L___1: 
#line 3372
              if ((int )*ptr == 0) {
#line 3376
                ptr --;
#line 3376
                *ptr = (char )'-';
#line 3377
                return (1);
              } else {
                {
#line 3372
                tmp___16 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 3372
                if ((unsigned long )gid <= tmp___16) {
#line 3376
                  ptr --;
#line 3376
                  *ptr = (char )'-';
#line 3377
                  return (1);
                }
              }
            }
          }
#line 3379
          ptr --;
#line 3379
          *ptr = (char )'-';
        }
      } else {
        {
#line 3383
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 3384
        if (grp) {
#line 3384
          if (gid == grp->gr_gid) {
#line 3385
            return (1);
          }
        }
      }
#line 3351
      which ++;
    }
  }
#line 3389
  return (0);
}
}
#line 3394 "ftpd.c"
static char buf[100]  ;
#line 3392 "ftpd.c"
char *opt_string(int options ) 
{ char *ptr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 3395
  ptr = buf;
#line 3397
  if ((options & 1) != 0) {
#line 3398
    tmp = ptr;
#line 3398
    ptr ++;
#line 3398
    *tmp = (char )'C';
  }
#line 3399
  if ((options & (1 << 2)) != 0) {
#line 3400
    tmp___0 = ptr;
#line 3400
    ptr ++;
#line 3400
    *tmp___0 = (char )'T';
  }
#line 3401
  if ((options & (1 << 1)) != 0) {
#line 3402
    tmp___1 = ptr;
#line 3402
    ptr ++;
#line 3402
    *tmp___1 = (char )'U';
  }
#line 3403
  if (options == 0) {
#line 3404
    tmp___2 = ptr;
#line 3404
    ptr ++;
#line 3404
    *tmp___2 = (char )'_';
  }
#line 3405
  tmp___3 = ptr;
#line 3405
  ptr ++;
#line 3405
  *tmp___3 = (char )'\000';
#line 3406
  return (buf);
}
}
#line 4056 "ftpd.c"
static char line[8192]  ;
#line 3866 "ftpd.c"
void retrieve(char *cmd , char *name ) 
{ FILE *fin ;
  FILE *dout___1 ;
  struct stat st ;
  struct stat junk ;
  int (*closefunc)() ;
  int options ;
  int ThisRetrieveIsData ;
  time_t start_time ;
  time_t tmp ;
  char *logname ;
  char namebuf[4096] ;
  char fnbuf[4096] ;
  int TransferComplete ;
  struct convert *cptr ;
  char realname[4096] ;
  int stat_ret ;
  int tmp___0 ;
  char *ptr ;
  int pfxlen ;
  size_t tmp___1 ;
  int sfxlen ;
  size_t tmp___2 ;
  int namelen ;
  size_t tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int pfxlen___0 ;
  size_t tmp___15 ;
  int namelen___0 ;
  size_t tmp___16 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  char *tmp___33 ;
  int tmp___34 ;
  int *tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  register int i ;
  register int n ;
  register int c ;
  int tmp___40 ;
  int tmp___41 ;
  __off_t tmp___42 ;
  char *tmp___43 ;
  char msg[4452] ;
  size_t msglen ;
  int xfertime ;
  time_t tmp___44 ;
  time_t curtime ;
  time_t tmp___45 ;
  int loop ;
  char *tmp___46 ;
  unsigned short const   **tmp___47 ;
  unsigned short const   **tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  char const   *tmp___51 ;
  char *tmp___52 ;
  int tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  size_t tmp___57 ;
  size_t tmp___58 ;

  {
  {
#line 3868
  fin = (FILE *)((void *)0);
#line 3870
  closefunc = (int (*)())((void *)0);
#line 3871
  options = 0;
#line 3872
  ThisRetrieveIsData = retrieve_is_data;
#line 3873
  tmp = time((time_t *)((void *)0));
#line 3873
  start_time = tmp;
#line 3877
  TransferComplete = 0;
#line 3880
  stat_ret = -1;
#line 3884
  wu_realpath((char const   *)name, realname, chroot_path);
  }
#line 3888
  if (retrieve_is_data) {
#line 3889
    if (file_limit_data_out > 0) {
#line 3889
      if (file_count_out >= file_limit_data_out) {
        goto _L;
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
#line 3889
      if (file_limit_data_total > 0) {
#line 3889
        if (file_count_total >= file_limit_data_total) {
          goto _L;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
#line 3889
        if (data_limit_data_out > 0) {
#line 3889
          if (data_count_out >= data_limit_data_out) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
#line 3889
          if (data_limit_data_total > 0) {
#line 3889
            if (data_count_total >= data_limit_data_total) {
              _L: 
#line 3893
              if (log_security) {
#line 3894
                if (anonymous) {
                  {
#line 3895
                  syslog(5, "anonymous(%s) of %s tried to retrieve %s (Transfer limits exceeded)",
                         guestpw, remoteident, realname);
                  }
                } else {
                  {
#line 3898
                  syslog(5, "%s of %s tried to retrieve %s (Transfer limits exceeded)",
                         pw->pw_name, remoteident, realname);
                  }
                }
              }
              {
#line 3900
              reply(553, (char *)"Permission denied on server. (Transfer limits exceeded)");
              }
#line 3901
              return;
            }
          }
        }
      }
    }
  }
#line 3903
  if (file_limit_raw_out > 0) {
#line 3903
    if (xfer_count_out >= file_limit_raw_out) {
      goto _L___3;
    } else {
      goto _L___6;
    }
  } else {
    _L___6: 
#line 3903
    if (file_limit_raw_total > 0) {
#line 3903
      if (xfer_count_total >= file_limit_raw_total) {
        goto _L___3;
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
#line 3903
      if (data_limit_raw_out > 0) {
#line 3903
        if (byte_count_out >= data_limit_raw_out) {
          goto _L___3;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: 
#line 3903
        if (data_limit_raw_total > 0) {
#line 3903
          if (byte_count_total >= data_limit_raw_total) {
            _L___3: 
#line 3907
            if (log_security) {
#line 3908
              if (anonymous) {
                {
#line 3909
                syslog(5, "anonymous(%s) of %s tried to retrieve %s (Transfer limits exceeded)",
                       guestpw, remoteident, realname);
                }
              } else {
                {
#line 3912
                syslog(5, "%s of %s tried to retrieve %s (Transfer limits exceeded)",
                       pw->pw_name, remoteident, realname);
                }
              }
            }
            {
#line 3914
            reply(553, (char *)"Permission denied on server. (Transfer limits exceeded)");
            }
#line 3915
            return;
          }
        }
      }
    }
  }
#line 3920
  if ((unsigned int )cmd == (unsigned int )((void *)0)) {
    {
#line 3920
    stat_ret = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 3920
    if (stat_ret == 0) {
#line 3922
      if (use_accessfile) {
        {
#line 3922
        tmp___0 = checknoretrieve(name);
        }
#line 3922
        if (tmp___0) {
#line 3923
          if (log_security) {
#line 3924
            if (anonymous) {
              {
#line 3925
              syslog(5, "anonymous(%s) of %s tried to download %s (noretrieve)", guestpw,
                     remoteident, realname);
              }
            } else {
              {
#line 3928
              syslog(5, "%s of %s tried to download %s (noretrieve)", pw->pw_name,
                     remoteident, realname);
              }
            }
          }
#line 3930
          return;
        }
      }
    }
  }
#line 3932
  logname = (char *)((void *)0);
#line 3933
  if ((unsigned int )cmd == (unsigned int )((void *)0)) {
#line 3933
    if (stat_ret != 0) {
#line 3936
      cptr = cvtptr;
#line 3936
      while ((unsigned int )cptr != (unsigned int )((void *)0)) {
#line 3937
        if (! (mangleopts & 1)) {
#line 3937
          if (cptr->options & 1) {
            goto __Cont;
          }
        }
#line 3939
        if (! (mangleopts & (1 << 1))) {
#line 3939
          if (cptr->options & (1 << 1)) {
            goto __Cont;
          }
        }
#line 3941
        if (! (mangleopts & (1 << 2))) {
#line 3941
          if (cptr->options & (1 << 2)) {
            goto __Cont;
          }
        }
#line 3944
        if (cptr->stripfix) {
#line 3944
          if (cptr->postfix) {
            {
#line 3945
            tmp___1 = strlen((char const   *)cptr->postfix);
#line 3945
            pfxlen = (int )tmp___1;
#line 3946
            tmp___2 = strlen((char const   *)cptr->stripfix);
#line 3946
            sfxlen = (int )tmp___2;
#line 3947
            tmp___3 = strlen((char const   *)name);
#line 3947
            namelen = (int )tmp___3;
#line 3948
            strcpy((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)name);
            }
#line 3950
            if (namelen <= pfxlen) {
              goto __Cont;
            }
#line 3952
            if ((unsigned int )((namelen - pfxlen) + sfxlen) >= sizeof(fnbuf)) {
              goto __Cont;
            }
#line 3955
            if (0) {
              {
#line 3955
              __s1_len = strlen((char const   *)((fnbuf + namelen) - pfxlen));
#line 3955
              __s2_len = strlen((char const   *)cptr->postfix);
              }
#line 3955
              if (! ((unsigned int )((void const   *)(((fnbuf + namelen) - pfxlen) + 1)) - (unsigned int )((void const   *)((fnbuf + namelen) - pfxlen)) == 1U)) {
                goto _L___8;
              } else {
#line 3955
                if (__s1_len >= 4U) {
                  _L___8: 
#line 3955
                  if (! ((unsigned int )((void const   *)(cptr->postfix + 1)) - (unsigned int )((void const   *)cptr->postfix) == 1U)) {
#line 3955
                    tmp___13 = 1;
                  } else {
#line 3955
                    if (__s2_len >= 4U) {
#line 3955
                      tmp___13 = 1;
                    } else {
#line 3955
                      tmp___13 = 0;
                    }
                  }
                } else {
#line 3955
                  tmp___13 = 0;
                }
              }
#line 3955
              if (tmp___13) {
                {
#line 3955
                tmp___9 = __builtin_strcmp((char const   *)((fnbuf + namelen) - pfxlen),
                                           (char const   *)cptr->postfix);
                }
              } else {
                {
#line 3955
                tmp___12 = __builtin_strcmp((char const   *)((fnbuf + namelen) - pfxlen),
                                            (char const   *)cptr->postfix);
#line 3955
                tmp___9 = tmp___12;
                }
              }
            } else {
              {
#line 3955
              tmp___12 = __builtin_strcmp((char const   *)((fnbuf + namelen) - pfxlen),
                                          (char const   *)cptr->postfix);
#line 3955
              tmp___9 = tmp___12;
              }
            }
#line 3955
            if (tmp___9) {
              goto __Cont;
            }
            {
#line 3957
            *((fnbuf + namelen) - pfxlen) = (char )'\000';
#line 3958
            strcat((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)cptr->stripfix);
#line 3959
            tmp___14 = stat((char const   */* __restrict  */)(fnbuf), (struct stat */* __restrict  */)(& st));
            }
#line 3959
            if (tmp___14 != 0) {
              goto __Cont;
            }
          } else {
            goto _L___11;
          }
        } else {
          _L___11: 
#line 3962
          if (cptr->postfix) {
            {
#line 3963
            tmp___15 = strlen((char const   *)cptr->postfix);
#line 3963
            pfxlen___0 = (int )tmp___15;
#line 3964
            tmp___16 = strlen((char const   *)name);
#line 3964
            namelen___0 = (int )tmp___16;
            }
#line 3966
            if (namelen___0 <= pfxlen___0) {
              goto __Cont;
            }
            {
#line 3968
            strcpy((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)name);
            }
#line 3969
            if (0) {
              {
#line 3969
              __s1_len___0 = strlen((char const   *)((fnbuf + namelen___0) - pfxlen___0));
#line 3969
              __s2_len___0 = strlen((char const   *)cptr->postfix);
              }
#line 3969
              if (! ((unsigned int )((void const   *)(((fnbuf + namelen___0) - pfxlen___0) + 1)) - (unsigned int )((void const   *)((fnbuf + namelen___0) - pfxlen___0)) == 1U)) {
                goto _L___10;
              } else {
#line 3969
                if (__s1_len___0 >= 4U) {
                  _L___10: 
#line 3969
                  if (! ((unsigned int )((void const   *)(cptr->postfix + 1)) - (unsigned int )((void const   *)cptr->postfix) == 1U)) {
#line 3969
                    tmp___26 = 1;
                  } else {
#line 3969
                    if (__s2_len___0 >= 4U) {
#line 3969
                      tmp___26 = 1;
                    } else {
#line 3969
                      tmp___26 = 0;
                    }
                  }
                } else {
#line 3969
                  tmp___26 = 0;
                }
              }
#line 3969
              if (tmp___26) {
                {
#line 3969
                tmp___22 = __builtin_strcmp((char const   *)((fnbuf + namelen___0) - pfxlen___0),
                                            (char const   *)cptr->postfix);
                }
              } else {
                {
#line 3969
                tmp___25 = __builtin_strcmp((char const   *)((fnbuf + namelen___0) - pfxlen___0),
                                            (char const   *)cptr->postfix);
#line 3969
                tmp___22 = tmp___25;
                }
              }
            } else {
              {
#line 3969
              tmp___25 = __builtin_strcmp((char const   *)((fnbuf + namelen___0) - pfxlen___0),
                                          (char const   *)cptr->postfix);
#line 3969
              tmp___22 = tmp___25;
              }
            }
#line 3969
            if (tmp___22) {
              goto __Cont;
            }
            {
#line 3971
            *((fnbuf + namelen___0) - pfxlen___0) = (char )((void *)0);
#line 3972
            tmp___27 = stat((char const   */* __restrict  */)(fnbuf), (struct stat */* __restrict  */)(& st));
            }
#line 3972
            if (tmp___27 != 0) {
              goto __Cont;
            }
          } else {
#line 3975
            if (cptr->stripfix) {
              {
#line 3976
              strcpy((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)name);
#line 3977
              strcat((char */* __restrict  */)(fnbuf), (char const   */* __restrict  */)cptr->stripfix);
#line 3978
              tmp___28 = stat((char const   */* __restrict  */)(fnbuf), (struct stat */* __restrict  */)(& st));
              }
#line 3978
              if (tmp___28 != 0) {
                goto __Cont;
              }
            } else {
              goto __Cont;
            }
          }
        }
#line 3985
        if ((st.st_mode & 61440U) == 16384U) {
#line 3986
          if (! cptr->types) {
            {
#line 3987
            reply(550, (char *)"Cannot %s directories.", cptr->name);
            }
#line 3988
            return;
          } else {
#line 3986
            if (! (cptr->types & 2)) {
              {
#line 3987
              reply(550, (char *)"Cannot %s directories.", cptr->name);
              }
#line 3988
              return;
            }
          }
#line 3990
          if (cptr->options & (1 << 2)) {
            {
#line 3991
            strcpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)(fnbuf));
#line 3992
            strcat((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)"/.notar");
#line 3993
            tmp___29 = stat((char const   */* __restrict  */)(namebuf), (struct stat */* __restrict  */)(& junk));
            }
#line 3993
            if (tmp___29 == 0) {
#line 3994
              if (log_security) {
#line 3995
                if (anonymous) {
                  {
#line 3996
                  syslog(5, "anonymous(%s) of %s tried to tar %s (.notar)", guestpw,
                         remoteident, realname);
                  }
                } else {
                  {
#line 3999
                  syslog(5, "%s of %s tried to tar %s (.notar)", pw->pw_name, remoteident,
                         realname);
                  }
                }
              }
              {
#line 4001
              reply(550, (char *)"Sorry, you may not TAR that directory.");
              }
#line 4002
              return;
            }
          }
        }
#line 4009
        if (use_accessfile) {
          {
#line 4009
          tmp___30 = checknoretrieve(fnbuf);
          }
#line 4009
          if (tmp___30) {
#line 4010
            if (log_security) {
#line 4011
              if (anonymous) {
                {
#line 4012
                syslog(5, "anonymous(%s) of %s tried to download %s (noretrieve)",
                       guestpw, remoteident, realname);
                }
              } else {
                {
#line 4015
                syslog(5, "%s of %s tried to download %s (noretrieve)", pw->pw_name,
                       remoteident, realname);
                }
              }
            }
#line 4017
            return;
          }
        }
#line 4020
        if ((st.st_mode & 61440U) == 32768U) {
#line 4020
          if (! cptr->types) {
            {
#line 4021
            reply(550, (char *)"Cannot %s plain files.", cptr->name);
            }
#line 4022
            return;
          } else {
#line 4020
            if ((cptr->types & 1) == 0) {
              {
#line 4021
              reply(550, (char *)"Cannot %s plain files.", cptr->name);
              }
#line 4022
              return;
            }
          }
        }
#line 4024
        if (((st.st_mode & 61440U) == 32768U) != 0) {
#line 4024
          if (((st.st_mode & 61440U) == 16384U) != 0) {
            {
#line 4025
            reply(550, (char *)"Cannot %s special files.", cptr->name);
            }
#line 4026
            return;
          }
        }
#line 4028
        if (! cptr->types) {
          goto _L___12;
        } else {
#line 4028
          if (! (cptr->types & 4)) {
            _L___12: 
            {
#line 4028
            tmp___31 = deny_badasciixfer(550, (char *)"");
            }
#line 4028
            if (tmp___31) {
#line 4029
              return;
            }
          }
        }
        {
#line 4031
        logname = fnbuf;
#line 4032
        options |= cptr->options;
#line 4034
        strcpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)cptr->external_cmd);
#line 4035
        tmp___33 = __builtin_strchr(namebuf, ' ');
#line 4035
        ptr = tmp___33;
        }
#line 4035
        if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 4036
          *ptr = (char )'\000';
        }
        {
#line 4037
        tmp___34 = stat((char const   */* __restrict  */)(namebuf), (struct stat */* __restrict  */)(& st));
        }
#line 4037
        if (tmp___34 != 0) {
          {
#line 4038
          syslog(3, "external command %s not found", namebuf);
#line 4040
          reply(550, (char *)"Local error: conversion program not found. Cannot %s file.",
                cptr->name);
          }
#line 4043
          return;
        }
        {
#line 4045
        retrieve(cptr->external_cmd, logname);
        }
        goto logresults;
        __Cont: 
#line 3936
        cptr = cptr->next;
      }
    }
  }
#line 4051
  if ((unsigned int )cmd == (unsigned int )((void *)0)) {
    {
#line 4052
    fin = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"r");
#line 4052
    closefunc = (int (*)())(& fclose);
#line 4053
    st.st_size = 0L;
    }
  } else {
    {
#line 4058
    snprintf((char */* __restrict  */)(line), sizeof(line), (char const   */* __restrict  */)cmd,
             name);
#line 4058
    name = line;
#line 4059
    fin = ftpd_popen(line, (char *)"r", 1);
#line 4059
    closefunc = (int (*)())(& ftpd_pclose);
#line 4060
    st.st_size = -1L;
#line 4062
    st.st_blksize = 8192L;
    }
  }
#line 4065
  if ((unsigned int )fin == (unsigned int )((void *)0)) {
    {
#line 4066
    tmp___35 = __errno_location();
    }
#line 4066
    if (*tmp___35 != 0) {
      {
#line 4067
      perror_reply(550, name);
      }
    }
    {
#line 4068
    tmp___36 = __errno_location();
    }
#line 4068
    if (*tmp___36 == 13) {
      goto _L___13;
    } else {
      {
#line 4068
      tmp___37 = __errno_location();
      }
#line 4068
      if (*tmp___37 == 1) {
        _L___13: 
#line 4069
        if (log_security) {
#line 4070
          if (anonymous) {
            {
#line 4071
            syslog(5, "anonymous(%s) of %s tried to download %s (file permissions)",
                   guestpw, remoteident, realname);
            }
          } else {
            {
#line 4074
            syslog(5, "%s of %s tried to download %s (file permissions)", pw->pw_name,
                   remoteident, realname);
            }
          }
        }
      }
    }
#line 4076
    return;
  }
#line 4078
  if ((unsigned int )cmd == (unsigned int )((void *)0)) {
    {
#line 4078
    tmp___38 = fileno(fin);
#line 4078
    tmp___39 = fstat(tmp___38, & st);
    }
#line 4078
    if (tmp___39 < 0) {
      {
#line 4080
      reply(550, (char *)"%s: not a plain file.", name);
      }
      goto done;
    } else {
#line 4078
      if ((st.st_mode & 61440U) != 32768U) {
        {
#line 4080
        reply(550, (char *)"%s: not a plain file.", name);
        }
        goto done;
      }
    }
  }
#line 4083
  if (restart_point) {
#line 4084
    if (type == 1) {
#line 4087
      n = (int )restart_point;
#line 4088
      i = 0;
#line 4089
      while (1) {
#line 4089
        tmp___40 = i;
#line 4089
        i ++;
#line 4089
        if (! (tmp___40 < n)) {
#line 4089
          break;
        }
        {
#line 4090
        c = _IO_getc(fin);
        }
#line 4090
        if (c == -1) {
          {
#line 4091
          perror_reply(550, name);
          }
          goto done;
        }
#line 4094
        if (c == 10) {
#line 4095
          i ++;
        }
      }
    } else {
      {
#line 4098
      tmp___41 = fileno(fin);
#line 4098
      tmp___42 = lseek(tmp___41, restart_point, 0);
      }
#line 4098
      if (tmp___42 < 0L) {
        {
#line 4099
        perror_reply(550, name);
        }
        goto done;
      }
    }
  }
  {
#line 4103
  dout___1 = dataconn(name, st.st_size, (char *)"w");
  }
#line 4104
  if ((unsigned int )dout___1 == (unsigned int )((void *)0)) {
    goto done;
  }
  {
#line 4115
  TransferComplete = send_data(name, fin, dout___1, st.st_blksize * 2L);
#line 4127
  fclose(dout___1);
  }
  logresults: 
#line 4130
  if (ThisRetrieveIsData) {
#line 4131
    if ((unsigned int )logname != (unsigned int )((void *)0)) {
#line 4131
      tmp___43 = logname;
    } else {
#line 4131
      tmp___43 = name;
    }
    {
#line 4131
    fb_realpath((char const   *)tmp___43, LastFileTransferred);
    }
  }
#line 4133
  if (log_outbound_xfers) {
#line 4133
    if (xferlog) {
      goto _L___14;
    } else {
#line 4133
      if (syslogmsg) {
        _L___14: 
#line 4133
        if ((unsigned int )cmd == (unsigned int )((char *)0)) {
          {
#line 4136
          tmp___44 = time((time_t *)((void *)0));
#line 4136
          xfertime = (int )(tmp___44 - start_time);
#line 4137
          tmp___45 = time((time_t *)((void *)0));
#line 4137
          curtime = tmp___45;
          }
#line 4140
          if (! xfertime) {
#line 4141
            xfertime ++;
          }
#line 4143
          if ((unsigned int )logname != (unsigned int )((void *)0)) {
#line 4143
            tmp___46 = logname;
          } else {
#line 4143
            tmp___46 = name;
          }
          {
#line 4143
          wu_realpath((char const   *)tmp___46, namebuf, chroot_path);
#line 4147
          loop = 0;
          }
#line 4147
          while (namebuf[loop]) {
            {
#line 4148
            tmp___47 = __ctype_b_loc();
            }
#line 4148
            if ((int const   )*(*tmp___47 + (int )namebuf[loop]) & 8192) {
#line 4149
              namebuf[loop] = (char )'_';
            } else {
              {
#line 4148
              tmp___48 = __ctype_b_loc();
              }
#line 4148
              if ((int const   )*(*tmp___48 + (int )namebuf[loop]) & 2) {
#line 4149
                namebuf[loop] = (char )'_';
              }
            }
#line 4147
            loop ++;
          }
          {
#line 4170
          tmp___49 = ctime((time_t const   *)(& curtime));
#line 4170
          sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%.24s %d %s %u ",
                  tmp___49, xfertime, remotehost, byte_count);
#line 4176
          msglen = strlen((char const   *)(msg));
          }
#line 4177
          if (TransferComplete) {
#line 4177
            tmp___50 = 'c';
          } else {
#line 4177
            tmp___50 = 'i';
          }
#line 4177
          if (authenticated) {
#line 4177
            tmp___51 = (char const   *)(authuser);
          } else {
#line 4177
            tmp___51 = "*";
          }
#line 4177
          if (anonymous) {
#line 4177
            tmp___52 = guestpw;
          } else {
#line 4177
            tmp___52 = pw->pw_name;
          }
#line 4177
          if (anonymous) {
#line 4177
            tmp___54 = 'a';
          } else {
#line 4177
            if (guest) {
#line 4177
              tmp___54 = 'g';
            } else {
#line 4177
              tmp___54 = 'r';
            }
          }
          {
#line 4177
          tmp___55 = opt_string(options);
          }
#line 4177
          if (type == 1) {
#line 4177
            tmp___56 = 'a';
          } else {
#line 4177
            tmp___56 = 'b';
          }
          {
#line 4177
          snprintf((char */* __restrict  */)(msg + msglen), sizeof(msg) - msglen,
                   (char const   */* __restrict  */)"%s %c %s %c %c %s ftp %d %s %c\n",
                   namebuf, tmp___56, tmp___55, 'o', tmp___54, tmp___52, authenticated,
                   tmp___51, tmp___50);
#line 4189
          tmp___57 = strlen((char const   *)(msg));
          }
#line 4189
          if (tmp___57 == sizeof(msg) - 1U) {
#line 4190
            msg[sizeof(msg) - 2U] = (char )'\n';
          }
#line 4191
          if (syslogmsg != 1) {
            {
#line 4192
            tmp___58 = strlen((char const   *)(msg));
#line 4192
            write(xferlog, (void const   *)(msg), tmp___58);
            }
          }
#line 4193
          if (syslogmsg != 0) {
            {
#line 4194
            syslog(6, "xferlog (send): %s", msg + 25);
            }
          }
        }
      }
    }
  }
#line 4196
  data = -1;
#line 4197
  pdata = -1;
  done: 
#line 4199
  if (closefunc) {
    {
#line 4200
    (*closefunc)(fin);
    }
  }
#line 4201
  return;
}
}
#line 4203 "ftpd.c"
void store(char *name , char *mode___0 , int unique ) 
{ FILE *fout ;
  FILE *din ;
  struct stat st ;
  int TransferIncomplete ;
  time_t start_time ;
  time_t tmp ;
  struct aclmember *entry ;
  int fdout ;
  char realname[4096] ;
  int overwrite ;
  int exists ;
  int open_flags ;
  mode_t oldmask ;
  uid_t uid ;
  gid_t gid ;
  uid_t oldid ;
  int f_mode ;
  int match_value ;
  int valid___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct aclmember *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  register int i ;
  register int n ;
  register int c ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  __off_t tmp___12 ;
  FILE *sck ;
  unsigned char temp ;
  unsigned char temp2 ;
  char pathname[4096] ;
  unsigned char tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char namebuf[4096] ;
  char msg[4452] ;
  size_t msglen ;
  int xfertime ;
  time_t tmp___23 ;
  time_t curtime ;
  time_t tmp___24 ;
  int loop ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  char const   *tmp___29 ;
  char *tmp___30 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;

  {
  {
#line 4207
  TransferIncomplete = 1;
#line 4209
  tmp = time((time_t *)((void *)0));
#line 4209
  start_time = tmp;
#line 4211
  entry = (struct aclmember *)((void *)0);
#line 4217
  overwrite = 1;
#line 4218
  exists = 0;
#line 4222
  open_flags = 0;
#line 4229
  f_mode = -1;
#line 4229
  match_value = -1;
#line 4230
  valid___0 = 0;
  }
#line 4231
  if ((unsigned int )mode___0 != (unsigned int )((void *)0)) {
#line 4231
    if ((int )*mode___0 == 97) {
#line 4231
      tmp___0 = 1024;
    } else {
#line 4231
      tmp___0 = 512;
    }
  } else {
#line 4231
    tmp___0 = 512;
  }
  {
#line 4231
  open_flags = 66 | tmp___0;
#line 4235
  wu_realpath((char const   *)name, realname, chroot_path);
  }
#line 4239
  if (file_limit_data_in > 0) {
#line 4239
    if (file_count_in >= file_limit_data_in) {
      goto _L;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
#line 4239
    if (file_limit_data_total > 0) {
#line 4239
      if (file_count_total >= file_limit_data_total) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 4239
      if (data_limit_data_in > 0) {
#line 4239
        if (data_count_in >= data_limit_data_in) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
#line 4239
        if (data_limit_data_total > 0) {
#line 4239
          if (data_count_total >= data_limit_data_total) {
            _L: 
#line 4243
            if (log_security) {
#line 4244
              if (anonymous) {
                {
#line 4245
                syslog(5, "anonymous(%s) of %s tried to upload %s (Transfer limits exceeded)",
                       guestpw, remoteident, realname);
                }
              } else {
                {
#line 4248
                syslog(5, "%s of %s tried to upload %s (Transfer limits exceeded)",
                       pw->pw_name, remoteident, realname);
                }
              }
            }
            {
#line 4250
            reply(553, (char *)"Permission denied on server. (Transfer limits exceeded)");
            }
#line 4251
            return;
          }
        }
      }
    }
  }
#line 4253
  if (file_limit_raw_in > 0) {
#line 4253
    if (xfer_count_in >= file_limit_raw_in) {
      goto _L___3;
    } else {
      goto _L___6;
    }
  } else {
    _L___6: 
#line 4253
    if (file_limit_raw_total > 0) {
#line 4253
      if (xfer_count_total >= file_limit_raw_total) {
        goto _L___3;
      } else {
        goto _L___5;
      }
    } else {
      _L___5: 
#line 4253
      if (data_limit_raw_in > 0) {
#line 4253
        if (byte_count_in >= data_limit_raw_in) {
          goto _L___3;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: 
#line 4253
        if (data_limit_raw_total > 0) {
#line 4253
          if (byte_count_total >= data_limit_raw_total) {
            _L___3: 
#line 4257
            if (log_security) {
#line 4258
              if (anonymous) {
                {
#line 4259
                syslog(5, "anonymous(%s) of %s tried to upload %s (Transfer limits exceeded)",
                       guestpw, remoteident, realname);
                }
              } else {
                {
#line 4262
                syslog(5, "%s of %s tried to upload %s (Transfer limits exceeded)",
                       pw->pw_name, remoteident, realname);
                }
              }
            }
            {
#line 4264
            reply(553, (char *)"Permission denied on server. (Transfer limits exceeded)");
            }
#line 4265
            return;
          }
        }
      }
    }
  }
#line 4270
  if (unique) {
    {
#line 4270
    tmp___1 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
    }
#line 4270
    if (tmp___1 == 0) {
      {
#line 4270
      name = gunique(name);
      }
#line 4270
      if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 4272
        return;
      }
    }
  }
  {
#line 4277
  tmp___2 = fn_check(name);
  }
#line 4277
  if (tmp___2 <= 0) {
#line 4278
    if (log_security) {
#line 4279
      if (anonymous) {
        {
#line 4280
        syslog(5, "anonymous(%s) of %s tried to upload \"%s\" (path-filter)", guestpw,
               remoteident, realname);
        }
      } else {
        {
#line 4283
        syslog(5, "%s of %s tried to upload \"%s\" (path-filter)", pw->pw_name, remoteident,
               realname);
        }
      }
    }
#line 4285
    return;
  }
#line 4291
  while (1) {
    {
#line 4291
    tmp___5 = getaclentry((char *)"overwrite", & entry);
    }
#line 4291
    if (tmp___5) {
#line 4291
      if (entry->arg[0]) {
#line 4291
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 4291
          break;
        }
      } else {
#line 4291
        break;
      }
    } else {
#line 4291
      break;
    }
    {
#line 4292
    tmp___4 = type_match(entry->arg[1]);
    }
#line 4292
    if (tmp___4) {
      {
#line 4293
      tmp___3 = strcasecmp((char const   *)entry->arg[0], "yes");
      }
#line 4293
      if (tmp___3 != 0) {
#line 4294
        overwrite = 0;
#line 4295
        open_flags |= 128;
      }
    }
  }
  {
#line 4302
  tmp___6 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
#line 4302
  if (! tmp___6) {
#line 4303
    exists = 1;
  }
#line 4305
  if (! overwrite) {
#line 4305
    if (exists) {
#line 4306
      if (log_security) {
#line 4307
        if (anonymous) {
          {
#line 4308
          syslog(5, "anonymous(%s) of %s tried to overwrite %s", guestpw, remoteident,
                 realname);
          }
        } else {
          {
#line 4311
          syslog(5, "%s of %s tried to overwrite %s", pw->pw_name, remoteident, realname);
          }
        }
      }
      {
#line 4313
      reply(553, (char *)"%s: Permission denied on server. (Overwrite)", name);
      }
#line 4314
      return;
    }
  }
  {
#line 4319
  match_value = upl_check(name, & uid, & gid, & f_mode, & valid___0);
  }
#line 4319
  if (match_value < 0) {
#line 4320
    if (log_security) {
#line 4321
      if (anonymous) {
        {
#line 4322
        syslog(5, "anonymous(%s) of %s tried to upload %s (upload denied)", guestpw,
               remoteident, realname);
        }
      } else {
        {
#line 4325
        syslog(5, "%s of %s tried to upload %s (upload denied)", pw->pw_name, remoteident,
               realname);
        }
      }
    }
#line 4327
    return;
  }
#line 4331
  if (restart_point) {
#line 4332
    open_flags &= -513;
  }
#line 4339
  if (f_mode >= 0) {
    {
#line 4340
    oldmask = umask(0U);
#line 4341
    fdout = open((char const   *)name, open_flags, f_mode);
#line 4342
    umask(oldmask);
    }
  } else {
    {
#line 4345
    fdout = open((char const   *)name, open_flags, 438);
    }
  }
#line 4347
  if (fdout < 0) {
#line 4348
    if (log_security) {
#line 4349
      if (anonymous) {
        {
#line 4350
        syslog(5, "anonymous(%s) of %s tried to upload %s (permissions)", guestpw,
               remoteident, realname);
        }
      } else {
        {
#line 4353
        syslog(5, "%s of %s tried to upload %s (permissions)", pw->pw_name, remoteident,
               realname);
        }
      }
    }
    {
#line 4355
    perror_reply(553, name);
    }
#line 4356
    return;
  }
#line 4361
  if (! exists) {
#line 4363
    if (valid___0 > 0) {
      {
#line 4364
      oldid = geteuid();
      }
#line 4365
      if (uid != 0U) {
        {
#line 4366
        seteuid(uid);
        }
      }
#line 4367
      if (uid == 0U) {
        goto _L___7;
      } else {
        {
#line 4367
        tmp___8 = fchown(fdout, uid, gid);
        }
#line 4367
        if (tmp___8 < 0) {
          _L___7: 
          {
#line 4368
          delay_signaling();
#line 4369
          seteuid(0U);
#line 4370
          tmp___7 = fchown(fdout, uid, gid);
          }
#line 4370
          if (tmp___7 < 0) {
            {
#line 4371
            seteuid(oldid);
#line 4372
            enable_signaling();
#line 4373
            perror_reply(550, (char *)"fchown");
            }
#line 4374
            return;
          }
          {
#line 4376
          seteuid(oldid);
#line 4377
          enable_signaling();
          }
        } else {
          {
#line 4380
          seteuid(oldid);
          }
        }
      }
    }
  }
#line 4384
  if (restart_point) {
#line 4384
    if ((open_flags & 1024) == 0) {
#line 4385
      mode___0 = (char *)"r+";
    }
  }
  {
#line 4388
  fout = fdopen(fdout, (char const   *)mode___0);
  }
#line 4393
  if ((unsigned int )fout == (unsigned int )((void *)0)) {
#line 4394
    if (log_security) {
#line 4395
      if (anonymous) {
        {
#line 4396
        syslog(5, "anonymous(%s) of %s tried to upload %s (permissions)", guestpw,
               remoteident, realname);
        }
      } else {
        {
#line 4399
        syslog(5, "%s of %s tried to upload %s (permissions)", pw->pw_name, remoteident,
               realname);
        }
      }
    }
    {
#line 4401
    perror_reply(553, name);
    }
#line 4402
    return;
  }
#line 4404
  if (restart_point) {
#line 4405
    if (type == 1) {
#line 4408
      n = (int )restart_point;
#line 4409
      i = 0;
#line 4410
      while (1) {
#line 4410
        tmp___9 = i;
#line 4410
        i ++;
#line 4410
        if (! (tmp___9 < n)) {
#line 4410
          break;
        }
        {
#line 4411
        c = _IO_getc(fout);
        }
#line 4411
        if (c == -1) {
          {
#line 4412
          perror_reply(550, name);
          }
          goto done;
        }
#line 4415
        if (c == 10) {
#line 4416
          i ++;
        }
      }
      {
#line 4420
      tmp___10 = fseek(fout, 0L, 1);
      }
#line 4420
      if (tmp___10 < 0) {
        {
#line 4421
        perror_reply(550, name);
        }
        goto done;
      }
    } else {
      {
#line 4425
      tmp___11 = fileno(fout);
#line 4425
      tmp___12 = lseek(tmp___11, restart_point, 0);
      }
#line 4425
      if (tmp___12 < 0L) {
        {
#line 4426
        perror_reply(550, name);
        }
        goto done;
      }
    }
  }
  {
#line 4430
  din = dataconn(name, -1L, (char *)"r");
  }
#line 4431
  if ((unsigned int )din == (unsigned int )((void *)0)) {
    goto done;
  }
  {
#line 4433
  TransferIncomplete = receive_data(din, fout);
#line 4434
  fclose(din);
  }
#line 4435
  if (TransferIncomplete == 0) {
#line 4436
    if (unique) {
      {
#line 4437
      reply(226, (char *)"Transfer complete (unique file name:%s).", name);
      }
    } else {
      {
#line 4439
      reply(226, (char *)"Transfer complete.");
      }
    }
  }
  {
#line 4442
  fb_realpath((char const   *)name, LastFileTransferred);
  }
#line 4445
  if (anonymous) {
#line 4445
    if (incmails > 0) {
#line 4446
      sck = (FILE *)((void *)0);
#line 4448
      temp = (unsigned char)0;
#line 4448
      temp2 = (unsigned char)0;
#line 4450
      while (1) {
#line 4450
        if ((int )temp < mailservers) {
#line 4450
          if (! ((unsigned int )sck == (unsigned int )((void *)0))) {
#line 4450
            break;
          }
        } else {
#line 4450
          break;
        }
        {
#line 4451
        tmp___13 = temp;
#line 4451
        temp = (unsigned char )((int )temp + 1);
#line 4451
        sck = SockOpen(mailserver[tmp___13], 25);
        }
      }
#line 4452
      if ((unsigned int )sck == (unsigned int )((void *)0)) {
        {
#line 4453
        syslog(3, "Can\'t connect to a mailserver.");
        }
        goto mailfail;
      }
      {
#line 4456
      tmp___14 = Reply(sck);
      }
#line 4456
      if (tmp___14 != 220) {
        {
#line 4457
        syslog(3, "Mailserver failed to initiate contact.");
        }
        goto mailfail;
      }
      {
#line 4460
      tmp___15 = Send(sck, (char *)"HELO localhost\r\n");
      }
#line 4460
      if (tmp___15 != 250) {
        {
#line 4461
        syslog(3, "Mailserver doesn\'t understand HELO.");
        }
        goto mailfail;
      }
      {
#line 4464
      tmp___16 = email(mailfrom);
#line 4464
      tmp___17 = Send(sck, (char *)"MAIL FROM: <%s>\r\n", tmp___16);
      }
#line 4464
      if (tmp___17 != 250) {
        {
#line 4465
        syslog(3, "Mailserver didn\'t accept MAIL FROM.");
        }
        goto mailfail;
      }
#line 4468
      temp = (unsigned char)0;
#line 4468
      while ((int )temp < incmails) {
        {
#line 4469
        tmp___18 = email(incmail[temp]);
#line 4469
        tmp___19 = Send(sck, (char *)"RCPT TO: <%s>\r\n", tmp___18);
        }
#line 4469
        if (tmp___19 == 250) {
#line 4470
          temp2 = (unsigned char )((int )temp2 + 1);
        }
#line 4468
        temp = (unsigned char )((int )temp + 1);
      }
#line 4472
      if ((int )temp2 == 0) {
        {
#line 4473
        syslog(3, "Mailserver didn\'t accept any RCPT TO.");
        }
        goto mailfail;
      }
      {
#line 4476
      tmp___20 = Send(sck, (char *)"DATA\r\n");
      }
#line 4476
      if (tmp___20 != 354) {
        {
#line 4477
        syslog(3, "Mailserver didn\'t accept DATA.");
        }
        goto mailfail;
      }
      {
#line 4480
      SockPrintf(sck, (char *)"From: wu-ftpd <%s>\r\n", mailfrom);
#line 4481
      SockPrintf(sck, (char *)"Subject: New file uploaded: %s\r\n\r\n", name);
#line 4482
      fb_realpath((char const   *)name, pathname);
#line 4483
      SockPrintf(sck, (char *)"%s uploaded %s from %s.\r\nFile size is %d.\r\nPlease move the file where it belongs.\r\n",
                 guestpw, pathname, remotehost, byte_count);
#line 4484
      tmp___21 = Send(sck, (char *)".\r\n");
      }
#line 4484
      if (tmp___21 != 250) {
        {
#line 4485
        syslog(3, "Message rejected by mailserver.");
        }
      }
      {
#line 4486
      tmp___22 = Send(sck, (char *)"QUIT\r\n");
      }
#line 4486
      if (tmp___22 != 221) {
        {
#line 4487
        syslog(3, "Mailserver didn\'t accept QUIT.");
        }
      }
      goto mailok;
      mailfail: 
#line 4490
      if ((unsigned int )sck != (unsigned int )((void *)0)) {
        {
#line 4491
        fclose(sck);
        }
      }
      mailok: 
#line 4493
      sck = (FILE *)((void *)0);
    }
  }
#line 4498
  if (log_incoming_xfers) {
#line 4498
    if (xferlog) {
      goto _L___8;
    } else {
#line 4498
      if (syslogmsg) {
        _L___8: 
        {
#line 4501
        tmp___23 = time((time_t *)((void *)0));
#line 4501
        xfertime = (int )(tmp___23 - start_time);
#line 4502
        tmp___24 = time((time_t *)((void *)0));
#line 4502
        curtime = tmp___24;
        }
#line 4505
        if (! xfertime) {
#line 4506
          xfertime ++;
        }
        {
#line 4508
        wu_realpath((char const   *)name, namebuf, chroot_path);
#line 4512
        loop = 0;
        }
#line 4512
        while (namebuf[loop]) {
          {
#line 4513
          tmp___25 = __ctype_b_loc();
          }
#line 4513
          if ((int const   )*(*tmp___25 + (int )namebuf[loop]) & 8192) {
#line 4514
            namebuf[loop] = (char )'_';
          } else {
            {
#line 4513
            tmp___26 = __ctype_b_loc();
            }
#line 4513
            if ((int const   )*(*tmp___26 + (int )namebuf[loop]) & 2) {
#line 4514
              namebuf[loop] = (char )'_';
            }
          }
#line 4512
          loop ++;
        }
        {
#line 4517
        tmp___27 = ctime((time_t const   *)(& curtime));
#line 4517
        sprintf((char */* __restrict  */)(msg), (char const   */* __restrict  */)"%.24s %d %s %u ",
                tmp___27, xfertime, remotehost, byte_count);
#line 4523
        msglen = strlen((char const   *)(msg));
        }
#line 4524
        if (TransferIncomplete) {
#line 4524
          tmp___28 = 'i';
        } else {
#line 4524
          tmp___28 = 'c';
        }
#line 4524
        if (authenticated) {
#line 4524
          tmp___29 = (char const   *)(authuser);
        } else {
#line 4524
          tmp___29 = "*";
        }
#line 4524
        if (anonymous) {
#line 4524
          tmp___30 = guestpw;
        } else {
#line 4524
          tmp___30 = pw->pw_name;
        }
#line 4524
        if (anonymous) {
#line 4524
          tmp___32 = 'a';
        } else {
#line 4524
          if (guest) {
#line 4524
            tmp___32 = 'g';
          } else {
#line 4524
            tmp___32 = 'r';
          }
        }
        {
#line 4524
        tmp___33 = opt_string(0);
        }
#line 4524
        if (type == 1) {
#line 4524
          tmp___34 = 'a';
        } else {
#line 4524
          tmp___34 = 'b';
        }
        {
#line 4524
        snprintf((char */* __restrict  */)(msg + msglen), sizeof(msg) - msglen, (char const   */* __restrict  */)"%s %c %s %c %c %s ftp %d %s %c\n",
                 namebuf, tmp___34, tmp___33, 'i', tmp___32, tmp___30, authenticated,
                 tmp___29, tmp___28);
#line 4536
        tmp___35 = strlen((char const   *)(msg));
        }
#line 4536
        if (tmp___35 == sizeof(msg) - 1U) {
#line 4537
          msg[sizeof(msg) - 2U] = (char )'\n';
        }
#line 4538
        if (syslogmsg != 1) {
          {
#line 4539
          tmp___36 = strlen((char const   *)(msg));
#line 4539
          write(xferlog, (void const   *)(msg), tmp___36);
          }
        }
#line 4540
        if (syslogmsg != 0) {
          {
#line 4541
          syslog(6, "xferlog (recv): %s", msg + 25);
          }
        }
      }
    }
  }
#line 4543
  data = -1;
#line 4544
  pdata = -1;
  done: 
  {
#line 4546
  fclose(fout);
  }
#line 4547
  return;
}
}
#line 4549 "ftpd.c"
FILE *getdatasock(char *mode___0 ) 
{ int s ;
  int on ;
  int tries ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  FILE *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 4551
  on = 1;
#line 4553
  if (data >= 0) {
    {
#line 4554
    tmp = fdopen(data, (char const   *)mode___0);
    }
#line 4554
    return (tmp);
  }
  {
#line 4555
  delay_signaling();
#line 4556
  seteuid(0U);
#line 4557
  s = socket(2, 1, 0);
  }
#line 4558
  if (s < 0) {
    goto bad;
  }
  {
#line 4560
  tmp___0 = setsockopt(s, 1, 2, (void const   *)((char *)(& on)), sizeof(on));
  }
#line 4560
  if (tmp___0 < 0) {
    goto bad;
  }
#line 4563
  if (keepalive) {
    {
#line 4564
    setsockopt(s, 1, 9, (void const   *)((char *)(& on)), sizeof(on));
    }
  }
#line 4565
  if (TCPwindowsize) {
#line 4566
    if ((int )*mode___0 == 119) {
#line 4566
      tmp___1 = 7;
    } else {
#line 4566
      tmp___1 = 8;
    }
    {
#line 4566
    setsockopt(s, 1, tmp___1, (void const   *)((char *)(& TCPwindowsize)), sizeof(TCPwindowsize));
    }
  }
#line 4569
  data_source.sin_family = (unsigned short)2;
#line 4570
  data_source.sin_addr = ctrl_addr.sin_addr;
#line 4575
  tries = 1;
#line 4575
  while (1) {
    {
#line 4576
    tmp___2 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& data_source)),
                   sizeof(data_source));
    }
#line 4576
    if (tmp___2 >= 0) {
#line 4578
      break;
    }
    {
#line 4579
    tmp___3 = __errno_location();
    }
#line 4579
    if (*tmp___3 != 98) {
      goto bad;
    } else {
#line 4579
      if (tries > 10) {
        goto bad;
      }
    }
    {
#line 4581
    sleep((unsigned int )tries);
#line 4575
    tries ++;
    }
  }
  {
#line 4595
  seteuid(pw->pw_uid);
#line 4596
  enable_signaling();
#line 4599
  on = 8;
#line 4600
  tmp___4 = setsockopt(s, 0, 1, (void const   *)((char *)(& on)), sizeof(int ));
  }
#line 4600
  if (tmp___4 < 0) {
    {
#line 4601
    syslog(4, "setsockopt (IP_TOS): %m");
    }
  }
  {
#line 4615
  tmp___5 = fdopen(s, (char const   *)mode___0);
  }
#line 4615
  return (tmp___5);
  bad: 
  {
#line 4617
  tmp___6 = __errno_location();
#line 4617
  on = *tmp___6;
#line 4618
  seteuid(pw->pw_uid);
#line 4619
  enable_signaling();
  }
#line 4620
  if (s != -1) {
    {
#line 4621
    close(s);
    }
  }
  {
#line 4622
  tmp___7 = __errno_location();
#line 4622
  *tmp___7 = on;
  }
#line 4623
  return ((FILE *)((void *)0));
}
}
#line 4626 "ftpd.c"
FILE *dataconn(char *name , off_t size , char *mode___0 ) 
{ char sizebuf[32] ;
  FILE *file ;
  int retry ;
  int on ;
  int tos ;
  int bps ;
  double bpsmult ;
  struct sockaddr_in from ;
  char dataaddr[64] ;
  int fromlen ;
  int s ;
  int rv ;
  int tmp ;
  struct timeval timeout ;
  fd_set set ;
  int __d0 ;
  int __d1 ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  FILE *tmp___7 ;
  FILE *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;

  {
#line 4630
  retry = 0;
#line 4631
  on = 1;
#line 4640
  file_size = size;
#line 4641
  byte_count = 0L;
#line 4642
  if (size != -1L) {
    {
#line 4643
    sprintf((char */* __restrict  */)(sizebuf), (char const   */* __restrict  */)" (%u bytes)",
            size);
    }
  } else {
    {
#line 4645
    strcpy((char */* __restrict  */)(sizebuf), (char const   */* __restrict  */)"");
    }
  }
#line 4646
  if (pdata >= 0) {
#line 4652
    fromlen = (int )sizeof(from);
#line 4659
    if (keepalive) {
      {
#line 4660
      setsockopt(pdata, 1, 9, (void const   *)((char *)(& on)), sizeof(on));
      }
    }
#line 4661
    if (TCPwindowsize) {
#line 4662
      if ((int )*mode___0 == 119) {
#line 4662
        tmp = 7;
      } else {
#line 4662
        tmp = 8;
      }
      {
#line 4662
      setsockopt(pdata, 1, tmp, (void const   *)((char *)(& TCPwindowsize)), sizeof(TCPwindowsize));
      }
    }
#line 4665
    while (1) {
#line 4669
      while (1) {
#line 4669
        __asm__  volatile   ("cld; rep; stosl": "=c" (__d0), "=D" (__d1): "a" (0),
                             "0" (sizeof(fd_set ) / sizeof(__fd_mask )), "1" (& set.__fds_bits[0]): "memory");
#line 4669
        break;
      }
      {
#line 4670
      __asm__  volatile   ("btsl %1,%0": "=m" (set.__fds_bits[(unsigned int )pdata / (8U * sizeof(__fd_mask ))]): "r" ((unsigned int )pdata % (8U * sizeof(__fd_mask ))): "cc",
                           "memory");
#line 4672
      timeout.tv_usec = 0L;
#line 4673
      timeout.tv_sec = (long )timeout_accept;
#line 4677
      rv = select(pdata + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((fd_set *)0),
                  (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)(& timeout));
      }
#line 4665
      if (rv == -1) {
        {
#line 4665
        tmp___0 = __errno_location();
        }
#line 4665
        if (! (*tmp___0 == 4)) {
#line 4665
          break;
        }
      } else {
#line 4665
        break;
      }
    }
#line 4681
    if (rv != -1) {
#line 4681
      if (rv != 0) {
        {
#line 4682
        s = accept(pdata, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& from)),
                   (socklen_t */* __restrict  */)(& fromlen));
        }
      } else {
#line 4684
        s = -1;
      }
    } else {
#line 4684
      s = -1;
    }
#line 4691
    if (s == -1) {
      {
#line 4692
      reply(425, (char *)"Can\'t open data connection.");
#line 4693
      close(pdata);
#line 4694
      pdata = -1;
      }
#line 4695
      return ((FILE *)((void *)0));
    }
    {
#line 4697
    close(pdata);
#line 4698
    pdata = s;
#line 4700
    tos = 16;
#line 4701
    setsockopt(s, 0, 1, (void const   *)((char *)(& tos)), sizeof(int ));
#line 4705
    tmp___1 = inet_ntoa(from.sin_addr);
#line 4705
    __builtin_strncpy(dataaddr, (char const   *)tmp___1, sizeof(dataaddr));
#line 4706
    tmp___4 = pasv_allowed(dataaddr);
    }
#line 4706
    if (! tmp___4) {
      {
#line 4707
      tmp___3 = strcasecmp((char const   *)(dataaddr), (char const   *)(remoteaddr));
      }
#line 4707
      if (tmp___3 != 0) {
#line 4713
        if (anonymous) {
#line 4713
          tmp___2 = guestpw;
        } else {
#line 4713
          tmp___2 = pw->pw_name;
        }
        {
#line 4713
        syslog(3, "%s of %s: data connect from %s for %s%s", tmp___2, remoteident,
               dataaddr, name, sizebuf);
#line 4716
        reply(425, (char *)"Possible PASV port theft, cannot open data connection.");
#line 4717
        close(pdata);
#line 4718
        pdata = -1;
        }
#line 4719
        return ((FILE *)((void *)0));
      }
    }
    {
#line 4727
    throughput_calc(name, & bps, & bpsmult);
    }
#line 4728
    if (bps != -1) {
#line 4729
      if (type == 1) {
#line 4729
        tmp___5 = "ASCII";
      } else {
#line 4729
        tmp___5 = "BINARY";
      }
      {
#line 4729
      lreply(150, (char *)"Opening %s mode data connection for %s%s.", tmp___5, name,
             sizebuf);
#line 4731
      reply(150, (char *)"Restricting network throughput to %d bytes/s.", bps);
      }
    } else {
#line 4735
      if (type == 1) {
#line 4735
        tmp___6 = "ASCII";
      } else {
#line 4735
        tmp___6 = "BINARY";
      }
      {
#line 4735
      reply(150, (char *)"Opening %s mode data connection for %s%s.", tmp___6, name,
            sizebuf);
      }
    }
    {
#line 4737
    tmp___7 = fdopen(pdata, (char const   *)mode___0);
    }
#line 4737
    return (tmp___7);
  }
#line 4739
  if (data >= 0) {
    {
#line 4740
    reply(125, (char *)"Using existing data connection for %s%s.", name, sizebuf);
#line 4742
    usedefault = 1;
#line 4743
    tmp___8 = fdopen(data, (char const   *)mode___0);
    }
#line 4743
    return (tmp___8);
  }
#line 4745
  if (usedefault) {
#line 4746
    data_dest = his_addr;
  }
#line 4747
  if ((int )data_dest.sin_port == 0) {
    {
#line 4748
    reply(500, (char *)"Can\'t build data connection: no PORT specified");
    }
#line 4749
    return ((FILE *)((void *)0));
  }
  {
#line 4751
  usedefault = 1;
#line 4752
  file = getdatasock(mode___0);
  }
#line 4753
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    {
#line 4754
    tmp___9 = __errno_location();
#line 4754
    tmp___10 = strerror(*tmp___9);
#line 4756
    __x = data_source.sin_port;
#line 4756
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 4756
    tmp___11 = inet_ntoa(data_source.sin_addr);
#line 4756
    reply(425, (char *)"Can\'t create data socket (%s,%d): %s.", tmp___11, __v, tmp___10);
    }
#line 4757
    return ((FILE *)((void *)0));
  }
  {
#line 4759
  data = fileno(file);
#line 4760
  signal(14, & alarm_signal);
#line 4761
  alarm(timeout_connect);
  }
#line 4762
  while (1) {
    {
#line 4762
    tmp___14 = connect(data, (struct sockaddr  const  *)((struct sockaddr *)(& data_dest)),
                       sizeof(data_dest));
    }
#line 4762
    if (! (tmp___14 < 0)) {
#line 4762
      break;
    }
    {
#line 4764
    alarm(0U);
#line 4765
    tmp___12 = __errno_location();
    }
#line 4765
    if (*tmp___12 == 98) {
      goto _L;
    } else {
      {
#line 4765
      tmp___13 = __errno_location();
      }
#line 4765
      if (*tmp___13 == 4) {
        _L: 
#line 4765
        if (retry < swaitmax) {
          {
#line 4766
          sleep((unsigned int )swaitint);
#line 4767
          retry += swaitint;
#line 4768
          signal(14, & alarm_signal);
#line 4769
          alarm(timeout_connect);
          }
#line 4770
          continue;
        }
      }
    }
    {
#line 4772
    perror_reply(425, (char *)"Can\'t build data connection");
#line 4773
    fclose(file);
#line 4774
    data = -1;
    }
#line 4775
    return ((FILE *)((void *)0));
  }
  {
#line 4777
  alarm(0U);
  }
#line 4778
  if (keepalive) {
    {
#line 4779
    setsockopt(pdata, 1, 9, (void const   *)((char *)(& on)), sizeof(on));
    }
  }
#line 4780
  if (TCPwindowsize) {
#line 4781
    if ((int )*mode___0 == 119) {
#line 4781
      tmp___15 = 7;
    } else {
#line 4781
      tmp___15 = 8;
    }
    {
#line 4781
    setsockopt(data, 1, tmp___15, (void const   *)((char *)(& TCPwindowsize)), sizeof(TCPwindowsize));
    }
  }
  {
#line 4784
  throughput_calc(name, & bps, & bpsmult);
  }
#line 4785
  if (bps != -1) {
#line 4786
    if (type == 1) {
#line 4786
      tmp___16 = "ASCII";
    } else {
#line 4786
      tmp___16 = "BINARY";
    }
    {
#line 4786
    lreply(150, (char *)"Opening %s mode data connection for %s%s.", tmp___16, name,
           sizebuf);
#line 4788
    reply(150, (char *)"Restricting network throughput to %d bytes/s.", bps);
    }
  } else {
#line 4792
    if (type == 1) {
#line 4792
      tmp___17 = "ASCII";
    } else {
#line 4792
      tmp___17 = "BINARY";
    }
    {
#line 4792
    reply(150, (char *)"Opening %s mode data connection for %s%s.", tmp___17, name,
          sizebuf);
    }
  }
#line 4794
  return (file);
}
}
#line 4810 "ftpd.c"
static char *buf___0  ;
#line 4802 "ftpd.c"
int send_data(char *name , FILE *instr , FILE *outstr , off_t blksize ) 
{ register int c ;
  register int cnt ;
  int netfd ;
  int filefd ;
  int bps ;
  double bpsmult ;
  time_t t1 ;
  time_t t2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  ssize_t tmp___4 ;

  {
  {
#line 4809
  cnt = 0;
#line 4819
  throughput_calc(name, & bps, & bpsmult);
#line 4822
  buf___0 = (char *)((void *)0);
#line 4823
  tmp = __sigsetjmp(urgcatch, 1);
  }
#line 4823
  if (tmp) {
    {
#line 4824
    draconian_FILE = (FILE *)((void *)0);
#line 4825
    alarm(0U);
#line 4826
    transflag = 0;
    }
#line 4827
    if (buf___0) {
      {
#line 4828
      free((void *)buf___0);
      }
    }
#line 4829
    retrieve_is_data = 1;
#line 4830
    return (0);
  }
#line 4832
  transflag ++;
#line 4833
  switch (type) {
  case 1: 
  {
#line 4836
  draconian_FILE = outstr;
#line 4837
  signal(14, & draconian_alarm_signal);
#line 4838
  alarm(timeout_data);
  }
#line 4839
  while (1) {
#line 4839
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 4839
      c = _IO_getc(instr);
      }
#line 4839
      if (! (c != -1)) {
#line 4839
        break;
      }
    } else {
#line 4839
      break;
    }
#line 4840
    byte_count ++;
#line 4840
    if (byte_count % 4096L == 0L) {
      {
#line 4841
      signal(14, & draconian_alarm_signal);
#line 4842
      alarm(timeout_data);
      }
    }
#line 4844
    if (c == 10) {
      {
#line 4845
      tmp___0 = ferror(outstr);
      }
#line 4845
      if (tmp___0) {
        goto data_err;
      }
      {
#line 4847
      _IO_putc('\r', outstr);
      }
#line 4849
      if (retrieve_is_data) {
#line 4850
        data_count_total ++;
#line 4851
        data_count_out ++;
      }
#line 4853
      byte_count_total ++;
#line 4854
      byte_count_out ++;
    }
    {
#line 4857
    _IO_putc(c, outstr);
    }
#line 4859
    if (retrieve_is_data) {
#line 4860
      data_count_total ++;
#line 4861
      data_count_out ++;
    }
#line 4863
    byte_count_total ++;
#line 4864
    byte_count_out ++;
  }
#line 4867
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 4868
    signal(14, & draconian_alarm_signal);
#line 4869
    alarm(timeout_data);
#line 4870
    fflush(outstr);
    }
  }
#line 4872
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 4873
    signal(14, & draconian_alarm_signal);
#line 4874
    alarm(timeout_data);
#line 4875
    socket_flush_wait(outstr);
    }
  }
  {
#line 4877
  transflag = 0;
#line 4878
  tmp___1 = ferror(instr);
  }
#line 4878
  if (tmp___1) {
    goto file_err;
  }
#line 4880
  if ((unsigned int )draconian_FILE == (unsigned int )((void *)0)) {
    goto data_err;
  } else {
    {
#line 4880
    tmp___2 = ferror(outstr);
    }
#line 4880
    if (tmp___2) {
      goto data_err;
    }
  }
  {
#line 4882
  draconian_FILE = (FILE *)((void *)0);
#line 4883
  alarm(0U);
#line 4884
  reply(226, (char *)"Transfer complete.");
  }
#line 4886
  if (retrieve_is_data) {
#line 4887
    file_count_total ++;
#line 4888
    file_count_out ++;
  }
#line 4890
  xfer_count_total ++;
#line 4891
  xfer_count_out ++;
#line 4893
  retrieve_is_data = 1;
#line 4894
  return (1);
  case 3: 
  case 4: 
#line 4899
  if (bps != -1) {
#line 4900
    blksize = (long )bps;
  }
  {
#line 4902
  tmp___3 = malloc((unsigned int )blksize);
#line 4902
  buf___0 = (char *)tmp___3;
  }
#line 4902
  if ((unsigned int )buf___0 == (unsigned int )((void *)0)) {
    {
#line 4903
    transflag = 0;
#line 4904
    perror_reply(451, (char *)"Local resource failure: malloc");
#line 4905
    retrieve_is_data = 1;
    }
#line 4906
    return (0);
  }
  {
#line 4908
  netfd = fileno(outstr);
#line 4909
  filefd = fileno(instr);
#line 4910
  draconian_FILE = outstr;
#line 4911
  signal(14, & draconian_alarm_signal);
#line 4912
  alarm(timeout_data);
  }
#line 4914
  if (bps != -1) {
    {
#line 4915
    t1 = time((time_t *)((void *)0));
    }
  }
#line 4917
  while (1) {
#line 4917
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 4917
      cnt = read(filefd, (void *)buf___0, (unsigned int )blksize);
      }
#line 4917
      if (cnt > 0) {
        {
#line 4917
        tmp___4 = write(netfd, (void const   *)buf___0, (unsigned int )cnt);
        }
#line 4917
        if (! (tmp___4 == cnt)) {
#line 4917
          break;
        }
      } else {
#line 4917
        break;
      }
    } else {
#line 4917
      break;
    }
    {
#line 4918
    signal(14, & draconian_alarm_signal);
#line 4919
    alarm(timeout_data);
#line 4920
    byte_count += (long )cnt;
    }
#line 4922
    if (retrieve_is_data) {
#line 4923
      data_count_total += cnt;
#line 4924
      data_count_out += cnt;
    }
#line 4926
    byte_count_total += cnt;
#line 4927
    byte_count_out += cnt;
#line 4930
    if (bps != -1) {
      {
#line 4931
      t2 = time((time_t *)((void *)0));
      }
#line 4932
      if (t2 == t1) {
        {
#line 4933
        sleep(1U);
        }
      }
      {
#line 4934
      t1 = time((time_t *)((void *)0));
      }
    }
  }
#line 4939
  if (bps != -1) {
    {
#line 4940
    throughput_adjust(name);
    }
  }
  {
#line 4942
  transflag = 0;
#line 4943
  free((void *)buf___0);
  }
#line 4944
  if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
    {
#line 4945
    signal(14, & draconian_alarm_signal);
#line 4946
    alarm(timeout_data);
#line 4947
    socket_flush_wait(outstr);
    }
  }
#line 4949
  if (cnt != 0) {
#line 4950
    if (cnt < 0) {
      goto file_err;
    }
    goto data_err;
  }
#line 4954
  if ((unsigned int )draconian_FILE == (unsigned int )((void *)0)) {
    goto data_err;
  }
  {
#line 4956
  draconian_FILE = (FILE *)((void *)0);
#line 4957
  alarm(0U);
#line 4958
  reply(226, (char *)"Transfer complete.");
  }
#line 4960
  if (retrieve_is_data) {
#line 4961
    file_count_total ++;
#line 4962
    file_count_out ++;
  }
#line 4964
  xfer_count_total ++;
#line 4965
  xfer_count_out ++;
#line 4967
  retrieve_is_data = 1;
#line 4968
  return (1);
  default: 
  {
#line 4970
  transflag = 0;
#line 4971
  reply(550, (char *)"Unimplemented TYPE %d in send_data", type);
#line 4972
  retrieve_is_data = 1;
  }
#line 4973
  return (0);
  }
  data_err: 
  {
#line 4977
  draconian_FILE = (FILE *)((void *)0);
#line 4978
  alarm(0U);
#line 4979
  transflag = 0;
#line 4980
  perror_reply(426, (char *)"Data connection");
#line 4981
  retrieve_is_data = 1;
  }
#line 4982
  return (0);
  file_err: 
  {
#line 4985
  draconian_FILE = (FILE *)((void *)0);
#line 4986
  alarm(0U);
#line 4987
  transflag = 0;
#line 4988
  perror_reply(551, (char *)"Error on input file");
#line 4989
  retrieve_is_data = 1;
  }
#line 4990
  return (0);
}
}
#line 5002 "ftpd.c"
static char *buf___1  ;
#line 4998 "ftpd.c"
int receive_data(FILE *instr , FILE *outstr ) 
{ register int c ;
  int cnt ;
  int bare_lfs ;
  int netfd ;
  int filefd ;
  size_t buffer_size ;
  int tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 5001
  cnt = 0;
#line 5001
  bare_lfs = 0;
#line 5007
  buffer_size = 8192U;
#line 5010
  buf___1 = (char *)((void *)0);
#line 5011
  tmp = __sigsetjmp(urgcatch, 1);
  }
#line 5011
  if (tmp) {
    {
#line 5012
    alarm(0U);
#line 5013
    transflag = 0;
    }
#line 5014
    if (buf___1) {
      {
#line 5015
      free((void *)buf___1);
      }
    }
#line 5016
    return (-1);
  }
#line 5018
  transflag ++;
#line 5019
  switch (type) {
  case 3: 
  case 4: 
  {
#line 5023
  tmp___0 = malloc(buffer_size);
#line 5023
  buf___1 = (char *)tmp___0;
  }
#line 5023
  if ((unsigned int )buf___1 == (unsigned int )((void *)0)) {
    {
#line 5024
    transflag = 0;
#line 5025
    perror_reply(451, (char *)"Local resource failure: malloc");
    }
#line 5026
    return (-1);
  }
  {
#line 5028
  netfd = fileno(instr);
#line 5029
  filefd = fileno(outstr);
#line 5030
  draconian_FILE = instr;
#line 5031
  signal(14, & draconian_alarm_signal);
#line 5032
  alarm(timeout_data);
  }
#line 5033
  while (1) {
#line 5033
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 5033
      cnt = read(netfd, (void *)buf___1, buffer_size);
      }
#line 5033
      if (cnt > 0) {
        {
#line 5033
        tmp___1 = write(filefd, (void const   *)buf___1, (unsigned int )cnt);
        }
#line 5033
        if (! (tmp___1 == cnt)) {
#line 5033
          break;
        }
      } else {
#line 5033
        break;
      }
    } else {
#line 5033
      break;
    }
    {
#line 5034
    byte_count += (long )cnt;
#line 5036
    data_count_total += cnt;
#line 5037
    data_count_in += cnt;
#line 5038
    byte_count_total += cnt;
#line 5039
    byte_count_in += cnt;
#line 5041
    signal(14, & draconian_alarm_signal);
#line 5042
    alarm(timeout_data);
    }
  }
  {
#line 5044
  transflag = 0;
#line 5045
  free((void *)buf___1);
  }
#line 5046
  if (cnt != 0) {
#line 5047
    if (cnt < 0) {
      goto data_err;
    }
    goto file_err;
  }
#line 5051
  if ((unsigned int )draconian_FILE == (unsigned int )((void *)0)) {
    goto data_err;
  }
  {
#line 5053
  draconian_FILE = (FILE *)((void *)0);
#line 5054
  alarm(0U);
#line 5056
  file_count_total ++;
#line 5057
  file_count_in ++;
#line 5058
  xfer_count_total ++;
#line 5059
  xfer_count_in ++;
  }
#line 5061
  return (0);
  case 2: 
  {
#line 5064
  reply(553, (char *)"TYPE E not implemented.");
#line 5065
  transflag = 0;
  }
#line 5066
  return (-1);
  case 1: 
  {
#line 5069
  draconian_FILE = instr;
#line 5070
  signal(14, & draconian_alarm_signal);
#line 5071
  alarm(timeout_data);
  }
#line 5072
  while (1) {
#line 5072
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 5072
      c = _IO_getc(instr);
      }
#line 5072
      if (! (c != -1)) {
#line 5072
        break;
      }
    } else {
#line 5072
      break;
    }
#line 5073
    byte_count ++;
#line 5073
    if (byte_count % 4096L == 0L) {
      {
#line 5074
      signal(14, & draconian_alarm_signal);
#line 5075
      alarm(timeout_data);
      }
    }
#line 5077
    if (c == 10) {
#line 5078
      bare_lfs ++;
    }
#line 5079
    while (c == 13) {
      {
#line 5080
      tmp___2 = ferror(outstr);
      }
#line 5080
      if (tmp___2) {
        goto file_err;
      }
      {
#line 5082
      signal(14, & draconian_alarm_signal);
#line 5083
      alarm(timeout_data);
      }
#line 5084
      if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
        {
#line 5084
        c = _IO_getc(instr);
        }
#line 5084
        if (c != 10) {
          {
#line 5085
          _IO_putc('\r', outstr);
#line 5087
          data_count_total ++;
#line 5088
          data_count_in ++;
#line 5089
          byte_count_total ++;
#line 5090
          byte_count_in ++;
          }
#line 5092
          if (c == -1) {
            goto contin2;
          }
#line 5094
          byte_count ++;
#line 5094
          if (byte_count % 4096L == 0L) {
            {
#line 5095
            signal(14, & draconian_alarm_signal);
#line 5096
            alarm(timeout_data);
            }
          }
        }
      }
    }
    {
#line 5100
    _IO_putc(c, outstr);
#line 5102
    data_count_total ++;
#line 5103
    data_count_in ++;
#line 5104
    byte_count_total ++;
#line 5105
    byte_count_in ++;
    }
    contin2: ;
  }
  {
#line 5109
  fflush(outstr);
  }
#line 5110
  if ((unsigned int )draconian_FILE == (unsigned int )((void *)0)) {
    goto data_err;
  } else {
    {
#line 5110
    tmp___3 = ferror(instr);
    }
#line 5110
    if (tmp___3) {
      goto data_err;
    }
  }
  {
#line 5112
  tmp___4 = ferror(outstr);
  }
#line 5112
  if (tmp___4) {
    goto file_err;
  }
  {
#line 5114
  transflag = 0;
#line 5115
  draconian_FILE = (FILE *)((void *)0);
#line 5116
  alarm(0U);
  }
#line 5117
  if (bare_lfs) {
    {
#line 5118
    lreply(226, (char *)"WARNING! %d bare linefeeds received in ASCII mode", bare_lfs);
#line 5119
    lreply(0, (char *)"   File may not have transferred correctly.");
    }
  }
#line 5122
  file_count_total ++;
#line 5123
  file_count_in ++;
#line 5124
  xfer_count_total ++;
#line 5125
  xfer_count_in ++;
#line 5127
  return (0);
  default: 
  {
#line 5129
  reply(550, (char *)"Unimplemented TYPE %d in receive_data", type);
#line 5130
  transflag = 0;
  }
#line 5131
  return (-1);
  }
  data_err: 
  {
#line 5135
  draconian_FILE = (FILE *)((void *)0);
#line 5136
  alarm(0U);
#line 5137
  transflag = 0;
#line 5138
  perror_reply(426, (char *)"Data Connection");
  }
#line 5139
  return (-1);
  file_err: 
  {
#line 5142
  draconian_FILE = (FILE *)((void *)0);
#line 5143
  alarm(0U);
#line 5144
  transflag = 0;
#line 5145
  perror_reply(452, (char *)"Error writing file");
  }
#line 5146
  return (-1);
}
}
#line 5149 "ftpd.c"
void statfilecmd(char *filename ) 
{ char line___0[8192] ;
  char *ptr ;
  FILE *fin ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 5157
  fixpath(filename);
  }
#line 5158
  if ((int )*(filename + 0) == 0) {
#line 5159
    filename = (char *)".";
  }
#line 5161
  if (anonymous) {
#line 5161
    if (dolreplies) {
      {
#line 5162
      snprintf((char */* __restrict  */)(line___0), sizeof(line___0), (char const   */* __restrict  */)(ls_long),
               filename);
      }
    } else {
      {
#line 5164
      snprintf((char */* __restrict  */)(line___0), sizeof(line___0), (char const   */* __restrict  */)(ls_short),
               filename);
      }
    }
  } else {
    {
#line 5164
    snprintf((char */* __restrict  */)(line___0), sizeof(line___0), (char const   */* __restrict  */)(ls_short),
             filename);
    }
  }
  {
#line 5165
  fin = ftpd_popen(line___0, (char *)"r", 0);
#line 5167
  lreply(213, (char *)"status of %s:", filename);
  }
#line 5188
  while (1) {
    {
#line 5188
    tmp___1 = fgets((char */* __restrict  */)(line___0), (int )sizeof(line___0), (FILE */* __restrict  */)fin);
    }
#line 5188
    if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
#line 5188
      break;
    }
    {
#line 5189
    tmp___0 = __builtin_strchr(line___0, '\n');
#line 5189
    ptr = tmp___0;
    }
#line 5189
    if (ptr) {
#line 5190
      *ptr = (char )'\000';
    }
    {
#line 5191
    lreply(0, (char *)"%s", line___0);
    }
  }
  {
#line 5193
  ftpd_pclose(fin);
#line 5197
  reply(213, (char *)"End of Status");
  }
#line 5198
  return;
}
}
#line 5200 "ftpd.c"
void statcmd(void) 
{ struct sockaddr_in *sin ;
  u_char *a ;
  u_char *p ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
  {
#line 5205
  lreply(211, (char *)"%s FTP server status:", hostname);
#line 5206
  lreply(0, (char *)"     %s", version);
#line 5207
  tmp___0 = __ctype_b_loc();
  }
#line 5207
  if ((int const   )*(*tmp___0 + (int )remotehost[0]) & 2048) {
    {
#line 5211
    lreply(0, (char *)"     Connected to %s", remotehost);
    }
  } else {
    {
#line 5208
    tmp = inet_ntoa(his_addr.sin_addr);
#line 5208
    lreply(0, (char *)"     Connected to %s (%s)", remotehost, tmp);
    }
  }
#line 5213
  if (logged_in) {
#line 5214
    if (anonymous) {
      {
#line 5215
      lreply(0, (char *)"     Logged in anonymously");
      }
    } else {
      {
#line 5217
      lreply(0, (char *)"     Logged in as %s", pw->pw_name);
      }
    }
  } else {
#line 5219
    if (askpasswd) {
      {
#line 5220
      lreply(0, (char *)"     Waiting for password");
      }
    } else {
      {
#line 5222
      lreply(0, (char *)"     Waiting for user name");
      }
    }
  }
#line 5224
  if (type == 4) {
    {
#line 5226
    lreply(0, (char *)"     TYPE: %s %d; STRUcture: %s; transfer MODE: %s", typenames[type],
           8, strunames[stru], modenames[mode]);
    }
  } else {
#line 5233
    if (type == 1) {
#line 5233
      tmp___1 = (char const   *)formnames[form];
    } else {
#line 5233
      if (type == 2) {
#line 5233
        tmp___1 = (char const   *)formnames[form];
      } else {
#line 5233
        tmp___1 = "";
      }
    }
#line 5233
    if (type == 1) {
#line 5233
      tmp___2 = ", FORM: ";
    } else {
#line 5233
      if (type == 2) {
#line 5233
        tmp___2 = ", FORM: ";
      } else {
#line 5233
        tmp___2 = "";
      }
    }
    {
#line 5233
    lreply(0, (char *)"     TYPE: %s%s%s; STRUcture: %s; transfer MODE: %s", typenames[type],
           tmp___2, tmp___1, strunames[stru], modenames[mode]);
    }
  }
#line 5237
  if (data != -1) {
    {
#line 5238
    lreply(0, (char *)"     Data connection open");
    }
  } else {
#line 5239
    if (pdata != -1) {
      goto _L;
    } else {
#line 5239
      if (usedefault == 0) {
        _L: 
#line 5240
        if (usedefault == 0) {
#line 5241
          sin = & data_dest;
        } else {
#line 5242
          if (route_vectored) {
#line 5243
            sin = & vect_addr;
          } else {
#line 5245
            sin = & pasv_addr;
          }
        }
#line 5246
        a = (u_char *)(& sin->sin_addr);
#line 5247
        p = (u_char *)(& sin->sin_port);
#line 5249
        if (usedefault == 0) {
#line 5249
          tmp___3 = "PORT";
        } else {
#line 5249
          tmp___3 = "in Passive mode";
        }
        {
#line 5249
        lreply(0, (char *)"     %s (%d,%d,%d,%d,%d,%d)", tmp___3, (int )*(a + 0) & 255,
               (int )*(a + 1) & 255, (int )*(a + 2) & 255, (int )*(a + 3) & 255, (int )*(p + 0) & 255,
               (int )*(p + 1) & 255);
        }
      } else {
        {
#line 5255
        lreply(0, (char *)"     No data connection");
        }
      }
    }
  }
  {
#line 5257
  lreply(0, (char *)"     %d data bytes received in %d files", data_count_in, file_count_in);
#line 5258
  lreply(0, (char *)"     %d data bytes transmitted in %d files", data_count_out,
         file_count_out);
#line 5259
  lreply(0, (char *)"     %d data bytes total in %d files", data_count_total, file_count_total);
#line 5260
  lreply(0, (char *)"     %d traffic bytes received in %d transfers", byte_count_in,
         xfer_count_in);
#line 5261
  lreply(0, (char *)"     %d traffic bytes transmitted in %d transfers", byte_count_out,
         xfer_count_out);
#line 5262
  lreply(0, (char *)"     %d traffic bytes total in %d transfers", byte_count_total,
         xfer_count_total);
#line 5264
  reply(211, (char *)"End of status");
  }
#line 5265
  return;
}
}
#line 5267 "ftpd.c"
void fatal(char *s ) 
{ 

  {
  {
#line 5269
  reply(451, (char *)"Error in server: %s\n", s);
#line 5270
  reply(221, (char *)"Closing connection due to server error.");
#line 5271
  dologout(0);
  }
#line 5273
  return;
}
}
#line 5278 "ftpd.c"
void vreply(long flags , int n , char *fmt , va_list ap ) 
{ char buf___2[8192] ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 5282
  flags &= (long )((1 << 1) | (1 << 2));
#line 5284
  if (n) {
#line 5285
    if (flags & (long )(1 << 2)) {
#line 5285
      tmp = '-';
    } else {
#line 5285
      tmp = ' ';
    }
    {
#line 5285
    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%03d%c",
            n, tmp);
    }
  }
#line 5290
  if (flags & (long )(1 << 1)) {
#line 5291
    if (n) {
#line 5291
      tmp___0 = sizeof(buf___2) - 4U;
    } else {
#line 5291
      tmp___0 = sizeof(buf___2);
    }
#line 5291
    if (n) {
#line 5291
      tmp___1 = 4;
    } else {
#line 5291
      tmp___1 = 0;
    }
    {
#line 5291
    snprintf((char */* __restrict  */)(buf___2 + tmp___1), tmp___0, (char const   */* __restrict  */)"%s",
             fmt);
    }
  } else {
#line 5293
    if (n) {
#line 5293
      tmp___2 = sizeof(buf___2) - 4U;
    } else {
#line 5293
      tmp___2 = sizeof(buf___2);
    }
#line 5293
    if (n) {
#line 5293
      tmp___3 = 4;
    } else {
#line 5293
      tmp___3 = 0;
    }
    {
#line 5293
    vsnprintf((char */* __restrict  */)(buf___2 + tmp___3), tmp___2, (char const   */* __restrict  */)fmt,
              ap);
    }
  }
#line 5295
  if (debug) {
    {
#line 5296
    syslog(7, "<--- %s", buf___2);
    }
  }
  {
#line 5303
  printf((char const   */* __restrict  */)"%s\r\n", buf___2);
#line 5305
  tmp___4 = strlen((char const   *)(buf___2));
#line 5305
  byte_count_total = (int )((unsigned int )byte_count_total + tmp___4);
#line 5306
  tmp___5 = strlen((char const   *)(buf___2));
#line 5306
  byte_count_out = (int )((unsigned int )byte_count_out + tmp___5);
#line 5308
  fflush(stdout);
  }
#line 5309
  return;
}
}
#line 5311 "ftpd.c"
void reply(int n , char *fmt  , ...) 
{ va_list ap ;
  char *p ;
  char *ptr ;
  char *tmp___0 ;

  {
#line 5315
  if ((unsigned int )autospout != (unsigned int )((void *)0)) {
#line 5316
    ptr = autospout;
#line 5318
    while (*ptr) {
      {
#line 5319
      tmp___0 = __builtin_strchr(ptr, '\n');
#line 5319
      p = tmp___0;
      }
#line 5319
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 5320
        *p = (char )'\000';
      }
      {
#line 5323
      vreply((long )((1 << 2) | (1 << 1)), n, ptr, ap);
      }
#line 5325
      if (p) {
#line 5326
        ptr = p + 1;
      } else {
#line 5328
        break;
      }
    }
#line 5331
    if (autospout_free) {
      {
#line 5332
      free((void *)autospout);
#line 5333
      autospout_free = 0;
      }
    }
#line 5335
    autospout = (char *)0;
  }
  {
#line 5338
  __builtin_va_start(ap, fmt);
#line 5341
  vreply(0L, n, fmt, ap);
#line 5343
  __builtin_va_end(ap);
  }
#line 5344
  return;
}
}
#line 5346 "ftpd.c"
void lreply(int n , char *fmt  , ...) 
{ va_list ap ;

  {
#line 5350
  if (! dolreplies) {
#line 5351
    return;
  }
  {
#line 5353
  __builtin_va_start(ap, fmt);
#line 5356
  vreply((long )(1 << 2), n, fmt, ap);
#line 5358
  __builtin_va_end(ap);
  }
#line 5359
  return;
}
}
#line 5361 "ftpd.c"
void ack(char *s ) 
{ 

  {
  {
#line 5363
  reply(250, (char *)"%s command successful.", s);
  }
#line 5364
  return;
}
}
#line 5366 "ftpd.c"
void nack(char *s ) 
{ 

  {
  {
#line 5368
  reply(502, (char *)"%s command not implemented.", s);
  }
#line 5369
  return;
}
}
#line 5371 "ftpd.c"
void yyerror(char *s ) 
{ char *cp ;
  char *tmp___0 ;

  {
#line 5374
  if ((unsigned int )s == (unsigned int )((void *)0)) {
#line 5375
    return;
  } else {
#line 5374
    if (yyerrorcalled != 0) {
#line 5375
      return;
    }
  }
  {
#line 5376
  tmp___0 = __builtin_strchr(cbuf, '\n');
#line 5376
  cp = tmp___0;
  }
#line 5376
  if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 5377
    *cp = (char )'\000';
  }
  {
#line 5378
  reply(500, (char *)"\'%s\': command not understood.", cbuf);
#line 5379
  yyerrorcalled = 1;
  }
#line 5380
  return;
}
}
#line 5383 "ftpd.c"
void delete(char *name ) 
{ struct stat st ;
  char realname[4096] ;
  int tmp ;
  int tmp___0 ;
  uid_t uid ;
  gid_t gid ;
  int d_mode ;
  int valid___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char path[4096] ;

  {
  {
#line 5392
  wu_realpath((char const   *)name, realname, chroot_path);
#line 5394
  tmp = del_check(name);
  }
#line 5394
  if (tmp == 0) {
#line 5395
    if (log_security) {
#line 5396
      if (anonymous) {
        {
#line 5397
        syslog(5, "anonymous(%s) of %s tried to delete %s", guestpw, remoteident,
               realname);
        }
      } else {
        {
#line 5400
        syslog(5, "%s of %s tried to delete %s", pw->pw_name, remoteident, realname);
        }
      }
    }
#line 5402
    return;
  }
  {
#line 5405
  tmp___0 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
#line 5405
  if (tmp___0 < 0) {
    {
#line 5406
    perror_reply(550, name);
    }
#line 5407
    return;
  }
#line 5409
  if ((st.st_mode & 61440U) == 16384U) {
    {
#line 5418
    tmp___1 = dir_check(name, & uid, & gid, & d_mode, & valid___0);
    }
#line 5418
    if (tmp___1 <= 0) {
#line 5419
      if (log_security) {
#line 5420
        if (anonymous) {
          {
#line 5421
          syslog(5, "anonymous(%s) of %s tried to delete directory %s", guestpw, remoteident,
                 realname);
          }
        } else {
          {
#line 5424
          syslog(5, "%s of %s tried to delete directory %s", pw->pw_name, remoteident,
                 realname);
          }
        }
      }
#line 5426
      return;
    }
    {
#line 5429
    tmp___2 = rmdir((char const   *)name);
    }
#line 5429
    if (tmp___2 < 0) {
#line 5430
      if (log_security) {
#line 5431
        if (anonymous) {
          {
#line 5432
          syslog(5, "anonymous(%s) of %s tried to delete directory %s (permissions)",
                 guestpw, remoteident, realname);
          }
        } else {
          {
#line 5435
          syslog(5, "%s of %s tried to delete directory %s (permissions)", pw->pw_name,
                 remoteident, realname);
          }
        }
      }
      {
#line 5437
      perror_reply(550, name);
      }
#line 5438
      return;
    }
    goto done;
  }
  {
#line 5442
  tmp___3 = unlink((char const   *)name);
  }
#line 5442
  if (tmp___3 < 0) {
#line 5443
    if (log_security) {
#line 5444
      if (anonymous) {
        {
#line 5445
        syslog(5, "anonymous(%s) of %s tried to delete %s (permissions)", guestpw,
               remoteident, realname);
        }
      } else {
        {
#line 5448
        syslog(5, "%s of %s tried to delete %s (permissions)", pw->pw_name, remoteident,
               realname);
        }
      }
    }
    {
#line 5450
    perror_reply(550, name);
    }
#line 5451
    return;
  }
  done: 
  {
#line 5457
  wu_realpath((char const   *)name, path, chroot_path);
  }
#line 5459
  if (log_security) {
#line 5460
    if ((st.st_mode & 61440U) == 16384U) {
#line 5461
      if (anonymous) {
        {
#line 5462
        syslog(5, "%s of %s deleted directory %s", guestpw, remoteident, path);
        }
      } else {
        {
#line 5465
        syslog(5, "%s of %s deleted directory %s", pw->pw_name, remoteident, path);
        }
      }
    } else {
#line 5468
      if (anonymous) {
        {
#line 5469
        syslog(5, "%s of %s deleted %s", guestpw, remoteident, path);
        }
      } else {
        {
#line 5473
        syslog(5, "%s of %s deleted %s", pw->pw_name, remoteident, path);
        }
      }
    }
  }
  {
#line 5478
  ack((char *)"DELE");
  }
#line 5479
  return;
}
}
#line 5481 "ftpd.c"
void cwd(char *path ) 
{ struct aclmember *entry ;
  char cdpath___0[4097] ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;
  int tmp___2 ;
  struct aclmember *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 5483
  entry = (struct aclmember *)((void *)0);
#line 5486
  tmp___4 = mapping_chdir(path);
  }
#line 5486
  if (tmp___4 < 0) {
#line 5488
    while (1) {
      {
#line 5488
      tmp___1 = getaclentry((char *)"alias", & entry);
      }
#line 5488
      if (tmp___1) {
#line 5488
        if (entry->arg[0]) {
#line 5488
          if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 5488
            break;
          }
        } else {
#line 5488
          break;
        }
      } else {
#line 5488
        break;
      }
      {
#line 5489
      tmp___0 = strcasecmp((char const   *)entry->arg[0], (char const   *)path);
      }
#line 5489
      if (! tmp___0) {
        {
#line 5490
        tmp = mapping_chdir(entry->arg[1]);
        }
#line 5490
        if (tmp < 0) {
          {
#line 5491
          perror_reply(550, path);
          }
        } else {
          {
#line 5493
          show_message(250, 1);
#line 5494
          show_readme(250, 1);
#line 5495
          ack((char *)"CWD");
          }
        }
#line 5497
        return;
      }
    }
#line 5501
    entry = (struct aclmember *)((void *)0);
#line 5502
    while (1) {
      {
#line 5502
      tmp___3 = getaclentry((char *)"cdpath", & entry);
      }
#line 5502
      if (tmp___3) {
#line 5502
        if (! ((unsigned int )entry->arg[0] != (unsigned int )((void *)0))) {
#line 5502
          break;
        }
      } else {
#line 5502
        break;
      }
      {
#line 5503
      snprintf((char */* __restrict  */)(cdpath___0), sizeof(cdpath___0), (char const   */* __restrict  */)"%s/%s",
               entry->arg[0], path);
#line 5504
      tmp___2 = mapping_chdir(cdpath___0);
      }
#line 5504
      if (tmp___2 >= 0) {
        {
#line 5505
        show_message(250, 1);
#line 5506
        show_readme(250, 1);
#line 5507
        ack((char *)"CWD");
        }
#line 5508
        return;
      }
    }
    {
#line 5511
    perror_reply(550, path);
    }
  } else {
    {
#line 5514
    show_message(250, 1);
#line 5515
    show_readme(250, 1);
#line 5516
    ack((char *)"CWD");
    }
  }
#line 5518
  return;
}
}
#line 5520 "ftpd.c"
void makedir(char *name ) 
{ uid_t uid ;
  gid_t gid ;
  int d_mode ;
  mode_t oldumask ;
  int valid___0 ;
  uid_t oldid ;
  char path[4097] ;
  char realname[4096] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 5531
  wu_realpath((char const   *)name, realname, chroot_path);
#line 5535
  tmp = dir_check(name, & uid, & gid, & d_mode, & valid___0);
  }
#line 5535
  if (tmp <= 0) {
#line 5536
    if (log_security) {
#line 5537
      if (anonymous) {
        {
#line 5538
        syslog(5, "anonymous(%s) of %s tried to create directory %s", guestpw, remoteident,
               realname);
        }
      } else {
        {
#line 5541
        syslog(5, "%s of %s tried to create directory %s", pw->pw_name, remoteident,
               realname);
        }
      }
    }
#line 5543
    return;
  }
  {
#line 5549
  tmp___0 = fn_check(name);
  }
#line 5549
  if (tmp___0 <= 0) {
#line 5550
    if (log_security) {
#line 5551
      if (anonymous) {
        {
#line 5552
        syslog(5, "anonymous(%s) of %s tried to create directory %s (path-filter)",
               guestpw, remoteident, realname);
        }
      } else {
        {
#line 5555
        syslog(5, "%s of %s tried to create directory %s (path-filter)", pw->pw_name,
               remoteident, realname);
        }
      }
    }
#line 5557
    return;
  }
  {
#line 5560
  oldumask = umask(0U);
  }
#line 5561
  if (valid___0 <= 0) {
    {
#line 5562
    d_mode = 511;
#line 5563
    umask(oldumask);
    }
  }
  {
#line 5566
  tmp___2 = mkdir((char const   *)name, (unsigned int )d_mode);
  }
#line 5566
  if (tmp___2 < 0) {
    {
#line 5567
    tmp___1 = __errno_location();
    }
#line 5567
    if (*tmp___1 == 17) {
#line 5568
      if (log_security) {
#line 5569
        if (anonymous) {
          {
#line 5570
          syslog(5, "anonymous(%s) of %s tried to create directory %s (exists)", guestpw,
                 remoteident, realname);
          }
        } else {
          {
#line 5573
          syslog(5, "%s of %s tried to create directory %s (exists)", pw->pw_name,
                 remoteident, realname);
          }
        }
      }
      {
#line 5575
      fb_realpath((char const   *)name, path);
#line 5576
      reply(521, (char *)"\"%s\" directory exists", path);
      }
    } else {
#line 5579
      if (log_security) {
#line 5580
        if (anonymous) {
          {
#line 5581
          syslog(5, "anonymous(%s) of %s tried to create directory %s (permissions)",
                 guestpw, remoteident, realname);
          }
        } else {
          {
#line 5584
          syslog(5, "%s of %s tried to create directory %s (permissions)", pw->pw_name,
                 remoteident, realname);
          }
        }
      }
      {
#line 5586
      perror_reply(550, name);
      }
    }
    {
#line 5588
    umask(oldumask);
    }
#line 5589
    return;
  }
  {
#line 5591
  umask(oldumask);
  }
#line 5592
  if (valid___0 > 0) {
    {
#line 5593
    oldid = geteuid();
    }
#line 5594
    if (uid != 0U) {
      {
#line 5595
      seteuid(uid);
      }
    }
#line 5596
    if (uid == 0U) {
      goto _L;
    } else {
      {
#line 5596
      tmp___4 = chown((char const   *)name, uid, gid);
      }
#line 5596
      if (tmp___4 < 0) {
        _L: 
        {
#line 5597
        delay_signaling();
#line 5598
        seteuid(0U);
#line 5599
        tmp___3 = chown((char const   *)name, uid, gid);
        }
#line 5599
        if (tmp___3 < 0) {
          {
#line 5600
          seteuid(oldid);
#line 5601
          enable_signaling();
#line 5602
          perror_reply(550, (char *)"chown");
          }
#line 5603
          return;
        }
        {
#line 5605
        seteuid(oldid);
#line 5606
        enable_signaling();
        }
      } else {
        {
#line 5609
        seteuid(oldid);
        }
      }
    }
  }
  {
#line 5611
  wu_realpath((char const   *)name, path, chroot_path);
  }
#line 5612
  if (log_security) {
#line 5613
    if (anonymous) {
      {
#line 5614
      syslog(5, "%s of %s created directory %s", guestpw, remoteident, path);
      }
    } else {
      {
#line 5617
      syslog(5, "%s of %s created directory %s", pw->pw_name, remoteident, path);
      }
    }
  }
  {
#line 5620
  fb_realpath((char const   *)name, path);
#line 5627
  reply(257, (char *)"\"%s\" new directory created.", path);
  }
#line 5628
  return;
}
}
#line 5630 "ftpd.c"
void removedir(char *name ) 
{ uid_t uid ;
  gid_t gid ;
  int d_mode ;
  int valid___0 ;
  char realname[4096] ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char path[4096] ;
  int tmp___2 ;

  {
  {
#line 5638
  wu_realpath((char const   *)name, realname, chroot_path);
#line 5644
  tmp = del_check(name);
  }
#line 5644
  if (tmp == 0) {
#line 5645
    return;
  }
  {
#line 5649
  tmp___0 = dir_check(name, & uid, & gid, & d_mode, & valid___0);
  }
#line 5649
  if (tmp___0 <= 0) {
#line 5650
    if (log_security) {
#line 5651
      if (anonymous) {
        {
#line 5652
        syslog(5, "anonymous(%s) of %s tried to remove directory %s", guestpw, remoteident,
               realname);
        }
      } else {
        {
#line 5655
        syslog(5, "%s of %s tried to remove directory %s", pw->pw_name, remoteident,
               realname);
        }
      }
    }
#line 5657
    return;
  }
  {
#line 5660
  tmp___2 = rmdir((char const   *)name);
  }
#line 5660
  if (tmp___2 < 0) {
    {
#line 5661
    tmp___1 = __errno_location();
    }
#line 5661
    if (*tmp___1 == 16) {
      {
#line 5662
      perror_reply(450, name);
      }
    } else {
#line 5664
      if (log_security) {
#line 5665
        if (anonymous) {
          {
#line 5666
          syslog(5, "anonymous(%s) of %s tried to remove directory %s (permissions)",
                 guestpw, remoteident, realname);
          }
        } else {
          {
#line 5669
          syslog(5, "%s of %s tried to remove directory %s (permissions)", pw->pw_name,
                 remoteident, realname);
          }
        }
      }
      {
#line 5671
      perror_reply(550, name);
      }
    }
  } else {
    {
#line 5677
    wu_realpath((char const   *)name, path, chroot_path);
    }
#line 5679
    if (log_security) {
#line 5680
      if (anonymous) {
        {
#line 5681
        syslog(5, "%s of %s deleted directory %s", guestpw, remoteident, path);
        }
      } else {
        {
#line 5684
        syslog(5, "%s of %s deleted directory %s", pw->pw_name, remoteident, path);
        }
      }
    }
    {
#line 5687
    ack((char *)"RMD");
    }
  }
#line 5689
  return;
}
}
#line 5691 "ftpd.c"
void pwd(void) 
{ char path[4097] ;
  char rhome[4097] ;
  char *rpath ;
  int pathlen ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 5695
  rpath = path;
#line 5706
  tmp = mapping_getcwd(path, 4096U);
  }
#line 5706
  if ((unsigned int )tmp == (unsigned int )((char *)((void *)0))) {
    {
#line 5714
    fb_realpath(".", path);
    }
  }
#line 5717
  if (restricted_user) {
    {
#line 5718
    fb_realpath((char const   *)home, rhome);
#line 5719
    tmp___0 = strlen((char const   *)(rhome));
#line 5719
    pathlen = (int )tmp___0;
    }
#line 5720
    if (pathlen) {
#line 5720
      if ((int )rhome[pathlen - 1] == 47) {
#line 5721
        pathlen --;
      }
    }
#line 5722
    rpath += pathlen;
#line 5723
    if (! *rpath) {
      {
#line 5724
      strcpy((char */* __restrict  */)rpath, (char const   */* __restrict  */)"/");
      }
    }
  }
  {
#line 5726
  reply(257, (char *)"\"%s\" is current directory.", rpath);
  }
#line 5727
  return;
}
}
#line 5729 "ftpd.c"
char *renamefrom(char *name ) 
{ struct stat st ;
  int tmp ;

  {
  {
#line 5733
  tmp = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st));
  }
#line 5733
  if (tmp < 0) {
    {
#line 5734
    perror_reply(550, name);
    }
#line 5735
    return ((char *)0);
  }
  {
#line 5737
  reply(350, (char *)"File exists, ready for destination name");
  }
#line 5738
  return (name);
}
}
#line 5741 "ftpd.c"
void renamecmd(char *from , char *to ) 
{ int allowed ;
  int tmp ;
  char realfrom[4096] ;
  char realto[4096] ;
  struct aclmember *entry ;
  int tmp___0 ;
  int tmp___1 ;
  struct aclmember *tmp___2 ;
  char frompath[4096] ;
  char topath[4096] ;
  int tmp___3 ;

  {
#line 5743
  if (anonymous) {
#line 5743
    tmp = 0;
  } else {
#line 5743
    tmp = 1;
  }
  {
#line 5743
  allowed = tmp;
#line 5746
  entry = (struct aclmember *)((void *)0);
#line 5750
  wu_realpath((char const   *)from, realfrom, chroot_path);
#line 5751
  wu_realpath((char const   *)to, realto, chroot_path);
#line 5755
  tmp___0 = fn_check(to);
  }
#line 5755
  if (tmp___0 == 0) {
#line 5756
    if (log_security) {
#line 5757
      if (anonymous) {
        {
#line 5758
        syslog(5, "anonymous(%s) of %s tried to rename %s to \"%s\" (path-filter)",
               guestpw, remoteident, realfrom, realto);
        }
      } else {
        {
#line 5761
        syslog(5, "%s of %s tried to rename %s to \"%s\" (path-filter)", pw->pw_name,
               remoteident, realfrom, realto);
        }
      }
    }
#line 5763
    return;
  }
#line 5770
  while (1) {
    {
#line 5770
    tmp___2 = getaclentry((char *)"rename", & entry);
    }
#line 5770
    if (tmp___2) {
#line 5770
      if (entry->arg[0]) {
#line 5770
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 5770
          break;
        }
      } else {
#line 5770
        break;
      }
    } else {
#line 5770
      break;
    }
    {
#line 5771
    tmp___1 = type_match(entry->arg[1]);
    }
#line 5771
    if (tmp___1) {
#line 5772
      if (anonymous) {
#line 5773
        if ((int )*(entry->arg[0]) == 121) {
#line 5774
          allowed = 1;
        }
      } else {
#line 5776
        if ((int )*(entry->arg[0]) == 110) {
#line 5777
          allowed = 0;
        }
      }
    }
  }
#line 5779
  if (! allowed) {
#line 5780
    if (log_security) {
#line 5781
      if (anonymous) {
        {
#line 5782
        syslog(5, "anonymous(%s) of %s tried to rename %s to %s", guestpw, remoteident,
               realfrom, realto);
        }
      } else {
        {
#line 5785
        syslog(5, "%s of %s tried to rename %s to %s", pw->pw_name, remoteident, realfrom,
               realto);
        }
      }
    }
    {
#line 5787
    reply(553, (char *)"%s: Permission denied on server. (rename)", from);
    }
#line 5788
    return;
  }
  {
#line 5808
  tmp___3 = rename((char const   *)from, (char const   *)to);
  }
#line 5808
  if (tmp___3 < 0) {
#line 5809
    if (log_security) {
#line 5810
      if (anonymous) {
        {
#line 5811
        syslog(5, "anonymous(%s) of %s tried to rename %s to %s", guestpw, remoteident,
               realfrom, realto);
        }
      } else {
        {
#line 5814
        syslog(5, "%s of %s tried to rename %s to %s", pw->pw_name, remoteident, realfrom,
               realto);
        }
      }
    }
    {
#line 5816
    perror_reply(550, (char *)"rename");
    }
  } else {
    {
#line 5822
    wu_realpath((char const   *)from, frompath, chroot_path);
#line 5823
    wu_realpath((char const   *)to, topath, chroot_path);
    }
#line 5825
    if (log_security) {
#line 5826
      if (anonymous) {
        {
#line 5827
        syslog(5, "%s of %s renamed %s to %s", guestpw, remoteident, frompath, topath);
        }
      } else {
        {
#line 5830
        syslog(5, "%s of %s renamed %s to %s", pw->pw_name, remoteident, frompath,
               topath);
        }
      }
    }
    {
#line 5833
    ack((char *)"RNTO");
    }
  }
#line 5835
  return;
}
}
#line 5837 "ftpd.c"
void dolog(struct sockaddr_in *sin ) 
{ struct hostent *hp ;
  char *blah ;
  int num_dns_tries ;
  int tmp ;
  int n ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 5844
  num_dns_tries = 0;
  dns_again: 
  {
#line 5854
  hp = gethostbyaddr((void const   *)((char *)(& sin->sin_addr)), sizeof(struct in_addr ),
                     2);
  }
#line 5857
  if (! hp) {
#line 5857
    num_dns_tries ++;
#line 5857
    if (num_dns_tries <= 1) {
      {
#line 5858
      sleep(3U);
      }
      goto dns_again;
    }
  }
  {
#line 5865
  blah = inet_ntoa(sin->sin_addr);
#line 5867
  __builtin_strncpy(remoteaddr, (char const   *)blah, sizeof(remoteaddr));
#line 5869
  tmp = strcasecmp((char const   *)(remoteaddr), "0.0.0.0");
  }
#line 5869
  if (tmp) {
#line 5874
    if (hp) {
      {
#line 5875
      nameserved = 1;
#line 5876
      __builtin_strncpy(remotehost, (char const   *)hp->h_name, sizeof(remotehost));
      }
    } else {
      {
#line 5879
      nameserved = 0;
#line 5880
      __builtin_strncpy(remotehost, (char const   *)(remoteaddr), sizeof(remotehost));
      }
    }
  } else {
    {
#line 5870
    nameserved = 1;
#line 5871
    __builtin_strncpy(remotehost, "localhost", sizeof(remotehost));
    }
  }
  {
#line 5892
  remotehost[sizeof(remotehost) - 1U] = (char )'\000';
#line 5893
  sprintf((char */* __restrict  */)(proctitle), (char const   */* __restrict  */)"%s: connected",
          remotehost);
#line 5894
  setproctitle((char const   *)(proctitle));
#line 5896
  wu_authenticate();
#line 5900
  tmp___0 = strlen((char const   *)(remotehost));
#line 5900
  tmp___1 = strlen((char const   *)(remoteaddr));
  }
#line 5900
  if (authenticated) {
    {
#line 5900
    tmp___3 = strlen((char const   *)(authuser + 5));
    }
  } else {
#line 5900
    tmp___3 = 0U;
  }
  {
#line 5900
  n = (int )(((20U + tmp___0) + tmp___1) + tmp___3);
#line 5902
  tmp___4 = malloc((unsigned int )n);
#line 5902
  remoteident = (char *)tmp___4;
  }
#line 5902
  if ((unsigned int )remoteident == (unsigned int )((void *)0)) {
    {
#line 5903
    syslog(3, "malloc: %m");
#line 5905
    exit(1);
    }
  } else {
#line 5908
    if (authenticated) {
      {
#line 5909
      sprintf((char */* __restrict  */)remoteident, (char const   */* __restrict  */)"%s @ %s [%s]",
              authuser, remotehost, remoteaddr);
      }
    } else {
      {
#line 5912
      sprintf((char */* __restrict  */)remoteident, (char const   */* __restrict  */)"%s [%s]",
              remotehost, remoteaddr);
      }
    }
  }
#line 5915
  if (be_daemon) {
#line 5915
    if (logging) {
      {
#line 5916
      syslog(6, "connection from %s", remoteident);
      }
    }
  }
#line 5924
  return;
}
}
#line 5928 "ftpd.c"
void dologout(int status ) 
{ 

  {
  {
#line 5934
  transflag = 0;
#line 5940
  alarm(0U);
  }
#line 5942
  if (logged_in) {
    {
#line 5943
    delay_signaling();
#line 5944
    seteuid(0U);
    }
#line 5945
    if (wtmp_logging) {
      {
#line 5946
      wu_logwtmp(ttyline, pw->pw_name, remotehost, 0);
      }
    }
  }
#line 5948
  if (logging) {
    {
#line 5949
    syslog(6, "FTP session closed");
    }
  }
#line 5950
  if (xferlog) {
    {
#line 5951
    close(xferlog);
    }
  }
  {
#line 5952
  acl_remove();
#line 5953
  close(data);
#line 5954
  close(pdata);
#line 5959
  _exit(status);
  }
}
}
#line 5962 "ftpd.c"
void myoob(int sig ) 
{ char *cp ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 5967
  if (! transflag) {
    {
#line 5969
    signal(23, & myoob);
    }
#line 5971
    return;
  }
  {
#line 5973
  cp = tmpline;
#line 5974
  tmp = wu_getline(cp, (int )(sizeof(tmpline) - 1U), stdin);
  }
#line 5974
  if ((unsigned int )tmp == (unsigned int )((void *)0)) {
    {
#line 5975
    reply(221, (char *)"You could at least say goodbye.");
#line 5976
    dologout(0);
    }
  }
  {
#line 5978
  upper(cp);
#line 5979
  tmp___0 = strcasecmp((char const   *)cp, "ABOR\r\n");
  }
#line 5979
  if (tmp___0 == 0) {
    {
#line 5980
    tmpline[0] = (char )'\000';
#line 5981
    reply(426, (char *)"Transfer aborted. Data connection closed.");
#line 5982
    reply(226, (char *)"Abort successful");
#line 5984
    signal(23, & myoob);
    }
#line 5986
    if (ftwflag > 0) {
#line 5987
      ftwflag ++;
#line 5988
      return;
    }
    {
#line 5990
    siglongjmp(urgcatch, 1);
    }
  }
  {
#line 5992
  tmp___1 = strcasecmp((char const   *)cp, "STAT\r\n");
  }
#line 5992
  if (tmp___1 == 0) {
#line 5993
    tmpline[0] = (char )'\000';
#line 5994
    if (file_size != -1L) {
      {
#line 5995
      reply(213, (char *)"Status: %u of %u bytes transferred", byte_count, file_size);
      }
    } else {
      {
#line 5998
      reply(213, (char *)"Status: %u bytes transferred", byte_count);
      }
    }
  }
  {
#line 6001
  signal(23, & myoob);
  }
#line 6003
  return;
}
}
#line 6010 "ftpd.c"
void passive(void) 
{ int len ;
  int bind_error ;
  int on ;
  register char *p ;
  register char *a ;
  int *port_array ;
  int *pasv_port_array ;
  int i ;
  int j ;
  int k ;
  void *tmp ;
  void *tmp___0 ;
  time_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *s ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int i___0 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  char *s___0 ;
  size_t tmp___10 ;
  void *tmp___11 ;

  {
#line 6018
  on = 1;
#line 6023
  if (pdata > 0) {
    {
#line 6024
    close(pdata);
#line 6025
    pdata = -1;
    }
  }
#line 6027
  if (! logged_in) {
    {
#line 6028
    reply(530, (char *)"Login with USER first.");
    }
#line 6029
    return;
  }
  {
#line 6031
  pdata = socket(2, 1, 0);
  }
#line 6032
  if (pdata < 0) {
    {
#line 6033
    perror_reply(425, (char *)"Can\'t open passive connection");
    }
#line 6034
    return;
  }
#line 6036
  if (keepalive) {
    {
#line 6037
    setsockopt(pdata, 1, 9, (void const   *)((char *)(& on)), sizeof(on));
    }
  }
#line 6038
  if (TCPwindowsize) {
    {
#line 6039
    setsockopt(pdata, 1, 7, (void const   *)((char *)(& TCPwindowsize)), sizeof(TCPwindowsize));
#line 6040
    setsockopt(pdata, 1, 8, (void const   *)((char *)(& TCPwindowsize)), sizeof(TCPwindowsize));
    }
  }
  {
#line 6042
  pasv_addr = ctrl_addr;
#line 6043
  pasv_addr.sin_port = (unsigned short)0;
#line 6044
  delay_signaling();
#line 6045
  seteuid(0U);
#line 6047
  checkports();
  }
#line 6049
  if (passive_port_min == -1) {
#line 6050
    passive_port_max = 65534;
#line 6051
    passive_port_min = 1024;
  }
#line 6061
  if (passive_port_max < passive_port_min) {
    {
#line 6062
    seteuid(pw->pw_uid);
#line 6063
    enable_signaling();
    }
    goto pasv_error;
  }
  {
#line 6067
  i = (passive_port_max - passive_port_min) + 1;
#line 6069
  tmp = calloc((unsigned int )i, sizeof(int ));
#line 6069
  port_array = (int *)tmp;
  }
#line 6070
  if ((unsigned int )port_array == (unsigned int )((void *)0)) {
    {
#line 6071
    seteuid(pw->pw_uid);
#line 6072
    enable_signaling();
    }
    goto pasv_error;
  }
  {
#line 6076
  tmp___0 = calloc((unsigned int )i, sizeof(int ));
#line 6076
  pasv_port_array = (int *)tmp___0;
  }
#line 6077
  if ((unsigned int )pasv_port_array == (unsigned int )((void *)0)) {
    {
#line 6078
    free((void *)port_array);
#line 6079
    seteuid(pw->pw_uid);
#line 6080
    enable_signaling();
    }
    goto pasv_error;
  }
#line 6084
  while (1) {
#line 6085
    i --;
#line 6086
    *(port_array + i) = passive_port_min + i;
#line 6084
    if (! (i > 0)) {
#line 6084
      break;
    }
  }
  {
#line 6089
  tmp___1 = time((time_t *)((void *)0));
#line 6089
  srand((unsigned int )tmp___1);
#line 6102
  bind_error = -1;
#line 6103
  tmp___2 = __errno_location();
#line 6103
  *tmp___2 = 98;
#line 6104
  i = 3;
  }
#line 6104
  while (1) {
#line 6104
    if (bind_error < 0) {
      {
#line 6104
      tmp___5 = __errno_location();
      }
#line 6104
      if (*tmp___5 == 98) {
#line 6104
        if (! (i > 0)) {
#line 6104
          break;
        }
      } else {
#line 6104
        break;
      }
    } else {
#line 6104
      break;
    }
#line 6105
    j = (passive_port_max - passive_port_min) + 1;
#line 6105
    while (1) {
#line 6105
      if (bind_error < 0) {
        {
#line 6105
        tmp___4 = __errno_location();
        }
#line 6105
        if (*tmp___4 == 98) {
#line 6105
          if (! (j > 0)) {
#line 6105
            break;
          }
        } else {
#line 6105
          break;
        }
      } else {
#line 6105
        break;
      }
#line 6106
      if (i == 3) {
        {
#line 6107
        tmp___3 = rand();
#line 6107
        k = (int )(((1.0 * (double )j) * (double )tmp___3) / ((double )2147483647 + 1.0));
#line 6108
        *(pasv_port_array + (j - 1)) = *(port_array + k);
        }
#line 6109
        while (1) {
#line 6109
          k ++;
#line 6109
          if (! (k < j)) {
#line 6109
            break;
          }
#line 6110
          *(port_array + (k - 1)) = *(port_array + k);
        }
      }
      {
#line 6112
      __x = (unsigned short )*(pasv_port_array + (j - 1));
#line 6112
      __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 6112
      pasv_addr.sin_port = __v;
#line 6113
      bind_error = bind(pdata, (struct sockaddr  const  *)((struct sockaddr *)(& pasv_addr)),
                        sizeof(pasv_addr));
#line 6105
      j --;
      }
    }
#line 6104
    i --;
  }
  {
#line 6117
  free((void *)pasv_port_array);
#line 6118
  free((void *)port_array);
  }
#line 6120
  if (bind_error < 0) {
    {
#line 6121
    seteuid(pw->pw_uid);
#line 6122
    enable_signaling();
    }
    goto pasv_error;
  }
  {
#line 6127
  seteuid(pw->pw_uid);
#line 6128
  enable_signaling();
#line 6129
  len = (int )sizeof(pasv_addr);
#line 6130
  tmp___6 = getsockname(pdata, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& pasv_addr)),
                        (socklen_t */* __restrict  */)(& len));
  }
#line 6130
  if (tmp___6 < 0) {
    goto pasv_error;
  }
  {
#line 6132
  tmp___7 = listen(pdata, 1);
  }
#line 6132
  if (tmp___7 < 0) {
    goto pasv_error;
  }
#line 6134
  usedefault = 1;
#line 6135
  if (route_vectored) {
#line 6136
    a = (char *)(& vect_addr.sin_addr);
  } else {
#line 6138
    a = (char *)(& pasv_addr.sin_addr);
  }
#line 6139
  p = (char *)(& pasv_addr.sin_port);
#line 6143
  if (debug) {
    {
#line 6144
    tmp___8 = strlen((char const   *)remoteident);
#line 6144
    tmp___9 = calloc(128U + tmp___8, sizeof(char ));
#line 6144
    s = (char *)tmp___9;
    }
#line 6145
    if (s) {
      {
#line 6146
      __x___0 = pasv_addr.sin_port;
#line 6146
      __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 6146
      i___0 = (int )__v___0;
#line 6147
      sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"PASV port %i assigned to %s",
              i___0, remoteident);
#line 6148
      syslog(7, (char const   *)s);
#line 6149
      free((void *)s);
      }
    }
  }
  {
#line 6152
  reply(227, (char *)"Entering Passive Mode (%d,%d,%d,%d,%d,%d)", (int )*(a + 0) & 255,
        (int )*(a + 1) & 255, (int )*(a + 2) & 255, (int )*(a + 3) & 255, (int )*(p + 0) & 255,
        (int )*(p + 1) & 255);
  }
#line 6154
  return;
  pasv_error: 
  {
#line 6157
  close(pdata);
#line 6158
  pdata = -1;
  }
#line 6159
  if (debug) {
    {
#line 6160
    tmp___10 = strlen((char const   *)remoteident);
#line 6160
    tmp___11 = calloc(128U + tmp___10, sizeof(char ));
#line 6160
    s___0 = (char *)tmp___11;
    }
#line 6161
    if (s___0) {
      {
#line 6162
      sprintf((char */* __restrict  */)s___0, (char const   */* __restrict  */)"PASV port assignment assigned for %s",
              remoteident);
#line 6163
      syslog(7, (char const   *)s___0);
#line 6164
      free((void *)s___0);
      }
    }
  }
  {
#line 6167
  perror_reply(425, (char *)"Can\'t open passive connection");
  }
#line 6168
  return;
}
}
#line 6177 "ftpd.c"
static char new[4096]  ;
#line 6175 "ftpd.c"
char *gunique(char *local ) 
{ struct stat st ;
  char *cp ;
  char *tmp ;
  int count ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 6179
  tmp = strrchr((char const   *)local, '/');
#line 6179
  cp = tmp;
#line 6180
  count = 0;
  }
#line 6182
  if (cp) {
#line 6183
    *cp = (char )'\000';
  }
#line 6184
  if (cp) {
#line 6184
    tmp___1 = (char const   *)local;
  } else {
#line 6184
    tmp___1 = ".";
  }
  {
#line 6184
  tmp___2 = stat((char const   */* __restrict  */)tmp___1, (struct stat */* __restrict  */)(& st));
  }
#line 6184
  if (tmp___2 < 0) {
#line 6185
    if (cp) {
#line 6185
      tmp___0 = (char const   *)local;
    } else {
#line 6185
      tmp___0 = ".";
    }
    {
#line 6185
    perror_reply(553, (char *)tmp___0);
    }
#line 6186
    return ((char *)0);
  }
#line 6188
  if (cp) {
#line 6189
    *cp = (char )'/';
  }
  {
#line 6190
  __builtin_strncpy(new, (char const   *)local, sizeof(new) - 3U);
#line 6191
  new[sizeof(new) - 3U] = (char )'\000';
#line 6192
  tmp___3 = strlen((char const   *)(new));
#line 6192
  cp = new + tmp___3;
#line 6193
  tmp___4 = cp;
#line 6193
  cp ++;
#line 6193
  *tmp___4 = (char )'.';
#line 6194
  count = 1;
  }
#line 6194
  while (count < 100) {
#line 6195
    if (count == 10) {
#line 6196
      cp -= 2;
#line 6197
      tmp___5 = cp;
#line 6197
      cp ++;
#line 6197
      *tmp___5 = (char )'.';
    }
    {
#line 6199
    sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"%d", count);
#line 6200
    tmp___6 = stat((char const   */* __restrict  */)(new), (struct stat */* __restrict  */)(& st));
    }
#line 6200
    if (tmp___6 < 0) {
#line 6201
      return (new);
    }
#line 6194
    count ++;
  }
  {
#line 6203
  reply(452, (char *)"Unique file name cannot be created.");
  }
#line 6204
  return ((char *)0);
}
}
#line 6209 "ftpd.c"
void perror_reply(int code , char *string ) 
{ size_t len ;
  size_t tmp ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int *tmp___26 ;
  char *tmp___27 ;

  {
#line 6215
  if (restricted_user) {
#line 6215
    if ((unsigned int )home != (unsigned int )((void *)0)) {
#line 6215
      if ((int )*(home + 0) != 0) {
        {
#line 6216
        tmp = strlen((char const   *)home);
#line 6216
        len = tmp;
        }
#line 6217
        if (0) {
#line 6217
          if (0) {
            {
#line 6217
            __s1_len___0 = strlen((char const   *)home);
#line 6217
            __s2_len___0 = strlen((char const   *)string);
            }
#line 6217
            if (! ((unsigned int )((void const   *)(home + 1)) - (unsigned int )((void const   *)home) == 1U)) {
              goto _L___2;
            } else {
#line 6217
              if (__s1_len___0 >= 4U) {
                _L___2: 
#line 6217
                if (! ((unsigned int )((void const   *)(string + 1)) - (unsigned int )((void const   *)string) == 1U)) {
#line 6217
                  tmp___23 = 1;
                } else {
#line 6217
                  if (__s2_len___0 >= 4U) {
#line 6217
                    tmp___23 = 1;
                  } else {
#line 6217
                    tmp___23 = 0;
                  }
                }
              } else {
#line 6217
                tmp___23 = 0;
              }
            }
#line 6217
            if (tmp___23) {
              {
#line 6217
              tmp___19 = __builtin_strcmp((char const   *)home, (char const   *)string);
              }
            } else {
              {
#line 6217
              tmp___22 = __builtin_strcmp((char const   *)home, (char const   *)string);
#line 6217
              tmp___19 = tmp___22;
              }
            }
          } else {
            {
#line 6217
            tmp___22 = __builtin_strcmp((char const   *)home, (char const   *)string);
#line 6217
            tmp___19 = tmp___22;
            }
          }
#line 6217
          tmp___13 = tmp___19;
        } else {
          {
#line 6217
          tmp___13 = strncmp((char const   *)home, (char const   *)string, len);
          }
        }
#line 6217
        if (tmp___13 == 0) {
#line 6218
          if ((int )*(string + (len - 1U)) == 47) {
#line 6219
            string += len - 1U;
          } else {
#line 6220
            if ((int )*(string + len) == 47) {
#line 6221
              string += len;
            } else {
#line 6222
              if ((int )*(string + len) == 0) {
#line 6223
                string = (char *)"/";
              }
            }
          }
        }
      }
    }
  }
  {
#line 6226
  tmp___26 = __errno_location();
#line 6226
  tmp___27 = strerror(*tmp___26);
#line 6226
  reply(code, (char *)"%s: %s.", string, tmp___27);
  }
#line 6227
  return;
}
}
#line 6229 "ftpd.c"
static char *onefile[2]  = {      (char *)"",      (char *)0};
#line 6233 "ftpd.c"
char *globerr  ;
#line 6238 "ftpd.c"
static FILE *dout___0  ;
#line 6239 "ftpd.c"
static DIR *dirp  ;
#line 6240 "ftpd.c"
static char **sdirlist  ;
#line 6241 "ftpd.c"
static char *wildcard  =    (char *)((void *)0);
#line 6235 "ftpd.c"
void send_file_list(char *whichfiles ) 
{ struct stat st ;
  register char **dirlist ;
  register char *dirname ;
  int simple ;
  char *tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  char *tmp___43 ;
  int *tmp___44 ;
  char *tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  char const   *tmp___79 ;
  size_t tmp___80 ;
  size_t tmp___81 ;
  size_t tmp___82 ;
  char **tmp___83 ;
  int tmp___84 ;

  {
#line 6246
  simple = 0;
#line 6255
  if (file_limit_raw_out > 0) {
#line 6255
    if (xfer_count_out >= file_limit_raw_out) {
      goto _L;
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
#line 6255
    if (file_limit_raw_total > 0) {
#line 6255
      if (xfer_count_total >= file_limit_raw_total) {
        goto _L;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 6255
      if (data_limit_raw_out > 0) {
#line 6255
        if (byte_count_out >= data_limit_raw_out) {
          goto _L;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
#line 6255
        if (data_limit_raw_total > 0) {
#line 6255
          if (byte_count_total >= data_limit_raw_total) {
            _L: 
#line 6259
            if (log_security) {
#line 6260
              if (anonymous) {
                {
#line 6261
                syslog(5, "anonymous(%s) of %s tried to list files (Transfer limits exceeded)",
                       guestpw, remoteident);
                }
              } else {
                {
#line 6264
                syslog(5, "%s of %s tried to list files (Transfer limits exceeded)",
                       pw->pw_name, remoteident);
                }
              }
            }
            {
#line 6266
            reply(553, (char *)"Permission denied on server. (Transfer limits exceeded)");
            }
#line 6267
            return;
          }
        }
      }
    }
  }
  {
#line 6272
  draconian_FILE = (FILE *)((void *)0);
#line 6273
  dout___0 = (FILE *)((void *)0);
#line 6274
  dirp = (DIR *)((void *)0);
#line 6275
  sdirlist = (char **)((void *)0);
#line 6276
  wildcard = (char *)((void *)0);
#line 6277
  tmp___43 = __builtin_strpbrk((char const   *)whichfiles, "~{[*?");
  }
#line 6277
  if ((unsigned int )tmp___43 == (unsigned int )((void *)0)) {
#line 6278
    if ((int )*(whichfiles + 0) == 0) {
      {
#line 6279
      tmp___8 = __strdup("*");
#line 6279
      wildcard = tmp___8;
      }
#line 6280
      if ((unsigned int )wildcard == (unsigned int )((void *)0)) {
        {
#line 6281
        reply(550, (char *)"Memory allocation error");
        }
        goto globfree;
      }
#line 6284
      whichfiles = wildcard;
    } else {
      {
#line 6286
      tmp___11 = stat((char const   */* __restrict  */)whichfiles, (struct stat */* __restrict  */)(& st));
      }
#line 6286
      if (tmp___11 >= 0) {
#line 6287
        if ((st.st_mode & 61440U) == 16384U) {
          {
#line 6288
          tmp___9 = strlen((char const   *)whichfiles);
#line 6288
          tmp___10 = malloc(tmp___9 + 3U);
#line 6288
          wildcard = (char *)tmp___10;
          }
#line 6289
          if ((unsigned int )wildcard == (unsigned int )((void *)0)) {
            {
#line 6290
            reply(550, (char *)"Memory allocation error");
            }
            goto globfree;
          }
          {
#line 6293
          strcpy((char */* __restrict  */)wildcard, (char const   */* __restrict  */)whichfiles);
#line 6294
          strcat((char */* __restrict  */)wildcard, (char const   */* __restrict  */)"/*");
#line 6295
          whichfiles = wildcard;
          }
        }
      }
    }
  }
  {
#line 6299
  tmp___76 = __builtin_strpbrk((char const   *)whichfiles, "~{[*?");
  }
#line 6299
  if ((unsigned int )tmp___76 != (unsigned int )((void *)0)) {
    {
#line 6300
    globerr = (char *)((void *)0);
#line 6301
    dirlist = ftpglob(whichfiles);
#line 6302
    sdirlist = dirlist;
    }
#line 6303
    if ((unsigned int )globerr != (unsigned int )((void *)0)) {
      {
#line 6304
      reply(550, globerr);
      }
      goto globfree;
    } else {
#line 6307
      if ((unsigned int )dirlist == (unsigned int )((void *)0)) {
        {
#line 6308
        tmp___44 = __errno_location();
#line 6308
        *tmp___44 = 2;
#line 6309
        perror_reply(550, whichfiles);
        }
        goto globfree;
      }
    }
  } else {
#line 6314
    onefile[0] = whichfiles;
#line 6315
    dirlist = onefile;
#line 6316
    simple = 1;
  }
  {
#line 6319
  tmp___77 = __sigsetjmp(urgcatch, 1);
  }
#line 6319
  if (tmp___77) {
#line 6320
    transflag = 0;
#line 6321
    if ((unsigned int )dout___0 != (unsigned int )((void *)0)) {
      {
#line 6322
      fclose(dout___0);
      }
    }
#line 6323
    if ((unsigned int )dirp != (unsigned int )((void *)0)) {
      {
#line 6324
      closedir(dirp);
      }
    }
#line 6325
    data = -1;
#line 6326
    pdata = -1;
    goto globfree;
  }
#line 6329
  while (1) {
#line 6329
    tmp___83 = dirlist;
#line 6329
    dirlist ++;
#line 6329
    dirname = *tmp___83;
#line 6329
    if (! ((unsigned int )dirname != (unsigned int )((void *)0))) {
#line 6329
      break;
    }
    {
#line 6330
    tmp___78 = stat((char const   */* __restrict  */)dirname, (struct stat */* __restrict  */)(& st));
    }
#line 6330
    if (tmp___78 < 0) {
#line 6333
      if ((int )*(dirname + 0) == 45) {
#line 6333
        if ((unsigned int )*dirlist == (unsigned int )((void *)0)) {
#line 6333
          if (transflag == 0) {
            {
#line 6334
            retrieve_is_data = 0;
#line 6336
            retrieve(ls_plain, dirname);
#line 6340
            retrieve_is_data = 1;
            }
            goto globfree;
          }
        }
      }
      {
#line 6343
      perror_reply(550, dirname);
      }
#line 6344
      if ((unsigned int )dout___0 != (unsigned int )((void *)0)) {
        {
#line 6345
        fclose(dout___0);
#line 6346
        transflag = 0;
#line 6347
        data = -1;
#line 6348
        pdata = -1;
        }
      }
      goto globfree;
    }
#line 6352
    if ((st.st_mode & 61440U) != 16384U) {
#line 6353
      if ((unsigned int )dout___0 == (unsigned int )((void *)0)) {
        {
#line 6354
        dout___0 = dataconn((char *)"file list", -1L, (char *)"w");
        }
#line 6355
        if ((unsigned int )dout___0 == (unsigned int )((void *)0)) {
          goto globfree;
        }
#line 6357
        transflag ++;
#line 6358
        draconian_FILE = dout___0;
      }
#line 6360
      if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
        {
#line 6361
        signal(14, & draconian_alarm_signal);
#line 6362
        alarm(timeout_data);
        }
#line 6363
        if (type == 1) {
#line 6363
          tmp___79 = "\r";
        } else {
#line 6363
          tmp___79 = "";
        }
        {
#line 6363
        fprintf((FILE */* __restrict  */)dout___0, (char const   */* __restrict  */)"%s%s\n",
                dirname, tmp___79);
        }
      }
      {
#line 6366
      tmp___80 = strlen((char const   *)dirname);
#line 6366
      byte_count = (long )((unsigned long )byte_count + (unsigned long )(tmp___80 + 1U));
#line 6368
      tmp___81 = strlen((char const   *)dirname);
#line 6368
      byte_count_total = (int )((unsigned int )byte_count_total + (tmp___81 + 1U));
#line 6369
      tmp___82 = strlen((char const   *)dirname);
#line 6369
      byte_count_out = (int )((unsigned int )byte_count_out + (tmp___82 + 1U));
      }
#line 6370
      if (type == 1) {
#line 6371
        byte_count_total ++;
#line 6372
        byte_count_out ++;
      }
    }
  }
#line 6378
  if ((unsigned int )dout___0 != (unsigned int )((void *)0)) {
#line 6379
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 6380
      signal(14, & draconian_alarm_signal);
#line 6381
      alarm(timeout_data);
#line 6382
      fflush(dout___0);
      }
    }
#line 6384
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 6385
      signal(14, & draconian_alarm_signal);
#line 6386
      alarm(timeout_data);
#line 6387
      socket_flush_wait(dout___0);
      }
    }
  }
#line 6390
  if ((unsigned int )dout___0 == (unsigned int )((void *)0)) {
    {
#line 6391
    reply(550, (char *)"No files found.");
    }
  } else {
#line 6392
    if ((unsigned int )draconian_FILE == (unsigned int )((void *)0)) {
      {
#line 6393
      alarm(0U);
#line 6394
      perror_reply(550, (char *)"Data connection");
      }
    } else {
      {
#line 6392
      tmp___84 = ferror(dout___0);
      }
#line 6392
      if (tmp___84 != 0) {
        {
#line 6393
        alarm(0U);
#line 6394
        perror_reply(550, (char *)"Data connection");
        }
      } else {
        {
#line 6398
        xfer_count_total ++;
#line 6399
        xfer_count_out ++;
#line 6401
        alarm(0U);
#line 6402
        reply(226, (char *)"Transfer complete.");
        }
      }
    }
  }
#line 6405
  transflag = 0;
#line 6406
  if ((unsigned int )dout___0 != (unsigned int )((void *)0)) {
#line 6406
    if ((unsigned int )draconian_FILE != (unsigned int )((void *)0)) {
      {
#line 6407
      fclose(dout___0);
      }
    }
  }
#line 6408
  data = -1;
#line 6409
  pdata = -1;
  globfree: 
#line 6411
  if ((unsigned int )wildcard != (unsigned int )((void *)0)) {
    {
#line 6412
    free((void *)wildcard);
#line 6413
    wildcard = (char *)((void *)0);
    }
  }
#line 6415
  if (sdirlist) {
    {
#line 6416
    blkfree(sdirlist);
#line 6417
    free((void *)((char *)sdirlist));
    }
  }
#line 6419
  return;
}
}
#line 6512 "ftpd.c"
char **Argv  =    (char **)((void *)0);
#line 6516 "ftpd.c"
char *LastArgv  =    (char *)((void *)0);
#line 6531
extern char **environ ;
#line 6523 "ftpd.c"
void initsetproctitle(int argc , char **argv , char **envp ) 
{ register int i ;
  register int envpsize ;
  char **newenviron ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int err ;
  char *tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;

  {
  {
#line 6529
  envpsize = 0;
#line 6537
  tmp = strlen((char const   *)*(argv + (argc - 1)));
#line 6537
  LastArgv = *(argv + (argc - 1)) + tmp;
  }
#line 6538
  if ((unsigned int )envp != (unsigned int )((void *)0)) {
#line 6543
    i = 0;
#line 6543
    while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
      {
#line 6544
      tmp___0 = strlen((char const   *)*(envp + i));
#line 6544
      envpsize = (int )((unsigned int )envpsize + (tmp___0 + 1U));
#line 6543
      i ++;
      }
    }
    {
#line 6545
    tmp___1 = malloc(sizeof(char *) * (unsigned int )(i + 1));
#line 6545
    newenviron = (char **)tmp___1;
    }
#line 6546
    if (newenviron) {
#line 6547
      err = 0;
#line 6548
      i = 0;
#line 6548
      while ((unsigned int )*(envp + i) != (unsigned int )((void *)0)) {
        {
#line 6549
        tmp___11 = __strdup((char const   *)*(envp + i));
#line 6549
        *(newenviron + i) = tmp___11;
        }
#line 6549
        if ((unsigned int )*(newenviron + i) == (unsigned int )((void *)0)) {
#line 6550
          err = 1;
#line 6551
          break;
        }
#line 6548
        i ++;
      }
#line 6554
      if (err) {
#line 6555
        i = 0;
#line 6555
        while ((unsigned int )*(newenviron + i) != (unsigned int )((void *)0)) {
          {
#line 6556
          free((void *)*(newenviron + i));
#line 6555
          i ++;
          }
        }
        {
#line 6557
        free((void *)newenviron);
#line 6558
        i = 0;
        }
      } else {
#line 6561
        *(newenviron + i) = (char *)((void *)0);
#line 6562
        environ = newenviron;
      }
    } else {
#line 6566
      i = 0;
    }
#line 6573
    while (1) {
#line 6573
      if (i > 0) {
#line 6573
        if (! ((unsigned int )*(envp + (i - 1)) < (unsigned int )*(argv + 0))) {
          {
#line 6573
          tmp___12 = strlen((char const   *)*(argv + (argc - 1)));
          }
#line 6573
          if (! ((unsigned int )*(envp + (i - 1)) > (unsigned int )(((*(argv + (argc - 1)) + tmp___12) + 1) + envpsize))) {
#line 6573
            break;
          }
        }
      } else {
#line 6573
        break;
      }
#line 6576
      i --;
    }
#line 6578
    if (i > 0) {
      {
#line 6579
      tmp___13 = strlen((char const   *)*(envp + (i - 1)));
#line 6579
      LastArgv = *(envp + (i - 1)) + tmp___13;
      }
    }
  }
#line 6584
  Argv = argv;
#line 6586
  return;
}
}
#line 6592 "ftpd.c"
void setproctitle(char const   *fmt  , ...) 
{ register char *p ;
  register int i ;
  char buf___2[2048] ;
  va_list ap ;
  size_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 6613
  p = buf___2;
#line 6616
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)"ftpd: ");
#line 6617
  tmp = strlen((char const   *)p);
#line 6617
  p += tmp;
#line 6620
  __builtin_va_start(ap, fmt);
#line 6621
  vsnprintf((char */* __restrict  */)p, sizeof(buf___2) - (unsigned int )(p - buf___2),
            (char const   */* __restrict  */)fmt, ap);
#line 6622
  __builtin_va_end(ap);
#line 6624
  tmp___0 = strlen((char const   *)(buf___2));
#line 6624
  i = (int )tmp___0;
  }
#line 6676
  if (i > (LastArgv - *(Argv + 0)) - 2) {
#line 6677
    i = (LastArgv - *(Argv + 0)) - 2;
#line 6678
    buf___2[i] = (char )'\000';
  }
  {
#line 6680
  strcpy((char */* __restrict  */)*(Argv + 0), (char const   */* __restrict  */)(buf___2));
#line 6681
  p = *(Argv + 0) + i;
  }
#line 6682
  while ((unsigned int )p < (unsigned int )LastArgv) {
#line 6683
    tmp___1 = p;
#line 6683
    p ++;
#line 6683
    *tmp___1 = (char )' ';
  }
#line 6684
  *(Argv + 1) = (char *)((void *)0);
#line 6691
  return;
}
}
#line 6877 "ftpd.c"
static unsigned long acl_DaemonAddress(void) 
{ unsigned long rv ;
  struct aclmember *entry ;
  in_addr_t tmp ;
  struct aclmember *tmp___0 ;

  {
  {
#line 6879
  rv = 0UL;
#line 6880
  entry = (struct aclmember *)((void *)0);
#line 6882
  tmp___0 = getaclentry((char *)"daemonaddress", & entry);
  }
#line 6882
  if (tmp___0) {
#line 6882
    if (entry->arg[0]) {
      {
#line 6883
      tmp = inet_addr((char const   *)entry->arg[0]);
#line 6883
      rv = (unsigned long )tmp;
      }
#line 6884
      if (rv == 4294967295UL) {
#line 6885
        rv = 0UL;
      }
    }
  }
#line 6887
  return (rv);
}
}
#line 6891 "ftpd.c"
void do_daemon(int argc , char **argv , char **envp ) 
{ struct sockaddr_in server ;
  struct servent *serv ;
  int pgrp ;
  int lsock ;
  int one ;
  FILE *pidfile ;
  int i ;
  __pid_t tmp ;
  int i___0 ;
  int fds___0 ;
  struct rlimit rlp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp___5 ;
  int pid ;
  int msgsock ;

  {
#line 6897
  one = 1;
#line 6903
  if (be_daemon == 2) {
    {
#line 6905
    i = fork();
    }
#line 6906
    if (i < 0) {
      {
#line 6907
      syslog(3, "cant fork %m");
#line 6908
      exit(1);
      }
    }
#line 6911
    if (i > 0) {
      {
#line 6912
      exit(0);
      }
    }
    {
#line 6917
    pgrp = setsid();
    }
#line 6919
    if (pgrp < 0) {
      {
#line 6920
      syslog(3, "cannot daemonise: %m");
#line 6921
      exit(1);
      }
    }
  }
#line 6925
  if (! Bypass_PID_Files) {
    {
#line 6926
    pidfile = fopen((char const   */* __restrict  */)"/var/run/ftpd.pid", (char const   */* __restrict  */)"w");
    }
#line 6926
    if (pidfile) {
      {
#line 6927
      tmp = getpid();
#line 6927
      fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%ld\n",
              (long )tmp);
#line 6928
      fclose(pidfile);
      }
    } else {
      {
#line 6931
      syslog(3, "Cannot write pidfile: %m");
      }
    }
  }
#line 6935
  if (be_daemon == 2) {
    {
#line 6940
    rlp.rlim_max = ~ 0UL;
#line 6940
    rlp.rlim_cur = rlp.rlim_max;
#line 6941
    tmp___0 = getrlimit(7, & rlp);
    }
#line 6941
    if (tmp___0) {
#line 6942
      return;
    }
    {
#line 6943
    fds___0 = (int )rlp.rlim_cur;
#line 6957
    closelog();
#line 6958
    i___0 = 0;
    }
#line 6958
    while (i___0 <= fds___0) {
      {
#line 6959
      close(i___0);
#line 6958
      i___0 ++;
      }
    }
    {
#line 6962
    openlog("ftpd", 9, 11 << 3);
#line 6968
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stderr);
    }
  }
#line 6971
  if ((unsigned int )RootDirectory != (unsigned int )((void *)0)) {
    {
#line 6972
    tmp___1 = chroot((char const   *)RootDirectory);
    }
#line 6972
    if (tmp___1 < 0) {
      {
#line 6974
      syslog(3, "Cannot chroot to initial directory, aborting.");
#line 6975
      exit(1);
      }
    } else {
      {
#line 6972
      tmp___2 = mapping_chdir((char *)"/");
      }
#line 6972
      if (tmp___2 < 0) {
        {
#line 6974
        syslog(3, "Cannot chroot to initial directory, aborting.");
#line 6975
        exit(1);
        }
      }
    }
    {
#line 6977
    free((void *)RootDirectory);
#line 6978
    RootDirectory = (char *)((void *)0);
    }
  }
#line 6981
  if (! use_accessfile) {
    {
#line 6982
    syslog(4, "FTP server started without ftpaccess file");
    }
  }
  {
#line 6984
  syslog(6, "FTP server (%s) ready.", version);
#line 6987
  lsock = socket(2, 1, 6);
  }
#line 6988
  if (lsock < 0) {
    {
#line 6989
    syslog(3, "Cannot create socket to listen on: %m");
#line 6990
    exit(1);
    }
  }
  {
#line 6992
  tmp___3 = setsockopt(lsock, 1, 2, (void const   *)((char *)(& one)), sizeof(one));
  }
#line 6992
  if (tmp___3 < 0) {
    {
#line 6993
    syslog(3, "Cannot set SO_REUSEADDR option: %m");
#line 6994
    exit(1);
    }
  }
#line 6996
  if (keepalive) {
    {
#line 6997
    setsockopt(lsock, 1, 9, (void const   *)((char *)(& one)), sizeof(one));
    }
  }
  {
#line 6999
  server.sin_family = (unsigned short)2;
#line 7000
  tmp___4 = acl_DaemonAddress();
#line 7000
  server.sin_addr.s_addr = (unsigned int )tmp___4;
  }
#line 7001
  if (daemon_port == 0) {
    {
#line 7002
    serv = getservbyname("ftp", "tcp");
    }
#line 7002
    if (! serv) {
      {
#line 7003
      syslog(3, "Cannot find service ftp: %m");
#line 7004
      exit(1);
      }
    }
#line 7006
    server.sin_port = (unsigned short )serv->s_port;
#line 7007
    __x = (unsigned short )serv->s_port;
#line 7007
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 7007
    daemon_port = (int )__v;
  } else {
#line 7010
    __x___0 = (unsigned short )daemon_port;
#line 7010
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 7010
    server.sin_port = __v___0;
  }
  {
#line 7012
  tmp___5 = bind(lsock, (struct sockaddr  const  *)((struct sockaddr *)(& server)),
                 sizeof(server));
  }
#line 7012
  if (tmp___5 < 0) {
    {
#line 7013
    syslog(3, "Cannot bind socket: %m");
#line 7014
    exit(1);
    }
  }
  {
#line 7017
  listen(lsock, 100);
#line 7019
  sprintf((char */* __restrict  */)(proctitle), (char const   */* __restrict  */)"accepting connections on port %i",
          daemon_port);
#line 7020
  setproctitle("%s", proctitle);
  }
#line 7022
  while (1) {
    {
#line 7026
    msgsock = accept(lsock, (struct sockaddr */* __restrict  */)0, (socklen_t */* __restrict  */)0);
    }
#line 7027
    if (msgsock < 0) {
      {
#line 7028
      syslog(3, "Accept failed: %m");
#line 7029
      sleep(1U);
      }
#line 7030
      continue;
    }
#line 7032
    if (keepalive) {
      {
#line 7033
      setsockopt(msgsock, 1, 9, (void const   *)((char *)(& one)), sizeof(one));
      }
    }
    {
#line 7036
    pid = fork();
    }
#line 7037
    if (pid < 0) {
      {
#line 7038
      syslog(3, "failed to fork: %m");
#line 7039
      sleep(1U);
      }
#line 7040
      continue;
    }
#line 7042
    if (pid == 0) {
      {
#line 7044
      closelog();
#line 7046
      dup2(msgsock, 0);
#line 7047
      dup2(msgsock, 1);
      }
#line 7049
      if (lsock != 0) {
#line 7049
        if (lsock != 1) {
          {
#line 7050
          close(lsock);
          }
        }
      }
      {
#line 7052
      openlog("ftpd", 9, 11 << 3);
      }
#line 7056
      return;
    }
    {
#line 7060
    close(msgsock);
    }
#line 7064
    while (1) {
      {
#line 7064
      pid = waitpid(-1, (int *)0, 1);
      }
#line 7064
      if (! (pid > 0)) {
#line 7064
        break;
      }
    }
  }
}
}
#line 7072 "ftpd.c"
int pasv_allowed(char *remoteaddr___0 ) 
{ char class[4096] ;
  int which ;
  struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
  {
#line 7076
  entry = (struct aclmember *)((void *)0);
#line 7077
  acl_getclass(class);
  }
#line 7078
  while (1) {
    {
#line 7078
    tmp___1 = getaclentry((char *)"pasv-allow", & entry);
    }
#line 7078
    if (! tmp___1) {
#line 7078
      break;
    }
#line 7079
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
      {
#line 7079
      tmp___0 = strcasecmp((char const   *)(class), (char const   *)entry->arg[0]);
      }
#line 7079
      if (tmp___0 == 0) {
#line 7080
        which = 1;
#line 7080
        while (1) {
#line 7080
          if (which < 50) {
#line 7080
            if (! ((unsigned int )entry->arg[which] != (unsigned int )((void *)0))) {
#line 7080
              break;
            }
          } else {
#line 7080
            break;
          }
          {
#line 7081
          tmp = hostmatch(entry->arg[which], remoteaddr___0, (char *)((void *)0));
          }
#line 7081
          if (tmp) {
#line 7082
            return (1);
          }
#line 7080
          which ++;
        }
      }
    }
  }
#line 7085
  return (0);
}
}
#line 7088 "ftpd.c"
int port_allowed(char *remoteaddr___0 ) 
{ char class[4096] ;
  int which ;
  struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
  {
#line 7092
  entry = (struct aclmember *)((void *)0);
#line 7093
  acl_getclass(class);
  }
#line 7094
  while (1) {
    {
#line 7094
    tmp___1 = getaclentry((char *)"pasv-allow", & entry);
    }
#line 7094
    if (! tmp___1) {
#line 7094
      break;
    }
#line 7095
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
      {
#line 7095
      tmp___0 = strcasecmp((char const   *)(class), (char const   *)entry->arg[0]);
      }
#line 7095
      if (tmp___0 == 0) {
#line 7096
        which = 1;
#line 7096
        while (1) {
#line 7096
          if (which < 50) {
#line 7096
            if (! ((unsigned int )entry->arg[which] != (unsigned int )((void *)0))) {
#line 7096
              break;
            }
          } else {
#line 7096
            break;
          }
          {
#line 7097
          tmp = hostmatch(entry->arg[which], remoteaddr___0, (char *)((void *)0));
          }
#line 7097
          if (tmp) {
#line 7098
            return (1);
          }
#line 7096
          which ++;
        }
      }
    }
  }
#line 7101
  return (0);
}
}
#line 7105 "ftpd.c"
char *email(char *full_address ) 
{ char *addr ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;
  char *tmp___9 ;
  char *tmp___11 ;

  {
  {
#line 7112
  tmp = strlen((char const   *)full_address);
#line 7112
  tmp___0 = malloc(tmp + 1U);
#line 7112
  addr = (char *)tmp___0;
#line 7113
  tmp___1 = strlen((char const   *)full_address);
#line 7113
  memset((void *)addr, 0, tmp___1 + 1U);
#line 7114
  strcpy((char */* __restrict  */)addr, (char const   */* __restrict  */)full_address);
#line 7117
  tmp___7 = __builtin_strchr(addr, '<');
  }
#line 7117
  if ((unsigned int )tmp___7 != (unsigned int )((void *)0)) {
    {
#line 7118
    tmp___3 = __builtin_strchr(addr, '<');
#line 7118
    addr = tmp___3 + 1;
#line 7119
    tmp___5 = __builtin_strchr(addr, '>');
#line 7119
    *(addr + (tmp___5 - addr)) = (char )'\000';
    }
  }
  {
#line 7123
  tmp___11 = __builtin_strchr(addr, ' ');
  }
#line 7123
  if ((unsigned int )tmp___11 != (unsigned int )((void *)0)) {
    {
#line 7124
    tmp___9 = __builtin_strchr(addr, ' ');
#line 7124
    *(addr + (tmp___9 - addr)) = (char )'\000';
    }
  }
#line 7126
  return (addr);
}
}
#line 7129 "ftpd.c"
FILE *SockOpen(char *host , int clientPort ) 
{ int sock ;
  unsigned long inaddr ;
  struct sockaddr_in ad ;
  struct hostent *hp ;
  FILE *fp ;
  in_addr_t tmp ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___0 ;

  {
  {
#line 7137
  memset((void *)(& ad), 0, sizeof(ad));
#line 7138
  ad.sin_family = (unsigned short)2;
#line 7140
  tmp = inet_addr((char const   *)host);
#line 7140
  inaddr = (unsigned long )tmp;
  }
#line 7141
  if (inaddr != 4294967295UL) {
    {
#line 7142
    memcpy((void */* __restrict  */)(& ad.sin_addr), (void const   */* __restrict  */)(& inaddr),
           sizeof(inaddr));
    }
  } else {
    {
#line 7144
    hp = gethostbyname((char const   *)host);
    }
#line 7145
    if ((unsigned int )hp == (unsigned int )((void *)0)) {
#line 7146
      return ((FILE *)((void *)0));
    }
    {
#line 7147
    memcpy((void */* __restrict  */)(& ad.sin_addr), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
           (unsigned int )hp->h_length);
    }
  }
  {
#line 7149
  __x = (unsigned short )clientPort;
#line 7149
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 7149
  ad.sin_port = __v;
#line 7151
  sock = socket(2, 1, 0);
  }
#line 7152
  if (sock < 0) {
#line 7153
    return ((FILE *)((void *)0));
  }
  {
#line 7154
  tmp___0 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& ad)),
                    sizeof(ad));
  }
#line 7154
  if (tmp___0 < 0) {
    {
#line 7155
    close(sock);
    }
#line 7156
    return ((FILE *)((void *)0));
  }
  {
#line 7158
  fp = fdopen(sock, "r+");
#line 7159
  setvbuf((FILE */* __restrict  */)fp, (char */* __restrict  */)((void *)0), 1, 2048U);
  }
#line 7160
  return (fp);
}
}
#line 7163 "ftpd.c"
int SockPrintf(FILE *sockfp , char *format  , ...) 
{ va_list ap ;
  char buf___2[32768] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 7168
  __builtin_va_start(ap, format);
#line 7169
  vsprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)format,
           ap);
#line 7170
  __builtin_va_end(ap);
#line 7171
  tmp = strlen((char const   *)(buf___2));
#line 7171
  tmp___0 = SockWrite(buf___2, 1, (int )tmp, sockfp);
  }
#line 7171
  return (tmp___0);
}
}
#line 7174 "ftpd.c"
int SockWrite(char *buf___2 , int size , int len , FILE *sockfp ) 
{ size_t tmp ;

  {
  {
#line 7176
  tmp = fwrite((void const   */* __restrict  */)buf___2, (unsigned int )size, (unsigned int )len,
               (FILE */* __restrict  */)sockfp);
  }
#line 7176
  return ((int )tmp);
}
}
#line 7179 "ftpd.c"
char *SockGets(FILE *sockfp , char *buf___2 , int len ) 
{ char *tmp ;

  {
  {
#line 7181
  tmp = fgets((char */* __restrict  */)buf___2, len, (FILE */* __restrict  */)sockfp);
  }
#line 7181
  return (tmp);
}
}
#line 7184 "ftpd.c"
int SockPuts(FILE *sockfp , char *buf___2 ) 
{ int rc ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 7188
  tmp = strlen((char const   *)buf___2);
#line 7188
  rc = SockWrite(buf___2, 1, (int )tmp, sockfp);
  }
#line 7188
  if (rc) {
#line 7189
    return (rc);
  }
  {
#line 7190
  tmp___0 = SockWrite((char *)"\r\n", 1, 2, sockfp);
  }
#line 7190
  return (tmp___0);
}
}
#line 7193 "ftpd.c"
int Reply(FILE *sockfp ) 
{ char *reply___0 ;
  char *rec ;
  char *separator ;
  int ret ;
  void *tmp ;
  long tmp___0 ;

  {
  {
#line 7196
  ret = 0;
#line 7198
  tmp = malloc(1024U);
#line 7198
  reply___0 = (char *)tmp;
#line 7199
  memset((void *)reply___0, 0, 1024U);
  }
#line 7200
  while (1) {
    {
#line 7201
    rec = SockGets(sockfp, reply___0, 1024);
    }
#line 7202
    if ((unsigned int )rec != (unsigned int )((void *)0)) {
      {
#line 7203
      tmp___0 = strtol((char const   */* __restrict  */)reply___0, (char **/* __restrict  */)(& separator),
                       10);
#line 7203
      ret = (int )tmp___0;
      }
    } else {
#line 7206
      ret = 250;
    }
#line 7200
    if ((unsigned int )rec != (unsigned int )((void *)0)) {
#line 7200
      if (! ((int )*(separator + 0) != 32)) {
#line 7200
        break;
      }
    } else {
#line 7200
      break;
    }
  }
#line 7208
  return (ret);
}
}
#line 7211 "ftpd.c"
int Send(FILE *sockfp , char *format  , ...) 
{ va_list ap ;
  char buf___2[32728] ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 7216
  __builtin_va_start(ap, format);
#line 7217
  vsprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)format,
           ap);
#line 7218
  __builtin_va_end(ap);
#line 7219
  tmp = strlen((char const   *)(buf___2));
#line 7219
  SockWrite(buf___2, 1, (int )tmp, sockfp);
#line 7220
  tmp___0 = Reply(sockfp);
  }
#line 7220
  return (tmp___0);
}
}
#line 7234 "ftpd.c"
void fixpath(char *path ) 
{ int abs___0 ;
  char *in ;
  char *out ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 7236
  abs___0 = 0;
#line 7240
  if ((int )*path == 47) {
#line 7241
    abs___0 = 1;
#line 7242
    path ++;
  } else {
#line 7244
    if ((int )*path == 126) {
#line 7245
      while (1) {
#line 7246
        path ++;
#line 7245
        if ((int )*path != 0) {
#line 7245
          if (! ((int )*path != 47)) {
#line 7245
            break;
          }
        } else {
#line 7245
          break;
        }
      }
#line 7248
      if ((int )*path == 47) {
#line 7249
        path ++;
      }
    }
  }
#line 7251
  in = path;
#line 7252
  out = path;
#line 7253
  while ((int )*in != 0) {
#line 7254
    if ((int )*in == 47) {
#line 7255
      in ++;
    } else {
#line 7256
      if ((int )*(in + 0) == 46) {
#line 7256
        if ((int )*(in + 1) == 47) {
          goto _L___3;
        } else {
#line 7256
          if ((int )*(in + 1) == 0) {
            _L___3: 
#line 7257
            in ++;
#line 7258
            if ((int )*in == 47) {
#line 7259
              in ++;
            }
          } else {
            goto _L___2;
          }
        }
      } else {
        _L___2: 
#line 7261
        if ((int )*(in + 0) == 46) {
#line 7261
          if ((int )*(in + 1) == 46) {
#line 7261
            if ((int )*(in + 2) == 47) {
              goto _L___0;
            } else {
#line 7261
              if ((int )*(in + 2) == 0) {
                _L___0: 
#line 7262
                if ((unsigned int )out == (unsigned int )path) {
#line 7263
                  if (abs___0) {
#line 7264
                    in ++;
#line 7265
                    in ++;
#line 7266
                    if ((int )*in == 47) {
#line 7267
                      in ++;
                    }
                  } else {
#line 7270
                    tmp = out;
#line 7270
                    out ++;
#line 7270
                    tmp___0 = in;
#line 7270
                    in ++;
#line 7270
                    *tmp = *tmp___0;
#line 7271
                    tmp___1 = out;
#line 7271
                    out ++;
#line 7271
                    tmp___2 = in;
#line 7271
                    in ++;
#line 7271
                    *tmp___1 = *tmp___2;
#line 7272
                    if ((int )*in == 47) {
#line 7273
                      tmp___3 = out;
#line 7273
                      out ++;
#line 7273
                      tmp___4 = in;
#line 7273
                      in ++;
#line 7273
                      *tmp___3 = *tmp___4;
                    }
#line 7274
                    path = out;
                  }
                } else {
#line 7278
                  out --;
#line 7279
                  while (1) {
#line 7279
                    if ((unsigned int )out != (unsigned int )path) {
#line 7279
                      out --;
#line 7279
                      if (! ((int )*out != 47)) {
#line 7279
                        break;
                      }
                    } else {
#line 7279
                      break;
                    }
                  }
#line 7280
                  in ++;
#line 7281
                  in ++;
#line 7282
                  if ((int )*in == 47) {
#line 7283
                    in ++;
                  }
                }
              } else {
                goto _L___1;
              }
            }
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
#line 7287
          while (1) {
#line 7288
            tmp___5 = out;
#line 7288
            out ++;
#line 7288
            tmp___6 = in;
#line 7288
            in ++;
#line 7288
            *tmp___5 = *tmp___6;
#line 7287
            if ((int )*in != 0) {
#line 7287
              if (! ((int )*in != 47)) {
#line 7287
                break;
              }
            } else {
#line 7287
              break;
            }
          }
#line 7290
          if ((int )*in == 47) {
#line 7291
            tmp___7 = out;
#line 7291
            out ++;
#line 7291
            tmp___8 = in;
#line 7291
            in ++;
#line 7291
            *tmp___7 = *tmp___8;
          }
        }
      }
    }
  }
#line 7294
  *out = (char )'\000';
#line 7295
  return;
}
}
#line 1 "ftpcmd.o"
/* #pragma merger(0,"/tmp/cil-v7tOWLxe.i","-g,-O2") */
#line 485 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__)) ;
#line 20 "ftpcmd.c"
static int yygrowstack(void) ;
#line 668 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int getgroups(int __size , __gid_t *__list ) ;
#line 282 "/usr/include/sys/stat.h"
extern  __attribute__((__nothrow__)) int chmod(char const   *__file , __mode_t __mode )  __attribute__((__nonnull__(1))) ;
#line 83 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
#line 85
extern  __attribute__((__nothrow__)) __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
#line 116
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 119
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 190
__inline static  __attribute__((__nothrow__)) int tolower(int __c ) ;
#line 190 "/usr/include/ctype.h"
__inline static int tolower(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 193
  if (__c >= -128) {
#line 193
    if (__c < 256) {
      {
#line 193
      tmp___1 = __ctype_tolower_loc();
#line 193
      tmp___0 = (int )*(*tmp___1 + __c);
      }
    } else {
#line 193
      tmp___0 = (int )((int const   )__c);
    }
  } else {
#line 193
    tmp___0 = (int )((int const   )__c);
  }
#line 193
  return (tmp___0);
}
}
#line 196
__inline static  __attribute__((__nothrow__)) int toupper(int __c ) ;
#line 196 "/usr/include/ctype.h"
__inline static int toupper(int __c ) 
{ __int32_t tmp___0 ;
  __int32_t const   **tmp___1 ;

  {
#line 199
  if (__c >= -128) {
#line 199
    if (__c < 256) {
      {
#line 199
      tmp___1 = __ctype_toupper_loc();
#line 199
      tmp___0 = (int )*(*tmp___1 + __c);
      }
    } else {
#line 199
      tmp___0 = (int )((int const   )__c);
    }
  } else {
#line 199
    tmp___0 = (int )((int const   )__c);
  }
#line 199
  return (tmp___0);
}
}
#line 82 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 232 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *gmtime(time_t const   *__timer ) ;
#line 103 "proto.h"
void newer(char *date , char *path , int showlots ) ;
#line 121
void SetCheckMethod(char const   *method ) ;
#line 122
void ShowCheckMethod(void) ;
#line 123
void CheckSum(char *pathname ) ;
#line 124
void CheckSumLastFile(void) ;
#line 132
char *copy(char *s ) ;
#line 133
void sizecmd(char *filename ) ;
#line 134
void site_exec(char *cmd ) ;
#line 135
void alias(char *s ) ;
#line 136
void cdpath(void) ;
#line 137
void print_groups(void) ;
#line 248
void priv_group(char *group ) ;
#line 249
void priv_gpass(char *gpass ) ;
#line 265
int restrict_check(char *name ) ;
#line 266
int test_restriction(char *name ) ;
#line 267
int restrict_list_check(char *name ) ;
#line 121 "ftpcmd.y"
int virtual_ftpaccess ;
#line 126 "ftpcmd.y"
static int alarm_running  =    0;
#line 129 "ftpcmd.y"
static unsigned short cliport  =    (unsigned short)0;
#line 130 "ftpcmd.y"
static struct in_addr cliaddr  ;
#line 131 "ftpcmd.y"
static int cmd_type  ;
#line 132 "ftpcmd.y"
static int cmd_form  ;
#line 133 "ftpcmd.y"
static int cmd_bytesz  ;
#line 135 "ftpcmd.y"
char *fromname  ;
#line 147
struct tab cmdtab[48] ;
#line 148
struct tab sitetab[16] ;
#line 150
static void toolong(int a ) ;
#line 151
void help(struct tab *ctab , char *s ) ;
#line 152
struct tab *lookup(struct tab *p , char *cmd ) ;
#line 153
int yylex(void) ;
#line 155 "ftpcmd.y"
static char *nullstr  =    (char *)"(null)";
#line 232 "y.tab.c"
short yylhs[93]  = 
#line 232 "y.tab.c"
  {      (short)-1,      (short)0,      (short)0,      (short)0, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)12,      (short)12,      (short)12,      (short)12, 
        (short)13,      (short)13,      (short)13,      (short)13, 
        (short)13,      (short)13,      (short)13,      (short)13, 
        (short)13,      (short)13,      (short)4,      (short)1, 
        (short)1,      (short)6,      (short)14,      (short)8, 
        (short)8,      (short)8,      (short)15,      (short)15, 
        (short)15,      (short)15,      (short)15,      (short)15, 
        (short)15,      (short)15,      (short)9,      (short)9, 
        (short)9,      (short)10,      (short)10,      (short)10, 
        (short)2,      (short)3,      (short)5,      (short)11, 
        (short)7};
#line 244 "y.tab.c"
short yylen[93]  = 
#line 244
  {      (short)2,      (short)0,      (short)2,      (short)2, 
        (short)4,      (short)4,      (short)5,      (short)3, 
        (short)5,      (short)5,      (short)5,      (short)5, 
        (short)9,      (short)5,      (short)5,      (short)5, 
        (short)3,      (short)5,      (short)3,      (short)5, 
        (short)5,      (short)3,      (short)5,      (short)5, 
        (short)3,      (short)3,      (short)5,      (short)3, 
        (short)5,      (short)3,      (short)5,      (short)5, 
        (short)3,      (short)3,      (short)5,      (short)7, 
        (short)5,      (short)7,      (short)9,      (short)5, 
        (short)7,      (short)7,      (short)7,      (short)5, 
        (short)7,      (short)9,      (short)7,      (short)9, 
        (short)7,      (short)7,      (short)5,      (short)3, 
        (short)5,      (short)5,      (short)2,      (short)2, 
        (short)5,      (short)5,      (short)5,      (short)7, 
        (short)5,      (short)5,      (short)7,      (short)5, 
        (short)7,      (short)5,      (short)1,      (short)0, 
        (short)1,      (short)1,      (short)11,      (short)1, 
        (short)1,      (short)1,      (short)1,      (short)3, 
        (short)1,      (short)3,      (short)1,      (short)1, 
        (short)3,      (short)2,      (short)1,      (short)1, 
        (short)1,      (short)1,      (short)1,      (short)1, 
        (short)1,      (short)1,      (short)1,      (short)1, 
        (short)0};
#line 256 "y.tab.c"
short yydefred[266]  = 
#line 256
  {      (short)1,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)92, 
        (short)92,      (short)92,      (short)92,      (short)2, 
        (short)3,      (short)55,      (short)0,      (short)0, 
        (short)54,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)66,      (short)0, 
        (short)68,      (short)0,      (short)0,      (short)7, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)24,      (short)0, 
        (short)0,      (short)25,      (short)0,      (short)18, 
        (short)0,      (short)16,      (short)0,      (short)0, 
        (short)21,      (short)0,      (short)27,      (short)29, 
        (short)0,      (short)0,      (short)32,      (short)33, 
        (short)0,      (short)51,      (short)0,      (short)0, 
        (short)4,      (short)5,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)78,      (short)0, 
        (short)0,      (short)82,      (short)84,      (short)83, 
        (short)0,      (short)86,      (short)87,      (short)85, 
        (short)0,      (short)89,      (short)0,      (short)88, 
        (short)0,      (short)0,      (short)0,      (short)69, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)6,      (short)0, 
        (short)0,      (short)0,      (short)81,      (short)8, 
        (short)9,      (short)10,      (short)13,      (short)14, 
        (short)15,      (short)0,      (short)11,      (short)57, 
        (short)56,      (short)23,      (short)22,      (short)26, 
        (short)19,      (short)17,      (short)0,      (short)34, 
        (short)0,      (short)36,      (short)0,      (short)39, 
        (short)0,      (short)0,      (short)0,      (short)43, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)58,      (short)61,      (short)60, 
        (short)0,      (short)63,      (short)0,      (short)65, 
        (short)20,      (short)28,      (short)30,      (short)31, 
        (short)50,      (short)52,      (short)53,      (short)0, 
        (short)73,      (short)71,      (short)72,      (short)75, 
        (short)77,      (short)80,      (short)0,      (short)0, 
        (short)91,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)90, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)35,      (short)37,      (short)40,      (short)0, 
        (short)41,      (short)42,      (short)0,      (short)44, 
        (short)0,      (short)46,      (short)48,      (short)49, 
        (short)59,      (short)62,      (short)64,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)12,      (short)38,      (short)45, 
        (short)47,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)70};
#line 285 "y.tab.c"
short yydgoto[16]  = 
#line 285
  {      (short)1,      (short)73,      (short)126,      (short)127, 
        (short)71,      (short)232,      (short)132,      (short)41, 
        (short)215,      (short)120,      (short)124,      (short)221, 
        (short)35,      (short)36,      (short)111,      (short)116};
#line 289 "y.tab.c"
short yysindex[266]  = 
#line 289
  {      (short)0,      (short)-245,      (short)-254,      (short)-266, 
        (short)-244,      (short)-251,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)-240,      (short)-170, 
        (short)0,      (short)-241,      (short)-224,      (short)-148, 
        (short)-122,      (short)-121,      (short)-120,      (short)-119, 
        (short)-118,      (short)-117,      (short)-116,      (short)-115, 
        (short)-114,      (short)-163,      (short)-113,      (short)-257, 
        (short)-226,      (short)-169,      (short)-112,      (short)-164, 
        (short)-161,      (short)-110,      (short)-111,      (short)-108, 
        (short)-107,      (short)-105,      (short)-103,      (short)-102, 
        (short)-100,      (short)-99,      (short)0,      (short)-97, 
        (short)0,      (short)-96,      (short)-106,      (short)0, 
        (short)-215,      (short)-162,      (short)-236,      (short)-101, 
        (short)-101,      (short)-101,      (short)-95,      (short)-94, 
        (short)-101,      (short)-101,      (short)0,      (short)-101, 
        (short)-101,      (short)0,      (short)-101,      (short)0, 
        (short)-92,      (short)0,      (short)-193,      (short)-101, 
        (short)0,      (short)-91,      (short)0,      (short)0, 
        (short)-101,      (short)-101,      (short)0,      (short)0, 
        (short)-101,      (short)0,      (short)-101,      (short)-101, 
        (short)0,      (short)0,      (short)-89,      (short)-93, 
        (short)-86,      (short)-85,      (short)0,      (short)-267, 
        (short)-84,      (short)0,      (short)0,      (short)0, 
        (short)-83,      (short)0,      (short)0,      (short)0, 
        (short)-82,      (short)0,      (short)-81,      (short)0, 
        (short)-79,      (short)-78,      (short)-159,      (short)0, 
        (short)-77,      (short)-76,      (short)-75,      (short)-74, 
        (short)-73,      (short)-72,      (short)-71,      (short)-156, 
        (short)-154,      (short)-152,      (short)-69,      (short)-68, 
        (short)-150,      (short)-67,      (short)-66,      (short)-65, 
        (short)-64,      (short)-132,      (short)-63,      (short)-62, 
        (short)-130,      (short)-128,      (short)-61,      (short)-60, 
        (short)-59,      (short)-58,      (short)-57,      (short)-56, 
        (short)-55,      (short)-88,      (short)0,      (short)-250, 
        (short)-250,      (short)-94,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)-90,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)-54,      (short)0, 
        (short)-53,      (short)0,      (short)-52,      (short)0, 
        (short)-53,      (short)-240,      (short)-170,      (short)0, 
        (short)-50,      (short)-49,      (short)-48,      (short)-47, 
        (short)-46,      (short)0,      (short)0,      (short)0, 
        (short)-45,      (short)0,      (short)-101,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)-43, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)-40,      (short)-51, 
        (short)0,      (short)-39,      (short)-38,      (short)-36, 
        (short)-35,      (short)-34,      (short)-126,      (short)-124, 
        (short)-33,      (short)-32,      (short)-31,      (short)0, 
        (short)-30,      (short)-29,      (short)-28,      (short)-27, 
        (short)0,      (short)0,      (short)0,      (short)-101, 
        (short)0,      (short)0,      (short)-101,      (short)0, 
        (short)-101,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)-41, 
        (short)-26,      (short)-23,      (short)-22,      (short)-21, 
        (short)-20,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)-37,      (short)-19,      (short)-16, 
        (short)-17,      (short)0};
#line 318 "y.tab.c"
short yyrindex[266]  = 
#line 318
  {      (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)-18, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)-13,      (short)-12,      (short)0,      (short)-11, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)-18,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0,      (short)0,      (short)0, 
        (short)0,      (short)0};
#line 347 "y.tab.c"
short yygindex[16]  = 
#line 347
  {      (short)0,      (short)-15,      (short)-80,      (short)0, 
        (short)1,      (short)0,      (short)-98,      (short)64, 
        (short)8,      (short)0,      (short)0,      (short)18, 
        (short)0,      (short)0,      (short)0,      (short)0};
#line 352 "y.tab.c"
short yytable[260]  = 
#line 352
  {      (short)128,      (short)129,      (short)165,      (short)38, 
        (short)133,      (short)134,      (short)131,      (short)135, 
        (short)136,      (short)212,      (short)137,      (short)2, 
        (short)88,      (short)89,      (short)213,      (short)154, 
        (short)37,      (short)166,      (short)214,      (short)40, 
        (short)156,      (short)157,      (short)121,      (short)122, 
        (short)158,      (short)39,      (short)159,      (short)160, 
        (short)74,      (short)3,      (short)4,      (short)123, 
        (short)70,      (short)5,      (short)6,      (short)7, 
        (short)8,      (short)9,      (short)10,      (short)11, 
        (short)12,      (short)13,      (short)112,      (short)90, 
        (short)91,      (short)113,      (short)75,      (short)114, 
        (short)115,      (short)14,      (short)15,      (short)16, 
        (short)17,      (short)18,      (short)19,      (short)20, 
        (short)21,      (short)22,      (short)23,      (short)24, 
        (short)25,      (short)26,      (short)27,      (short)28, 
        (short)29,      (short)30,      (short)31,      (short)217, 
        (short)32,      (short)33,      (short)34,      (short)42, 
        (short)43,      (short)44,      (short)45,      (short)46, 
        (short)47,      (short)48,      (short)49,      (short)50, 
        (short)51,      (short)52,      (short)53,      (short)54, 
        (short)55,      (short)56,      (short)57,      (short)58, 
        (short)59,      (short)60,      (short)61,      (short)62, 
        (short)63,      (short)64,      (short)65,      (short)66, 
        (short)67,      (short)68,      (short)69,      (short)117, 
        (short)92,      (short)93,      (short)72,      (short)118, 
        (short)119,      (short)95,      (short)96,      (short)86, 
        (short)97,      (short)98,      (short)173,      (short)174, 
        (short)139,      (short)182,      (short)183,      (short)184, 
        (short)185,      (short)186,      (short)187,      (short)190, 
        (short)191,      (short)76,      (short)233,      (short)140, 
        (short)141,      (short)142,      (short)143,      (short)144, 
        (short)145,      (short)146,      (short)147,      (short)148, 
        (short)149,      (short)150,      (short)151,      (short)152, 
        (short)153,      (short)196,      (short)197,      (short)200, 
        (short)201,      (short)202,      (short)203,      (short)242, 
        (short)243,      (short)244,      (short)245,      (short)77, 
        (short)78,      (short)79,      (short)80,      (short)81, 
        (short)82,      (short)83,      (short)84,      (short)85, 
        (short)87,      (short)94,      (short)100,      (short)253, 
        (short)99,      (short)101,      (short)254,      (short)102, 
        (short)255,      (short)103,      (short)104,      (short)110, 
        (short)105,      (short)106,      (short)107,      (short)125, 
        (short)216,      (short)108,      (short)109,      (short)225, 
        (short)218,      (short)162,      (short)130,      (short)131, 
        (short)138,      (short)155,      (short)161,      (short)163, 
        (short)164,      (short)211,      (short)167,      (short)168, 
        (short)169,      (short)170,      (short)224,      (short)171, 
        (short)172,      (short)175,      (short)176,      (short)177, 
        (short)178,      (short)179,      (short)180,      (short)181, 
        (short)188,      (short)189,      (short)192,      (short)193, 
        (short)194,      (short)195,      (short)223,      (short)198, 
        (short)199,      (short)204,      (short)205,      (short)206, 
        (short)207,      (short)208,      (short)209,      (short)210, 
        (short)0,      (short)0,      (short)219,      (short)236, 
        (short)220,      (short)222,      (short)226,      (short)227, 
        (short)228,      (short)229,      (short)230,      (short)231, 
        (short)234,      (short)235,      (short)256,      (short)237, 
        (short)238,      (short)239,      (short)262,      (short)240, 
        (short)241,      (short)246,      (short)247,      (short)248, 
        (short)249,      (short)250,      (short)0,      (short)0, 
        (short)257,      (short)251,      (short)252,      (short)258, 
        (short)259,      (short)260,      (short)0,      (short)0, 
        (short)67,      (short)261,      (short)263,      (short)264, 
        (short)265,      (short)74,      (short)76,      (short)79};
#line 380 "y.tab.c"
short yycheck[260]  = 
#line 380
  {      (short)80,      (short)81,      (short)269,      (short)269, 
        (short)84,      (short)85,      (short)273,      (short)87, 
        (short)88,      (short)259,      (short)90,      (short)256, 
        (short)269,      (short)270,      (short)264,      (short)95, 
        (short)270,      (short)115,      (short)268,      (short)270, 
        (short)100,      (short)101,      (short)258,      (short)259, 
        (short)104,      (short)269,      (short)106,      (short)107, 
        (short)269,      (short)274,      (short)275,      (short)267, 
        (short)272,      (short)278,      (short)279,      (short)280, 
        (short)281,      (short)282,      (short)283,      (short)284, 
        (short)285,      (short)286,      (short)257,      (short)269, 
        (short)270,      (short)260,      (short)270,      (short)262, 
        (short)263,      (short)294,      (short)295,      (short)296, 
        (short)297,      (short)298,      (short)299,      (short)300, 
        (short)301,      (short)302,      (short)303,      (short)304, 
        (short)305,      (short)306,      (short)307,      (short)308, 
        (short)309,      (short)310,      (short)311,      (short)165, 
        (short)313,      (short)314,      (short)315,      (short)7, 
        (short)8,      (short)9,      (short)10,      (short)11, 
        (short)12,      (short)13,      (short)14,      (short)15, 
        (short)16,      (short)17,      (short)18,      (short)19, 
        (short)20,      (short)21,      (short)22,      (short)23, 
        (short)24,      (short)25,      (short)26,      (short)27, 
        (short)28,      (short)29,      (short)30,      (short)31, 
        (short)32,      (short)33,      (short)34,      (short)261, 
        (short)269,      (short)270,      (short)272,      (short)265, 
        (short)266,      (short)269,      (short)270,      (short)270, 
        (short)269,      (short)270,      (short)269,      (short)270, 
        (short)305,      (short)269,      (short)270,      (short)269, 
        (short)270,      (short)269,      (short)270,      (short)269, 
        (short)270,      (short)269,      (short)202,      (short)316, 
        (short)317,      (short)318,      (short)319,      (short)320, 
        (short)321,      (short)322,      (short)323,      (short)324, 
        (short)325,      (short)326,      (short)327,      (short)328, 
        (short)329,      (short)269,      (short)270,      (short)269, 
        (short)270,      (short)269,      (short)270,      (short)269, 
        (short)270,      (short)269,      (short)270,      (short)269, 
        (short)269,      (short)269,      (short)269,      (short)269, 
        (short)269,      (short)269,      (short)269,      (short)269, 
        (short)269,      (short)269,      (short)269,      (short)239, 
        (short)270,      (short)269,      (short)242,      (short)270, 
        (short)244,      (short)270,      (short)269,      (short)273, 
        (short)270,      (short)269,      (short)269,      (short)272, 
        (short)164,      (short)270,      (short)270,      (short)190, 
        (short)266,      (short)270,      (short)273,      (short)273, 
        (short)272,      (short)272,      (short)271,      (short)269, 
        (short)269,      (short)273,      (short)270,      (short)270, 
        (short)270,      (short)270,      (short)189,      (short)270, 
        (short)270,      (short)270,      (short)270,      (short)270, 
        (short)270,      (short)270,      (short)270,      (short)270, 
        (short)269,      (short)269,      (short)269,      (short)269, 
        (short)269,      (short)269,      (short)188,      (short)270, 
        (short)270,      (short)270,      (short)270,      (short)270, 
        (short)270,      (short)270,      (short)270,      (short)270, 
        (short)-1,      (short)-1,      (short)272,      (short)270, 
        (short)273,      (short)273,      (short)272,      (short)272, 
        (short)272,      (short)272,      (short)272,      (short)272, 
        (short)271,      (short)269,      (short)271,      (short)270, 
        (short)270,      (short)269,      (short)271,      (short)270, 
        (short)270,      (short)270,      (short)270,      (short)270, 
        (short)270,      (short)270,      (short)-1,      (short)-1, 
        (short)270,      (short)273,      (short)273,      (short)270, 
        (short)270,      (short)270,      (short)-1,      (short)-1, 
        (short)270,      (short)273,      (short)273,      (short)271, 
        (short)273,      (short)270,      (short)270,      (short)270};
#line 545 "y.tab.c"
int yydebug  ;
#line 546 "y.tab.c"
int yynerrs  ;
#line 547 "y.tab.c"
int yyerrflag  ;
#line 548 "y.tab.c"
int yychar  ;
#line 549 "y.tab.c"
short *yyssp  ;
#line 550 "y.tab.c"
YYSTYPE *yyvsp  ;
#line 551 "y.tab.c"
YYSTYPE yyval  ;
#line 552 "y.tab.c"
YYSTYPE yylval  ;
#line 555 "y.tab.c"
static short *yyss  ;
#line 556 "y.tab.c"
static short *yysslim  ;
#line 557 "y.tab.c"
static YYSTYPE *yyvs  ;
#line 558 "y.tab.c"
static int yystacksize  ;
#line 1233 "ftpcmd.y"
struct tab cmdtab[48]  = 
#line 1233 "ftpcmd.y"
  {      {(char *)"USER", (short)274, (short)2, (short)1, (char *)"<sp> username"}, 
        {(char *)"PASS", (short)275, (short)5, (short)1, (char *)"<sp> password"}, 
        {(char *)"ACCT", (short)276, (short)2, (short)0, (char *)"(specify account)"}, 
        {(char *)"SMNT",
      (short)312, (short)1, (short)0, (char *)"(structure mount)"}, 
        {(char *)"REIN", (short)277, (short)1, (short)0, (char *)"(reinitialize server state)"}, 
        {(char *)"QUIT",
      (short)278, (short)1, (short)1, (char *)"(terminate service)"}, 
        {(char *)"PORT", (short)279, (short)1, (short)1, (char *)"<sp> b0, b1, b2, b3, b4, b5"}, 
        {(char *)"PASV",
      (short)280, (short)1, (short)1, (char *)"(set server in passive mode)"}, 
        {(char *)"TYPE", (short)281, (short)1, (short)1, (char *)"<sp> [ A | E | I | L ]"}, 
        {(char *)"STRU",
      (short)282, (short)1, (short)1, (char *)"(specify file structure)"}, 
        {(char *)"MODE", (short)283, (short)1, (short)1, (char *)"(specify transfer mode)"}, 
        {(char *)"RETR",
      (short)284, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"STOR", (short)285, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"APPE", (short)286, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"MLFL", (short)287, (short)4, (short)0, (char *)"(mail file)"}, 
        {(char *)"MAIL", (short)288, (short)4, (short)0, (char *)"(mail to user)"}, 
        {(char *)"MSND", (short)289, (short)4, (short)0, (char *)"(mail send to terminal)"}, 
        {(char *)"MSOM",
      (short)290, (short)4, (short)0, (char *)"(mail send to terminal or mailbox)"}, 
        {(char *)"MSAM",
      (short)291, (short)4, (short)0, (char *)"(mail send to terminal and mailbox)"}, 
        {(char *)"MRSQ",
      (short)292, (short)4, (short)0, (char *)"(mail recipient scheme question)"}, 
        {(char *)"MRCP",
      (short)293, (short)2, (short)0, (char *)"(mail recipient)"}, 
        {(char *)"ALLO", (short)294, (short)1, (short)1, (char *)"allocate storage (vacuously)"}, 
        {(char *)"REST",
      (short)295, (short)1, (short)1, (char *)"(restart command)"}, 
        {(char *)"RNFR", (short)296, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"RNTO", (short)297, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"ABOR", (short)298, (short)1, (short)1, (char *)"(abort operation)"}, 
        {(char *)"DELE",
      (short)299, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"CWD", (short)300, (short)4, (short)1, (char *)"[ <sp> directory-name ]"}, 
        {(char *)"XCWD",
      (short)300, (short)4, (short)1, (char *)"[ <sp> directory-name ]"}, 
        {(char *)"LIST", (short)301, (short)4, (short)1, (char *)"[ <sp> path-name ]"}, 
        {(char *)"NLST",
      (short)302, (short)4, (short)1, (char *)"[ <sp> path-name ]"}, 
        {(char *)"SITE", (short)303, (short)7, (short)1, (char *)"site-cmd [ <sp> arguments ]"}, 
        {(char *)"SYST",
      (short)313, (short)1, (short)1, (char *)"(get type of operating system)"}, 
        {(char *)"STAT", (short)304, (short)4, (short)1, (char *)"[ <sp> path-name ]"}, 
        {(char *)"HELP",
      (short)305, (short)4, (short)1, (char *)"[ <sp> <string> ]"}, 
        {(char *)"NOOP", (short)306, (short)1, (short)1, (char *)""}, 
        {(char *)"MKD", (short)307, (short)2, (short)1, (char *)"<sp> path-name"}, 
        {(char *)"XMKD", (short)307, (short)2, (short)1, (char *)"<sp> path-name"}, 
        {(char *)"RMD", (short)308, (short)2, (short)1, (char *)"<sp> path-name"}, 
        {(char *)"XRMD", (short)308, (short)2, (short)1, (char *)"<sp> path-name"}, 
        {(char *)"PWD", (short)309, (short)1, (short)1, (char *)"(return current directory)"}, 
        {(char *)"XPWD",
      (short)309, (short)1, (short)1, (char *)"(return current directory)"}, 
        {(char *)"CDUP", (short)310, (short)1, (short)1, (char *)"(change to parent directory)"}, 
        {(char *)"XCUP",
      (short)310, (short)1, (short)1, (char *)"(change to parent directory)"}, 
        {(char *)"STOU", (short)311, (short)2, (short)1, (char *)"<sp> file-name"}, 
        {(char *)"SIZE", (short)314, (short)4, (short)1, (char *)"<sp> path-name"}, 
        {(char *)"MDTM", (short)315, (short)4, (short)1, (char *)"<sp> path-name"}, 
        {(char *)((void *)0), (short)0, (short)0, (short)0, (char *)0}};
#line 1285 "ftpcmd.y"
struct tab sitetab[16]  = 
#line 1285
  {      {(char *)"UMASK", (short)316, (short)1, (short)1, (char *)"[ <sp> umask ]"}, 
        {(char *)"IDLE", (short)317, (short)1, (short)1, (char *)"[ <sp> maximum-idle-time ]"}, 
        {(char *)"CHMOD",
      (short)318, (short)8, (short)1, (char *)"<sp> mode <sp> file-name"}, 
        {(char *)"HELP", (short)305, (short)4, (short)1, (char *)"[ <sp> <string> ]"}, 
        {(char *)"GROUP",
      (short)319, (short)2, (short)1, (char *)"<sp> access-group"}, 
        {(char *)"GPASS", (short)320, (short)4, (short)1, (char *)"<sp> access-password"}, 
        {(char *)"NEWER",
      (short)321, (short)9, (short)1, (char *)"<sp> YYYYMMDDHHMMSS [ <sp> path-name ]"}, 
        {(char *)"MINFO",
      (short)322, (short)9, (short)1, (char *)"<sp> YYYYMMDDHHMMSS [ <sp> path-name ]"}, 
        {(char *)"INDEX",
      (short)323, (short)2, (short)1, (char *)"<sp> pattern"}, 
        {(char *)"EXEC", (short)324, (short)2, (short)1, (char *)"<sp> command [ <sp> arguments ]"}, 
        {(char *)"ALIAS",
      (short)325, (short)4, (short)1, (char *)"[ <sp> alias ] "}, 
        {(char *)"CDPATH", (short)326, (short)4, (short)1, (char *)"[ <sp> ] "}, 
        {(char *)"GROUPS", (short)327, (short)4, (short)1, (char *)"[ <sp> ] "}, 
        {(char *)"CHECKMETHOD", (short)328, (short)4, (short)1, (char *)"[ <sp> method ]"}, 
        {(char *)"CHECKSUM",
      (short)329, (short)4, (short)1, (char *)"[ <sp> file-name ]"}, 
        {(char *)((void *)0), (short)0, (short)0, (short)0, (char *)0}};
#line 1305 "ftpcmd.y"
struct tab *lookup(struct tab *p , char *cmd ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1307
  while ((unsigned int )p->name != (unsigned int )((void *)0)) {
#line 1308
    if (0) {
      {
#line 1308
      __s1_len = strlen((char const   *)cmd);
#line 1308
      __s2_len = strlen((char const   *)p->name);
      }
#line 1308
      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
        goto _L___0;
      } else {
#line 1308
        if (__s1_len >= 4U) {
          _L___0: 
#line 1308
          if (! ((unsigned int )((void const   *)(p->name + 1)) - (unsigned int )((void const   *)p->name) == 1U)) {
#line 1308
            tmp___8 = 1;
          } else {
#line 1308
            if (__s2_len >= 4U) {
#line 1308
              tmp___8 = 1;
            } else {
#line 1308
              tmp___8 = 0;
            }
          }
        } else {
#line 1308
          tmp___8 = 0;
        }
      }
#line 1308
      if (tmp___8) {
        {
#line 1308
        tmp___4 = __builtin_strcmp((char const   *)cmd, (char const   *)p->name);
        }
      } else {
        {
#line 1308
        tmp___7 = __builtin_strcmp((char const   *)cmd, (char const   *)p->name);
#line 1308
        tmp___4 = tmp___7;
        }
      }
    } else {
      {
#line 1308
      tmp___7 = __builtin_strcmp((char const   *)cmd, (char const   *)p->name);
#line 1308
      tmp___4 = tmp___7;
      }
    }
#line 1308
    if (tmp___4 == 0) {
#line 1309
      return (p);
    }
#line 1307
    p ++;
  }
#line 1310
  return ((struct tab *)0);
}
}
#line 1318 "ftpcmd.y"
char *wu_getline(char *s , int n , FILE *iop ) 
{ register int c ;
  register char *cs ;
  char *passtxt ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 1322
  passtxt = (char *)"PASS password\r\n";
#line 1324
  cs = s;
#line 1326
  c = 0;
#line 1326
  while (1) {
#line 1326
    if ((int )tmpline[c] != 0) {
#line 1326
      n --;
#line 1326
      if (! (n > 0)) {
#line 1326
        break;
      }
    } else {
#line 1326
      break;
    }
#line 1327
    tmp = cs;
#line 1327
    cs ++;
#line 1327
    *tmp = tmpline[c];
#line 1328
    if ((int )tmpline[c] == 10) {
#line 1329
      tmp___0 = cs;
#line 1329
      cs ++;
#line 1329
      *tmp___0 = (char )'\000';
#line 1330
      if (debug) {
        {
#line 1331
        tmp___1 = strncasecmp((char const   *)passtxt, (char const   *)s, 5U);
        }
#line 1331
        if (tmp___1 == 0) {
          {
#line 1332
          syslog(7, "command: %s", passtxt);
          }
        } else {
          {
#line 1334
          syslog(7, "command: %s", s);
          }
        }
      }
#line 1336
      tmpline[0] = (char )'\000';
#line 1337
      return (s);
    }
#line 1339
    if (c == 0) {
#line 1340
      tmpline[0] = (char )'\000';
    }
#line 1326
    c ++;
  }
  retry: 
#line 1343
  while (1) {
    {
#line 1343
    c = _IO_getc(iop);
    }
#line 1343
    if (! (c != -1)) {
#line 1343
      break;
    }
#line 1345
    byte_count_total ++;
#line 1346
    byte_count_in ++;
#line 1348
    c &= 255;
#line 1349
    if (c == 255) {
      {
#line 1350
      c = _IO_getc(iop);
      }
#line 1350
      if (c != -1) {
#line 1352
        byte_count_total ++;
#line 1353
        byte_count_in ++;
#line 1355
        c &= 255;
#line 1356
        switch (c) {
        case 251: 
        case 252: 
        {
#line 1359
        c = _IO_getc(iop);
#line 1361
        byte_count_total ++;
#line 1362
        byte_count_in ++;
#line 1364
        printf((char const   */* __restrict  */)"%c%c%c", 255, 254, 255 & c);
#line 1365
        fflush(stdout);
        }
#line 1366
        continue;
        case 253: 
        case 254: 
        {
#line 1369
        c = _IO_getc(iop);
#line 1371
        byte_count_total ++;
#line 1372
        byte_count_in ++;
#line 1374
        printf((char const   */* __restrict  */)"%c%c%c", 255, 252, 255 & c);
#line 1375
        fflush(stdout);
        }
#line 1376
        continue;
        case 255: 
#line 1378
        break;
        default: ;
#line 1380
        continue;
        }
      }
    }
#line 1384
    tmp___2 = cs;
#line 1384
    cs ++;
#line 1384
    *tmp___2 = (char )c;
#line 1385
    n --;
#line 1385
    if (n <= 0) {
#line 1386
      break;
    } else {
#line 1385
      if (c == 10) {
#line 1386
        break;
      }
    }
  }
#line 1389
  if (c == -1) {
#line 1389
    if ((unsigned int )cs == (unsigned int )s) {
      {
#line 1390
      tmp___3 = ferror(iop);
      }
#line 1390
      if (tmp___3) {
        {
#line 1390
        tmp___4 = __errno_location();
        }
#line 1390
        if (*tmp___4 == 4) {
          goto retry;
        }
      }
#line 1392
      return ((char *)((void *)0));
    }
  }
#line 1395
  tmp___5 = cs;
#line 1395
  cs ++;
#line 1395
  *tmp___5 = (char )'\000';
#line 1396
  if (debug) {
    {
#line 1397
    tmp___6 = strncasecmp((char const   *)passtxt, (char const   *)s, 5U);
    }
#line 1397
    if (tmp___6 == 0) {
      {
#line 1398
      syslog(7, "command: %s", passtxt);
      }
    } else {
      {
#line 1400
      syslog(7, "command: %s", s);
      }
    }
  }
#line 1402
  return (s);
}
}
#line 1405 "ftpcmd.y"
static void toolong(int a ) 
{ time_t now ;
  char *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1409
  reply(421, (char *)"Timeout (%d seconds): closing control connection.", timeout_idle);
#line 1411
  time(& now);
  }
#line 1412
  if (logging) {
    {
#line 1413
    tmp = ctime((time_t const   *)(& now));
    }
#line 1413
    if (pw) {
#line 1413
      tmp___0 = (char const   *)pw->pw_name;
    } else {
#line 1413
      tmp___0 = "unknown";
    }
    {
#line 1413
    syslog(6, "User %s timed out after %d seconds at %.24s", tmp___0, timeout_idle,
           tmp);
    }
  }
  {
#line 1417
  dologout(1);
  }
#line 1418
  return;
}
}
#line 1422 "ftpcmd.y"
static int cpos  ;
#line 1422 "ftpcmd.y"
static int state  ;
#line 1420 "ftpcmd.y"
int yylex(void) 
{ register char *cp ;
  register char *cp2 ;
  register struct tab *p ;
  int n ;
  time_t now ;
  char c ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___35 ;
  int tmp___36 ;
  char *tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  char *tmp___72 ;
  size_t tmp___73 ;
  unsigned short const   **tmp___74 ;
  unsigned short const   **tmp___75 ;
  char *tmp___107 ;
  size_t tmp___108 ;
  unsigned short const   **tmp___109 ;
  unsigned short const   **tmp___110 ;
  int tmp___111 ;
  char *tmp___113 ;

  {
#line 1427
  c = (char )'\000';
#line 1431
  while (1) {
#line 1432
    switch (state) {
    case 0: 
    {
#line 1435
    yyerrorcalled = 0;
#line 1437
    setproctitle("%s: IDLE", proctitle);
#line 1439
    tmp = is_shutdown(! logged_in, 0);
    }
#line 1439
    if (tmp != 0) {
      {
#line 1440
      reply(221, (char *)"Server shutting down.  Goodbye.");
#line 1441
      dologout(0);
      }
    }
    {
#line 1444
    time(& now);
    }
#line 1445
    if (limit_time > 0L) {
#line 1445
      if ((now - login_time) / 60L > limit_time) {
        {
#line 1446
        reply(221, (char *)"Time limit reached.  Goodbye.");
#line 1447
        dologout(0);
        }
      }
    }
#line 1451
    if (! alarm_running) {
      {
#line 1452
      signal(14, & toolong);
#line 1453
      alarm(timeout_idle);
#line 1454
      alarm_running = 1;
      }
    }
    {
#line 1460
    tmp___0 = wu_getline(cbuf, (int )(sizeof(cbuf) - 1U), stdin);
    }
#line 1460
    if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
      {
#line 1461
      alarm(0U);
#line 1462
      reply(221, (char *)"You could at least say goodbye.");
#line 1463
      dologout(0);
      }
    }
    {
#line 1468
    tmp___3 = __builtin_strchr(cbuf, '\r');
#line 1468
    cp = tmp___3;
    }
#line 1468
    if (cp) {
#line 1469
      tmp___1 = cp;
#line 1469
      cp ++;
#line 1469
      *tmp___1 = (char )'\n';
#line 1470
      *cp = (char )'\000';
    }
    {
#line 1472
    tmp___35 = __builtin_strpbrk((char const   *)(cbuf), " \n");
#line 1472
    cp = tmp___35;
    }
#line 1472
    if (cp) {
#line 1473
      cpos = cp - cbuf;
    }
#line 1474
    if (cpos == 0) {
#line 1475
      cpos = 4;
    }
    {
#line 1476
    c = cbuf[cpos];
#line 1477
    cbuf[cpos] = (char )'\000';
#line 1478
    upper(cbuf);
#line 1480
    tmp___36 = strncasecmp((char const   *)(cbuf), "NOOP", 4U);
    }
#line 1480
    if (tmp___36 != 0) {
      {
#line 1481
      alarm(0U);
#line 1482
      alarm_running = 0;
      }
    }
    {
#line 1485
    p = lookup(cmdtab, cbuf);
#line 1486
    cbuf[cpos] = c;
#line 1487
    tmp___39 = strncasecmp((char const   *)(cbuf), "PASS", 4U);
    }
#line 1487
    if (tmp___39 != 0) {
      {
#line 1487
      tmp___40 = strncasecmp((char const   *)(cbuf), "SITE GPASS", 10U);
      }
#line 1487
      if (tmp___40 != 0) {
        {
#line 1489
        tmp___38 = __builtin_strchr(cbuf, '\n');
#line 1489
        cp = tmp___38;
        }
#line 1489
        if (cp) {
#line 1490
          *cp = (char )'\000';
        }
        {
#line 1491
        setproctitle("%s: %s", proctitle, cbuf);
        }
#line 1492
        if (cp) {
#line 1493
          *cp = (char )'\n';
        }
      }
    }
#line 1495
    if ((unsigned int )p != (unsigned int )((struct tab *)0)) {
#line 1496
      if ((int )p->implemented == 0) {
        {
#line 1497
        nack(p->name);
#line 1498
        longjmp(errcatch, 0);
        }
      }
#line 1501
      state = (int )p->state;
#line 1502
      yylval.String = p->name;
#line 1503
      return ((int )p->token);
    }
#line 1505
    break;
    case 7: 
#line 1508
    if ((int )cbuf[cpos] == 32) {
#line 1509
      cpos ++;
#line 1510
      return (269);
    }
    {
#line 1512
    cp = & cbuf[cpos];
#line 1513
    tmp___72 = __builtin_strpbrk((char const   *)cp, " \n");
#line 1513
    cp2 = tmp___72;
    }
#line 1513
    if (cp2) {
#line 1514
      cpos = cp2 - cbuf;
    }
    {
#line 1515
    c = cbuf[cpos];
#line 1516
    cbuf[cpos] = (char )'\000';
#line 1517
    upper(cp);
#line 1518
    p = lookup(sitetab, cp);
#line 1519
    cbuf[cpos] = c;
    }
#line 1520
    if ((unsigned int )p != (unsigned int )((struct tab *)0)) {
#line 1522
      if ((int )p->implemented == 0) {
        {
#line 1529
        state = 0;
#line 1530
        nack(p->name);
#line 1531
        longjmp(errcatch, 0);
        }
      }
#line 1534
      state = (int )p->state;
#line 1535
      yylval.String = p->name;
#line 1536
      return ((int )p->token);
    }
#line 1538
    state = 0;
#line 1539
    break;
    case 4: 
#line 1542
    if ((int )cbuf[cpos] == 10) {
#line 1543
      state = 0;
#line 1544
      return (270);
    }
    dostr1: 
    case 2: 
    case 5: 
#line 1551
    if ((int )cbuf[cpos] == 32) {
#line 1552
      cpos ++;
#line 1553
      if (state == 4) {
#line 1554
        state = 3;
      } else {
#line 1556
        state ++;
      }
#line 1557
      return (269);
    }
#line 1559
    break;
    case 6: 
#line 1562
    if ((int )cbuf[cpos] == 10) {
#line 1563
      state = 0;
#line 1564
      return (270);
    }
    case 3: 
    {
#line 1569
    cp = & cbuf[cpos];
#line 1570
    tmp___73 = strlen((char const   *)cp);
#line 1570
    n = (int )tmp___73;
#line 1571
    cpos += n - 1;
    }
#line 1575
    if (n > 1) {
#line 1575
      if ((int )cbuf[cpos] == 10) {
        {
#line 1576
        cbuf[cpos] = (char )'\000';
#line 1577
        yylval.String = copy(cp);
#line 1578
        cbuf[cpos] = (char )'\n';
#line 1579
        state = 1;
        }
#line 1580
        return (272);
      }
    }
#line 1582
    break;
    case 8: 
#line 1585
    if ((int )cbuf[cpos] == 32) {
#line 1586
      cpos ++;
#line 1587
      return (269);
    }
    {
#line 1589
    tmp___75 = __ctype_b_loc();
    }
#line 1589
    if ((int const   )*(*tmp___75 + (int )cbuf[cpos]) & 2048) {
#line 1590
      cp = & cbuf[cpos];
#line 1591
      while (1) {
        {
#line 1591
        tmp___74 = __ctype_b_loc();
#line 1591
        cpos ++;
        }
#line 1591
        if (! ((int const   )*(*tmp___74 + (int )cbuf[cpos]) & 2048)) {
#line 1591
          break;
        }
      }
      {
#line 1592
      c = cbuf[cpos];
#line 1593
      cbuf[cpos] = (char )'\000';
#line 1594
      yylval.Number = atoi((char const   *)cp);
#line 1595
      cbuf[cpos] = c;
#line 1596
      state = 2;
      }
#line 1597
      return (273);
    }
#line 1599
    state = 2;
    goto dostr1;
    case 9: 
#line 1603
    if ((int )cbuf[cpos] == 32) {
#line 1604
      cpos ++;
#line 1605
      return (269);
    }
    {
#line 1608
    cp = & cbuf[cpos];
#line 1609
    tmp___107 = __builtin_strpbrk((char const   *)cp, " \n");
#line 1609
    cp2 = tmp___107;
    }
#line 1610
    if ((unsigned int )cp2 != (unsigned int )((void *)0)) {
#line 1611
      c = *cp2;
#line 1612
      *cp2 = (char )'\000';
    }
    {
#line 1614
    tmp___108 = strlen((char const   *)cp);
#line 1614
    n = (int )tmp___108;
#line 1615
    cpos += n;
    }
#line 1619
    if (cp2 - cp > 1) {
      {
#line 1620
      yylval.String = copy(cp);
#line 1621
      cbuf[cpos] = c;
#line 1622
      state = 4;
      }
#line 1623
      return (272);
    }
#line 1625
    break;
    case 1: 
    {
#line 1628
    tmp___110 = __ctype_b_loc();
    }
#line 1628
    if ((int const   )*(*tmp___110 + (int )cbuf[cpos]) & 2048) {
#line 1629
      cp = & cbuf[cpos];
#line 1630
      while (1) {
        {
#line 1630
        tmp___109 = __ctype_b_loc();
#line 1630
        cpos ++;
        }
#line 1630
        if (! ((int const   )*(*tmp___109 + (int )cbuf[cpos]) & 2048)) {
#line 1630
          break;
        }
      }
      {
#line 1631
      c = cbuf[cpos];
#line 1632
      cbuf[cpos] = (char )'\000';
#line 1633
      yylval.Number = atoi((char const   *)cp);
#line 1634
      cbuf[cpos] = c;
      }
#line 1635
      return (273);
    }
#line 1637
    tmp___111 = cpos;
#line 1637
    cpos ++;
#line 1637
    switch ((int )cbuf[tmp___111]) {
    case 10: 
#line 1640
    state = 0;
#line 1641
    return (270);
    case 32: 
#line 1644
    return (269);
    case 44: 
#line 1647
    return (271);
    case 65: 
    case 97: 
#line 1651
    return (257);
    case 66: 
    case 98: 
#line 1655
    return (258);
    case 67: 
    case 99: 
#line 1659
    return (259);
    case 69: 
    case 101: 
#line 1663
    return (260);
    case 70: 
    case 102: 
#line 1667
    return (261);
    case 73: 
    case 105: 
#line 1671
    return (262);
    case 76: 
    case 108: 
#line 1675
    return (263);
    case 78: 
    case 110: 
#line 1679
    return (264);
    case 80: 
    case 112: 
#line 1683
    return (265);
    case 82: 
    case 114: 
#line 1687
    return (266);
    case 83: 
    case 115: 
#line 1691
    return (267);
    case 84: 
    case 116: 
#line 1695
    return (268);
    }
#line 1698
    break;
    default: 
    {
#line 1701
    fatal((char *)"Unknown state in scanner.");
    }
    }
#line 1703
    if (yyerrorcalled == 0) {
      {
#line 1704
      tmp___113 = __builtin_strchr(cbuf, '\n');
#line 1704
      cp = tmp___113;
      }
#line 1704
      if ((unsigned int )cp != (unsigned int )((void *)0)) {
#line 1705
        *cp = (char )'\000';
      }
#line 1706
      if (logged_in) {
        {
#line 1707
        reply(500, (char *)"\'%s\': command not understood.", cbuf);
        }
      } else {
        {
#line 1709
        reply(530, (char *)"Please login with USER and PASS.");
        }
      }
    }
    {
#line 1711
    state = 0;
#line 1712
    longjmp(errcatch, 0);
    }
  }
}
}
#line 1716 "ftpcmd.y"
void upper(char *s ) 
{ int __res ;
  __int32_t const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 1718
  while ((int )*s != 0) {
    {
#line 1719
    tmp___2 = __ctype_b_loc();
    }
#line 1719
    if ((int const   )*(*tmp___2 + (int )*s) & 512) {
#line 1720
      if (sizeof(*s) > 1U) {
        {
#line 1720
        __res = toupper((int )*s);
        }
      } else {
        {
#line 1720
        tmp___1 = __ctype_toupper_loc();
#line 1720
        __res = (int )*(*tmp___1 + (int )*s);
        }
      }
#line 1720
      *s = (char )__res;
    }
#line 1721
    s ++;
  }
#line 1723
  return;
}
}
#line 1725 "ftpcmd.y"
char *copy(char *s ) 
{ char *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1729
  tmp = strlen((char const   *)s);
#line 1729
  tmp___0 = malloc(tmp + 1U);
#line 1729
  p = (char *)tmp___0;
  }
#line 1730
  if ((unsigned int )p == (unsigned int )((void *)0)) {
    {
#line 1731
    fatal((char *)"Ran out of memory.");
    }
  }
  {
#line 1732
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)s);
  }
#line 1733
  return (p);
}
}
#line 1736 "ftpcmd.y"
void help(struct tab *ctab , char *s ) 
{ struct aclmember *entry ;
  struct tab *c ;
  size_t width ;
  size_t NCMDS ;
  char *type___0 ;
  size_t len ;
  size_t tmp ;
  register size_t i ;
  register size_t j ;
  register size_t w ;
  size_t columns ;
  size_t lines ;
  char line___0[8192] ;
  char *ptr ;
  int tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  struct aclmember *tmp___3 ;

  {
#line 1738
  entry = (struct aclmember *)((void *)0);
#line 1743
  if ((unsigned int )ctab == (unsigned int )(sitetab)) {
#line 1744
    type___0 = (char *)"SITE ";
  } else {
#line 1746
    type___0 = (char *)"";
  }
#line 1747
  width = 0U;
#line 1747
  NCMDS = 0U;
#line 1748
  c = ctab;
#line 1748
  while ((unsigned int )c->name != (unsigned int )((void *)0)) {
    {
#line 1749
    tmp = strlen((char const   *)c->name);
#line 1749
    len = tmp;
    }
#line 1751
    if (len > width) {
#line 1752
      width = len;
    }
#line 1753
    NCMDS ++;
#line 1748
    c ++;
  }
#line 1755
  width = (width + 8U) & 4294967288U;
#line 1756
  if ((unsigned int )s == (unsigned int )((char *)0)) {
    {
#line 1760
    lreply(214, (char *)"The following %scommands are recognized %s.", type___0, "(* =>\'s unimplemented)");
#line 1762
    columns = 76U / width;
    }
#line 1763
    if (columns == 0U) {
#line 1764
      columns = 1U;
    }
#line 1765
    lines = ((NCMDS + columns) - 1U) / columns;
#line 1766
    i = 0U;
#line 1766
    while (i < lines) {
      {
#line 1767
      ptr = line___0;
#line 1768
      strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"   ");
#line 1769
      ptr += 3;
#line 1770
      j = 0U;
      }
#line 1770
      while (j < columns) {
#line 1771
        c = (ctab + j * lines) + i;
#line 1772
        if (c->implemented) {
#line 1772
          tmp___0 = ' ';
        } else {
#line 1772
          tmp___0 = '*';
        }
        {
#line 1772
        sprintf((char */* __restrict  */)ptr, (char const   */* __restrict  */)"%s%c",
                c->name, tmp___0);
#line 1774
        tmp___1 = strlen((char const   *)c->name);
#line 1774
        w = tmp___1 + 1U;
#line 1775
        ptr += w;
        }
#line 1776
        if ((unsigned int )(c + lines) >= (unsigned int )(ctab + NCMDS)) {
#line 1777
          break;
        }
#line 1778
        while (w < width) {
#line 1779
          tmp___2 = ptr;
#line 1779
          ptr ++;
#line 1779
          *tmp___2 = (char )' ';
#line 1780
          w ++;
        }
#line 1770
        j ++;
      }
      {
#line 1783
      *ptr = (char )'\000';
#line 1784
      lreply(0, (char *)"%s", line___0);
#line 1766
      i ++;
      }
    }
    {
#line 1786
    fflush(stdout);
    }
#line 1788
    if (virtual_mode) {
#line 1788
      if (! virtual_ftpaccess) {
#line 1788
        if ((int )virtual_email[0] != 0) {
          {
#line 1789
          reply(214, (char *)"Direct comments to %s.", virtual_email);
          }
        } else {
          goto _L___0;
        }
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      {
#line 1792
      tmp___3 = getaclentry((char *)"email", & entry);
      }
#line 1792
      if (tmp___3) {
#line 1792
        if (entry->arg[0]) {
          {
#line 1793
          reply(214, (char *)"Direct comments to %s.", entry->arg[0]);
          }
        } else {
          {
#line 1795
          reply(214, (char *)"Direct comments to ftp-bugs@%s.", hostname);
          }
        }
      } else {
        {
#line 1795
        reply(214, (char *)"Direct comments to ftp-bugs@%s.", hostname);
        }
      }
    }
#line 1796
    return;
  }
  {
#line 1798
  upper(s);
#line 1799
  c = lookup(ctab, s);
  }
#line 1800
  if ((unsigned int )c == (unsigned int )((struct tab *)((void *)0))) {
    {
#line 1801
    reply(502, (char *)"Unknown command %s.", s);
    }
#line 1802
    return;
  }
#line 1804
  if (c->implemented) {
    {
#line 1805
    reply(214, (char *)"Syntax: %s%s %s", type___0, c->name, c->help);
    }
  } else {
    {
#line 1807
    reply(214, (char *)"%s%-*s\t%s; unimplemented.", type___0, width, c->name, c->help);
    }
  }
#line 1809
  return;
}
}
#line 1811 "ftpcmd.y"
void sizecmd(char *filename ) 
{ struct stat stbuf ;
  int tmp ;
  FILE *fin ;
  register int c ;
  register long count ;
  struct stat stbuf___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1813
  switch (type) {
  case 4: 
  case 3: 
  {
#line 1817
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& stbuf));
  }
#line 1817
  if (tmp < 0) {
    {
#line 1819
    reply(550, (char *)"%s: not a plain file.", filename);
    }
  } else {
#line 1817
    if ((stbuf.st_mode & 61440U) != 32768U) {
      {
#line 1819
      reply(550, (char *)"%s: not a plain file.", filename);
      }
    } else {
      {
#line 1827
      reply(213, (char *)"%lu", stbuf.st_size);
      }
    }
  }
#line 1830
  break;
  case 1: 
  {
#line 1837
  fin = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 1838
  if ((unsigned int )fin == (unsigned int )((void *)0)) {
    {
#line 1839
    perror_reply(550, filename);
    }
#line 1840
    return;
  }
  {
#line 1842
  tmp___0 = fileno(fin);
#line 1842
  tmp___1 = fstat(tmp___0, & stbuf___0);
  }
#line 1842
  if (tmp___1 < 0) {
    {
#line 1844
    reply(550, (char *)"%s: not a plain file.", filename);
#line 1845
    fclose(fin);
    }
#line 1846
    return;
  } else {
#line 1842
    if ((stbuf___0.st_mode & 61440U) != 32768U) {
      {
#line 1844
      reply(550, (char *)"%s: not a plain file.", filename);
#line 1845
      fclose(fin);
      }
#line 1846
      return;
    }
  }
#line 1849
  count = 0L;
#line 1850
  while (1) {
    {
#line 1850
    c = _IO_getc(fin);
    }
#line 1850
    if (! (c != -1)) {
#line 1850
      break;
    }
#line 1851
    if (c == 10) {
#line 1852
      count ++;
    }
#line 1853
    count ++;
  }
  {
#line 1855
  fclose(fin);
#line 1857
  reply(213, (char *)"%ld", count);
  }
#line 1858
  break;
  default: 
  {
#line 1861
  reply(504, (char *)"SIZE not implemented for Type %c.", *("?AEIL" + type));
  }
  }
#line 1863
  return;
}
}
#line 1865 "ftpcmd.y"
void site_exec(char *cmd ) 
{ char buf___2[4096] ;
  char *sp ;
  char *tmp___0 ;
  char *slash ;
  char *t ;
  FILE *cmdf ;
  char *tmp___2 ;
  char *tmp___4 ;
  int __res ;
  __int32_t const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int lines ;
  int maxlines ;
  struct aclmember *entry ;
  char class[1024] ;
  int maxfound ;
  int defmaxlines ;
  int which ;
  int tmp___12 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  struct aclmember *tmp___23 ;
  size_t len ;
  size_t tmp___24 ;
  char *tmp___25 ;

  {
  {
#line 1871
  tmp___0 = __builtin_strchr(cmd, ' ');
#line 1871
  sp = tmp___0;
  }
#line 1877
  if ((unsigned int )sp == (unsigned int )((char *)0)) {
#line 1878
    while (1) {
      {
#line 1878
      tmp___2 = __builtin_strchr(cmd, '/');
#line 1878
      slash = tmp___2;
      }
#line 1878
      if (! ((unsigned int )slash != (unsigned int )((char *)0))) {
#line 1878
        break;
      }
#line 1879
      cmd = slash + 1;
    }
  } else {
#line 1882
    while (1) {
#line 1882
      if (sp) {
        {
#line 1882
        tmp___4 = __builtin_strchr(cmd, '/');
#line 1882
        slash = tmp___4;
        }
#line 1882
        if (slash) {
#line 1882
          if (! ((unsigned int )slash < (unsigned int )sp)) {
#line 1882
            break;
          }
        } else {
#line 1882
          break;
        }
      } else {
#line 1882
        break;
      }
#line 1884
      cmd = slash + 1;
    }
  }
#line 1887
  t = cmd;
#line 1887
  while (1) {
#line 1887
    if (*t) {
      {
#line 1887
      tmp___9 = __ctype_b_loc();
      }
#line 1887
      if ((int const   )*(*tmp___9 + (int )*t) & 8192) {
#line 1887
        break;
      }
    } else {
#line 1887
      break;
    }
    {
#line 1888
    tmp___8 = __ctype_b_loc();
    }
#line 1888
    if ((int const   )*(*tmp___8 + (int )*t) & 256) {
#line 1889
      if (sizeof(*t) > 1U) {
        {
#line 1889
        __res = tolower((int )*t);
        }
      } else {
        {
#line 1889
        tmp___7 = __ctype_tolower_loc();
#line 1889
        __res = (int )*(*tmp___7 + (int )*t);
        }
      }
#line 1889
      *t = (char )__res;
    }
#line 1887
    t ++;
  }
  {
#line 1894
  tmp___10 = strlen("/bin/ftp-exec");
#line 1894
  tmp___11 = strlen((char const   *)cmd);
  }
#line 1894
  if ((tmp___10 + tmp___11) + 2U > sizeof(buf___2)) {
#line 1895
    return;
  }
  {
#line 1896
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s/%s",
          "/bin/ftp-exec", cmd);
#line 1898
  cmdf = ftpd_popen(buf___2, (char *)"r", 0);
  }
#line 1899
  if (! cmdf) {
    {
#line 1900
    perror_reply(550, cmd);
    }
#line 1901
    if (log_commands) {
      {
#line 1902
      syslog(6, "SITE EXEC (FAIL: %m): %s", cmd);
      }
    }
  } else {
    {
#line 1905
    lines = 0;
#line 1906
    maxlines = 0;
#line 1907
    entry = (struct aclmember *)((void *)0);
#line 1909
    maxfound = 0;
#line 1910
    defmaxlines = 20;
#line 1913
    acl_getclass(class);
    }
#line 1914
    while (1) {
      {
#line 1914
      tmp___23 = getaclentry((char *)"site-exec-max-lines", & entry);
      }
#line 1914
      if (tmp___23) {
#line 1914
        if (! entry->arg[0]) {
#line 1914
          break;
        }
      } else {
#line 1914
        break;
      }
#line 1915
      if (entry->arg[1]) {
#line 1916
        which = 1;
#line 1916
        while (1) {
#line 1916
          if (which < 50) {
#line 1916
            if (! entry->arg[which]) {
#line 1916
              break;
            }
          } else {
#line 1916
            break;
          }
          {
#line 1917
          tmp___12 = strcasecmp((char const   *)entry->arg[which], (char const   *)(class));
          }
#line 1917
          if (! tmp___12) {
            {
#line 1918
            maxlines = atoi((char const   *)entry->arg[0]);
#line 1919
            maxfound = 1;
            }
          }
#line 1921
          if (0) {
            {
#line 1921
            __s1_len = strlen((char const   *)entry->arg[which]);
#line 1921
            __s2_len = strlen("*");
            }
#line 1921
            if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
              goto _L___0;
            } else {
#line 1921
              if (__s1_len >= 4U) {
                _L___0: 
#line 1921
                if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 1921
                  tmp___22 = 1;
                } else {
#line 1921
                  if (__s2_len >= 4U) {
#line 1921
                    tmp___22 = 1;
                  } else {
#line 1921
                    tmp___22 = 0;
                  }
                }
              } else {
#line 1921
                tmp___22 = 0;
              }
            }
#line 1921
            if (tmp___22) {
              {
#line 1921
              tmp___18 = __builtin_strcmp((char const   *)entry->arg[which], "*");
              }
            } else {
              {
#line 1921
              tmp___21 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 1921
              tmp___18 = tmp___21;
              }
            }
          } else {
            {
#line 1921
            tmp___21 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 1921
            tmp___18 = tmp___21;
            }
          }
#line 1921
          if (! tmp___18) {
            {
#line 1922
            defmaxlines = atoi((char const   *)entry->arg[0]);
            }
          }
#line 1916
          which ++;
        }
      } else {
        {
#line 1925
        defmaxlines = atoi((char const   *)entry->arg[0]);
        }
      }
    }
#line 1927
    if (! maxfound) {
#line 1928
      maxlines = defmaxlines;
    }
    {
#line 1929
    lreply(200, cmd);
    }
#line 1930
    while (1) {
      {
#line 1930
      tmp___25 = fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2),
                       (FILE */* __restrict  */)cmdf);
      }
#line 1930
      if (! tmp___25) {
#line 1930
        break;
      }
      {
#line 1931
      tmp___24 = strlen((char const   *)(buf___2));
#line 1931
      len = tmp___24;
      }
#line 1933
      if (len > 0U) {
#line 1933
        if ((int )buf___2[len - 1U] == 10) {
#line 1934
          len --;
#line 1934
          buf___2[len] = (char )'\000';
        }
      }
      {
#line 1935
      lreply(200, buf___2);
      }
#line 1936
      if (maxlines <= 0) {
#line 1937
        lines ++;
      } else {
#line 1938
        lines ++;
#line 1938
        if (lines >= maxlines) {
          {
#line 1939
          lreply(200, (char *)"*** Truncated ***");
          }
#line 1940
          break;
        }
      }
    }
    {
#line 1943
    reply(200, (char *)" (end of \'%s\')", cmd);
    }
#line 1944
    if (log_commands) {
      {
#line 1945
      syslog(6, "SITE EXEC (lines: %d): %s", lines, cmd);
      }
    }
    {
#line 1946
    ftpd_pclose(cmdf);
    }
  }
#line 1949
  return;
}
}
#line 1951 "ftpcmd.y"
void alias(char *s ) 
{ struct aclmember *entry ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  struct aclmember *tmp___9 ;
  struct aclmember *tmp___10 ;

  {
#line 1953
  entry = (struct aclmember *)((void *)0);
#line 1955
  if ((unsigned int )s != (unsigned int )((char *)((void *)0))) {
#line 1956
    while (1) {
      {
#line 1956
      tmp___9 = getaclentry((char *)"alias", & entry);
      }
#line 1956
      if (tmp___9) {
#line 1956
        if (entry->arg[0]) {
#line 1956
          if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 1956
            break;
          }
        } else {
#line 1956
          break;
        }
      } else {
#line 1956
        break;
      }
#line 1957
      if (0) {
        {
#line 1957
        __s1_len = strlen((char const   *)entry->arg[0]);
#line 1957
        __s2_len = strlen((char const   *)s);
        }
#line 1957
        if (! ((unsigned int )((void const   *)(entry->arg[0] + 1)) - (unsigned int )((void const   *)entry->arg[0]) == 1U)) {
          goto _L___0;
        } else {
#line 1957
          if (__s1_len >= 4U) {
            _L___0: 
#line 1957
            if (! ((unsigned int )((void const   *)(s + 1)) - (unsigned int )((void const   *)s) == 1U)) {
#line 1957
              tmp___8 = 1;
            } else {
#line 1957
              if (__s2_len >= 4U) {
#line 1957
                tmp___8 = 1;
              } else {
#line 1957
                tmp___8 = 0;
              }
            }
          } else {
#line 1957
            tmp___8 = 0;
          }
        }
#line 1957
        if (tmp___8) {
          {
#line 1957
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[0], (char const   *)s);
          }
        } else {
          {
#line 1957
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[0], (char const   *)s);
#line 1957
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 1957
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[0], (char const   *)s);
#line 1957
        tmp___4 = tmp___7;
        }
      }
#line 1957
      if (! tmp___4) {
        {
#line 1958
        reply(214, (char *)"%s is an alias for %s.", entry->arg[0], entry->arg[1]);
        }
#line 1959
        return;
      }
    }
    {
#line 1961
    reply(502, (char *)"Unknown alias %s.", s);
    }
#line 1962
    return;
  }
  {
#line 1965
  lreply(214, (char *)"The following aliases are available.");
  }
#line 1967
  while (1) {
    {
#line 1967
    tmp___10 = getaclentry((char *)"alias", & entry);
    }
#line 1967
    if (tmp___10) {
#line 1967
      if (entry->arg[0]) {
#line 1967
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 1967
          break;
        }
      } else {
#line 1967
        break;
      }
    } else {
#line 1967
      break;
    }
    {
#line 1968
    lreply(0, (char *)"   %-8s %s", entry->arg[0], entry->arg[1]);
    }
  }
  {
#line 1969
  fflush(stdout);
#line 1971
  reply(214, (char *)"");
  }
#line 1972
  return;
}
}
#line 1974 "ftpcmd.y"
void cdpath(void) 
{ struct aclmember *entry ;
  struct aclmember *tmp ;

  {
  {
#line 1976
  entry = (struct aclmember *)((void *)0);
#line 1978
  lreply(214, (char *)"The cdpath is:");
  }
#line 1979
  while (1) {
    {
#line 1979
    tmp = getaclentry((char *)"cdpath", & entry);
    }
#line 1979
    if (tmp) {
#line 1979
      if (! ((unsigned int )entry->arg[0] != (unsigned int )((void *)0))) {
#line 1979
        break;
      }
    } else {
#line 1979
      break;
    }
    {
#line 1980
    lreply(0, (char *)"  %s", entry->arg[0]);
    }
  }
  {
#line 1981
  fflush(stdout);
#line 1982
  reply(214, (char *)"");
  }
#line 1983
  return;
}
}
#line 1985 "ftpcmd.y"
void print_groups(void) 
{ gid_t groups[65536] ;
  int ngroups ;

  {
  {
#line 1988
  ngroups = 0;
#line 1990
  ngroups = getgroups(65536, groups);
  }
#line 1990
  if (ngroups < 0) {
#line 1991
    return;
  }
  {
#line 1994
  lreply(214, (char *)"Group membership is:");
#line 1995
  ngroups --;
  }
#line 1997
  while (ngroups >= 0) {
    {
#line 1998
    lreply(214, (char *)"  %d", groups[ngroups]);
#line 1997
    ngroups --;
    }
  }
  {
#line 2000
  fflush(stdout);
#line 2001
  reply(214, (char *)"");
  }
#line 2002
  return;
}
}
#line 1346 "y.tab.c"
static int yygrowstack(void) 
{ int newsize ;
  int i ;
  short *newss ;
  YYSTYPE *newvs ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 1352
  newsize = yystacksize;
#line 1352
  if (newsize == 0) {
#line 1353
    newsize = 500;
  } else {
#line 1354
    if (newsize >= 500) {
#line 1355
      return (-1);
    } else {
#line 1356
      newsize *= 2;
#line 1356
      if (newsize > 500) {
#line 1357
        newsize = 500;
      }
    }
  }
#line 1359
  i = yyssp - yyss;
#line 1360
  if ((unsigned int )yyss != (unsigned int )((short *)0)) {
    {
#line 1360
    tmp___1 = realloc((void *)yyss, (unsigned int )newsize * sizeof(*newss));
#line 1360
    newss = (short *)tmp___1;
    }
  } else {
    {
#line 1360
    tmp___2 = malloc((unsigned int )newsize * sizeof(*newss));
#line 1360
    newss = (short *)tmp___2;
    }
  }
#line 1363
  if ((unsigned int )newss == (unsigned int )((short *)0)) {
#line 1364
    return (-1);
  }
#line 1366
  yyss = newss;
#line 1367
  yyssp = newss + i;
#line 1368
  if ((unsigned int )yyvs != (unsigned int )((YYSTYPE *)0)) {
    {
#line 1368
    tmp___5 = realloc((void *)yyvs, (unsigned int )newsize * sizeof(*newvs));
#line 1368
    newvs = (YYSTYPE *)tmp___5;
    }
  } else {
    {
#line 1368
    tmp___6 = malloc((unsigned int )newsize * sizeof(*newvs));
#line 1368
    newvs = (YYSTYPE *)tmp___6;
    }
  }
#line 1371
  if ((unsigned int )newvs == (unsigned int )((YYSTYPE *)0)) {
#line 1372
    return (-1);
  }
#line 1374
  yyvs = newvs;
#line 1375
  yyvsp = newvs + i;
#line 1376
  yystacksize = newsize;
#line 1377
  yysslim = (yyss + newsize) - 1;
#line 1378
  return (0);
}
}
#line 1385 "y.tab.c"
int yyparse(void) 
{ register int yym ;
  register int yyn ;
  register int yystate ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  register char *cp ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  mode_t oldmask ;
  mode_t oldmask___0 ;
  struct aclmember *entry ;
  int ok ;
  int tmp___31 ;
  struct aclmember *tmp___32 ;
  struct aclmember *entry___0 ;
  int ok___0 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  struct aclmember *tmp___36 ;
  char path[4096] ;
  int tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char buf___2[4096] ;
  size_t tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  struct stat stbuf ;
  register struct tm *t ;
  int tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  void *tmp___55 ;
  register char *a ;
  register char *p ;
  char **globlist ;
  char *t___0 ;
  size_t tmp___56 ;
  void *tmp___57 ;
  int *tmp___58 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___82 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___88 ;
  int tmp___91 ;
  int tmp___92 ;
  int *tmp___95 ;
  char **globlist___0 ;
  int *tmp___96 ;
  int tmp___110 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___116 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___136 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___142 ;
  int tmp___145 ;
  int tmp___146 ;
  register int ret ;
  register int dec ;
  register int multby ;
  register int digit___0 ;
  int tmp___149 ;

  {
#line 1400
  yynerrs = 0;
#line 1401
  yyerrflag = 0;
#line 1402
  yychar = -1;
#line 1404
  if ((unsigned int )yyss == (unsigned int )((void *)0)) {
    {
#line 1404
    tmp = yygrowstack();
    }
#line 1404
    if (tmp) {
      goto yyoverflow;
    }
  }
#line 1405
  yyssp = yyss;
#line 1406
  yyvsp = yyvs;
#line 1407
  yystate = 0;
#line 1407
  *yyssp = (short )yystate;
  yyloop: 
#line 1410
  yyn = (int )yydefred[yystate];
#line 1410
  if (yyn != 0) {
    goto yyreduce;
  }
#line 1411
  if (yychar < 0) {
    {
#line 1413
    yychar = yylex();
    }
#line 1413
    if (yychar < 0) {
#line 1413
      yychar = 0;
    }
  }
#line 1425
  yyn = (int )yysindex[yystate];
#line 1425
  if (yyn) {
#line 1425
    yyn += yychar;
#line 1425
    if (yyn >= 0) {
#line 1425
      if (yyn <= 259) {
#line 1425
        if ((int )yycheck[yyn] == yychar) {
#line 1433
          if ((unsigned int )yyssp >= (unsigned int )yysslim) {
            {
#line 1433
            tmp___0 = yygrowstack();
            }
#line 1433
            if (tmp___0) {
              goto yyoverflow;
            }
          }
#line 1437
          yyssp ++;
#line 1437
          yystate = (int )yytable[yyn];
#line 1437
          *yyssp = (short )yystate;
#line 1438
          yyvsp ++;
#line 1438
          *yyvsp = yylval;
#line 1439
          yychar = -1;
#line 1440
          if (yyerrflag > 0) {
#line 1440
            yyerrflag --;
          }
          goto yyloop;
        }
      }
    }
  }
#line 1443
  yyn = (int )yyrindex[yystate];
#line 1443
  if (yyn) {
#line 1443
    yyn += yychar;
#line 1443
    if (yyn >= 0) {
#line 1443
      if (yyn <= 259) {
#line 1443
        if ((int )yycheck[yyn] == yychar) {
#line 1446
          yyn = (int )yytable[yyn];
          goto yyreduce;
        }
      }
    }
  }
#line 1449
  if (yyerrflag) {
    goto yyinrecovery;
  }
  {
#line 1451
  yyerror((char *)"syntax error");
#line 1458
  yynerrs ++;
  }
  yyinrecovery: 
#line 1461
  if (yyerrflag < 3) {
#line 1463
    yyerrflag = 3;
#line 1464
    while (1) {
#line 1466
      yyn = (int )yysindex[*yyssp];
#line 1466
      if (yyn) {
#line 1466
        yyn += 256;
#line 1466
        if (yyn >= 0) {
#line 1466
          if (yyn <= 259) {
#line 1466
            if ((int )yycheck[yyn] == 256) {
#line 1474
              if ((unsigned int )yyssp >= (unsigned int )yysslim) {
                {
#line 1474
                tmp___1 = yygrowstack();
                }
#line 1474
                if (tmp___1) {
                  goto yyoverflow;
                }
              }
#line 1478
              yyssp ++;
#line 1478
              yystate = (int )yytable[yyn];
#line 1478
              *yyssp = (short )yystate;
#line 1479
              yyvsp ++;
#line 1479
              *yyvsp = yylval;
              goto yyloop;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
#line 1489
        if ((unsigned int )yyssp <= (unsigned int )yyss) {
          goto yyabort;
        }
#line 1490
        yyssp --;
#line 1491
        yyvsp --;
      }
    }
  } else {
#line 1497
    if (yychar == 0) {
      goto yyabort;
    }
#line 1508
    yychar = -1;
    goto yyloop;
  }
  yyreduce: 
#line 1518
  yym = (int )yylen[yyn];
#line 1519
  if (yym) {
#line 1520
    yyval = *(yyvsp + (1 - yym));
  } else {
    {
#line 1522
    memset((void *)(& yyval), 0, sizeof(yyval));
    }
  }
#line 1523 "y.tab.c"
  switch (yyn) {
  case 2: 
#line 198 "ftpcmd.y"
  fromname = (char *)((void *)0);
#line 199
  restart_point = 0L;
#line 201
  break;
  case 4: 
  {
#line 206
  user((yyvsp + -1)->String);
  }
#line 207
  if (log_commands) {
    {
#line 208
    syslog(6, "USER %s", (yyvsp + -1)->String);
    }
  }
  {
#line 209
  free((void *)(yyvsp + -1)->String);
  }
#line 211
  break;
  case 5: 
#line 213
  if (log_commands) {
#line 214
    if (anonymous) {
      {
#line 215
      syslog(6, "PASS %s", (yyvsp + -1)->String);
      }
    } else {
      {
#line 217
      syslog(6, "PASS password");
      }
    }
  }
  {
#line 219
  pass((yyvsp + -1)->String);
#line 220
  free((void *)(yyvsp + -1)->String);
  }
#line 222
  break;
  case 6: 
#line 224
  if (log_commands) {
    {
#line 225
    syslog(6, "PORT");
    }
  }
#line 228
  if ((yyvsp + -3)->Number) {
#line 232
    if (cliaddr.s_addr == his_addr.sin_addr.s_addr) {
      goto _L___3;
    } else {
      {
#line 230
      tmp___3 = inet_ntoa(cliaddr);
#line 230
      tmp___4 = port_allowed((char *)((char const   *)tmp___3));
      }
#line 232
      if (tmp___4) {
        _L___3: 
#line 232
        __x___0 = cliport;
#line 232
        __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 232
        if ((int )__v___0 > 1023) {
#line 233
          usedefault = 0;
#line 234
          if (pdata >= 0) {
            {
#line 235
            close(pdata);
#line 236
            pdata = -1;
            }
          }
          {
#line 238
          data_dest.sin_family = (unsigned short)2;
#line 239
          data_dest.sin_addr = cliaddr;
#line 240
          data_dest.sin_port = cliport;
#line 241
          reply(200, (char *)"PORT command successful.");
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        {
#line 245
        memset((void *)(& data_dest), 0, sizeof(data_dest));
#line 247
        __x = cliport;
#line 247
        __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 247
        tmp___2 = inet_ntoa(cliaddr);
#line 247
        syslog(4, "refused PORT %s,%d from %s", tmp___2, __v, remoteident);
#line 248
        reply(500, (char *)"Illegal PORT Command");
        }
      }
    }
  }
#line 254
  break;
  case 7: 
#line 258
  if (log_commands) {
    {
#line 259
    syslog(6, "PASV");
    }
  }
#line 260
  if ((yyvsp + -1)->Number) {
    {
#line 262
    passive();
    }
  }
#line 267
  break;
  case 8: 
#line 269
  if (log_commands) {
    {
#line 270
    syslog(6, "TYPE %s", typenames[cmd_type]);
    }
  }
#line 271
  if ((yyvsp + -3)->Number) {
#line 272
    switch (cmd_type) {
    case 1: 
#line 275
    if (cmd_form == 1) {
      {
#line 276
      reply(200, (char *)"Type set to A.");
#line 277
      type = cmd_type;
#line 278
      form = cmd_form;
      }
    } else {
      {
#line 281
      reply(504, (char *)"Form must be N.");
      }
    }
#line 282
    break;
    case 2: 
    {
#line 285
    reply(504, (char *)"Type E not implemented.");
    }
#line 286
    break;
    case 3: 
    {
#line 289
    reply(200, (char *)"Type set to I.");
#line 290
    type = cmd_type;
    }
#line 291
    break;
    case 4: 
#line 295
    if (cmd_bytesz == 8) {
      {
#line 296
      reply(200, (char *)"Type set to L (byte size 8).");
#line 298
      type = cmd_type;
      }
    } else {
      {
#line 301
      reply(504, (char *)"Byte size must be 8.");
      }
    }
    }
  }
#line 307
  break;
  case 9: 
#line 309
  if (log_commands) {
    {
#line 310
    syslog(6, "STRU %s", strunames[(yyvsp + -1)->Number]);
    }
  }
#line 311
  if ((yyvsp + -3)->Number) {
#line 312
    switch ((yyvsp + -1)->Number) {
    case 1: 
    {
#line 315
    reply(200, (char *)"STRU F ok.");
    }
#line 316
    break;
    default: 
    {
#line 319
    reply(504, (char *)"Unimplemented STRU type.");
    }
    }
  }
#line 322
  break;
  case 10: 
#line 324
  if (log_commands) {
    {
#line 325
    syslog(6, "MODE %s", modenames[(yyvsp + -1)->Number]);
    }
  }
#line 326
  if ((yyvsp + -3)->Number) {
#line 327
    switch ((yyvsp + -1)->Number) {
    case 1: 
    {
#line 330
    reply(200, (char *)"MODE S ok.");
    }
#line 331
    break;
    default: 
    {
#line 334
    reply(502, (char *)"Unimplemented MODE type.");
    }
    }
  }
#line 337
  break;
  case 11: 
#line 339
  if (log_commands) {
    {
#line 340
    syslog(6, "ALLO %d", (yyvsp + -1)->Number);
    }
  }
#line 341
  if ((yyvsp + -3)->Number) {
    {
#line 342
    reply(202, (char *)"ALLO command ignored.");
    }
  }
#line 344
  break;
  case 12: 
#line 346
  if (log_commands) {
    {
#line 347
    syslog(6, "ALLO %d R %d", (yyvsp + -5)->Number, (yyvsp + -1)->Number);
    }
  }
#line 348
  if ((yyvsp + -7)->Number) {
    {
#line 349
    reply(202, (char *)"ALLO command ignored.");
    }
  }
#line 351
  break;
  case 13: 
#line 353
  if (log_commands) {
#line 354
    if ((yyvsp + -1)->String) {
#line 354
      tmp___5 = (yyvsp + -1)->String;
    } else {
#line 354
      tmp___5 = nullstr;
    }
    {
#line 354
    syslog(6, "RETR %s", tmp___5);
    }
  }
#line 355
  if ((yyvsp + -3)->Number) {
#line 355
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 355
      tmp___6 = restrict_check((yyvsp + -1)->String);
      }
#line 355
      if (! tmp___6) {
        {
#line 356
        retrieve_is_data = 1;
#line 357
        retrieve((char *)((void *)0), (yyvsp + -1)->String);
        }
      }
    }
  }
#line 359
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 360
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 362
  break;
  case 14: 
#line 364
  if (log_commands) {
#line 365
    if ((yyvsp + -1)->String) {
#line 365
      tmp___7 = (yyvsp + -1)->String;
    } else {
#line 365
      tmp___7 = nullstr;
    }
    {
#line 365
    syslog(6, "STOR %s", tmp___7);
    }
  }
#line 366
  if ((yyvsp + -3)->Number) {
#line 366
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 366
      tmp___8 = restrict_check((yyvsp + -1)->String);
      }
#line 366
      if (! tmp___8) {
        {
#line 367
        store((yyvsp + -1)->String, (char *)"w", 0);
        }
      }
    }
  }
#line 368
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 369
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 371
  break;
  case 15: 
#line 373
  if (log_commands) {
#line 374
    if ((yyvsp + -1)->String) {
#line 374
      tmp___9 = (yyvsp + -1)->String;
    } else {
#line 374
      tmp___9 = nullstr;
    }
    {
#line 374
    syslog(6, "APPE %s", tmp___9);
    }
  }
#line 375
  if ((yyvsp + -3)->Number) {
#line 375
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 375
      tmp___10 = restrict_check((yyvsp + -1)->String);
      }
#line 375
      if (! tmp___10) {
        {
#line 376
        store((yyvsp + -1)->String, (char *)"a", 0);
        }
      }
    }
  }
#line 377
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 378
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 380
  break;
  case 16: 
#line 382
  if (log_commands) {
    {
#line 383
    syslog(6, "NLST");
    }
  }
#line 384
  if ((yyvsp + -1)->Number) {
    {
#line 384
    tmp___11 = restrict_check((char *)".");
    }
#line 384
    if (! tmp___11) {
      {
#line 385
      send_file_list((char *)"");
      }
    }
  }
#line 387
  break;
  case 17: 
#line 389
  if (log_commands) {
    {
#line 390
    syslog(6, "NLST %s", (yyvsp + -1)->String);
    }
  }
#line 391
  if ((yyvsp + -3)->Number) {
#line 391
    if ((yyvsp + -1)->String) {
      {
#line 391
      tmp___12 = restrict_check((yyvsp + -1)->String);
      }
#line 391
      if (! tmp___12) {
        {
#line 392
        send_file_list((yyvsp + -1)->String);
        }
      }
    }
  }
#line 393
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 394
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 396
  break;
  case 18: 
#line 398
  if (log_commands) {
    {
#line 399
    syslog(6, "LIST");
    }
  }
#line 400
  if ((yyvsp + -1)->Number) {
    {
#line 400
    tmp___13 = restrict_check((char *)".");
    }
#line 400
    if (! tmp___13) {
#line 401
      retrieve_is_data = 0;
#line 403
      if (anonymous) {
#line 403
        if (dolreplies) {
          {
#line 404
          retrieve(ls_long, (char *)"");
          }
        } else {
          {
#line 406
          retrieve(ls_short, (char *)"");
          }
        }
      } else {
        {
#line 406
        retrieve(ls_short, (char *)"");
        }
      }
    }
  }
#line 412
  break;
  case 19: 
#line 414
  if (log_commands) {
#line 415
    if ((yyvsp + -1)->String) {
#line 415
      tmp___14 = (yyvsp + -1)->String;
    } else {
#line 415
      tmp___14 = nullstr;
    }
    {
#line 415
    syslog(6, "LIST %s", tmp___14);
    }
  }
#line 416
  if ((yyvsp + -3)->Number) {
#line 416
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 416
      tmp___15 = restrict_list_check((yyvsp + -1)->String);
      }
#line 416
      if (! tmp___15) {
#line 417
        retrieve_is_data = 0;
#line 419
        if (anonymous) {
#line 419
          if (dolreplies) {
            {
#line 420
            retrieve(ls_long, (yyvsp + -1)->String);
            }
          } else {
            {
#line 422
            retrieve(ls_short, (yyvsp + -1)->String);
            }
          }
        } else {
          {
#line 422
          retrieve(ls_short, (yyvsp + -1)->String);
          }
        }
      }
    }
  }
#line 427
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 428
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 430
  break;
  case 20: 
#line 432
  if (log_commands) {
#line 433
    if ((yyvsp + -1)->String) {
#line 433
      tmp___16 = (yyvsp + -1)->String;
    } else {
#line 433
      tmp___16 = nullstr;
    }
    {
#line 433
    syslog(6, "STAT %s", tmp___16);
    }
  }
#line 434
  if ((yyvsp + -3)->Number) {
#line 434
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 434
      tmp___17 = restrict_check((yyvsp + -1)->String);
      }
#line 434
      if (! tmp___17) {
        {
#line 435
        statfilecmd((yyvsp + -1)->String);
        }
      }
    }
  }
#line 436
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 437
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 439
  break;
  case 21: 
#line 441
  if (log_commands) {
    {
#line 442
    syslog(6, "STAT");
    }
  }
#line 443
  if ((yyvsp + -1)->Number) {
    {
#line 444
    statcmd();
    }
  }
#line 446
  break;
  case 22: 
#line 448
  if (log_commands) {
#line 449
    if ((yyvsp + -1)->String) {
#line 449
      tmp___18 = (yyvsp + -1)->String;
    } else {
#line 449
      tmp___18 = nullstr;
    }
    {
#line 449
    syslog(6, "DELE %s", tmp___18);
    }
  }
#line 450
  if ((yyvsp + -3)->Number) {
#line 450
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 450
      tmp___19 = restrict_check((yyvsp + -1)->String);
      }
#line 450
      if (! tmp___19) {
        {
#line 451
        delete((yyvsp + -1)->String);
        }
      }
    }
  }
#line 452
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 453
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 455
  break;
  case 23: 
#line 457
  if (log_commands) {
#line 458
    if ((yyvsp + -1)->String) {
#line 458
      tmp___20 = (yyvsp + -1)->String;
    } else {
#line 458
      tmp___20 = nullstr;
    }
    {
#line 458
    syslog(6, "RNTO %s", tmp___20);
    }
  }
#line 459
  if ((yyvsp + -3)->Number) {
#line 459
    if ((yyvsp + -1)->String) {
      {
#line 459
      tmp___21 = restrict_check((yyvsp + -1)->String);
      }
#line 459
      if (! tmp___21) {
#line 460
        if (fromname) {
          {
#line 461
          renamecmd(fromname, (yyvsp + -1)->String);
#line 462
          free((void *)fromname);
#line 463
          fromname = (char *)((void *)0);
          }
        } else {
          {
#line 466
          reply(503, (char *)"Bad sequence of commands.");
          }
        }
      }
    }
  }
#line 469
  if ((yyvsp + -1)->String) {
    {
#line 470
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 472
  break;
  case 24: 
#line 474
  if (log_commands) {
    {
#line 475
    syslog(6, "ABOR");
    }
  }
#line 476
  if ((yyvsp + -1)->Number) {
    {
#line 477
    reply(225, (char *)"ABOR command successful.");
    }
  }
#line 479
  break;
  case 25: 
#line 481
  if (log_commands) {
    {
#line 482
    syslog(6, "CWD");
    }
  }
#line 483
  if ((yyvsp + -1)->Number) {
    {
#line 483
    tmp___22 = restrict_check(home);
    }
#line 483
    if (! tmp___22) {
      {
#line 484
      cwd(home);
      }
    }
  }
#line 486
  break;
  case 26: 
#line 488
  if (log_commands) {
#line 489
    if ((yyvsp + -1)->String) {
#line 489
      tmp___23 = (yyvsp + -1)->String;
    } else {
#line 489
      tmp___23 = nullstr;
    }
    {
#line 489
    syslog(6, "CWD %s", tmp___23);
    }
  }
#line 490
  if ((yyvsp + -3)->Number) {
#line 490
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 490
      tmp___24 = restrict_check((yyvsp + -1)->String);
      }
#line 490
      if (! tmp___24) {
        {
#line 491
        cwd((yyvsp + -1)->String);
        }
      }
    }
  }
#line 492
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 493
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 495
  break;
  case 27: 
#line 497
  if (log_commands) {
    {
#line 498
    syslog(6, "HELP");
    }
  }
#line 499
  if ((yyvsp + -1)->Number) {
    {
#line 500
    help(cmdtab, (char *)((void *)0));
    }
  }
#line 502
  break;
  case 28: 
#line 504
  cp = (yyvsp + -1)->String;
#line 506
  if (log_commands) {
    {
#line 507
    syslog(6, "HELP %s", (yyvsp + -1)->String);
    }
  }
#line 508
  if ((yyvsp + -3)->Number) {
    {
#line 509
    tmp___25 = strncasecmp((char const   *)cp, "SITE", 4U);
    }
#line 509
    if (tmp___25 == 0) {
#line 510
      cp = (yyvsp + -1)->String + 4;
#line 511
      if ((int )*cp == 32) {
#line 512
        cp ++;
      }
#line 513
      if (*cp) {
        {
#line 514
        help(sitetab, cp);
        }
      } else {
        {
#line 516
        help(sitetab, (char *)((void *)0));
        }
      }
    } else {
      {
#line 519
      help(cmdtab, (yyvsp + -1)->String);
      }
    }
  }
#line 520
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 521
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 523
  break;
  case 29: 
#line 525
  if (log_commands) {
    {
#line 526
    syslog(6, "NOOP");
    }
  }
#line 527
  if ((yyvsp + -1)->Number) {
    {
#line 528
    reply(200, (char *)"NOOP command successful.");
    }
  }
#line 530
  break;
  case 30: 
#line 532
  if (log_commands) {
#line 533
    if ((yyvsp + -1)->String) {
#line 533
      tmp___26 = (yyvsp + -1)->String;
    } else {
#line 533
      tmp___26 = nullstr;
    }
    {
#line 533
    syslog(6, "MKD %s", tmp___26);
    }
  }
#line 534
  if ((yyvsp + -3)->Number) {
#line 534
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 534
      tmp___27 = restrict_check((yyvsp + -1)->String);
      }
#line 534
      if (! tmp___27) {
        {
#line 535
        makedir((yyvsp + -1)->String);
        }
      }
    }
  }
#line 536
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 537
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 539
  break;
  case 31: 
#line 541
  if (log_commands) {
#line 542
    if ((yyvsp + -1)->String) {
#line 542
      tmp___28 = (yyvsp + -1)->String;
    } else {
#line 542
      tmp___28 = nullstr;
    }
    {
#line 542
    syslog(6, "RMD %s", tmp___28);
    }
  }
#line 543
  if ((yyvsp + -3)->Number) {
#line 543
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 543
      tmp___29 = restrict_check((yyvsp + -1)->String);
      }
#line 543
      if (! tmp___29) {
        {
#line 544
        removedir((yyvsp + -1)->String);
        }
      }
    }
  }
#line 545
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 546
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 548
  break;
  case 32: 
#line 550
  if (log_commands) {
    {
#line 551
    syslog(6, "PWD");
    }
  }
#line 552
  if ((yyvsp + -1)->Number) {
    {
#line 553
    pwd();
    }
  }
#line 555
  break;
  case 33: 
#line 557
  if (log_commands) {
    {
#line 558
    syslog(6, "CDUP");
    }
  }
#line 559
  if ((yyvsp + -1)->Number) {
    {
#line 560
    tmp___30 = test_restriction((char *)"..");
    }
#line 560
    if (tmp___30) {
      {
#line 563
      ack((char *)"CWD");
      }
    } else {
      {
#line 561
      cwd((char *)"..");
      }
    }
  }
#line 565
  break;
  case 34: 
#line 568
  if (log_commands) {
    {
#line 569
    syslog(6, "SITE HELP");
    }
  }
#line 570
  if ((yyvsp + -3)->Number) {
    {
#line 571
    help(sitetab, (char *)((void *)0));
    }
  }
#line 573
  break;
  case 35: 
#line 575
  if (log_commands) {
    {
#line 576
    syslog(6, "SITE HELP %s", (yyvsp + -1)->String);
    }
  }
#line 577
  if ((yyvsp + -5)->Number) {
    {
#line 578
    help(sitetab, (yyvsp + -1)->String);
    }
  }
#line 579
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 580
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 582
  break;
  case 36: 
#line 586
  if (log_commands) {
    {
#line 587
    syslog(6, "SITE UMASK");
    }
  }
#line 588
  if ((yyvsp + -3)->Number) {
    {
#line 589
    oldmask = umask(0U);
#line 590
    umask(oldmask);
#line 591
    reply(200, (char *)"Current UMASK is %03o", oldmask);
    }
  }
#line 594
  break;
  case 37: 
#line 597
  entry = (struct aclmember *)((void *)0);
#line 598
  ok = 1;
#line 600
  if (log_commands) {
    {
#line 601
    syslog(6, "SITE UMASK %03o", (yyvsp + -1)->Number);
    }
  }
#line 602
  if ((yyvsp + -5)->Number) {
#line 604
    while (1) {
      {
#line 604
      tmp___32 = getaclentry((char *)"umask", & entry);
      }
#line 604
      if (tmp___32) {
#line 604
        if (entry->arg[0]) {
#line 604
          if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 604
            break;
          }
        } else {
#line 604
          break;
        }
      } else {
#line 604
        break;
      }
      {
#line 605
      tmp___31 = type_match(entry->arg[1]);
      }
#line 605
      if (tmp___31) {
#line 606
        if ((int )*(entry->arg[0]) == 110) {
#line 607
          ok = 0;
        }
      }
    }
#line 609
    if (ok) {
#line 609
      if (! restricted_user) {
#line 610
        if ((yyvsp + -1)->Number < 0) {
          {
#line 611
          reply(501, (char *)"Bad UMASK value");
          }
        } else {
#line 610
          if ((yyvsp + -1)->Number > 511) {
            {
#line 611
            reply(501, (char *)"Bad UMASK value");
            }
          } else {
            {
#line 614
            oldmask___0 = umask((unsigned int )(yyvsp + -1)->Number);
#line 615
            reply(200, (char *)"UMASK set to %03o (was %03o)", (yyvsp + -1)->Number,
                  oldmask___0);
            }
          }
        }
      } else {
        {
#line 619
        reply(553, (char *)"Permission denied on server. (umask)");
        }
      }
    } else {
      {
#line 619
      reply(553, (char *)"Permission denied on server. (umask)");
      }
    }
  }
#line 622
  break;
  case 38: 
#line 624
  entry___0 = (struct aclmember *)((void *)0);
#line 625
  if (anonymous) {
#line 625
    tmp___33 = 0;
  } else {
#line 625
    tmp___33 = 1;
  }
#line 625
  ok___0 = tmp___33;
#line 627
  if (log_commands) {
#line 628
    if ((yyvsp + -1)->String) {
#line 628
      tmp___34 = (yyvsp + -1)->String;
    } else {
#line 628
      tmp___34 = nullstr;
    }
    {
#line 628
    syslog(6, "SITE CHMOD %03o %s", (yyvsp + -3)->Number, tmp___34);
    }
  }
#line 629
  if ((yyvsp + -7)->Number) {
#line 629
    if ((yyvsp + -1)->String) {
#line 631
      while (1) {
        {
#line 631
        tmp___36 = getaclentry((char *)"chmod", & entry___0);
        }
#line 631
        if (tmp___36) {
#line 631
          if (entry___0->arg[0]) {
#line 631
            if (! ((unsigned int )entry___0->arg[1] != (unsigned int )((void *)0))) {
#line 631
              break;
            }
          } else {
#line 631
            break;
          }
        } else {
#line 631
          break;
        }
        {
#line 632
        tmp___35 = type_match(entry___0->arg[1]);
        }
#line 632
        if (tmp___35) {
#line 633
          if (anonymous) {
#line 634
            if ((int )*(entry___0->arg[0]) == 121) {
#line 635
              ok___0 = 1;
            }
          } else {
#line 637
            if ((int )*(entry___0->arg[0]) == 110) {
#line 638
              ok___0 = 0;
            }
          }
        }
      }
#line 640
      if (ok___0) {
#line 644
        if ((yyvsp + -3)->Number < 0) {
          {
#line 645
          reply(501, (char *)"CHMOD: Mode value must be between 0 and 0777");
          }
        } else {
#line 644
          if ((yyvsp + -3)->Number > 511) {
            {
#line 645
            reply(501, (char *)"CHMOD: Mode value must be between 0 and 0777");
            }
          } else {
            {
#line 647
            tmp___37 = chmod((char const   *)(yyvsp + -1)->String, (unsigned int )(yyvsp + -3)->Number);
            }
#line 647
            if (tmp___37 < 0) {
              {
#line 649
              perror_reply(550, (yyvsp + -1)->String);
              }
            } else {
              {
#line 653
              wu_realpath((char const   *)(yyvsp + -1)->String, path, chroot_path);
              }
#line 655
              if (log_security) {
#line 656
                if (anonymous) {
                  {
#line 657
                  syslog(5, "%s of %s changed permissions for %s", guestpw, remoteident,
                         path);
                  }
                } else {
                  {
#line 660
                  syslog(5, "%s of %s changed permissions for %s", pw->pw_name, remoteident,
                         path);
                  }
                }
              }
              {
#line 663
              reply(200, (char *)"CHMOD command successful.");
              }
            }
          }
        }
      } else {
        {
#line 667
        reply(553, (char *)"Permission denied on server. (chmod)");
        }
      }
    }
  }
#line 669
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 670
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 672
  break;
  case 39: 
#line 674
  if (log_commands) {
    {
#line 675
    syslog(6, "SITE IDLE");
    }
  }
#line 676
  if ((yyvsp + -3)->Number) {
    {
#line 677
    reply(200, (char *)"Current IDLE time limit is %d seconds; max %d", timeout_idle,
          timeout_maxidle);
    }
  }
#line 681
  break;
  case 40: 
#line 683
  if (log_commands) {
    {
#line 684
    syslog(6, "SITE IDLE %d", (yyvsp + -1)->Number);
    }
  }
#line 685
  if ((yyvsp + -5)->Number) {
#line 686
    if ((yyvsp + -1)->Number < 30) {
      {
#line 687
      reply(501, (char *)"Maximum IDLE time must be between 30 and %d seconds", timeout_maxidle);
      }
    } else {
#line 686
      if ((unsigned int )(yyvsp + -1)->Number > timeout_maxidle) {
        {
#line 687
        reply(501, (char *)"Maximum IDLE time must be between 30 and %d seconds",
              timeout_maxidle);
        }
      } else {
        {
#line 692
        timeout_idle = (unsigned int )(yyvsp + -1)->Number;
#line 693
        reply(200, (char *)"Maximum IDLE time set to %d seconds", timeout_idle);
        }
      }
    }
  }
#line 696
  break;
  case 41: 
#line 699
  if (log_commands) {
    {
#line 700
    syslog(6, "SITE GROUP %s", (yyvsp + -1)->String);
    }
  }
#line 701
  if (! restricted_user) {
#line 701
    if ((yyvsp + -5)->Number) {
#line 701
      if ((yyvsp + -1)->String) {
        {
#line 702
        priv_group((yyvsp + -1)->String);
        }
      }
    }
  }
  {
#line 703
  free((void *)(yyvsp + -1)->String);
  }
#line 706
  break;
  case 42: 
#line 709
  if (log_commands) {
    {
#line 710
    syslog(6, "SITE GPASS password");
    }
  }
#line 711
  if (! restricted_user) {
#line 711
    if ((yyvsp + -5)->Number) {
#line 711
      if ((yyvsp + -1)->String) {
        {
#line 712
        priv_gpass((yyvsp + -1)->String);
        }
      }
    }
  }
  {
#line 713
  free((void *)(yyvsp + -1)->String);
  }
#line 716
  break;
  case 43: 
#line 719
  if (log_commands) {
    {
#line 720
    syslog(6, "SITE GPASS");
    }
  }
#line 721
  if (! restricted_user) {
#line 721
    if ((yyvsp + -3)->Number) {
      {
#line 722
      priv_gpass((char *)((void *)0));
      }
    }
  }
#line 725
  break;
  case 44: 
#line 727
  if (log_commands) {
    {
#line 728
    syslog(6, "SITE NEWER %s", (yyvsp + -1)->String);
    }
  }
  {
#line 733
  reply(500, (char *)"Command no longer honored by this server");
#line 735
  free((void *)(yyvsp + -1)->String);
  }
#line 737
  break;
  case 45: 
#line 739
  if (log_commands) {
#line 740
    if ((yyvsp + -1)->String) {
#line 740
      tmp___38 = (yyvsp + -1)->String;
    } else {
#line 740
      tmp___38 = nullstr;
    }
    {
#line 740
    syslog(6, "SITE NEWER %s %s", (yyvsp + -3)->String, tmp___38);
    }
  }
  {
#line 746
  reply(500, (char *)"Command no longer honored by this server");
#line 748
  free((void *)(yyvsp + -3)->String);
  }
#line 749
  if ((yyvsp + -1)->String) {
    {
#line 750
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 752
  break;
  case 46: 
#line 754
  if (log_commands) {
    {
#line 755
    syslog(6, "SITE MINFO %s", (yyvsp + -1)->String);
    }
  }
#line 756
  if ((yyvsp + -5)->Number) {
#line 756
    if ((yyvsp + -1)->String) {
      {
#line 756
      tmp___39 = restrict_check((char *)".");
      }
#line 756
      if (! tmp___39) {
        {
#line 757
        newer((yyvsp + -1)->String, (char *)".", 1);
        }
      }
    }
  }
  {
#line 758
  free((void *)(yyvsp + -1)->String);
  }
#line 760
  break;
  case 47: 
#line 762
  if (log_commands) {
#line 763
    if ((yyvsp + -1)->String) {
#line 763
      tmp___40 = (yyvsp + -1)->String;
    } else {
#line 763
      tmp___40 = nullstr;
    }
    {
#line 763
    syslog(6, "SITE MINFO %s %s", (yyvsp + -3)->String, tmp___40);
    }
  }
#line 765
  if ((yyvsp + -7)->Number) {
#line 765
    if ((yyvsp + -3)->String) {
#line 765
      if ((yyvsp + -1)->String) {
        {
#line 765
        tmp___41 = restrict_check((yyvsp + -1)->String);
        }
#line 765
        if (! tmp___41) {
          {
#line 766
          newer((yyvsp + -3)->String, (yyvsp + -1)->String, 1);
          }
        }
      }
    }
  }
  {
#line 767
  free((void *)(yyvsp + -3)->String);
  }
#line 768
  if ((yyvsp + -1)->String) {
    {
#line 769
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 771
  break;
  case 48: 
#line 776
  if (! restricted_user) {
#line 776
    if ((yyvsp + -5)->Number != 0) {
#line 776
      if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
        {
#line 778
        tmp___42 = strlen((char const   *)(yyvsp + -1)->String);
        }
#line 778
        if (tmp___42 + 7U <= sizeof(buf___2)) {
          {
#line 779
          sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"index %s",
                  (yyvsp + -1)->String);
#line 780
          site_exec(buf___2);
          }
        }
      }
    }
  }
#line 783
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 784
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 786
  break;
  case 49: 
#line 788
  if (! restricted_user) {
#line 788
    if ((yyvsp + -5)->Number != 0) {
#line 788
      if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
        {
#line 789
        site_exec((yyvsp + -1)->String);
        }
      }
    }
  }
#line 791
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 792
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 794
  break;
  case 50: 
#line 797
  if (log_commands) {
#line 798
    if ((yyvsp + -1)->String) {
#line 798
      tmp___43 = (yyvsp + -1)->String;
    } else {
#line 798
      tmp___43 = nullstr;
    }
    {
#line 798
    syslog(6, "STOU %s", tmp___43);
    }
  }
#line 799
  if ((yyvsp + -3)->Number) {
#line 799
    if ((yyvsp + -1)->String) {
      {
#line 799
      tmp___44 = restrict_check((yyvsp + -1)->String);
      }
#line 799
      if (! tmp___44) {
        {
#line 800
        store((yyvsp + -1)->String, (char *)"w", 1);
        }
      }
    }
  }
#line 801
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 802
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 804
  break;
  case 51: 
#line 806
  if (log_commands) {
    {
#line 807
    syslog(6, "SYST");
    }
  }
#line 808
  if ((yyvsp + -1)->Number) {
    {
#line 814
    reply(215, (char *)"UNIX Type: L%d", 8);
    }
  }
#line 820
  break;
  case 52: 
#line 830
  if (log_commands) {
#line 831
    if ((yyvsp + -1)->String) {
#line 831
      tmp___45 = (yyvsp + -1)->String;
    } else {
#line 831
      tmp___45 = nullstr;
    }
    {
#line 831
    syslog(6, "SIZE %s", tmp___45);
    }
  }
#line 832
  if ((yyvsp + -3)->Number) {
#line 832
    if ((yyvsp + -1)->String) {
      {
#line 832
      tmp___46 = restrict_check((yyvsp + -1)->String);
      }
#line 832
      if (! tmp___46) {
        {
#line 833
        sizecmd((yyvsp + -1)->String);
        }
      }
    }
  }
#line 835
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 836
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 838
  break;
  case 53: 
#line 850
  if (log_commands) {
#line 851
    if ((yyvsp + -1)->String) {
#line 851
      tmp___47 = (yyvsp + -1)->String;
    } else {
#line 851
      tmp___47 = nullstr;
    }
    {
#line 851
    syslog(6, "MDTM %s", tmp___47);
    }
  }
#line 852
  if ((yyvsp + -3)->Number) {
#line 852
    if ((yyvsp + -1)->String) {
      {
#line 852
      tmp___49 = restrict_check((yyvsp + -1)->String);
      }
#line 852
      if (! tmp___49) {
        {
#line 855
        tmp___48 = stat((char const   */* __restrict  */)(yyvsp + -1)->String, (struct stat */* __restrict  */)(& stbuf));
        }
#line 855
        if (tmp___48 < 0) {
          {
#line 856
          perror_reply(550, (yyvsp + -1)->String);
          }
        } else {
#line 857
          if ((stbuf.st_mode & 61440U) != 32768U) {
            {
#line 858
            reply(550, (char *)"%s: not a plain file.", (yyvsp + -1)->String);
            }
          } else {
            {
#line 863
            t = gmtime((time_t const   *)(& stbuf.st_mtim.tv_sec));
#line 864
            reply(213, (char *)"%04d%02d%02d%02d%02d%02d", t->tm_year + 1900, t->tm_mon + 1,
                  t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
            }
          }
        }
      }
    }
  }
#line 870
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 871
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 873
  break;
  case 54: 
#line 875
  if (log_commands) {
    {
#line 876
    syslog(6, "QUIT");
    }
  }
#line 878
  if (logged_in) {
    {
#line 879
    lreply(221, (char *)"You have transferred %d bytes in %d files.", data_count_total,
           file_count_total);
#line 880
    lreply(221, (char *)"Total traffic for this session was %d bytes in %d transfers.",
           byte_count_total, xfer_count_total);
#line 881
    lreply(221, (char *)"Thank you for using the FTP service on %s.", hostname);
    }
  }
  {
#line 884
  reply(221, (char *)"Goodbye.");
#line 885
  dologout(0);
  }
#line 887
  break;
  case 55: 
#line 889
  yyerrflag = 0;
#line 891
  break;
  case 56: 
#line 896
  if (log_commands) {
#line 897
    if ((yyvsp + -1)->String) {
#line 897
      tmp___50 = (yyvsp + -1)->String;
    } else {
#line 897
      tmp___50 = nullstr;
    }
    {
#line 897
    syslog(6, "RNFR %s", tmp___50);
    }
  }
#line 898
  if ((yyvsp + -3)->Number) {
#line 899
    restart_point = 0L;
  }
#line 900
  if ((yyvsp + -3)->Number) {
#line 900
    if ((yyvsp + -1)->String) {
      {
#line 900
      tmp___51 = restrict_check((yyvsp + -1)->String);
      }
#line 900
      if (! tmp___51) {
        {
#line 901
        fromname = renamefrom((yyvsp + -1)->String);
        }
      }
    }
  }
#line 903
  if ((unsigned int )fromname == (unsigned int )((char *)0)) {
#line 903
    if ((yyvsp + -1)->String) {
      {
#line 904
      free((void *)(yyvsp + -1)->String);
      }
    }
  }
#line 906
  break;
  case 57: 
#line 908
  if (log_commands) {
    {
#line 909
    syslog(6, "REST %d", (int )restart_point);
    }
  }
#line 910
  if ((yyvsp + -3)->Number) {
    {
#line 911
    fromname = (char *)0;
#line 912
    restart_point = (long )(yyvsp + -1)->Number;
#line 913
    reply(350, (char *)"Restarting at %ld. %s", restart_point, "Send STORE or RETRIEVE to initiate transfer.");
    }
  }
#line 917
  break;
  case 58: 
#line 920
  if (log_commands) {
    {
#line 921
    syslog(6, "SITE ALIAS");
    }
  }
#line 922
  if ((yyvsp + -3)->Number) {
    {
#line 923
    alias((char *)((void *)0));
    }
  }
#line 925
  break;
  case 59: 
#line 927
  if (log_commands) {
    {
#line 928
    syslog(6, "SITE ALIAS %s", (yyvsp + -1)->String);
    }
  }
#line 929
  if ((yyvsp + -5)->Number) {
    {
#line 930
    alias((yyvsp + -1)->String);
    }
  }
#line 931
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 932
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 934
  break;
  case 60: 
#line 936
  if (log_commands) {
    {
#line 937
    syslog(6, "SITE GROUPS");
    }
  }
#line 938
  if ((yyvsp + -3)->Number) {
    {
#line 939
    print_groups();
    }
  }
#line 941
  break;
  case 61: 
#line 943
  if (log_commands) {
    {
#line 944
    syslog(6, "SITE CDPATH");
    }
  }
#line 945
  if ((yyvsp + -3)->Number) {
    {
#line 946
    cdpath();
    }
  }
#line 948
  break;
  case 62: 
#line 950
  if (log_commands) {
#line 951
    if ((yyvsp + -1)->String) {
#line 951
      tmp___52 = (yyvsp + -1)->String;
    } else {
#line 951
      tmp___52 = nullstr;
    }
    {
#line 951
    syslog(6, "SITE CHECKMETHOD %s", tmp___52);
    }
  }
#line 952
  if ((yyvsp + -5)->Number) {
#line 952
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 953
      SetCheckMethod((char const   *)(yyvsp + -1)->String);
      }
    }
  }
#line 954
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 955
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 957
  break;
  case 63: 
#line 959
  if (log_commands) {
    {
#line 960
    syslog(6, "SITE CHECKMETHOD");
    }
  }
#line 961
  if ((yyvsp + -3)->Number) {
    {
#line 962
    ShowCheckMethod();
    }
  }
#line 964
  break;
  case 64: 
#line 966
  if (log_commands) {
#line 967
    if ((yyvsp + -1)->String) {
#line 967
      tmp___53 = (yyvsp + -1)->String;
    } else {
#line 967
      tmp___53 = nullstr;
    }
    {
#line 967
    syslog(6, "SITE CHECKSUM %s", tmp___53);
    }
  }
#line 968
  if ((yyvsp + -5)->Number) {
#line 968
    if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
      {
#line 968
      tmp___54 = restrict_check((yyvsp + -1)->String);
      }
#line 968
      if (! tmp___54) {
        {
#line 969
        CheckSum((yyvsp + -1)->String);
        }
      }
    }
  }
#line 970
  if ((unsigned int )(yyvsp + -1)->String != (unsigned int )((void *)0)) {
    {
#line 971
    free((void *)(yyvsp + -1)->String);
    }
  }
#line 973
  break;
  case 65: 
#line 975
  if (log_commands) {
    {
#line 976
    syslog(6, "SITE CHECKSUM");
    }
  }
#line 977
  if ((yyvsp + -3)->Number) {
    {
#line 978
    CheckSumLastFile();
    }
  }
#line 980
  break;
  case 67: 
  {
#line 987
  tmp___55 = malloc(1U);
#line 987
  yyval.String = (char *)tmp___55;
#line 988
  *(yyval.String + 0) = (char )'\000';
  }
#line 990
  break;
  case 70: 
#line 1000
  a = (char *)(& cliaddr);
#line 1001
  *(a + 0) = (char )(yyvsp + -10)->Number;
#line 1002
  *(a + 1) = (char )(yyvsp + -8)->Number;
#line 1003
  *(a + 2) = (char )(yyvsp + -6)->Number;
#line 1004
  *(a + 3) = (char )(yyvsp + -4)->Number;
#line 1005
  p = (char *)(& cliport);
#line 1006
  *(p + 0) = (char )(yyvsp + -2)->Number;
#line 1007
  *(p + 1) = (char )(yyvsp + 0)->Number;
#line 1009
  break;
  case 71: 
#line 1013
  yyval.Number = 1;
#line 1015
  break;
  case 72: 
#line 1017
  yyval.Number = 2;
#line 1019
  break;
  case 73: 
#line 1021
  yyval.Number = 3;
#line 1023
  break;
  case 74: 
#line 1027
  cmd_type = 1;
#line 1028
  cmd_form = 1;
#line 1030
  break;
  case 75: 
#line 1032
  cmd_type = 1;
#line 1033
  cmd_form = (yyvsp + 0)->Number;
#line 1035
  break;
  case 76: 
#line 1037
  cmd_type = 2;
#line 1038
  cmd_form = 1;
#line 1040
  break;
  case 77: 
#line 1042
  cmd_type = 2;
#line 1043
  cmd_form = (yyvsp + 0)->Number;
#line 1045
  break;
  case 78: 
#line 1047
  cmd_type = 3;
#line 1049
  break;
  case 79: 
#line 1051
  cmd_type = 4;
#line 1052
  cmd_bytesz = 8;
#line 1054
  break;
  case 80: 
#line 1056
  cmd_type = 4;
#line 1057
  cmd_bytesz = (yyvsp + 0)->Number;
#line 1059
  break;
  case 81: 
#line 1062
  cmd_type = 4;
#line 1063
  cmd_bytesz = (yyvsp + 0)->Number;
#line 1065
  break;
  case 82: 
#line 1069
  yyval.Number = 1;
#line 1071
  break;
  case 83: 
#line 1073
  yyval.Number = 2;
#line 1075
  break;
  case 84: 
#line 1077
  yyval.Number = 3;
#line 1079
  break;
  case 85: 
#line 1083
  yyval.Number = 1;
#line 1085
  break;
  case 86: 
#line 1087
  yyval.Number = 2;
#line 1089
  break;
  case 87: 
#line 1091
  yyval.Number = 3;
#line 1093
  break;
  case 88: 
#line 1102
  if (restricted_user) {
#line 1102
    if (logged_in) {
#line 1102
      if ((yyvsp + 0)->String) {
#line 1102
        if (0) {
#line 1102
          if (0) {
            {
#line 1102
            __s1_len___5 = strlen((char const   *)(yyvsp + 0)->String);
#line 1102
            __s2_len___5 = strlen("/");
            }
#line 1102
            if (! ((unsigned int )((void const   *)((yyvsp + 0)->String + 1)) - (unsigned int )((void const   *)(yyvsp + 0)->String) == 1U)) {
              goto _L___17;
            } else {
#line 1102
              if (__s1_len___5 >= 4U) {
                _L___17: 
#line 1102
                if (! ((unsigned int )((void const   *)("/" + 1)) - (unsigned int )((void const   *)"/") == 1U)) {
#line 1102
                  tmp___146 = 1;
                } else {
#line 1102
                  if (__s2_len___5 >= 4U) {
#line 1102
                    tmp___146 = 1;
                  } else {
#line 1102
                    tmp___146 = 0;
                  }
                }
              } else {
#line 1102
                tmp___146 = 0;
              }
            }
#line 1102
            if (tmp___146) {
              {
#line 1102
              tmp___142 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "/");
              }
            } else {
              {
#line 1102
              tmp___145 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "/");
#line 1102
              tmp___142 = tmp___145;
              }
            }
          } else {
            {
#line 1102
            tmp___145 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "/");
#line 1102
            tmp___142 = tmp___145;
            }
          }
#line 1102
          tmp___136 = tmp___142;
        } else {
          {
#line 1102
          tmp___136 = strncmp((char const   *)(yyvsp + 0)->String, "/", 1U);
          }
        }
#line 1102
        if (tmp___136 == 0) {
          {
#line 1108
          tmp___56 = strlen((char const   *)(yyvsp + 0)->String);
#line 1108
          tmp___57 = calloc((1U + tmp___56) + 1U, sizeof(char ));
#line 1108
          t___0 = (char *)tmp___57;
          }
#line 1109
          if ((unsigned int )t___0 == (unsigned int )((void *)0)) {
            {
#line 1110
            tmp___58 = __errno_location();
#line 1110
            *tmp___58 = 11;
#line 1111
            perror_reply(550, (yyvsp + 0)->String);
#line 1112
            yyval.String = (char *)((void *)0);
            }
          } else {
#line 1115
            *(t___0 + 0) = (char )'~';
#line 1116
            *(t___0 + 1) = (char )'\000';
#line 1117
            if (0) {
#line 1117
              if (0) {
                {
#line 1117
                __s1_len___1 = strlen((char const   *)(yyvsp + 0)->String);
#line 1117
                __s2_len___1 = strlen("/../");
                }
#line 1117
                if (! ((unsigned int )((void const   *)((yyvsp + 0)->String + 1)) - (unsigned int )((void const   *)(yyvsp + 0)->String) == 1U)) {
                  goto _L___9;
                } else {
#line 1117
                  if (__s1_len___1 >= 4U) {
                    _L___9: 
#line 1117
                    if (! ((unsigned int )((void const   *)("/../" + 1)) - (unsigned int )((void const   *)"/../") == 1U)) {
#line 1117
                      tmp___92 = 1;
                    } else {
#line 1117
                      if (__s2_len___1 >= 4U) {
#line 1117
                        tmp___92 = 1;
                      } else {
#line 1117
                        tmp___92 = 0;
                      }
                    }
                  } else {
#line 1117
                    tmp___92 = 0;
                  }
                }
#line 1117
                if (tmp___92) {
                  {
#line 1117
                  tmp___88 = __builtin_strcmp((char const   *)(yyvsp + 0)->String,
                                              "/../");
                  }
                } else {
                  {
#line 1117
                  tmp___91 = __builtin_strcmp((char const   *)(yyvsp + 0)->String,
                                              "/../");
#line 1117
                  tmp___88 = tmp___91;
                  }
                }
              } else {
                {
#line 1117
                tmp___91 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "/../");
#line 1117
                tmp___88 = tmp___91;
                }
              }
#line 1117
              tmp___82 = tmp___88;
            } else {
              {
#line 1117
              tmp___82 = strncmp((char const   *)(yyvsp + 0)->String, "/../", 4U);
              }
            }
#line 1117
            if (tmp___82 == 0) {
              {
#line 1118
              strcpy((char */* __restrict  */)(t___0 + 1), (char const   */* __restrict  */)((yyvsp + 0)->String + 3));
              }
            } else {
#line 1119
              if (0) {
                {
#line 1119
                __s1_len = strlen((char const   *)(yyvsp + 0)->String);
#line 1119
                __s2_len = strlen("/..");
                }
#line 1119
                if (! ((unsigned int )((void const   *)((yyvsp + 0)->String + 1)) - (unsigned int )((void const   *)(yyvsp + 0)->String) == 1U)) {
                  goto _L___5;
                } else {
#line 1119
                  if (__s1_len >= 4U) {
                    _L___5: 
#line 1119
                    if (! ((unsigned int )((void const   *)("/.." + 1)) - (unsigned int )((void const   *)"/..") == 1U)) {
#line 1119
                      tmp___68 = 1;
                    } else {
#line 1119
                      if (__s2_len >= 4U) {
#line 1119
                        tmp___68 = 1;
                      } else {
#line 1119
                        tmp___68 = 0;
                      }
                    }
                  } else {
#line 1119
                    tmp___68 = 0;
                  }
                }
#line 1119
                if (tmp___68) {
                  {
#line 1119
                  tmp___64 = __builtin_strcmp((char const   *)(yyvsp + 0)->String,
                                              "/..");
                  }
                } else {
                  {
#line 1119
                  tmp___67 = __builtin_strcmp((char const   *)(yyvsp + 0)->String,
                                              "/..");
#line 1119
                  tmp___64 = tmp___67;
                  }
                }
              } else {
                {
#line 1119
                tmp___67 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "/..");
#line 1119
                tmp___64 = tmp___67;
                }
              }
#line 1119
              if (tmp___64 != 0) {
                {
#line 1120
                strcpy((char */* __restrict  */)(t___0 + 1), (char const   */* __restrict  */)(yyvsp + 0)->String);
                }
              }
            }
            {
#line 1121
            globlist = ftpglob(t___0);
            }
#line 1122
            if (globerr) {
              {
#line 1123
              reply(550, globerr);
#line 1124
              yyval.String = (char *)((void *)0);
              }
#line 1125
              if (globlist) {
                {
#line 1126
                blkfree(globlist);
#line 1127
                free((void *)((char *)globlist));
                }
              }
            } else {
#line 1130
              if (globlist) {
                {
#line 1131
                yyval.String = *globlist;
#line 1132
                blkfree(globlist + 1);
#line 1133
                free((void *)((char *)globlist));
                }
              } else {
                {
#line 1136
                tmp___95 = __errno_location();
#line 1136
                *tmp___95 = 2;
#line 1137
                perror_reply(550, (yyvsp + 0)->String);
#line 1138
                yyval.String = (char *)((void *)0);
                }
              }
            }
            {
#line 1140
            free((void *)t___0);
            }
          }
          {
#line 1142
          free((void *)(yyvsp + 0)->String);
          }
        } else {
          goto _L___20;
        }
      } else {
        goto _L___20;
      }
    } else {
      goto _L___20;
    }
  } else {
    _L___20: 
#line 1144
    if (logged_in) {
#line 1144
      if ((yyvsp + 0)->String) {
#line 1144
        if (0) {
#line 1144
          if (0) {
            {
#line 1144
            __s1_len___3 = strlen((char const   *)(yyvsp + 0)->String);
#line 1144
            __s2_len___3 = strlen("~");
            }
#line 1144
            if (! ((unsigned int )((void const   *)((yyvsp + 0)->String + 1)) - (unsigned int )((void const   *)(yyvsp + 0)->String) == 1U)) {
              goto _L___13;
            } else {
#line 1144
              if (__s1_len___3 >= 4U) {
                _L___13: 
#line 1144
                if (! ((unsigned int )((void const   *)("~" + 1)) - (unsigned int )((void const   *)"~") == 1U)) {
#line 1144
                  tmp___120 = 1;
                } else {
#line 1144
                  if (__s2_len___3 >= 4U) {
#line 1144
                    tmp___120 = 1;
                  } else {
#line 1144
                    tmp___120 = 0;
                  }
                }
              } else {
#line 1144
                tmp___120 = 0;
              }
            }
#line 1144
            if (tmp___120) {
              {
#line 1144
              tmp___116 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "~");
              }
            } else {
              {
#line 1144
              tmp___119 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "~");
#line 1144
              tmp___116 = tmp___119;
              }
            }
          } else {
            {
#line 1144
            tmp___119 = __builtin_strcmp((char const   *)(yyvsp + 0)->String, "~");
#line 1144
            tmp___116 = tmp___119;
            }
          }
#line 1144
          tmp___110 = tmp___116;
        } else {
          {
#line 1144
          tmp___110 = strncmp((char const   *)(yyvsp + 0)->String, "~", 1U);
          }
        }
#line 1144
        if (tmp___110 == 0) {
          {
#line 1147
          globlist___0 = ftpglob((yyvsp + 0)->String);
          }
#line 1148
          if (globerr) {
            {
#line 1149
            reply(550, globerr);
#line 1150
            yyval.String = (char *)((void *)0);
            }
#line 1151
            if (globlist___0) {
              {
#line 1152
              blkfree(globlist___0);
#line 1153
              free((void *)((char *)globlist___0));
              }
            }
          } else {
#line 1156
            if (globlist___0) {
              {
#line 1157
              yyval.String = *globlist___0;
#line 1158
              blkfree(globlist___0 + 1);
#line 1159
              free((void *)((char *)globlist___0));
              }
            } else {
              {
#line 1162
              tmp___96 = __errno_location();
#line 1162
              *tmp___96 = 2;
#line 1163
              perror_reply(550, (yyvsp + 0)->String);
#line 1164
              yyval.String = (char *)((void *)0);
              }
            }
          }
          {
#line 1166
          free((void *)(yyvsp + 0)->String);
          }
        } else {
#line 1169
          yyval.String = (yyvsp + 0)->String;
        }
      } else {
#line 1169
        yyval.String = (yyvsp + 0)->String;
      }
    } else {
#line 1169
      yyval.String = (yyvsp + 0)->String;
    }
  }
#line 1171
  break;
  case 91: 
#line 1187
  dec = (yyvsp + 0)->Number;
#line 1188
  multby = 1;
#line 1189
  ret = 0;
#line 1190
  while (dec) {
#line 1191
    digit___0 = dec % 10;
#line 1192
    if (digit___0 > 7) {
#line 1193
      ret = -1;
#line 1194
      break;
    }
#line 1196
    ret += digit___0 * multby;
#line 1197
    multby *= 8;
#line 1198
    dec /= 10;
  }
#line 1200
  yyval.Number = ret;
#line 1202
  break;
  case 92: 
#line 1206
  if (logged_in) {
#line 1207
    yyval.Number = 1;
  } else {
#line 1209
    if (log_commands) {
      {
#line 1210
      syslog(6, "cmd failure - not logged in");
      }
    }
    {
#line 1211
    reply(530, (char *)"Please login with USER and PASS.");
#line 1212
    yyval.Number = 0;
#line 1213
    yyerrorcalled = 1;
    }
  }
#line 1216
  break;
  }
#line 2659 "ftpcmd.y"
  yyssp -= yym;
#line 2660
  yystate = (int )*yyssp;
#line 2661
  yyvsp -= yym;
#line 2662
  yym = (int )yylhs[yyn];
#line 2663
  if (yystate == 0) {
#line 2663
    if (yym == 0) {
#line 2670
      yystate = 1;
#line 2671
      yyssp ++;
#line 2671
      *yyssp = (short)1;
#line 2672
      yyvsp ++;
#line 2672
      *yyvsp = yyval;
#line 2673
      if (yychar < 0) {
        {
#line 2675
        yychar = yylex();
        }
#line 2675
        if (yychar < 0) {
#line 2675
          yychar = 0;
        }
      }
#line 2687
      if (yychar == 0) {
        goto yyaccept;
      }
      goto yyloop;
    }
  }
#line 2690
  yyn = (int )yygindex[yym];
#line 2690
  if (yyn) {
#line 2690
    yyn += yystate;
#line 2690
    if (yyn >= 0) {
#line 2690
      if (yyn <= 259) {
#line 2690
        if ((int )yycheck[yyn] == yystate) {
#line 2692
          yystate = (int )yytable[yyn];
        } else {
#line 2694
          yystate = (int )yydgoto[yym];
        }
      } else {
#line 2694
        yystate = (int )yydgoto[yym];
      }
    } else {
#line 2694
      yystate = (int )yydgoto[yym];
    }
  } else {
#line 2694
    yystate = (int )yydgoto[yym];
  }
#line 2700
  if ((unsigned int )yyssp >= (unsigned int )yysslim) {
    {
#line 2700
    tmp___149 = yygrowstack();
    }
#line 2700
    if (tmp___149) {
      goto yyoverflow;
    }
  }
#line 2704
  yyssp ++;
#line 2704
  *yyssp = (short )yystate;
#line 2705
  yyvsp ++;
#line 2705
  *yyvsp = yyval;
  goto yyloop;
  yyoverflow: 
  {
#line 2709
  yyerror((char *)"yacc stack overflow");
  }
  yyabort: 
#line 2712
  return (1);
  yyaccept: 
#line 2715
  return (0);
}
}
#line 1 "glob.o"
/* #pragma merger(0,"/tmp/cil-1Yf37zOx.i","-g,-O2") */
#line 135 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
#line 163
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 224
extern  __attribute__((__nothrow__)) int dirfd(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
#line 54 "glob.c"
static char **gargv  ;
#line 55 "glob.c"
static int gargc  ;
#line 56 "glob.c"
static size_t gnleft  ;
#line 57 "glob.c"
static short gflag  ;
#line 58
static int tglob(char c ) ;
#line 62
static char *strend(char *cp ) ;
#line 63
static void addpath(char c ) ;
#line 64
static void ginit(char **agargv ) ;
#line 65
static void collect(char *as ) ;
#line 66
static void acollect(char *as ) ;
#line 67
static void sort(void) ;
#line 68
static void expand(char *as ) ;
#line 69
static void matchdir(char *pattern ) ;
#line 70
static int execbrc(char *p , char *s ) ;
#line 71
static int match(char *s , char *p ) ;
#line 72
static int amatch(char *s , char *p ) ;
#line 73
static void Gcat(char *s1 , char *s2 ) ;
#line 75
static void rscan(char **t , int (*f)(char  ) ) ;
#line 79
int letter(char c ) ;
#line 80
int digit(char c ) ;
#line 81
int gethdir(char *home___0 ) ;
#line 82
int any(int c , char *s ) ;
#line 83
int blklen(char **av ) ;
#line 85
char *strspl(char *cp , char *dp ) ;
#line 86
char **copyblk(char **v ) ;
#line 87
char **blkcpy(char **oav , char **bv ) ;
#line 93 "glob.c"
static int globcnt  ;
#line 95 "glob.c"
char *globchars  =    (char *)"`{[*?";
#line 97 "glob.c"
static char *gpath  ;
#line 97 "glob.c"
static char *gpathp  ;
#line 97 "glob.c"
static char *lastgpathp  ;
#line 98 "glob.c"
static int globbed  ;
#line 99 "glob.c"
static char *entp  ;
#line 100 "glob.c"
static char **sortbas  ;
#line 102 "glob.c"
char **ftpglob(char *v ) 
{ char agpath[8192] ;
  char *agargv[21845] ;
  char *vv[2] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char **tmp___2 ;

  {
  {
#line 108
  fixpath(v);
  }
#line 109
  if ((int )*(v + 0) == 0) {
#line 110
    v = (char *)"*";
  } else {
    {
#line 111
    tmp___0 = strlen((char const   *)v);
    }
#line 111
    if (tmp___0 > 1U) {
      {
#line 111
      tmp___1 = strlen((char const   *)v);
      }
#line 111
      if ((int )*(v + (tmp___1 - 1U)) == 47) {
        {
#line 112
        tmp = strlen((char const   *)v);
#line 112
        *(v + (tmp - 1U)) = (char )'\000';
        }
      }
    }
  }
  {
#line 114
  vv[0] = v;
#line 115
  vv[1] = (char *)((void *)0);
#line 116
  globerr = (char *)((void *)0);
#line 117
  gflag = (short)0;
#line 118
  rscan(vv, & tglob);
  }
#line 119
  if ((int )gflag == 0) {
    {
#line 120
    vv[0] = strspl(v, (char *)"");
#line 121
    tmp___2 = copyblk(vv);
    }
#line 121
    return (tmp___2);
  }
  {
#line 124
  globerr = (char *)((void *)0);
#line 125
  gpath = agpath;
#line 126
  gpathp = gpath;
#line 127
  *gpathp = (char)0;
#line 128
  lastgpathp = gpath + (sizeof(agpath) - 2U);
#line 129
  ginit(agargv);
#line 130
  globcnt = 0;
#line 131
  collect(v);
  }
#line 132
  if (globcnt == 0) {
#line 132
    if ((int )gflag & 1) {
      {
#line 133
      blkfree(gargv);
#line 133
      gargv = (char **)0;
      }
#line 134
      return ((char **)0);
    } else {
      {
#line 137
      gargv = copyblk(gargv);
      }
#line 137
      return (gargv);
    }
  } else {
    {
#line 137
    gargv = copyblk(gargv);
    }
#line 137
    return (gargv);
  }
}
}
#line 140 "glob.c"
static void ginit(char **agargv ) 
{ 

  {
#line 143
  *(agargv + 0) = (char *)0;
#line 144
  gargv = agargv;
#line 145
  sortbas = agargv;
#line 146
  gargc = 0;
#line 147
  gnleft = 131068U;
#line 148
  return;
}
}
#line 150 "glob.c"
static void collect(char *as ) 
{ size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 152
  if (0) {
    {
#line 152
    __s1_len = strlen((char const   *)as);
#line 152
    __s2_len = strlen("{");
    }
#line 152
    if (! ((unsigned int )((void const   *)(as + 1)) - (unsigned int )((void const   *)as) == 1U)) {
      goto _L___0;
    } else {
#line 152
      if (__s1_len >= 4U) {
        _L___0: 
#line 152
        if (! ((unsigned int )((void const   *)("{" + 1)) - (unsigned int )((void const   *)"{") == 1U)) {
#line 152
          tmp___8 = 1;
        } else {
#line 152
          if (__s2_len >= 4U) {
#line 152
            tmp___8 = 1;
          } else {
#line 152
            tmp___8 = 0;
          }
        }
      } else {
#line 152
        tmp___8 = 0;
      }
    }
#line 152
    if (tmp___8) {
      {
#line 152
      tmp___4 = __builtin_strcmp((char const   *)as, "{");
      }
    } else {
      {
#line 152
      tmp___7 = __builtin_strcmp((char const   *)as, "{");
#line 152
      tmp___4 = tmp___7;
      }
    }
  } else {
    {
#line 152
    tmp___7 = __builtin_strcmp((char const   *)as, "{");
#line 152
    tmp___4 = tmp___7;
    }
  }
#line 152
  if (tmp___4 == 0) {
    {
#line 153
    Gcat(as, (char *)"");
#line 154
    sort();
    }
  } else {
#line 152
    if (0) {
      {
#line 152
      __s1_len___0 = strlen((char const   *)as);
#line 152
      __s2_len___0 = strlen("{}");
      }
#line 152
      if (! ((unsigned int )((void const   *)(as + 1)) - (unsigned int )((void const   *)as) == 1U)) {
        goto _L___2;
      } else {
#line 152
        if (__s1_len___0 >= 4U) {
          _L___2: 
#line 152
          if (! ((unsigned int )((void const   *)("{}" + 1)) - (unsigned int )((void const   *)"{}") == 1U)) {
#line 152
            tmp___18 = 1;
          } else {
#line 152
            if (__s2_len___0 >= 4U) {
#line 152
              tmp___18 = 1;
            } else {
#line 152
              tmp___18 = 0;
            }
          }
        } else {
#line 152
          tmp___18 = 0;
        }
      }
#line 152
      if (tmp___18) {
        {
#line 152
        tmp___14 = __builtin_strcmp((char const   *)as, "{}");
        }
      } else {
        {
#line 152
        tmp___17 = __builtin_strcmp((char const   *)as, "{}");
#line 152
        tmp___14 = tmp___17;
        }
      }
    } else {
      {
#line 152
      tmp___17 = __builtin_strcmp((char const   *)as, "{}");
#line 152
      tmp___14 = tmp___17;
      }
    }
#line 152
    if (tmp___14 == 0) {
      {
#line 153
      Gcat(as, (char *)"");
#line 154
      sort();
      }
    } else {
      {
#line 157
      acollect(as);
      }
    }
  }
#line 158
  return;
}
}
#line 160 "glob.c"
static void acollect(char *as ) 
{ register int ogargc ;

  {
  {
#line 162
  ogargc = gargc;
#line 164
  gpathp = gpath;
#line 165
  *gpathp = (char)0;
#line 166
  globbed = 0;
#line 167
  expand(as);
  }
#line 168
  if (gargc != ogargc) {
    {
#line 169
    sort();
    }
  }
#line 170
  return;
}
}
#line 172 "glob.c"
static void sort(void) 
{ register char **p1 ;
  register char **p2 ;
  register char *c ;
  char **Gvp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 175
  Gvp = gargv + gargc;
#line 177
  p1 = sortbas;
#line 178
  while ((unsigned int )p1 < (unsigned int )(Gvp - 1)) {
#line 179
    p2 = p1;
#line 180
    while (1) {
#line 180
      p2 ++;
#line 180
      if (! ((unsigned int )p2 < (unsigned int )Gvp)) {
#line 180
        break;
      }
#line 181
      if (0) {
        {
#line 181
        __s1_len = strlen((char const   *)*p1);
#line 181
        __s2_len = strlen((char const   *)*p2);
        }
#line 181
        if (! ((unsigned int )((void const   *)(*p1 + 1)) - (unsigned int )((void const   *)*p1) == 1U)) {
          goto _L___0;
        } else {
#line 181
          if (__s1_len >= 4U) {
            _L___0: 
#line 181
            if (! ((unsigned int )((void const   *)(*p2 + 1)) - (unsigned int )((void const   *)*p2) == 1U)) {
#line 181
              tmp___8 = 1;
            } else {
#line 181
              if (__s2_len >= 4U) {
#line 181
                tmp___8 = 1;
              } else {
#line 181
                tmp___8 = 0;
              }
            }
          } else {
#line 181
            tmp___8 = 0;
          }
        }
#line 181
        if (tmp___8) {
          {
#line 181
          tmp___4 = __builtin_strcmp((char const   *)*p1, (char const   *)*p2);
          }
        } else {
          {
#line 181
          tmp___7 = __builtin_strcmp((char const   *)*p1, (char const   *)*p2);
#line 181
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 181
        tmp___7 = __builtin_strcmp((char const   *)*p1, (char const   *)*p2);
#line 181
        tmp___4 = tmp___7;
        }
      }
#line 181
      if (tmp___4 > 0) {
#line 182
        c = *p1;
#line 182
        *p1 = *p2;
#line 182
        *p2 = c;
      }
    }
#line 183
    p1 ++;
  }
#line 185
  sortbas = Gvp;
#line 186
  return;
}
}
#line 188 "glob.c"
static void expand(char *as ) 
{ register char *cs ;
  register char *sgpathp ;
  register char *oldcs ;
  struct stat stb ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 194
  if (globerr) {
#line 195
    return;
  }
#line 196
  sgpathp = gpathp;
#line 197
  cs = as;
#line 198
  if ((int )*cs == 126) {
#line 198
    if ((unsigned int )gpathp == (unsigned int )gpath) {
      {
#line 199
      addpath((char )'~');
#line 200
      cs ++;
      }
#line 200
      while (1) {
        {
#line 200
        tmp___0 = letter(*cs);
        }
#line 200
        if (! tmp___0) {
          {
#line 200
          tmp___1 = digit(*cs);
          }
#line 200
          if (! tmp___1) {
#line 200
            if (! ((int )*cs == 45)) {
#line 200
              break;
            }
          }
        }
        {
#line 201
        tmp = cs;
#line 201
        cs ++;
#line 201
        addpath(*tmp);
        }
      }
#line 202
      if (! *cs) {
        goto _L;
      } else {
#line 202
        if ((int )*cs == 47) {
          _L: 
#line 203
          if ((unsigned int )gpathp != (unsigned int )(gpath + 1)) {
            {
#line 204
            *gpathp = (char)0;
#line 205
            tmp___2 = gethdir(gpath + 1);
            }
#line 205
            if (tmp___2) {
#line 206
              globerr = (char *)"Unknown user name after ~";
            }
            {
#line 207
            strcpy((char */* __restrict  */)gpath, (char const   */* __restrict  */)(gpath + 1));
            }
          } else {
            {
#line 210
            strcpy((char */* __restrict  */)gpath, (char const   */* __restrict  */)home);
            }
          }
          {
#line 211
          gpathp = strend(gpath);
          }
        }
      }
    }
  }
#line 214
  while (1) {
    {
#line 214
    tmp___5 = any((int )*cs, globchars);
    }
#line 214
    if (tmp___5) {
#line 214
      break;
    }
#line 215
    if ((int )*cs == 0) {
#line 216
      if (! globbed) {
        {
#line 217
        Gcat(gpath, (char *)"");
        }
      } else {
        {
#line 218
        tmp___3 = stat((char const   */* __restrict  */)gpath, (struct stat */* __restrict  */)(& stb));
        }
#line 218
        if (tmp___3 >= 0) {
          {
#line 219
          Gcat(gpath, (char *)"");
#line 220
          globcnt ++;
          }
        }
      }
      goto endit;
    }
    {
#line 224
    tmp___4 = cs;
#line 224
    cs ++;
#line 224
    addpath(*tmp___4);
    }
  }
#line 226
  oldcs = cs;
#line 227
  while (1) {
#line 227
    if ((unsigned int )cs > (unsigned int )as) {
#line 227
      if (! ((int )*cs != 47)) {
#line 227
        break;
      }
    } else {
#line 227
      break;
    }
#line 228
    cs --;
#line 228
    gpathp --;
  }
#line 229
  if ((int )*cs == 47) {
#line 230
    cs ++;
#line 230
    gpathp ++;
  }
#line 231
  *gpathp = (char)0;
#line 232
  if ((int )*oldcs == 123) {
    {
#line 233
    execbrc(cs, (char *)0);
    }
#line 234
    return;
  }
  {
#line 236
  matchdir(cs);
  }
  endit: 
#line 238
  gpathp = sgpathp;
#line 239
  *gpathp = (char)0;
#line 240
  return;
}
}
#line 242 "glob.c"
static void matchdir(char *pattern ) 
{ struct stat stb ;
  register struct dirent *dp ;
  DIR *dirp___0 ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 254
  if ((int )*gpath == 0) {
#line 254
    tmp = ".";
  } else {
#line 254
    tmp = (char const   *)gpath;
  }
  {
#line 254
  dirp___0 = opendir(tmp);
  }
#line 255
  if ((unsigned int )dirp___0 == (unsigned int )((void *)0)) {
#line 256
    if (globbed) {
#line 257
      return;
    }
    goto patherr2;
  }
  {
#line 261
  tmp___0 = dirfd(dirp___0);
#line 261
  tmp___1 = fstat(tmp___0, & stb);
  }
#line 261
  if (tmp___1 < 0) {
    goto patherr1;
  }
#line 266
  if (! ((stb.st_mode & 61440U) == 16384U)) {
    {
#line 267
    tmp___2 = __errno_location();
#line 267
    *tmp___2 = 20;
    }
    goto patherr1;
  }
#line 270
  while (1) {
#line 270
    if (! globerr) {
      {
#line 270
      dp = readdir(dirp___0);
      }
#line 270
      if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
#line 270
        break;
      }
    } else {
#line 270
      break;
    }
#line 271
    if (dp->d_ino == 0UL) {
#line 272
      continue;
    }
    {
#line 273
    tmp___3 = match(dp->d_name, pattern);
    }
#line 273
    if (tmp___3) {
      {
#line 274
      Gcat(gpath, dp->d_name);
#line 275
      globcnt ++;
      }
    }
  }
  {
#line 278
  closedir(dirp___0);
  }
#line 279
  return;
  patherr1: 
  {
#line 282
  closedir(dirp___0);
  }
  patherr2: 
#line 284
  globerr = (char *)"Bad directory components";
#line 285
  return;
}
}
#line 287 "glob.c"
static int execbrc(char *p , char *s ) 
{ char restbuf[8194] ;
  register char *pe ;
  register char *pm ;
  register char *pl ;
  int brclev ;
  char *lm ;
  char savec ;
  char *sgpathp ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 291
  brclev = 0;
#line 294
  lm = restbuf;
#line 294
  while ((int )*p != 123) {
    goto __Cont;
    __Cont: 
#line 294
    tmp = lm;
#line 294
    lm ++;
#line 294
    tmp___0 = p;
#line 294
    p ++;
#line 294
    *tmp = *tmp___0;
  }
#line 296
  p ++;
#line 296
  pe = p;
#line 296
  while (*pe) {
#line 297
    switch ((int )*pe) {
    case 123: 
#line 300
    brclev ++;
    goto __Cont___0;
    case 125: 
#line 304
    if (brclev == 0) {
      goto pend;
    }
#line 306
    brclev --;
    goto __Cont___0;
    case 91: 
#line 310
    pe ++;
#line 310
    while (1) {
#line 310
      if (*pe) {
#line 310
        if (! ((int )*pe != 93)) {
#line 310
          break;
        }
      } else {
#line 310
        break;
      }
      goto __Cont___1;
      __Cont___1: 
#line 310
      pe ++;
    }
    goto __Cont___0;
    }
    __Cont___0: 
#line 296
    pe ++;
  }
  pend: 
#line 315
  brclev = 0;
#line 316
  pm = p;
#line 316
  pl = pm;
#line 316
  while ((unsigned int )pm <= (unsigned int )pe) {
#line 317
    switch ((int )*pm & 255) {
    case 123: 
#line 320
    brclev ++;
    goto __Cont___2;
    case 125: 
#line 324
    if (brclev) {
#line 325
      brclev --;
      goto __Cont___2;
    }
    goto doit;
    case 172: 
    case 44: 
#line 332
    if (brclev) {
      goto __Cont___2;
    }
    doit: 
    {
#line 335
    savec = *pm;
#line 336
    *pm = (char)0;
#line 337
    strcpy((char */* __restrict  */)lm, (char const   */* __restrict  */)pl);
#line 338
    strcat((char */* __restrict  */)(restbuf), (char const   */* __restrict  */)(pe + 1));
#line 339
    *pm = savec;
    }
#line 340
    if ((unsigned int )s == (unsigned int )((char *)0)) {
      {
#line 341
      sgpathp = gpathp;
#line 342
      expand(restbuf);
#line 343
      gpathp = sgpathp;
#line 344
      *gpathp = (char)0;
      }
    } else {
      {
#line 346
      tmp___1 = amatch(s, restbuf);
      }
#line 346
      if (tmp___1) {
#line 347
        return (1);
      }
    }
    {
#line 348
    sort();
#line 349
    pl = pm + 1;
    }
#line 350
    if (brclev) {
#line 351
      return (0);
    }
    goto __Cont___2;
    case 91: 
#line 355
    pm ++;
#line 355
    while (1) {
#line 355
      if (*pm) {
#line 355
        if (! ((int )*pm != 93)) {
#line 355
          break;
        }
      } else {
#line 355
        break;
      }
      goto __Cont___3;
      __Cont___3: 
#line 355
      pm ++;
    }
#line 357
    if (! *pm) {
#line 358
      pm --;
    }
    goto __Cont___2;
    }
    __Cont___2: 
#line 316
    pm ++;
  }
#line 361
  if (brclev) {
    goto doit;
  }
#line 363
  return (0);
}
}
#line 366 "glob.c"
static int match(char *s , char *p ) 
{ register int c ;
  register char *sentp ;
  char sglobbed ;

  {
#line 370
  sglobbed = (char )globbed;
#line 372
  if ((int )*s == 46) {
#line 372
    if ((int )*p != 46) {
#line 373
      return (0);
    }
  }
  {
#line 374
  sentp = entp;
#line 375
  entp = s;
#line 376
  c = amatch(s, p);
#line 377
  entp = sentp;
#line 378
  globbed = (int )sglobbed;
  }
#line 379
  return (c);
}
}
#line 382 "glob.c"
static int amatch(char *s , char *p ) 
{ register int scc ;
  int ok ;
  int lc ;
  char *sgpathp ;
  struct stat stb ;
  int c ;
  int cc ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 390
  globbed = 1;
#line 391
  while (1) {
#line 392
    tmp = s;
#line 392
    s ++;
#line 392
    scc = (int )*tmp & 127;
#line 393
    tmp___0 = p;
#line 393
    p ++;
#line 393
    c = (int )*tmp___0;
#line 393
    switch (c) {
    case 123: 
    {
#line 396
    tmp___1 = execbrc(p - 1, s - 1);
    }
#line 396
    return (tmp___1);
    case 91: 
#line 399
    ok = 0;
#line 400
    lc = 32767;
#line 401
    while (1) {
#line 401
      tmp___3 = p;
#line 401
      p ++;
#line 401
      cc = (int )*tmp___3;
#line 401
      if (! cc) {
#line 401
        break;
      }
#line 402
      if (cc == 93) {
#line 403
        if (ok) {
#line 404
          break;
        }
#line 405
        return (0);
      }
#line 407
      if (cc == 45) {
#line 408
        if (lc <= scc) {
#line 408
          tmp___2 = p;
#line 408
          p ++;
#line 408
          if (scc <= (int )*tmp___2) {
#line 409
            ok ++;
          }
        }
      } else {
#line 411
        lc = cc;
#line 411
        if (scc == lc) {
#line 412
          ok ++;
        }
      }
    }
#line 414
    if (cc == 0) {
#line 415
      if (ok) {
#line 416
        p --;
      } else {
#line 418
        return (0);
      }
    }
    goto __Cont;
    case 42: 
#line 422
    if (! *p) {
#line 423
      return (1);
    }
#line 424
    if ((int )*p == 47) {
#line 425
      p ++;
      goto slash;
    }
#line 428
    s --;
#line 429
    while (1) {
      {
#line 430
      tmp___4 = amatch(s, p);
      }
#line 430
      if (tmp___4) {
#line 431
        return (1);
      }
#line 429
      tmp___5 = s;
#line 429
      s ++;
#line 429
      if (! *tmp___5) {
#line 429
        break;
      }
    }
#line 433
    return (0);
    case 0: 
#line 436
    return (scc == 0);
    default: ;
#line 439
    if (c != scc) {
#line 440
      return (0);
    }
    goto __Cont;
    case 63: 
#line 444
    if (scc == 0) {
#line 445
      return (0);
    }
    goto __Cont;
    case 47: 
#line 449
    if (scc) {
#line 450
      return (0);
    }
    slash: 
#line 452
    s = entp;
#line 453
    sgpathp = gpathp;
#line 454
    while (*s) {
      {
#line 455
      tmp___6 = s;
#line 455
      s ++;
#line 455
      addpath(*tmp___6);
      }
    }
    {
#line 456
    addpath((char )'/');
#line 457
    tmp___7 = stat((char const   */* __restrict  */)gpath, (struct stat */* __restrict  */)(& stb));
    }
#line 457
    if (tmp___7 == 0) {
#line 457
      if ((stb.st_mode & 61440U) == 16384U) {
#line 458
        if ((int )*p == 0) {
          {
#line 459
          Gcat(gpath, (char *)"");
#line 460
          globcnt ++;
          }
        } else {
          {
#line 463
          expand(p);
          }
        }
      }
    }
#line 464
    gpathp = sgpathp;
#line 465
    *gpathp = (char)0;
#line 466
    return (0);
    }
    __Cont: ;
  }
}
}
#line 532 "glob.c"
static void Gcat(char *s1 , char *s2 ) 
{ register size_t len ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 534
  tmp = strlen((char const   *)s1);
#line 534
  tmp___0 = strlen((char const   *)s2);
#line 534
  len = (tmp + tmp___0) + 1U;
  }
#line 536
  if (len >= gnleft) {
#line 537
    globerr = (char *)"Arguments too long";
  } else {
#line 536
    if (gargc >= 21844) {
#line 537
      globerr = (char *)"Arguments too long";
    } else {
      {
#line 539
      gargc ++;
#line 540
      gnleft -= len;
#line 541
      *(gargv + gargc) = (char *)0;
#line 542
      *(gargv + (gargc - 1)) = strspl(s1, s2);
      }
    }
  }
#line 544
  return;
}
}
#line 546 "glob.c"
static void addpath(char c ) 
{ char *tmp ;

  {
#line 549
  if ((unsigned int )gpathp >= (unsigned int )lastgpathp) {
#line 550
    globerr = (char *)"Pathname too long";
  } else {
#line 552
    tmp = gpathp;
#line 552
    gpathp ++;
#line 552
    *tmp = c;
#line 553
    *gpathp = (char)0;
  }
#line 555
  return;
}
}
#line 557 "glob.c"
static void rscan(char **t , int (*f)(char  ) ) 
{ register char *p ;
  register char c ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char **tmp___20 ;

  {
#line 561
  while (1) {
#line 561
    tmp___20 = t;
#line 561
    t ++;
#line 561
    p = *tmp___20;
#line 561
    if (! p) {
#line 561
      break;
    }
#line 562
    if ((int )*p == 126) {
#line 563
      gflag = (short )((int )gflag | 2);
    } else {
#line 564
      if (0) {
        {
#line 564
        __s1_len = strlen((char const   *)p);
#line 564
        __s2_len = strlen("{");
        }
#line 564
        if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
          goto _L___0;
        } else {
#line 564
          if (__s1_len >= 4U) {
            _L___0: 
#line 564
            if (! ((unsigned int )((void const   *)("{" + 1)) - (unsigned int )((void const   *)"{") == 1U)) {
#line 564
              tmp___8 = 1;
            } else {
#line 564
              if (__s2_len >= 4U) {
#line 564
                tmp___8 = 1;
              } else {
#line 564
                tmp___8 = 0;
              }
            }
          } else {
#line 564
            tmp___8 = 0;
          }
        }
#line 564
        if (tmp___8) {
          {
#line 564
          tmp___4 = __builtin_strcmp((char const   *)p, "{");
          }
        } else {
          {
#line 564
          tmp___7 = __builtin_strcmp((char const   *)p, "{");
#line 564
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 564
        tmp___7 = __builtin_strcmp((char const   *)p, "{");
#line 564
        tmp___4 = tmp___7;
        }
      }
#line 564
      if (tmp___4 == 0) {
#line 565
        continue;
      } else {
#line 564
        if (0) {
          {
#line 564
          __s1_len___0 = strlen((char const   *)p);
#line 564
          __s2_len___0 = strlen("{}");
          }
#line 564
          if (! ((unsigned int )((void const   *)(p + 1)) - (unsigned int )((void const   *)p) == 1U)) {
            goto _L___2;
          } else {
#line 564
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 564
              if (! ((unsigned int )((void const   *)("{}" + 1)) - (unsigned int )((void const   *)"{}") == 1U)) {
#line 564
                tmp___18 = 1;
              } else {
#line 564
                if (__s2_len___0 >= 4U) {
#line 564
                  tmp___18 = 1;
                } else {
#line 564
                  tmp___18 = 0;
                }
              }
            } else {
#line 564
              tmp___18 = 0;
            }
          }
#line 564
          if (tmp___18) {
            {
#line 564
            tmp___14 = __builtin_strcmp((char const   *)p, "{}");
            }
          } else {
            {
#line 564
            tmp___17 = __builtin_strcmp((char const   *)p, "{}");
#line 564
            tmp___14 = tmp___17;
            }
          }
        } else {
          {
#line 564
          tmp___17 = __builtin_strcmp((char const   *)p, "{}");
#line 564
          tmp___14 = tmp___17;
          }
        }
#line 564
        if (tmp___14 == 0) {
#line 565
          continue;
        }
      }
    }
#line 566
    while (1) {
#line 566
      tmp___19 = p;
#line 566
      p ++;
#line 566
      c = *tmp___19;
#line 566
      if (! c) {
#line 566
        break;
      }
      {
#line 567
      (*f)(c);
      }
    }
  }
#line 569
  return;
}
}
#line 570 "glob.c"
static int tglob(char c ) 
{ int tmp ;
  int tmp___0 ;

  {
  {
#line 572
  tmp___0 = any((int )c, globchars);
  }
#line 572
  if (tmp___0) {
#line 573
    if ((int )c == 123) {
#line 573
      tmp = 2;
    } else {
#line 573
      tmp = 1;
    }
#line 573
    gflag = (short )((int )gflag | tmp);
  }
#line 574
  return ((int )c);
}
}
#line 577 "glob.c"
int letter(char c ) 
{ int tmp ;

  {
#line 579
  if ((int )c >= 97) {
#line 579
    if ((int )c <= 122) {
#line 579
      tmp = 1;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
#line 579
    if ((int )c >= 65) {
#line 579
      if ((int )c <= 90) {
#line 579
        tmp = 1;
      } else {
        goto _L;
      }
    } else {
      _L: 
#line 579
      if ((int )c == 95) {
#line 579
        tmp = 1;
      } else {
#line 579
        tmp = 0;
      }
    }
  }
#line 579
  return (tmp);
}
}
#line 583 "glob.c"
int digit(char c ) 
{ int tmp ;

  {
#line 585
  if ((int )c >= 48) {
#line 585
    if ((int )c <= 57) {
#line 585
      tmp = 1;
    } else {
#line 585
      tmp = 0;
    }
  } else {
#line 585
    tmp = 0;
  }
#line 585
  return (tmp);
}
}
#line 588 "glob.c"
int any(int c , char *s ) 
{ char *tmp ;

  {
#line 590
  while (*s) {
#line 591
    tmp = s;
#line 591
    s ++;
#line 591
    if ((int )*tmp == c) {
#line 592
      return (1);
    }
  }
#line 593
  return (0);
}
}
#line 596 "glob.c"
int blklen(char **av ) 
{ register int i ;
  char **tmp ;

  {
#line 598
  i = 0;
#line 600
  while (1) {
#line 600
    tmp = av;
#line 600
    av ++;
#line 600
    if (! *tmp) {
#line 600
      break;
    }
#line 601
    i ++;
  }
#line 602
  return (i);
}
}
#line 605 "glob.c"
char **blkcpy(char **oav , char **bv ) 
{ register char **av ;
  char **tmp ;
  char **tmp___0 ;

  {
#line 607
  av = oav;
#line 609
  while (1) {
#line 609
    tmp = av;
#line 609
    av ++;
#line 609
    tmp___0 = bv;
#line 609
    bv ++;
#line 609
    *tmp = *tmp___0;
#line 609
    if (! *tmp) {
#line 609
      break;
    }
#line 610
    continue;
  }
#line 611
  return (oav);
}
}
#line 614 "glob.c"
void blkfree(char **av0 ) 
{ register char **av ;
  char **tmp ;

  {
#line 616
  av = av0;
#line 618
  while (*av) {
    {
#line 619
    tmp = av;
#line 619
    av ++;
#line 619
    free((void *)*tmp);
    }
  }
#line 620
  return;
}
}
#line 622 "glob.c"
char *strspl(char *cp , char *dp ) 
{ register char *ep ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 624
  tmp = strlen((char const   *)cp);
#line 624
  tmp___0 = strlen((char const   *)dp);
#line 624
  tmp___1 = malloc((tmp + tmp___0) + 1U);
#line 624
  ep = (char *)tmp___1;
  }
#line 627
  if ((unsigned int )ep == (unsigned int )((char *)0)) {
    {
#line 628
    fatal((char *)"Out of memory");
    }
  }
  {
#line 629
  strcpy((char */* __restrict  */)ep, (char const   */* __restrict  */)cp);
#line 630
  strcat((char */* __restrict  */)ep, (char const   */* __restrict  */)dp);
  }
#line 631
  return (ep);
}
}
#line 634 "glob.c"
char **copyblk(char **v ) 
{ register char **nv ;
  int tmp ;
  void *tmp___0 ;
  char **tmp___1 ;

  {
  {
#line 636
  tmp = blklen(v);
#line 636
  tmp___0 = malloc((unsigned int )(tmp + 1) * sizeof(char **));
#line 636
  nv = (char **)tmp___0;
  }
#line 638
  if ((unsigned int )nv == (unsigned int )((char **)0)) {
    {
#line 639
    fatal((char *)"Out of memory");
    }
  }
  {
#line 641
  tmp___1 = blkcpy(nv, v);
  }
#line 641
  return (tmp___1);
}
}
#line 644 "glob.c"
static char *strend(char *cp ) 
{ 

  {
#line 646
  while (*cp) {
#line 647
    cp ++;
  }
#line 648
  return (cp);
}
}
#line 656 "glob.c"
int gethdir(char *home___0 ) 
{ register struct passwd *pp ;
  struct passwd *tmp ;
  register char *root ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 658
  tmp = getpwnam((char const   *)home___0);
#line 658
  pp = tmp;
#line 659
  root = (char *)((void *)0);
  }
#line 660
  if (! pp) {
#line 661
    return (1);
  } else {
    {
#line 660
    tmp___0 = strlen((char const   *)pp->pw_dir);
    }
#line 660
    if ((unsigned int )(home___0 + tmp___0) >= (unsigned int )lastgpathp) {
#line 661
      return (1);
    }
  }
  {
#line 662
  root = strstr((char const   *)pp->pw_dir, "/./");
  }
#line 663
  if (root) {
#line 663
    tmp___1 = root + 2;
  } else {
#line 663
    tmp___1 = pp->pw_dir;
  }
  {
#line 663
  strcpy((char */* __restrict  */)home___0, (char const   */* __restrict  */)tmp___1);
  }
#line 665
  return (0);
}
}
#line 1 "logwtmp.o"
/* #pragma merger(0,"/tmp/cil-FGM7hS19.i","-g,-O2") */
#line 982 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
#line 72 "logwtmp.c"
static int fd  =    -1;
#line 80 "logwtmp.c"
void wu_logwtmp(char *line___0 , char *name , char *host , int login___0 ) 
{ struct stat buf___2 ;
  struct utmp ut ;
  ssize_t tmp ;
  int tmp___0 ;

  {
#line 154
  if (fd < 0) {
    {
#line 154
    fd = open("/var/log/wtmp", 1025, 0);
    }
#line 154
    if (fd < 0) {
      {
#line 155
      syslog(3, "wtmp %s %m", "/var/log/wtmp");
      }
#line 156
      return;
    }
  }
  {
#line 158
  tmp___0 = fstat(fd, & buf___2);
  }
#line 158
  if (tmp___0 == 0) {
    {
#line 179
    __builtin_strncpy(ut.ut_line, (char const   *)line___0, sizeof(ut.ut_line));
    }
#line 180
    if (login___0) {
      {
#line 181
      __builtin_strncpy(ut.ut_user, (char const   *)name, sizeof(ut.ut_user));
      }
    } else {
      {
#line 184
      __builtin_strncpy(ut.ut_user, "", sizeof(ut.ut_user));
      }
    }
#line 188
    if (login___0) {
      {
#line 189
      __builtin_strncpy(ut.ut_host, (char const   *)host, sizeof(ut.ut_host));
      }
    } else {
      {
#line 192
      __builtin_strncpy(ut.ut_host, "", sizeof(ut.ut_host));
      }
    }
    {
#line 195
    time(& ut.ut_tv.tv_sec);
#line 196
    tmp = write(fd, (void const   *)((char *)(& ut)), sizeof(struct utmp ));
    }
#line 196
    if ((unsigned int )tmp != sizeof(struct utmp )) {
      {
#line 198
      ftruncate(fd, buf___2.st_size);
      }
    }
  }
#line 200
  return;
}
}
#line 1 "popen.o"
/* #pragma merger(0,"/tmp/cil-4gI10E5S.i","-g,-O2") */
#line 384 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int pipe(int *__pipedes ) ;
#line 528
extern  __attribute__((__nothrow__)) int execv(char const   *__path , char * const  *__argv )  __attribute__((__nonnull__(1))) ;
#line 663
extern  __attribute__((__nothrow__)) __gid_t getegid(void) ;
#line 679
extern  __attribute__((__nothrow__)) int setuid(__uid_t __uid ) ;
#line 696
extern  __attribute__((__nothrow__)) int setgid(__gid_t __gid ) ;
#line 742
extern  __attribute__((__nothrow__)) __pid_t vfork(void) ;
#line 216 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
#line 222
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
#line 249
extern  __attribute__((__nothrow__)) int sigprocmask(int __how , sigset_t const   * __restrict  __set ,
                                                     sigset_t * __restrict  __oset ) ;
#line 116 "/usr/include/sys/wait.h"
extern __pid_t wait(union wait *__stat_loc ) ;
#line 199 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *strtok(char * __restrict  __s , char const   * __restrict  __delim )  __attribute__((__nonnull__(2))) ;
#line 57 "popen.c"
static int *pids  ;
#line 58 "popen.c"
static int fds  ;
#line 62 "popen.c"
FILE *ftpd_popen(char *program , char *type___0 , int closestderr ) 
{ register char *cp ;
  FILE *iop ;
  int argc ;
  int gargc___0 ;
  int pdes[2] ;
  int pid ;
  int i ;
  int devnullfd ;
  char **pop ;
  char *argv[100] ;
  char *gargv___0[1000] ;
  char *vv[2] ;
  struct rlimit rlp ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char **tmp___4 ;
  __uid_t tmp___5 ;
  __gid_t tmp___6 ;
  int tmp___7 ;

  {
  {
#line 77
  rlp.rlim_max = ~ 0UL;
#line 77
  rlp.rlim_cur = rlp.rlim_max;
#line 78
  tmp = getrlimit(7, & rlp);
  }
#line 78
  if (tmp) {
#line 79
    return ((FILE *)((void *)0));
  }
#line 80
  fds = (int )rlp.rlim_cur;
#line 97
  if ((int )*type___0 != 114) {
#line 97
    if ((int )*type___0 != 119) {
#line 98
      return ((FILE *)((void *)0));
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 97
    if (*(type___0 + 1)) {
#line 98
      return ((FILE *)((void *)0));
    }
  }
#line 100
  if (! pids) {
    {
#line 101
    tmp___0 = calloc((unsigned int )fds, sizeof(int ));
#line 101
    pids = (int *)tmp___0;
    }
#line 102
    if ((unsigned int )pids == (unsigned int )((void *)0)) {
#line 103
      return ((FILE *)((void *)0));
    }
  }
  {
#line 105
  tmp___1 = pipe(pdes);
  }
#line 105
  if (tmp___1 < 0) {
#line 106
    return ((FILE *)((void *)0));
  }
  {
#line 107
  memset((void *)(argv), 0, sizeof(argv));
#line 110
  memset((void *)((char *)(argv)), '\000', sizeof(argv));
#line 112
  argc = 0;
#line 112
  cp = program;
  }
#line 112
  while (argc < 99) {
    {
#line 113
    tmp___2 = argc;
#line 113
    argc ++;
#line 113
    argv[tmp___2] = strtok((char */* __restrict  */)cp, (char const   */* __restrict  */)" \t\n");
    }
#line 113
    if (! argv[tmp___2]) {
#line 114
      break;
    }
#line 112
    cp = (char *)((void *)0);
  }
#line 117
  gargv___0[0] = argv[0];
#line 118
  argc = 1;
#line 118
  gargc___0 = argc;
#line 118
  while (1) {
#line 118
    if (argc < 100) {
#line 118
      if (! argv[argc]) {
#line 118
        break;
      }
    } else {
#line 118
      break;
    }
    {
#line 119
    pop = ftpglob(argv[argc]);
    }
#line 119
    if (pop) {
#line 119
      if ((unsigned int )globerr != (unsigned int )((void *)0)) {
        {
#line 120
        vv[0] = strspl(argv[argc], (char *)"");
#line 121
        vv[1] = (char *)((void *)0);
#line 122
        pop = copyblk(vv);
        }
      }
    } else {
      {
#line 120
      vv[0] = strspl(argv[argc], (char *)"");
#line 121
      vv[1] = (char *)((void *)0);
#line 122
      pop = copyblk(vv);
      }
    }
#line 124
    argv[argc] = (char *)pop;
#line 125
    while (1) {
#line 125
      if (*pop) {
#line 125
        if (! (gargc___0 < 999)) {
#line 125
          break;
        }
      } else {
#line 125
        break;
      }
#line 126
      tmp___3 = gargc___0;
#line 126
      gargc___0 ++;
#line 126
      tmp___4 = pop;
#line 126
      pop ++;
#line 126
      gargv___0[tmp___3] = *tmp___4;
    }
#line 118
    argc ++;
  }
  {
#line 128
  gargv___0[gargc___0] = (char *)((void *)0);
#line 131
  signal(17, (void (*)(int  ))0);
#line 133
  iop = (FILE *)((void *)0);
#line 134
  pid = vfork();
  }
#line 134
  switch (pid) {
  case -1: 
  {
#line 136
  close(pdes[0]);
#line 137
  close(pdes[1]);
  }
  goto pfree;
  case 0: 
#line 141
  if ((int )*type___0 == 114) {
#line 142
    if (pdes[1] != 1) {
      {
#line 143
      dup2(pdes[1], 1);
      }
#line 144
      if (closestderr) {
        {
#line 145
        close(2);
#line 148
        devnullfd = open("/dev/null", 2);
        }
#line 148
        if (devnullfd != -1) {
#line 149
          if (devnullfd != 2) {
            {
#line 150
            dup2(devnullfd, 2);
#line 151
            close(devnullfd);
            }
          }
        }
      } else {
        {
#line 156
        dup2(pdes[1], 2);
        }
      }
      {
#line 157
      close(pdes[1]);
      }
    }
    {
#line 159
    close(pdes[0]);
    }
  } else {
#line 162
    if (pdes[0] != 0) {
      {
#line 163
      dup2(pdes[0], 0);
#line 164
      close(pdes[0]);
      }
    }
    {
#line 166
    close(pdes[1]);
    }
  }
#line 168
  i = 3;
#line 168
  while (i < fds) {
    {
#line 169
    close(i);
#line 168
    i ++;
    }
  }
  {
#line 171
  close(0);
#line 172
  tmp___5 = geteuid();
#line 172
  i = (int )tmp___5;
#line 173
  delay_signaling();
#line 174
  seteuid(0U);
#line 175
  tmp___6 = getegid();
#line 175
  setgid(tmp___6);
#line 176
  setuid((unsigned int )i);
#line 177
  enable_signaling();
#line 179
  execv((char const   *)gargv___0[0], (char * const  *)(gargv___0));
#line 180
  _exit(1);
  }
  }
#line 183
  if ((int )*type___0 == 114) {
    {
#line 184
    iop = fdopen(pdes[0], (char const   *)type___0);
#line 185
    close(pdes[1]);
    }
  } else {
    {
#line 188
    iop = fdopen(pdes[1], (char const   *)type___0);
#line 189
    close(pdes[0]);
    }
  }
  {
#line 191
  tmp___7 = fileno(iop);
#line 191
  *(pids + tmp___7) = pid;
  }
  pfree: 
#line 193
  argc = 1;
#line 193
  while (1) {
#line 193
    if (argc < 100) {
#line 193
      if (! argv[argc]) {
#line 193
        break;
      }
    } else {
#line 193
      break;
    }
    {
#line 194
    blkfree((char **)argv[argc]);
#line 195
    free((void *)argv[argc]);
#line 193
    argc ++;
    }
  }
#line 197
  return (iop);
}
}
#line 200 "popen.c"
int ftpd_pclose(FILE *iop ) 
{ register int fdes ;
  int pid ;
  sigset_t sig ;
  sigset_t omask ;
  int stat_loc ;
  int tmp ;
  union __anonunion_57 __constr_expr_1 ;

  {
  {
#line 207
  sigemptyset(& sig);
#line 208
  sigaddset(& sig, 2);
#line 209
  sigaddset(& sig, 3);
#line 210
  sigaddset(& sig, 1);
  }
#line 222
  if ((unsigned int )pids == (unsigned int )((int *)0)) {
#line 223
    return (-1);
  } else {
    {
#line 222
    fdes = fileno(iop);
    }
#line 222
    if (*(pids + fdes) == 0) {
#line 223
      return (-1);
    }
  }
  {
#line 224
  fclose(iop);
#line 226
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& sig), (sigset_t */* __restrict  */)(& omask));
  }
#line 234
  while (1) {
    {
#line 234
    pid = wait((union wait *)(& stat_loc));
    }
#line 234
    if (pid != *(pids + fdes)) {
#line 234
      if (! (pid != -1)) {
#line 234
        break;
      }
    } else {
#line 234
      break;
    }
  }
  {
#line 238
  *(pids + fdes) = 0;
#line 240
  signal(17, (void (*)(int  ))1);
#line 243
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& omask), (sigset_t */* __restrict  */)((sigset_t *)((void *)0)));
  }
#line 244
  if (pid == -1) {
#line 244
    tmp = -1;
  } else {
#line 244
    __constr_expr_1.__in = stat_loc;
#line 244
    tmp = (__constr_expr_1.__i & 65280) >> 8;
  }
#line 244
  return (tmp);
}
}
#line 1 "access.o"
/* #pragma merger(0,"/tmp/cil-MPEwPEZa.i","-g,-O2") */
#line 413 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                                                , ...) ;
#line 555 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int nice(int __inc ) ;
#line 236 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *localtime(time_t const   *__timer ) ;
#line 69 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 51 "/usr/include/sys/file.h"
extern  __attribute__((__nothrow__)) int flock(int __fd , int __operation ) ;
#line 146 "pathnames.h"
char _path_ftpaccess[4096]  ;
#line 149 "pathnames.h"
char _path_private[4096]  ;
#line 117 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
#line 44 "proto.h"
int parsetime(char *whattime ) ;
#line 45
int validtime(char *ptr ) ;
#line 52
int acl_getlimit(char *class , char *msgpathbuf ) ;
#line 53
int acl_getnice(char *class ) ;
#line 54
void acl_getdefumask(char *class ) ;
#line 55
void acl_tcpwindow(char *class ) ;
#line 56
void acl_filelimit(char *class ) ;
#line 57
void acl_datalimit(char *class ) ;
#line 58
int acl_deny(char *msgpathbuf ) ;
#line 59
int acl_countusers(char *class ) ;
#line 60
void acl_join(char *class ) ;
#line 70
void parseacl(void) ;
#line 71
int readacl(char *aclpath ) ;
#line 96
void msg_massage(char const   *inbuf , char *outbuf , size_t outlen ) ;
#line 247
void priv_setup(char *path ) ;
#line 284
void load_timeouts(void) ;
#line 295
extern char *strcasestr(char *s , char *find ) ;
#line 71 "access.c"
char *aclbuf ;
#line 74 "access.c"
char Shutdown[4096]  ;
#line 75 "access.c"
int keepalive  =    0;
#line 77 "access.c"
static char incline[80]  ;
#line 78 "access.c"
int pidfd  =    -1;
#line 29 "wu_fnmatch.h"
int wu_fnmatch(char const   *pattern , char const   *string , int flags ) ;
#line 98 "access.c"
static char *days[8]  = 
#line 98 "access.c"
  {      (char *)"Su",      (char *)"Mo",      (char *)"Tu",      (char *)"We", 
        (char *)"Th",      (char *)"Fr",      (char *)"Sa",      (char *)"Wk"};
#line 96 "access.c"
int parsetime(char *whattime ) 
{ time_t clock___0 ;
  struct tm *curtime ;
  int wday ;
  int start ;
  int stop ;
  int ltime ;
  int validday ;
  int loop ;
  int match___0 ;
  int tmp___12 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned short const   **tmp___25 ;
  unsigned short const   **tmp___26 ;
  int tmp___40 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___53 ;

  {
  {
#line 104
  time(& clock___0);
#line 105
  curtime = localtime((time_t const   *)(& clock___0));
#line 106
  wday = curtime->tm_wday;
#line 107
  validday = 0;
#line 108
  match___0 = 1;
  }
#line 110
  while (1) {
#line 110
    if (match___0) {
      {
#line 110
      tmp___25 = __ctype_b_loc();
      }
#line 110
      if ((int const   )*(*tmp___25 + (int )*whattime) & 1024) {
        {
#line 110
        tmp___26 = __ctype_b_loc();
        }
#line 110
        if (! ((int const   )*(*tmp___26 + (int )*whattime) & 256)) {
#line 110
          break;
        }
      } else {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 111
    match___0 = 0;
#line 112
    loop = 0;
#line 112
    while (loop < 8) {
#line 113
      if (0) {
#line 113
        if (0) {
          {
#line 113
          __s1_len___0 = strlen((char const   *)days[loop]);
#line 113
          __s2_len___0 = strlen((char const   *)whattime);
          }
#line 113
          if (! ((unsigned int )((void const   *)(days[loop] + 1)) - (unsigned int )((void const   *)days[loop]) == 1U)) {
            goto _L___2;
          } else {
#line 113
            if (__s1_len___0 >= 4U) {
              _L___2: 
#line 113
              if (! ((unsigned int )((void const   *)(whattime + 1)) - (unsigned int )((void const   *)whattime) == 1U)) {
#line 113
                tmp___22 = 1;
              } else {
#line 113
                if (__s2_len___0 >= 4U) {
#line 113
                  tmp___22 = 1;
                } else {
#line 113
                  tmp___22 = 0;
                }
              }
            } else {
#line 113
              tmp___22 = 0;
            }
          }
#line 113
          if (tmp___22) {
            {
#line 113
            tmp___18 = __builtin_strcmp((char const   *)days[loop], (char const   *)whattime);
            }
          } else {
            {
#line 113
            tmp___21 = __builtin_strcmp((char const   *)days[loop], (char const   *)whattime);
#line 113
            tmp___18 = tmp___21;
            }
          }
        } else {
          {
#line 113
          tmp___21 = __builtin_strcmp((char const   *)days[loop], (char const   *)whattime);
#line 113
          tmp___18 = tmp___21;
          }
        }
#line 113
        tmp___12 = tmp___18;
      } else {
        {
#line 113
        tmp___12 = strncmp((char const   *)days[loop], (char const   *)whattime, 2U);
        }
      }
#line 113
      if (tmp___12 == 0) {
#line 114
        whattime += 2;
#line 115
        match___0 = 1;
#line 116
        if (wday == loop) {
#line 117
          validday = 1;
        } else {
#line 116
          if (loop == 7) {
#line 116
            if (wday) {
#line 116
              if (wday < 6) {
#line 117
                validday = 1;
              }
            }
          }
        }
      }
#line 112
      loop ++;
    }
  }
#line 123
  if (! validday) {
#line 124
    if (0) {
#line 124
      if (0) {
        {
#line 124
        __s1_len___2 = strlen((char const   *)whattime);
#line 124
        __s2_len___2 = strlen("Any");
        }
#line 124
        if (! ((unsigned int )((void const   *)(whattime + 1)) - (unsigned int )((void const   *)whattime) == 1U)) {
          goto _L___6;
        } else {
#line 124
          if (__s1_len___2 >= 4U) {
            _L___6: 
#line 124
            if (! ((unsigned int )((void const   *)("Any" + 1)) - (unsigned int )((void const   *)"Any") == 1U)) {
#line 124
              tmp___50 = 1;
            } else {
#line 124
              if (__s2_len___2 >= 4U) {
#line 124
                tmp___50 = 1;
              } else {
#line 124
                tmp___50 = 0;
              }
            }
          } else {
#line 124
            tmp___50 = 0;
          }
        }
#line 124
        if (tmp___50) {
          {
#line 124
          tmp___46 = __builtin_strcmp((char const   *)whattime, "Any");
          }
        } else {
          {
#line 124
          tmp___49 = __builtin_strcmp((char const   *)whattime, "Any");
#line 124
          tmp___46 = tmp___49;
          }
        }
      } else {
        {
#line 124
        tmp___49 = __builtin_strcmp((char const   *)whattime, "Any");
#line 124
        tmp___46 = tmp___49;
        }
      }
#line 124
      tmp___40 = tmp___46;
    } else {
      {
#line 124
      tmp___40 = strncmp((char const   *)whattime, "Any", 3U);
      }
    }
#line 124
    if (tmp___40 == 0) {
#line 125
      validday = 1;
#line 126
      whattime += 3;
    } else {
#line 129
      return (0);
    }
  }
  {
#line 132
  tmp___53 = sscanf((char const   */* __restrict  */)whattime, (char const   */* __restrict  */)"%d-%d",
                    & start, & stop);
  }
#line 132
  if (tmp___53 == 2) {
#line 133
    ltime = curtime->tm_min + 100 * curtime->tm_hour;
#line 134
    if (start < stop) {
#line 134
      if (ltime >= start) {
#line 134
        if (ltime < stop) {
#line 135
          return (1);
        }
      }
    }
#line 136
    if (start > stop) {
#line 136
      if (ltime >= start) {
#line 137
        return (1);
      } else {
#line 136
        if (ltime < stop) {
#line 137
          return (1);
        }
      }
    }
  } else {
#line 140
    return (1);
  }
#line 142
  return (0);
}
}
#line 152 "access.c"
int validtime(char *ptr ) 
{ char *nextptr ;
  int good ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 157
  while (1) {
    {
#line 158
    tmp___0 = __builtin_strchr(ptr, '|');
#line 158
    nextptr = tmp___0;
#line 159
    tmp___3 = __builtin_strchr(ptr, '|');
    }
#line 159
    if ((unsigned int )tmp___3 == (unsigned int )((void *)0)) {
      {
#line 160
      tmp___1 = parsetime(ptr);
      }
#line 160
      return (tmp___1);
    }
    {
#line 161
    *nextptr = (char )'\000';
#line 162
    good = parsetime(ptr);
#line 164
    tmp___4 = nextptr;
#line 164
    nextptr ++;
#line 164
    *tmp___4 = (char )'|';
    }
#line 165
    if (good) {
#line 166
      return (1);
    }
#line 167
    ptr = nextptr;
  }
}
}
#line 178 "access.c"
int hostmatch(char *addr , char *remoteaddr___0 , char *remotehost___0 ) 
{ FILE *incfile ;
  char *ptr ;
  int found ;
  int not_found ;
  int match___0 ;
  int i ;
  int a[4] ;
  int m[4] ;
  int r[4] ;
  int cidr ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 182
  found = 1;
#line 183
  not_found = 0;
#line 184
  match___0 = 0;
#line 187
  if ((unsigned int )addr == (unsigned int )((void *)0)) {
#line 188
    return (0);
  }
#line 190
  if ((int )*addr == 33) {
#line 191
    found = 0;
#line 192
    not_found = 1;
#line 193
    addr ++;
  }
  {
#line 196
  tmp___12 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.%d.%d/%d",
                    a, a + 1, a + 2, a + 3, & cidr);
  }
#line 196
  if (tmp___12 == 5) {
#line 197
    m[0] = 0;
#line 198
    m[1] = 0;
#line 199
    m[2] = 0;
#line 200
    m[3] = 0;
#line 201
    if (cidr < 0) {
#line 202
      cidr = 0;
    } else {
#line 203
      if (cidr > 32) {
#line 204
        cidr = 32;
      }
    }
#line 205
    i = 0;
#line 205
    while (cidr > 8) {
#line 206
      m[i] = 255;
#line 207
      cidr -= 8;
#line 205
      i ++;
    }
#line 209
    switch (cidr) {
    case 8: 
#line 211
    (m[i]) ++;
    case 7: 
#line 213
    m[i] += 2;
    case 6: 
#line 215
    m[i] += 4;
    case 5: 
#line 217
    m[i] += 8;
    case 4: 
#line 219
    m[i] += 16;
    case 3: 
#line 221
    m[i] += 32;
    case 2: 
#line 223
    m[i] += 64;
    case 1: 
#line 225
    m[i] += 128;
    }
    {
#line 227
    sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
           r, r + 1, r + 2, r + 3);
#line 228
    i = 0;
    }
#line 228
    while (i < 4) {
#line 229
      if ((a[i] & m[i]) != (r[i] & m[i])) {
#line 230
        return (not_found);
      }
#line 228
      i ++;
    }
#line 231
    return (found);
  } else {
    {
#line 233
    tmp___11 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.%d.%d:%d.%d.%d.%d",
                      a, a + 1, a + 2, a + 3, m, m + 1, m + 2, m + 3);
    }
#line 233
    if (tmp___11 == 8) {
      {
#line 234
      sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
             r, r + 1, r + 2, r + 3);
#line 235
      i = 0;
      }
#line 235
      while (i < 4) {
#line 236
        if ((a[i] & m[i]) != (r[i] & m[i])) {
#line 237
          return (not_found);
        }
#line 235
        i ++;
      }
#line 238
      return (found);
    } else {
      {
#line 240
      tmp___10 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.%d.%d",
                        a, a + 1, a + 2, a + 3);
      }
#line 240
      if (tmp___10 == 4) {
        {
#line 241
        sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
               r, r + 1, r + 2, r + 3);
#line 242
        i = 0;
        }
#line 242
        while (i < 4) {
#line 243
          if (a[i] != r[i]) {
#line 244
            return (not_found);
          }
#line 242
          i ++;
        }
#line 245
        return (found);
      } else {
        {
#line 247
        tmp___9 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.%d.*",
                         a, a + 1, a + 2);
        }
#line 247
        if (tmp___9 == 3) {
          {
#line 248
          sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
                 r, r + 1, r + 2, r + 3);
#line 249
          i = 0;
          }
#line 249
          while (i < 3) {
#line 250
            if (a[i] != r[i]) {
#line 251
              return (not_found);
            }
#line 249
            i ++;
          }
#line 252
          return (found);
        } else {
          {
#line 254
          tmp___8 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.%d.*.*",
                           a, a + 1);
          }
#line 254
          if (tmp___8 == 2) {
            {
#line 255
            sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
                   r, r + 1, r + 2, r + 3);
#line 256
            i = 0;
            }
#line 256
            while (i < 2) {
#line 257
              if (a[i] != r[i]) {
#line 258
                return (not_found);
              }
#line 256
              i ++;
            }
#line 259
            return (found);
          } else {
            {
#line 261
            tmp___7 = sscanf((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"%d.*.*.*",
                             a);
            }
#line 261
            if (tmp___7 == 1) {
              {
#line 262
              sscanf((char const   */* __restrict  */)remoteaddr___0, (char const   */* __restrict  */)"%d.%d.%d.%d",
                     r, r + 1, r + 2, r + 3);
#line 263
              i = 0;
              }
#line 263
              while (i < 1) {
#line 264
                if (a[i] != r[i]) {
#line 265
                  return (not_found);
                }
#line 263
                i ++;
              }
#line 266
              return (found);
            } else {
#line 268
              if ((int )*addr == 47) {
                {
#line 273
                incfile = fopen((char const   */* __restrict  */)addr, (char const   */* __restrict  */)"r");
                }
#line 273
                if ((unsigned int )incfile == (unsigned int )((void *)0)) {
                  {
#line 274
                  tmp = __errno_location();
                  }
#line 274
                  if (*tmp != 2) {
                    {
#line 275
                    syslog(3, "cannot open addrglob file %s: %m", addr);
                    }
                  }
#line 277
                  return (0);
                }
#line 280
                while (1) {
#line 280
                  if (! match___0) {
                    {
#line 280
                    tmp___2 = fgets((char */* __restrict  */)(incline), 80, (FILE */* __restrict  */)incfile);
                    }
#line 280
                    if (! ((unsigned int )tmp___2 != (unsigned int )((void *)0))) {
#line 280
                      break;
                    }
                  } else {
#line 280
                    break;
                  }
                  {
#line 281
                  ptr = strtok((char */* __restrict  */)(incline), (char const   */* __restrict  */)" \t\n");
                  }
#line 282
                  if (ptr) {
                    {
#line 282
                    tmp___0 = hostmatch(ptr, remoteaddr___0, remotehost___0);
                    }
#line 282
                    if (tmp___0) {
#line 283
                      match___0 = 1;
                    }
                  }
#line 284
                  while (1) {
#line 284
                    if (! match___0) {
                      {
#line 284
                      ptr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\n");
                      }
#line 284
                      if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 284
                        break;
                      }
                    } else {
#line 284
                      break;
                    }
#line 285
                    if (ptr) {
                      {
#line 285
                      tmp___1 = hostmatch(ptr, remoteaddr___0, remotehost___0);
                      }
#line 285
                      if (tmp___1) {
#line 286
                        match___0 = 1;
                      }
                    }
                  }
                }
                {
#line 289
                fclose(incfile);
                }
#line 290
                if (match___0) {
#line 290
                  tmp___3 = found;
                } else {
#line 290
                  tmp___3 = not_found;
                }
#line 290
                return (tmp___3);
              } else {
                {
#line 293
                tmp___4 = wu_fnmatch((char const   *)addr, (char const   *)remotehost___0,
                                     16);
                }
#line 293
                if (tmp___4) {
#line 293
                  tmp___5 = 0;
                } else {
#line 293
                  tmp___5 = 1;
                }
#line 293
                match___0 = tmp___5;
#line 294
                if (match___0) {
#line 294
                  tmp___6 = found;
                } else {
#line 294
                  tmp___6 = not_found;
                }
#line 294
                return (tmp___6);
              }
            }
          }
        }
      }
    }
  }
}
}
#line 305 "access.c"
int acl_guestgroup(struct passwd *pw___0 ) 
{ struct aclmember *entry ;
  struct group *grp ;
  int which ;
  char **member ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *ptr ;
  char *tmp___10 ;
  char *tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  struct passwd *g_pw ;
  struct passwd *tmp___19 ;
  struct aclmember *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  char *ptr___0 ;
  char *tmp___32 ;
  char *tmp___34 ;
  unsigned long tmp___35 ;
  char *tmp___36 ;
  unsigned long tmp___37 ;
  char *tmp___38 ;
  unsigned long tmp___39 ;
  unsigned long tmp___40 ;
  int tmp___41 ;
  struct aclmember *tmp___42 ;

  {
#line 307
  entry = (struct aclmember *)((void *)0);
#line 324
  while (1) {
    {
#line 324
    tmp___20 = getaclentry((char *)"guestuser", & entry);
    }
#line 324
    if (! tmp___20) {
#line 324
      break;
    }
#line 325
    which = 0;
#line 325
    while (1) {
#line 325
      if (which < 50) {
#line 325
        if (! entry->arg[which]) {
#line 325
          break;
        }
      } else {
#line 325
        break;
      }
#line 326
      if (0) {
        {
#line 326
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 326
        __s2_len = strlen("*");
        }
#line 326
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 326
          if (__s1_len >= 4U) {
            _L___0: 
#line 326
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 326
              tmp___8 = 1;
            } else {
#line 326
              if (__s2_len >= 4U) {
#line 326
                tmp___8 = 1;
              } else {
#line 326
                tmp___8 = 0;
              }
            }
          } else {
#line 326
            tmp___8 = 0;
          }
        }
#line 326
        if (tmp___8) {
          {
#line 326
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 326
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 326
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 326
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 326
        tmp___4 = tmp___7;
        }
      }
#line 326
      if (! tmp___4) {
#line 327
        return (1);
      }
#line 328
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 329
        tmp___10 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 329
        ptr = tmp___10;
        }
#line 330
        if (! ptr) {
          {
#line 331
          tmp___12 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 331
          ptr = tmp___12;
          }
#line 332
          if (! ptr) {
            {
#line 333
            tmp___13 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 333
            if ((unsigned long )pw___0->pw_uid == tmp___13) {
#line 334
              return (1);
            }
          } else {
#line 337
            tmp___14 = ptr;
#line 337
            ptr ++;
#line 337
            *tmp___14 = (char )'\000';
#line 338
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 340
              ptr --;
#line 340
              *ptr = (char )'+';
#line 341
              return (1);
            } else {
              {
#line 338
              tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 338
              if ((unsigned long )pw___0->pw_uid >= tmp___15) {
#line 340
                ptr --;
#line 340
                *ptr = (char )'+';
#line 341
                return (1);
              }
            }
#line 343
            ptr --;
#line 343
            *ptr = (char )'+';
          }
        } else {
#line 347
          tmp___16 = ptr;
#line 347
          ptr ++;
#line 347
          *tmp___16 = (char )'\000';
#line 348
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 348
            tmp___17 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 348
            if ((unsigned long )pw___0->pw_uid >= tmp___17) {
              _L___1: 
#line 348
              if ((int )*ptr == 0) {
#line 352
                ptr --;
#line 352
                *ptr = (char )'-';
#line 353
                return (1);
              } else {
                {
#line 348
                tmp___18 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 348
                if ((unsigned long )pw___0->pw_uid <= tmp___18) {
#line 352
                  ptr --;
#line 352
                  *ptr = (char )'-';
#line 353
                  return (1);
                }
              }
            }
          }
#line 355
          ptr --;
#line 355
          *ptr = (char )'-';
        }
      } else {
        {
#line 359
        tmp___19 = getpwnam((char const   *)entry->arg[which]);
#line 359
        g_pw = tmp___19;
        }
#line 360
        if (g_pw) {
#line 360
          if (g_pw->pw_uid == pw___0->pw_uid) {
#line 361
            return (1);
          }
        }
      }
#line 325
      which ++;
    }
  }
#line 378
  while (1) {
    {
#line 378
    tmp___42 = getaclentry((char *)"guestgroup", & entry);
    }
#line 378
    if (! tmp___42) {
#line 378
      break;
    }
#line 379
    which = 0;
#line 379
    while (1) {
#line 379
      if (which < 50) {
#line 379
        if (! entry->arg[which]) {
#line 379
          break;
        }
      } else {
#line 379
        break;
      }
#line 380
      if (0) {
        {
#line 380
        __s1_len___0 = strlen((char const   *)entry->arg[which]);
#line 380
        __s2_len___0 = strlen("*");
        }
#line 380
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___3;
        } else {
#line 380
          if (__s1_len___0 >= 4U) {
            _L___3: 
#line 380
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 380
              tmp___30 = 1;
            } else {
#line 380
              if (__s2_len___0 >= 4U) {
#line 380
                tmp___30 = 1;
              } else {
#line 380
                tmp___30 = 0;
              }
            }
          } else {
#line 380
            tmp___30 = 0;
          }
        }
#line 380
        if (tmp___30) {
          {
#line 380
          tmp___26 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 380
          tmp___29 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 380
          tmp___26 = tmp___29;
          }
        }
      } else {
        {
#line 380
        tmp___29 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 380
        tmp___26 = tmp___29;
        }
      }
#line 380
      if (! tmp___26) {
#line 381
        return (1);
      }
#line 382
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 383
        tmp___32 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 383
        ptr___0 = tmp___32;
        }
#line 384
        if (! ptr___0) {
          {
#line 385
          tmp___34 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 385
          ptr___0 = tmp___34;
          }
#line 386
          if (! ptr___0) {
            {
#line 387
            tmp___35 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 387
            if ((unsigned long )pw___0->pw_gid == tmp___35) {
#line 388
              return (1);
            }
          } else {
#line 391
            tmp___36 = ptr___0;
#line 391
            ptr___0 ++;
#line 391
            *tmp___36 = (char )'\000';
#line 392
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 394
              ptr___0 --;
#line 394
              *ptr___0 = (char )'+';
#line 395
              return (1);
            } else {
              {
#line 392
              tmp___37 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 392
              if ((unsigned long )pw___0->pw_gid >= tmp___37) {
#line 394
                ptr___0 --;
#line 394
                *ptr___0 = (char )'+';
#line 395
                return (1);
              }
            }
#line 397
            ptr___0 --;
#line 397
            *ptr___0 = (char )'+';
          }
        } else {
#line 401
          tmp___38 = ptr___0;
#line 401
          ptr___0 ++;
#line 401
          *tmp___38 = (char )'\000';
#line 402
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___4;
          } else {
            {
#line 402
            tmp___39 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 402
            if ((unsigned long )pw___0->pw_gid >= tmp___39) {
              _L___4: 
#line 402
              if ((int )*ptr___0 == 0) {
#line 406
                ptr___0 --;
#line 406
                *ptr___0 = (char )'-';
#line 407
                return (1);
              } else {
                {
#line 402
                tmp___40 = strtoul((char const   */* __restrict  */)ptr___0, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 402
                if ((unsigned long )pw___0->pw_gid <= tmp___40) {
#line 406
                  ptr___0 --;
#line 406
                  *ptr___0 = (char )'-';
#line 407
                  return (1);
                }
              }
            }
          }
#line 409
          ptr___0 --;
#line 409
          *ptr___0 = (char )'-';
        }
      } else {
        {
#line 413
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 413
        if (grp) {
#line 414
          if (grp->gr_gid == pw___0->pw_gid) {
#line 415
            return (1);
          }
#line 416
          member = grp->gr_mem;
#line 416
          while (*member) {
            {
#line 417
            tmp___41 = strcasecmp((char const   *)*member, (char const   *)pw___0->pw_name);
            }
#line 417
            if (! tmp___41) {
#line 418
              return (1);
            }
#line 416
            member ++;
          }
        }
      }
#line 379
      which ++;
    }
  }
#line 424
  return (0);
}
}
#line 427 "access.c"
int acl_realgroup(struct passwd *pw___0 ) 
{ struct aclmember *entry ;
  struct group *grp ;
  int which ;
  char **member ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *ptr ;
  char *tmp___10 ;
  char *tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  unsigned long tmp___17 ;
  unsigned long tmp___18 ;
  struct passwd *g_pw ;
  struct passwd *tmp___19 ;
  struct aclmember *tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  char *ptr___0 ;
  char *tmp___32 ;
  char *tmp___34 ;
  unsigned long tmp___35 ;
  char *tmp___36 ;
  unsigned long tmp___37 ;
  char *tmp___38 ;
  unsigned long tmp___39 ;
  unsigned long tmp___40 ;
  int tmp___41 ;
  struct aclmember *tmp___42 ;

  {
#line 429
  entry = (struct aclmember *)((void *)0);
#line 446
  while (1) {
    {
#line 446
    tmp___20 = getaclentry((char *)"realuser", & entry);
    }
#line 446
    if (! tmp___20) {
#line 446
      break;
    }
#line 447
    which = 0;
#line 447
    while (1) {
#line 447
      if (which < 50) {
#line 447
        if (! entry->arg[which]) {
#line 447
          break;
        }
      } else {
#line 447
        break;
      }
#line 448
      if (0) {
        {
#line 448
        __s1_len = strlen((char const   *)entry->arg[which]);
#line 448
        __s2_len = strlen("*");
        }
#line 448
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___0;
        } else {
#line 448
          if (__s1_len >= 4U) {
            _L___0: 
#line 448
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 448
              tmp___8 = 1;
            } else {
#line 448
              if (__s2_len >= 4U) {
#line 448
                tmp___8 = 1;
              } else {
#line 448
                tmp___8 = 0;
              }
            }
          } else {
#line 448
            tmp___8 = 0;
          }
        }
#line 448
        if (tmp___8) {
          {
#line 448
          tmp___4 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 448
          tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 448
          tmp___4 = tmp___7;
          }
        }
      } else {
        {
#line 448
        tmp___7 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 448
        tmp___4 = tmp___7;
        }
      }
#line 448
      if (! tmp___4) {
#line 449
        return (1);
      }
#line 450
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 451
        tmp___10 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 451
        ptr = tmp___10;
        }
#line 452
        if (! ptr) {
          {
#line 453
          tmp___12 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 453
          ptr = tmp___12;
          }
#line 454
          if (! ptr) {
            {
#line 455
            tmp___13 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 455
            if ((unsigned long )pw___0->pw_uid == tmp___13) {
#line 456
              return (1);
            }
          } else {
#line 459
            tmp___14 = ptr;
#line 459
            ptr ++;
#line 459
            *tmp___14 = (char )'\000';
#line 460
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 462
              ptr --;
#line 462
              *ptr = (char )'+';
#line 463
              return (1);
            } else {
              {
#line 460
              tmp___15 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 460
              if ((unsigned long )pw___0->pw_uid >= tmp___15) {
#line 462
                ptr --;
#line 462
                *ptr = (char )'+';
#line 463
                return (1);
              }
            }
#line 465
            ptr --;
#line 465
            *ptr = (char )'+';
          }
        } else {
#line 469
          tmp___16 = ptr;
#line 469
          ptr ++;
#line 469
          *tmp___16 = (char )'\000';
#line 470
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___1;
          } else {
            {
#line 470
            tmp___17 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 470
            if ((unsigned long )pw___0->pw_uid >= tmp___17) {
              _L___1: 
#line 470
              if ((int )*ptr == 0) {
#line 474
                ptr --;
#line 474
                *ptr = (char )'-';
#line 475
                return (1);
              } else {
                {
#line 470
                tmp___18 = strtoul((char const   */* __restrict  */)ptr, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 470
                if ((unsigned long )pw___0->pw_uid <= tmp___18) {
#line 474
                  ptr --;
#line 474
                  *ptr = (char )'-';
#line 475
                  return (1);
                }
              }
            }
          }
#line 477
          ptr --;
#line 477
          *ptr = (char )'-';
        }
      } else {
        {
#line 481
        tmp___19 = getpwnam((char const   *)entry->arg[which]);
#line 481
        g_pw = tmp___19;
        }
#line 482
        if (g_pw) {
#line 482
          if (g_pw->pw_uid == pw___0->pw_uid) {
#line 483
            return (1);
          }
        }
      }
#line 447
      which ++;
    }
  }
#line 500
  while (1) {
    {
#line 500
    tmp___42 = getaclentry((char *)"realgroup", & entry);
    }
#line 500
    if (! tmp___42) {
#line 500
      break;
    }
#line 501
    which = 0;
#line 501
    while (1) {
#line 501
      if (which < 50) {
#line 501
        if (! entry->arg[which]) {
#line 501
          break;
        }
      } else {
#line 501
        break;
      }
#line 502
      if (0) {
        {
#line 502
        __s1_len___0 = strlen((char const   *)entry->arg[which]);
#line 502
        __s2_len___0 = strlen("*");
        }
#line 502
        if (! ((unsigned int )((void const   *)(entry->arg[which] + 1)) - (unsigned int )((void const   *)entry->arg[which]) == 1U)) {
          goto _L___3;
        } else {
#line 502
          if (__s1_len___0 >= 4U) {
            _L___3: 
#line 502
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 502
              tmp___30 = 1;
            } else {
#line 502
              if (__s2_len___0 >= 4U) {
#line 502
                tmp___30 = 1;
              } else {
#line 502
                tmp___30 = 0;
              }
            }
          } else {
#line 502
            tmp___30 = 0;
          }
        }
#line 502
        if (tmp___30) {
          {
#line 502
          tmp___26 = __builtin_strcmp((char const   *)entry->arg[which], "*");
          }
        } else {
          {
#line 502
          tmp___29 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 502
          tmp___26 = tmp___29;
          }
        }
      } else {
        {
#line 502
        tmp___29 = __builtin_strcmp((char const   *)entry->arg[which], "*");
#line 502
        tmp___26 = tmp___29;
        }
      }
#line 502
      if (! tmp___26) {
#line 503
        return (1);
      }
#line 504
      if ((int )*(entry->arg[which] + 0) == 37) {
        {
#line 505
        tmp___32 = __builtin_strchr(entry->arg[which] + 1, '-');
#line 505
        ptr___0 = tmp___32;
        }
#line 506
        if (! ptr___0) {
          {
#line 507
          tmp___34 = __builtin_strchr(entry->arg[which] + 1, '+');
#line 507
          ptr___0 = tmp___34;
          }
#line 508
          if (! ptr___0) {
            {
#line 509
            tmp___35 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 509
            if ((unsigned long )pw___0->pw_gid == tmp___35) {
#line 510
              return (1);
            }
          } else {
#line 513
            tmp___36 = ptr___0;
#line 513
            ptr___0 ++;
#line 513
            *tmp___36 = (char )'\000';
#line 514
            if ((int )*(entry->arg[which] + 1) == 0) {
#line 516
              ptr___0 --;
#line 516
              *ptr___0 = (char )'+';
#line 517
              return (1);
            } else {
              {
#line 514
              tmp___37 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                                 (char **/* __restrict  */)((void *)0), 0);
              }
#line 514
              if ((unsigned long )pw___0->pw_gid >= tmp___37) {
#line 516
                ptr___0 --;
#line 516
                *ptr___0 = (char )'+';
#line 517
                return (1);
              }
            }
#line 519
            ptr___0 --;
#line 519
            *ptr___0 = (char )'+';
          }
        } else {
#line 523
          tmp___38 = ptr___0;
#line 523
          ptr___0 ++;
#line 523
          *tmp___38 = (char )'\000';
#line 524
          if ((int )*(entry->arg[which] + 1) == 0) {
            goto _L___4;
          } else {
            {
#line 524
            tmp___39 = strtoul((char const   */* __restrict  */)(entry->arg[which] + 1),
                               (char **/* __restrict  */)((void *)0), 0);
            }
#line 524
            if ((unsigned long )pw___0->pw_gid >= tmp___39) {
              _L___4: 
#line 524
              if ((int )*ptr___0 == 0) {
#line 528
                ptr___0 --;
#line 528
                *ptr___0 = (char )'-';
#line 529
                return (1);
              } else {
                {
#line 524
                tmp___40 = strtoul((char const   */* __restrict  */)ptr___0, (char **/* __restrict  */)((void *)0),
                                   0);
                }
#line 524
                if ((unsigned long )pw___0->pw_gid <= tmp___40) {
#line 528
                  ptr___0 --;
#line 528
                  *ptr___0 = (char )'-';
#line 529
                  return (1);
                }
              }
            }
          }
#line 531
          ptr___0 --;
#line 531
          *ptr___0 = (char )'-';
        }
      } else {
        {
#line 535
        grp = getgrnam((char const   *)entry->arg[which]);
        }
#line 535
        if (grp) {
#line 536
          if (grp->gr_gid == pw___0->pw_gid) {
#line 537
            return (1);
          }
#line 538
          member = grp->gr_mem;
#line 538
          while (*member) {
            {
#line 539
            tmp___41 = strcasecmp((char const   *)*member, (char const   *)pw___0->pw_name);
            }
#line 539
            if (! tmp___41) {
#line 540
              return (1);
            }
#line 538
            member ++;
          }
        }
      }
#line 501
      which ++;
    }
  }
#line 546
  return (0);
}
}
#line 557 "access.c"
void acl_autogroup(struct passwd *pw___0 ) 
{ char class[1024] ;
  struct aclmember *entry ;
  struct group *grp ;
  int which ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
  {
#line 561
  entry = (struct aclmember *)((void *)0);
#line 565
  acl_getclass(class);
  }
#line 568
  while (1) {
    {
#line 568
    tmp___1 = getaclentry((char *)"autogroup", & entry);
    }
#line 568
    if (! tmp___1) {
#line 568
      break;
    }
#line 569
    if (! entry->arg[0]) {
#line 570
      continue;
    } else {
#line 569
      if (! entry->arg[1]) {
#line 570
        continue;
      }
    }
#line 571
    which = 1;
#line 571
    while (1) {
#line 571
      if (which < 50) {
#line 571
        if (! entry->arg[which]) {
#line 571
          break;
        }
      } else {
#line 571
        break;
      }
      {
#line 572
      tmp___0 = strcasecmp((char const   *)entry->arg[which], (char const   *)(class));
      }
#line 572
      if (! tmp___0) {
#line 573
        if ((int )*(entry->arg[0] + 0) == 37) {
          {
#line 574
          tmp = atoi((char const   *)(entry->arg[0] + 1));
#line 574
          pw___0->pw_gid = (unsigned int )tmp;
          }
        } else {
          {
#line 576
          grp = getgrnam((char const   *)entry->arg[0]);
          }
#line 576
          if (grp) {
#line 577
            pw___0->pw_gid = grp->gr_gid;
          } else {
            {
#line 579
            syslog(3, "autogroup: set group %s not found", entry->arg[0]);
            }
          }
          {
#line 580
          endgrent();
          }
        }
#line 582
        return;
      }
#line 571
      which ++;
    }
  }
#line 586
  return;
}
}
#line 599 "access.c"
void acl_setfunctions(void) 
{ char class[1024] ;
  struct aclmember *entry ;
  int l_compress ;
  int l_tar ;
  int inbound ;
  int outbound ;
  int which ;
  int set ;
  struct aclmember *tmp ;
  struct aclmember *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct aclmember *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  struct aclmember *tmp___26 ;

  {
  {
#line 606
  entry = (struct aclmember *)((void *)0);
#line 608
  inbound = 0;
#line 608
  outbound = 0;
#line 610
  log_incoming_xfers = 0;
#line 611
  log_outbound_xfers = 0;
#line 612
  log_commands = 0;
#line 613
  log_security = 0;
#line 615
  memset((void *)(class), 0, sizeof(class));
#line 617
  acl_getclass(class);
#line 619
  entry = (struct aclmember *)((void *)0);
#line 620
  tmp = getaclentry((char *)"loginfails", & entry);
  }
#line 620
  if (tmp) {
#line 620
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
      {
#line 621
      lgi_failure_threshold = atoi((char const   *)entry->arg[0]);
      }
    }
  }
  {
#line 624
  entry = (struct aclmember *)((void *)0);
#line 625
  tmp___0 = getaclentry((char *)"private", & entry);
  }
#line 625
  if (tmp___0) {
    {
#line 625
    tmp___1 = strcasecmp((char const   *)entry->arg[0], "yes");
    }
#line 625
    if (! tmp___1) {
      {
#line 626
      priv_setup(_path_private);
      }
    }
  }
#line 629
  entry = (struct aclmember *)((void *)0);
#line 630
  set = 0;
#line 631
  while (1) {
#line 631
    if (! set) {
      {
#line 631
      tmp___4 = getaclentry((char *)"compress", & entry);
      }
#line 631
      if (! tmp___4) {
#line 631
        break;
      }
    } else {
#line 631
      break;
    }
    {
#line 632
    l_compress = 0;
#line 633
    tmp___2 = strcasecmp((char const   *)entry->arg[0], "yes");
    }
#line 633
    if (! tmp___2) {
#line 634
      l_compress = 1;
    }
#line 635
    which = 1;
#line 635
    while (1) {
#line 635
      if (which < 50) {
#line 635
        if (! entry->arg[which]) {
#line 635
          break;
        }
      } else {
#line 635
        break;
      }
      {
#line 636
      tmp___3 = wu_fnmatch((char const   *)entry->arg[which], (char const   *)(class),
                           16);
      }
#line 636
      if (! tmp___3) {
#line 637
        mangleopts |= l_compress * (1 | (1 << 1));
#line 638
        set = 1;
      }
#line 635
      which ++;
    }
  }
#line 643
  entry = (struct aclmember *)((void *)0);
#line 644
  set = 0;
#line 645
  while (1) {
#line 645
    if (! set) {
      {
#line 645
      tmp___7 = getaclentry((char *)"tar", & entry);
      }
#line 645
      if (! tmp___7) {
#line 645
        break;
      }
    } else {
#line 645
      break;
    }
    {
#line 646
    l_tar = 0;
#line 647
    tmp___5 = strcasecmp((char const   *)entry->arg[0], "yes");
    }
#line 647
    if (! tmp___5) {
#line 648
      l_tar = 1;
    }
#line 649
    which = 1;
#line 649
    while (1) {
#line 649
      if (which < 50) {
#line 649
        if (! entry->arg[which]) {
#line 649
          break;
        }
      } else {
#line 649
        break;
      }
      {
#line 650
      tmp___6 = wu_fnmatch((char const   *)entry->arg[which], (char const   *)(class),
                           16);
      }
#line 650
      if (! tmp___6) {
#line 651
        mangleopts |= l_tar * (1 << 2);
#line 652
        set = 1;
      }
#line 649
      which ++;
    }
  }
#line 659
  entry = (struct aclmember *)((void *)0);
#line 660
  while (1) {
    {
#line 660
    tmp___26 = getaclentry((char *)"log", & entry);
    }
#line 660
    if (! tmp___26) {
#line 660
      break;
    }
    {
#line 661
    tmp___11 = strcasecmp((char const   *)entry->arg[0], "commands");
    }
#line 661
    if (! tmp___11) {
#line 662
      if (anonymous) {
        {
#line 662
        tmp___8 = strcasestr(entry->arg[1], (char *)"anonymous");
        }
#line 662
        if (tmp___8) {
#line 663
          log_commands = 1;
        }
      }
#line 664
      if (guest) {
        {
#line 664
        tmp___9 = strcasestr(entry->arg[1], (char *)"guest");
        }
#line 664
        if (tmp___9) {
#line 665
          log_commands = 1;
        }
      }
#line 666
      if (! guest) {
#line 666
        if (! anonymous) {
          {
#line 666
          tmp___10 = strcasestr(entry->arg[1], (char *)"real");
          }
#line 666
          if (tmp___10) {
#line 667
            log_commands = 1;
          }
        }
      }
    }
    {
#line 669
    tmp___17 = strcasecmp((char const   *)entry->arg[0], "transfers");
    }
#line 669
    if (! tmp___17) {
      {
#line 670
      set = 0;
#line 671
      tmp___12 = strcasestr(entry->arg[1], (char *)"anonymous");
      }
#line 671
      if (tmp___12) {
#line 671
        if (anonymous) {
#line 672
          set = 1;
        }
      }
      {
#line 673
      tmp___13 = strcasestr(entry->arg[1], (char *)"guest");
      }
#line 673
      if (tmp___13) {
#line 673
        if (guest) {
#line 674
          set = 1;
        }
      }
      {
#line 675
      tmp___14 = strcasestr(entry->arg[1], (char *)"real");
      }
#line 675
      if (tmp___14) {
#line 675
        if (! guest) {
#line 675
          if (! anonymous) {
#line 676
            set = 1;
          }
        }
      }
      {
#line 677
      tmp___15 = strcasestr(entry->arg[2], (char *)"inbound");
      }
#line 677
      if (tmp___15) {
#line 678
        inbound = 1;
      }
      {
#line 679
      tmp___16 = strcasestr(entry->arg[2], (char *)"outbound");
      }
#line 679
      if (tmp___16) {
#line 680
        outbound = 1;
      }
#line 681
      if (set) {
#line 682
        log_incoming_xfers = inbound;
      }
#line 683
      if (set) {
#line 684
        log_outbound_xfers = outbound;
      }
    }
    {
#line 686
    tmp___21 = strcasecmp((char const   *)entry->arg[0], "security");
    }
#line 686
    if (! tmp___21) {
      {
#line 687
      tmp___18 = strcasestr(entry->arg[1], (char *)"anonymous");
      }
#line 687
      if (tmp___18) {
#line 687
        if (anonymous) {
#line 688
          log_security = 1;
        }
      }
      {
#line 689
      tmp___19 = strcasestr(entry->arg[1], (char *)"guest");
      }
#line 689
      if (tmp___19) {
#line 689
        if (guest) {
#line 690
          log_security = 1;
        }
      }
      {
#line 691
      tmp___20 = strcasestr(entry->arg[1], (char *)"real");
      }
#line 691
      if (tmp___20) {
#line 691
        if (! guest) {
#line 691
          if (! anonymous) {
#line 692
            log_security = 1;
          }
        }
      }
    }
    {
#line 694
    tmp___22 = strcasecmp((char const   *)entry->arg[0], "syslog");
    }
#line 694
    if (! tmp___22) {
#line 695
      syslogmsg = 1;
    }
    {
#line 696
    tmp___23 = strcasecmp((char const   *)entry->arg[0], "xferlog");
    }
#line 696
    if (! tmp___23) {
#line 697
      syslogmsg = 0;
    }
    {
#line 698
    tmp___24 = strcasecmp((char const   *)entry->arg[0], "syslog+xferlog");
    }
#line 698
    if (tmp___24) {
      {
#line 698
      tmp___25 = strcasecmp((char const   *)entry->arg[0], "xferlog+syslog");
      }
#line 698
      if (! tmp___25) {
#line 700
        syslogmsg = 2;
      }
    } else {
#line 700
      syslogmsg = 2;
    }
  }
#line 702
  return;
}
}
#line 710 "access.c"
int acl_getclass(char *classbuf ) 
{ int which ;
  struct aclmember *entry ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct aclmember *tmp___5 ;

  {
#line 713
  entry = (struct aclmember *)((void *)0);
#line 715
  while (1) {
    {
#line 715
    tmp___5 = getaclentry((char *)"class", & entry);
    }
#line 715
    if (! tmp___5) {
#line 715
      break;
    }
#line 716
    if (entry->arg[0]) {
      {
#line 717
      strcpy((char */* __restrict  */)classbuf, (char const   */* __restrict  */)entry->arg[0]);
      }
    }
#line 719
    which = 2;
#line 719
    while (1) {
#line 719
      if (which < 50) {
#line 719
        if (! entry->arg[which]) {
#line 719
          break;
        }
      } else {
#line 719
        break;
      }
#line 720
      if (anonymous) {
        {
#line 720
        tmp = strcasestr(entry->arg[1], (char *)"anonymous");
        }
#line 720
        if (tmp) {
          {
#line 720
          tmp___0 = hostmatch(entry->arg[which], remoteaddr, remotehost);
          }
#line 720
          if (tmp___0) {
#line 722
            return (1);
          }
        }
      }
#line 724
      if (guest) {
        {
#line 724
        tmp___1 = strcasestr(entry->arg[1], (char *)"guest");
        }
#line 724
        if (tmp___1) {
          {
#line 724
          tmp___2 = hostmatch(entry->arg[which], remoteaddr, remotehost);
          }
#line 724
          if (tmp___2) {
#line 725
            return (1);
          }
        }
      }
#line 727
      if (! guest) {
#line 727
        if (! anonymous) {
          {
#line 727
          tmp___3 = strcasestr(entry->arg[1], (char *)"real");
          }
#line 727
          if (tmp___3) {
            {
#line 727
            tmp___4 = hostmatch(entry->arg[which], remoteaddr, remotehost);
            }
#line 727
            if (tmp___4) {
#line 729
              return (1);
            }
          }
        }
      }
#line 719
      which ++;
    }
  }
#line 733
  *classbuf = (char )((void *)0);
#line 734
  return (0);
}
}
#line 745 "access.c"
int acl_getlimit(char *class , char *msgpathbuf ) 
{ int limit ;
  struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
#line 748
  entry = (struct aclmember *)((void *)0);
#line 750
  if (msgpathbuf) {
#line 751
    *msgpathbuf = (char )'\000';
  }
#line 754
  while (1) {
    {
#line 754
    tmp___1 = getaclentry((char *)"limit", & entry);
    }
#line 754
    if (! tmp___1) {
#line 754
      break;
    }
#line 755
    if (! entry->arg[0]) {
#line 756
      continue;
    } else {
#line 755
      if (! entry->arg[1]) {
#line 756
        continue;
      } else {
#line 755
        if (! entry->arg[2]) {
#line 756
          continue;
        }
      }
    }
    {
#line 757
    tmp___0 = strcasecmp((char const   *)class, (char const   *)entry->arg[0]);
    }
#line 757
    if (! tmp___0) {
      {
#line 758
      limit = atoi((char const   *)entry->arg[1]);
#line 759
      tmp = validtime(entry->arg[2]);
      }
#line 759
      if (tmp) {
#line 760
        if (entry->arg[3]) {
#line 760
          if (msgpathbuf) {
            {
#line 761
            strcpy((char */* __restrict  */)msgpathbuf, (char const   */* __restrict  */)entry->arg[3]);
            }
          }
        }
#line 762
        return (limit);
      }
    }
  }
#line 766
  return (-1);
}
}
#line 776 "access.c"
int acl_getnice(char *class ) 
{ int nice_delta_for_class_found ;
  int nice_delta ;
  int default_nice_delta ;
  struct aclmember *entry ;
  int tmp ;
  struct aclmember *tmp___0 ;

  {
#line 778
  nice_delta_for_class_found = 0;
#line 779
  nice_delta = 0;
#line 780
  default_nice_delta = 0;
#line 782
  entry = (struct aclmember *)((void *)0);
#line 785
  while (1) {
    {
#line 785
    tmp___0 = getaclentry((char *)"nice", & entry);
    }
#line 785
    if (! tmp___0) {
#line 785
      break;
    }
#line 786
    if (! entry->arg[0]) {
#line 787
      continue;
    }
#line 788
    if (! entry->arg[1]) {
      {
#line 789
      default_nice_delta = atoi((char const   *)entry->arg[0]);
      }
    } else {
      {
#line 790
      tmp = strcasecmp((char const   *)class, (char const   *)entry->arg[1]);
      }
#line 790
      if (! tmp) {
        {
#line 791
        nice_delta_for_class_found = 1;
#line 792
        nice_delta = atoi((char const   *)entry->arg[0]);
        }
      }
    }
  }
#line 795
  if (! nice_delta_for_class_found) {
#line 796
    nice_delta = default_nice_delta;
  }
#line 797
  return (nice_delta);
}
}
#line 808 "access.c"
void acl_getdefumask(char *class ) 
{ struct aclmember *entry ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  struct aclmember *tmp___2 ;

  {
#line 810
  entry = (struct aclmember *)((void *)0);
#line 813
  while (1) {
    {
#line 813
    tmp___2 = getaclentry((char *)"defumask", & entry);
    }
#line 813
    if (! tmp___2) {
#line 813
      break;
    }
#line 814
    if (! entry->arg[0]) {
#line 815
      continue;
    }
#line 816
    if (! entry->arg[1]) {
      {
#line 817
      tmp = strtoul((char const   */* __restrict  */)entry->arg[0], (char **/* __restrict  */)((void *)0),
                    0);
#line 817
      defumask = (unsigned int )tmp;
      }
    } else {
      {
#line 818
      tmp___1 = strcasecmp((char const   *)class, (char const   *)entry->arg[1]);
      }
#line 818
      if (! tmp___1) {
        {
#line 819
        tmp___0 = strtoul((char const   */* __restrict  */)entry->arg[0], (char **/* __restrict  */)((void *)0),
                          0);
#line 819
        defumask = (unsigned int )tmp___0;
        }
#line 820
        break;
      }
    }
  }
  {
#line 823
  umask(defumask);
  }
#line 824
  return;
}
}
#line 833 "access.c"
void acl_tcpwindow(char *class ) 
{ struct aclmember *entry ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  struct aclmember *tmp___2 ;

  {
#line 835
  entry = (struct aclmember *)((void *)0);
#line 838
  while (1) {
    {
#line 838
    tmp___2 = getaclentry((char *)"tcpwindow", & entry);
    }
#line 838
    if (! tmp___2) {
#line 838
      break;
    }
#line 839
    if (! entry->arg[0]) {
#line 840
      continue;
    }
#line 841
    if (! entry->arg[1]) {
      {
#line 842
      tmp = strtoul((char const   */* __restrict  */)entry->arg[0], (char **/* __restrict  */)((void *)0),
                    0);
#line 842
      TCPwindowsize = (int )tmp;
      }
    } else {
      {
#line 843
      tmp___1 = strcasecmp((char const   *)class, (char const   *)entry->arg[1]);
      }
#line 843
      if (! tmp___1) {
        {
#line 844
        tmp___0 = strtoul((char const   */* __restrict  */)entry->arg[0], (char **/* __restrict  */)((void *)0),
                          0);
#line 844
        TCPwindowsize = (int )tmp___0;
        }
#line 845
        break;
      }
    }
  }
#line 848
  return;
}
}
#line 860 "access.c"
void acl_filelimit(char *class ) 
{ struct aclmember *entry ;
  int raw_in ;
  int raw_out ;
  int raw_total ;
  int data_in ;
  int data_out ;
  int data_total ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct aclmember *tmp___12 ;

  {
#line 862
  entry = (struct aclmember *)((void *)0);
#line 863
  raw_in = 0;
#line 864
  raw_out = 0;
#line 865
  raw_total = 0;
#line 866
  data_in = 0;
#line 867
  data_out = 0;
#line 868
  data_total = 0;
#line 877
  while (1) {
    {
#line 877
    tmp___12 = getaclentry((char *)"file-limit", & entry);
    }
#line 877
    if (! tmp___12) {
#line 877
      break;
    }
#line 878
    if (! entry->arg[0]) {
#line 879
      continue;
    } else {
#line 878
      if (! entry->arg[1]) {
#line 879
        continue;
      }
    }
    {
#line 880
    tmp___11 = strcasecmp((char const   *)entry->arg[0], "raw");
    }
#line 880
    if (tmp___11) {
      {
#line 914
      tmp___10 = strcasecmp((char const   *)entry->arg[0], "in");
      }
#line 914
      if (tmp___10) {
        {
#line 924
        tmp___9 = strcasecmp((char const   *)entry->arg[0], "out");
        }
#line 924
        if (tmp___9) {
          {
#line 934
          tmp___8 = strcasecmp((char const   *)entry->arg[0], "total");
          }
#line 934
          if (! tmp___8) {
#line 935
            if (! entry->arg[2]) {
#line 936
              if (! data_total) {
                {
#line 937
                file_limit_data_total = atoi((char const   *)entry->arg[1]);
                }
              }
            } else {
              {
#line 939
              tmp___7 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
              }
#line 939
              if (! tmp___7) {
                {
#line 940
                data_total = 1;
#line 941
                file_limit_data_total = atoi((char const   *)entry->arg[1]);
                }
              }
            }
          }
        } else {
#line 925
          if (! entry->arg[2]) {
#line 926
            if (! data_out) {
              {
#line 927
              file_limit_data_out = atoi((char const   *)entry->arg[1]);
              }
            }
          } else {
            {
#line 929
            tmp___6 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
            }
#line 929
            if (! tmp___6) {
              {
#line 930
              data_out = 1;
#line 931
              file_limit_data_out = atoi((char const   *)entry->arg[1]);
              }
            }
          }
        }
      } else {
#line 915
        if (! entry->arg[2]) {
#line 916
          if (! data_in) {
            {
#line 917
            file_limit_data_in = atoi((char const   *)entry->arg[1]);
            }
          }
        } else {
          {
#line 919
          tmp___5 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
          }
#line 919
          if (! tmp___5) {
            {
#line 920
            data_in = 1;
#line 921
            file_limit_data_in = atoi((char const   *)entry->arg[1]);
            }
          }
        }
      }
    } else {
#line 881
      if (! entry->arg[2]) {
#line 882
        continue;
      }
      {
#line 883
      tmp___4 = strcasecmp((char const   *)entry->arg[1], "in");
      }
#line 883
      if (tmp___4) {
        {
#line 893
        tmp___3 = strcasecmp((char const   *)entry->arg[1], "out");
        }
#line 893
        if (tmp___3) {
          {
#line 903
          tmp___2 = strcasecmp((char const   *)entry->arg[1], "total");
          }
#line 903
          if (! tmp___2) {
#line 904
            if (! entry->arg[3]) {
#line 905
              if (! raw_total) {
                {
#line 906
                file_limit_raw_total = atoi((char const   *)entry->arg[2]);
                }
              }
            } else {
              {
#line 908
              tmp___1 = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
              }
#line 908
              if (! tmp___1) {
                {
#line 909
                raw_total = 1;
#line 910
                file_limit_raw_total = atoi((char const   *)entry->arg[2]);
                }
              }
            }
          }
        } else {
#line 894
          if (! entry->arg[3]) {
#line 895
            if (! raw_out) {
              {
#line 896
              file_limit_raw_out = atoi((char const   *)entry->arg[2]);
              }
            }
          } else {
            {
#line 898
            tmp___0 = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
            }
#line 898
            if (! tmp___0) {
              {
#line 899
              raw_out = 1;
#line 900
              file_limit_raw_out = atoi((char const   *)entry->arg[2]);
              }
            }
          }
        }
      } else {
#line 884
        if (! entry->arg[3]) {
#line 885
          if (! raw_in) {
            {
#line 886
            file_limit_raw_in = atoi((char const   *)entry->arg[2]);
            }
          }
        } else {
          {
#line 888
          tmp = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
          }
#line 888
          if (! tmp) {
            {
#line 889
            raw_in = 1;
#line 890
            file_limit_raw_in = atoi((char const   *)entry->arg[2]);
            }
          }
        }
      }
    }
  }
#line 945
  return;
}
}
#line 954 "access.c"
void acl_datalimit(char *class ) 
{ struct aclmember *entry ;
  int raw_in ;
  int raw_out ;
  int raw_total ;
  int data_in ;
  int data_out ;
  int data_total ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct aclmember *tmp___12 ;

  {
#line 956
  entry = (struct aclmember *)((void *)0);
#line 957
  raw_in = 0;
#line 958
  raw_out = 0;
#line 959
  raw_total = 0;
#line 960
  data_in = 0;
#line 961
  data_out = 0;
#line 962
  data_total = 0;
#line 971
  while (1) {
    {
#line 971
    tmp___12 = getaclentry((char *)"data-limit", & entry);
    }
#line 971
    if (! tmp___12) {
#line 971
      break;
    }
#line 972
    if (! entry->arg[0]) {
#line 973
      continue;
    } else {
#line 972
      if (! entry->arg[1]) {
#line 973
        continue;
      }
    }
    {
#line 974
    tmp___11 = strcasecmp((char const   *)entry->arg[0], "raw");
    }
#line 974
    if (tmp___11) {
      {
#line 1008
      tmp___10 = strcasecmp((char const   *)entry->arg[0], "in");
      }
#line 1008
      if (tmp___10) {
        {
#line 1018
        tmp___9 = strcasecmp((char const   *)entry->arg[0], "out");
        }
#line 1018
        if (tmp___9) {
          {
#line 1028
          tmp___8 = strcasecmp((char const   *)entry->arg[0], "total");
          }
#line 1028
          if (! tmp___8) {
#line 1029
            if (! entry->arg[2]) {
#line 1030
              if (! data_total) {
                {
#line 1031
                data_limit_data_total = atoi((char const   *)entry->arg[1]);
                }
              }
            } else {
              {
#line 1033
              tmp___7 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
              }
#line 1033
              if (! tmp___7) {
                {
#line 1034
                data_total = 1;
#line 1035
                data_limit_data_total = atoi((char const   *)entry->arg[1]);
                }
              }
            }
          }
        } else {
#line 1019
          if (! entry->arg[2]) {
#line 1020
            if (! data_out) {
              {
#line 1021
              data_limit_data_out = atoi((char const   *)entry->arg[1]);
              }
            }
          } else {
            {
#line 1023
            tmp___6 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
            }
#line 1023
            if (! tmp___6) {
              {
#line 1024
              data_out = 1;
#line 1025
              data_limit_data_out = atoi((char const   *)entry->arg[1]);
              }
            }
          }
        }
      } else {
#line 1009
        if (! entry->arg[2]) {
#line 1010
          if (! data_in) {
            {
#line 1011
            data_limit_data_in = atoi((char const   *)entry->arg[1]);
            }
          }
        } else {
          {
#line 1013
          tmp___5 = strcasecmp((char const   *)class, (char const   *)entry->arg[2]);
          }
#line 1013
          if (! tmp___5) {
            {
#line 1014
            data_in = 1;
#line 1015
            data_limit_data_in = atoi((char const   *)entry->arg[1]);
            }
          }
        }
      }
    } else {
#line 975
      if (! entry->arg[2]) {
#line 976
        continue;
      }
      {
#line 977
      tmp___4 = strcasecmp((char const   *)entry->arg[1], "in");
      }
#line 977
      if (tmp___4) {
        {
#line 987
        tmp___3 = strcasecmp((char const   *)entry->arg[1], "out");
        }
#line 987
        if (tmp___3) {
          {
#line 997
          tmp___2 = strcasecmp((char const   *)entry->arg[1], "total");
          }
#line 997
          if (! tmp___2) {
#line 998
            if (! entry->arg[3]) {
#line 999
              if (! raw_total) {
                {
#line 1000
                data_limit_raw_total = atoi((char const   *)entry->arg[2]);
                }
              }
            } else {
              {
#line 1002
              tmp___1 = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
              }
#line 1002
              if (! tmp___1) {
                {
#line 1003
                raw_total = 1;
#line 1004
                data_limit_raw_total = atoi((char const   *)entry->arg[2]);
                }
              }
            }
          }
        } else {
#line 988
          if (! entry->arg[3]) {
#line 989
            if (! raw_out) {
              {
#line 990
              data_limit_raw_out = atoi((char const   *)entry->arg[2]);
              }
            }
          } else {
            {
#line 992
            tmp___0 = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
            }
#line 992
            if (! tmp___0) {
              {
#line 993
              raw_out = 1;
#line 994
              data_limit_raw_out = atoi((char const   *)entry->arg[2]);
              }
            }
          }
        }
      } else {
#line 978
        if (! entry->arg[3]) {
#line 979
          if (! raw_in) {
            {
#line 980
            data_limit_raw_in = atoi((char const   *)entry->arg[2]);
            }
          }
        } else {
          {
#line 982
          tmp = strcasecmp((char const   *)class, (char const   *)entry->arg[3]);
          }
#line 982
          if (! tmp) {
            {
#line 983
            raw_in = 1;
#line 984
            data_limit_raw_in = atoi((char const   *)entry->arg[2]);
            }
          }
        }
      }
    }
  }
#line 1039
  return;
}
}
#line 1050 "access.c"
int acl_deny(char *msgpathbuf ) 
{ struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
#line 1052
  entry = (struct aclmember *)((void *)0);
#line 1054
  if (msgpathbuf) {
#line 1055
    *msgpathbuf = (char )((void *)0);
  }
#line 1058
  while (1) {
    {
#line 1058
    tmp___1 = getaclentry((char *)"deny", & entry);
    }
#line 1058
    if (! tmp___1) {
#line 1058
      break;
    }
#line 1059
    if (! entry->arg[0]) {
#line 1060
      continue;
    }
    {
#line 1061
    tmp___0 = strcasecmp((char const   *)entry->arg[0], "!nameserved");
    }
#line 1061
    if (tmp___0 == 0) {
#line 1062
      if (! nameserved) {
#line 1063
        if (entry->arg[1]) {
          {
#line 1064
          strcpy((char */* __restrict  */)msgpathbuf, (char const   */* __restrict  */)entry->arg[1]);
          }
        }
#line 1065
        return (1);
      }
    } else {
      {
#line 1068
      tmp = hostmatch(entry->arg[0], remoteaddr, remotehost);
      }
#line 1068
      if (tmp) {
#line 1069
        if (entry->arg[1]) {
          {
#line 1070
          strcpy((char */* __restrict  */)msgpathbuf, (char const   */* __restrict  */)entry->arg[1]);
          }
        }
#line 1071
        return (1);
      }
    }
  }
#line 1074
  return (0);
}
}
#line 1084 "access.c"
int acl_countusers(char *class ) 
{ int count ;
  int which ;
  char pidfile[4096] ;
  pid_t buf___2[1024] ;
  mode_t oldmask ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 1093
  if (Bypass_PID_Files) {
#line 1094
    return (0);
  }
  {
#line 1100
  sprintf((char */* __restrict  */)(pidfile), (char const   */* __restrict  */)"/var/run/ftp.pids-%s",
          class);
  }
#line 1102
  if (pidfd < 0) {
    {
#line 1104
    oldmask = umask(0U);
#line 1105
    pidfd = open((char const   *)(pidfile), 66, 420);
#line 1106
    umask(oldmask);
    }
  }
#line 1109
  if (pidfd < 0) {
    {
#line 1110
    syslog(3, "cannot open pid file %s: %m", pidfile);
    }
#line 1111
    return (-1);
  }
#line 1115
  while (1) {
    {
#line 1115
    tmp = flock(pidfd, 2);
    }
#line 1115
    if (! tmp) {
#line 1115
      break;
    }
    {
#line 1117
    syslog(3, "sleeping: flock of pid file failed: %m");
#line 1127
    sleep(1U);
    }
  }
  {
#line 1129
  lseek(pidfd, 0L, 0);
#line 1131
  count = 0;
#line 1133
  tmp___1 = read(pidfd, (void *)(buf___2), sizeof(buf___2));
  }
#line 1133
  if ((unsigned int )tmp___1 == sizeof(buf___2)) {
#line 1134
    which = 0;
#line 1134
    while (which < 1024) {
#line 1135
      if (buf___2[which]) {
        {
#line 1135
        tmp___0 = kill(buf___2[which], 0);
        }
#line 1135
        if (! tmp___0) {
#line 1136
          count ++;
        }
      }
#line 1134
      which ++;
    }
  }
  {
#line 1139
  flock(pidfd, 8);
  }
#line 1145
  return (count);
}
}
#line 1155 "access.c"
void acl_join(char *class ) 
{ int which ;
  int avail ;
  pid_t buf___2[1024] ;
  char pidfile[4096] ;
  pid_t procid ;
  mode_t oldmask ;
  int tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
#line 1165
  if (Bypass_PID_Files) {
#line 1166
    return;
  }
  {
#line 1173
  sprintf((char */* __restrict  */)(pidfile), (char const   */* __restrict  */)"/var/run/ftp.pids-%s",
          class);
  }
#line 1175
  if (pidfd < 0) {
    {
#line 1177
    oldmask = umask(0U);
#line 1178
    pidfd = open((char const   *)(pidfile), 66, 420);
#line 1179
    umask(oldmask);
    }
  }
#line 1182
  if (pidfd < 0) {
    {
#line 1183
    syslog(3, "cannot open pid file %s: %m", pidfile);
    }
#line 1184
    return;
  }
#line 1188
  while (1) {
    {
#line 1188
    tmp = flock(pidfd, 2);
    }
#line 1188
    if (! tmp) {
#line 1188
      break;
    }
    {
#line 1190
    syslog(3, "sleeping: flock of pid file failed: %m");
#line 1200
    sleep(1U);
    }
  }
  {
#line 1203
  procid = getpid();
#line 1205
  lseek(pidfd, 0L, 0);
#line 1206
  tmp___1 = read(pidfd, (void *)(buf___2), sizeof(buf___2));
  }
#line 1206
  if ((unsigned int )tmp___1 < sizeof(buf___2)) {
#line 1207
    which = 0;
#line 1207
    while (which < 1024) {
      goto __Cont;
      __Cont: 
#line 1207
      tmp___0 = which;
#line 1207
      which ++;
#line 1207
      buf___2[tmp___0] = 0;
    }
  }
#line 1210
  avail = 0;
#line 1211
  which = 0;
#line 1211
  while (which < 1024) {
#line 1212
    if (buf___2[which] == 0) {
#line 1213
      avail = which;
#line 1214
      buf___2[which] = 0;
    } else {
      {
#line 1212
      tmp___2 = kill(buf___2[which], 0);
      }
#line 1212
      if (tmp___2 == -1) {
#line 1213
        avail = which;
#line 1214
        buf___2[which] = 0;
      } else {
#line 1216
        if (buf___2[which] == procid) {
          {
#line 1219
          flock(pidfd, 8);
          }
#line 1225
          return;
        }
      }
    }
#line 1211
    which ++;
  }
  {
#line 1229
  buf___2[avail] = procid;
#line 1231
  lseek(pidfd, 0L, 0);
#line 1232
  write(pidfd, (void const   *)((void *)(buf___2)), sizeof(buf___2));
#line 1234
  flock(pidfd, 8);
  }
#line 1241
  return;
}
}
#line 1250 "access.c"
void acl_remove(void) 
{ char class[1024] ;
  int which ;
  int avail ;
  pid_t buf___2[1024] ;
  char pidfile[4096] ;
  pid_t procid ;
  int tmp ;
  mode_t oldmask ;
  int tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 1261
  if (Bypass_PID_Files) {
#line 1262
    return;
  }
  {
#line 1264
  tmp = acl_getclass(class);
  }
#line 1264
  if (! tmp) {
#line 1265
    return;
  }
  {
#line 1273
  sprintf((char */* __restrict  */)(pidfile), (char const   */* __restrict  */)"/var/run/ftp.pids-%s",
          class);
  }
#line 1275
  if (pidfd < 0) {
    {
#line 1277
    oldmask = umask(0U);
#line 1278
    pidfd = open((char const   *)(pidfile), 66, 420);
#line 1279
    umask(oldmask);
    }
  }
#line 1282
  if (pidfd < 0) {
    {
#line 1283
    syslog(3, "cannot open pid file %s: %m", pidfile);
    }
#line 1284
    return;
  }
#line 1288
  while (1) {
    {
#line 1288
    tmp___0 = flock(pidfd, 2);
    }
#line 1288
    if (! tmp___0) {
#line 1288
      break;
    }
    {
#line 1290
    syslog(3, "sleeping: flock of pid file failed: %m");
#line 1300
    sleep(1U);
    }
  }
  {
#line 1303
  procid = getpid();
#line 1305
  lseek(pidfd, 0L, 0);
#line 1306
  tmp___2 = read(pidfd, (void *)(buf___2), sizeof(buf___2));
  }
#line 1306
  if ((unsigned int )tmp___2 < sizeof(buf___2)) {
#line 1307
    which = 0;
#line 1307
    while (which < 1024) {
      goto __Cont;
      __Cont: 
#line 1307
      tmp___1 = which;
#line 1307
      which ++;
#line 1307
      buf___2[tmp___1] = 0;
    }
  }
#line 1310
  avail = 0;
#line 1311
  which = 0;
#line 1311
  while (which < 1024) {
#line 1312
    if (buf___2[which] == 0) {
#line 1313
      avail = which;
#line 1314
      buf___2[which] = 0;
    } else {
      {
#line 1312
      tmp___3 = kill(buf___2[which], 0);
      }
#line 1312
      if (tmp___3 == -1) {
#line 1313
        avail = which;
#line 1314
        buf___2[which] = 0;
      } else {
#line 1316
        if (buf___2[which] == procid) {
#line 1317
          buf___2[which] = 0;
        }
      }
    }
#line 1311
    which ++;
  }
  {
#line 1321
  lseek(pidfd, 0L, 0);
#line 1322
  write(pidfd, (void const   *)((void *)(buf___2)), sizeof(buf___2));
#line 1324
  flock(pidfd, 8);
#line 1331
  close(pidfd);
#line 1332
  pidfd = -1;
  }
#line 1333
  return;
}
}
#line 1341 "access.c"
void pr_mesg(int msgcode , char *msgfile ) 
{ FILE *infile ;
  char inbuf[1024] ;
  char outbuf[1024] ;
  char *cr ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
#line 1346
  if (msgfile) {
    {
#line 1346
    tmp___2 = strlen((char const   *)msgfile);
    }
#line 1346
    if ((int )tmp___2 > 0) {
      {
#line 1347
      infile = fopen((char const   */* __restrict  */)msgfile, (char const   */* __restrict  */)"r");
      }
#line 1348
      if (infile) {
#line 1349
        while (1) {
          {
#line 1349
          tmp___1 = fgets((char */* __restrict  */)(inbuf), (int )sizeof(inbuf), (FILE */* __restrict  */)infile);
          }
#line 1349
          if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
#line 1349
            break;
          }
          {
#line 1350
          tmp___0 = __builtin_strchr(inbuf, '\n');
#line 1350
          cr = tmp___0;
          }
#line 1350
          if ((unsigned int )cr != (unsigned int )((void *)0)) {
#line 1351
            *cr = (char )'\000';
          }
          {
#line 1352
          msg_massage((char const   *)(inbuf), outbuf, sizeof(outbuf));
#line 1353
          lreply(msgcode, (char *)"%s", outbuf);
          }
        }
        {
#line 1355
        fclose(infile);
        }
      }
    }
  }
#line 1358
  return;
}
}
#line 1366 "access.c"
void access_init(void) 
{ struct aclmember *entry ;
  int tmp ;
  struct aclmember *tmp___0 ;
  int tmp___1 ;
  struct aclmember *tmp___2 ;

  {
  {
#line 1370
  tmp = readacl(_path_ftpaccess);
  }
#line 1370
  if (! tmp) {
#line 1371
    return;
  }
  {
#line 1372
  parseacl();
#line 1374
  Shutdown[0] = (char )'\000';
#line 1375
  entry = (struct aclmember *)((void *)0);
#line 1376
  tmp___0 = getaclentry((char *)"shutdown", & entry);
  }
#line 1376
  if (tmp___0) {
#line 1376
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
      {
#line 1377
      __builtin_strncpy(Shutdown, (char const   *)entry->arg[0], sizeof(Shutdown));
      }
    }
  }
  {
#line 1378
  entry = (struct aclmember *)((void *)0);
#line 1379
  tmp___2 = getaclentry((char *)"keepalive", & entry);
  }
#line 1379
  if (tmp___2) {
#line 1379
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
      {
#line 1380
      tmp___1 = strcasecmp((char const   *)entry->arg[0], "yes");
      }
#line 1380
      if (! tmp___1) {
#line 1381
        keepalive = 1;
      }
    }
  }
  {
#line 1382
  load_timeouts();
  }
#line 1383
  return;
}
}
#line 1392 "access.c"
int access_ok(int msgcode ) 
{ char class[1024] ;
  char msgfile[4096] ;
  int limit ;
  int nice_delta ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1398
  if (! use_accessfile) {
#line 1399
    return (1);
  }
#line 1401
  if ((unsigned int )aclbuf == (unsigned int )((void *)0)) {
    {
#line 1402
    syslog(5, "ACCESS DENIED (error reading access file) TO %s", remoteident);
    }
#line 1405
    return (0);
  }
  {
#line 1407
  tmp = acl_deny(msgfile);
  }
#line 1407
  if (tmp) {
    {
#line 1409
    memcpy((void */* __restrict  */)(DelayedMessageFile), (void const   */* __restrict  */)(msgfile),
           sizeof(msgfile));
#line 1413
    syslog(5, "ACCESS DENIED (deny command) TO %s", remoteident);
    }
#line 1415
    return (0);
  }
  {
#line 1418
  tmp___0 = acl_getclass(class);
  }
#line 1418
  if (! tmp___0) {
    {
#line 1419
    syslog(5, "ACCESS DENIED (not in any class) TO %s", remoteident);
    }
#line 1421
    return (0);
  }
  {
#line 1423
  nice_delta = acl_getnice(class);
  }
#line 1423
  if (nice_delta) {
#line 1424
    if (nice_delta < 0) {
      {
#line 1425
      syslog(5, "Process nice value adjusted by %d", nice_delta);
      }
    }
    {
#line 1426
    nice(nice_delta);
    }
  }
  {
#line 1428
  acl_getdefumask(class);
#line 1429
  acl_tcpwindow(class);
#line 1432
  acl_filelimit(class);
#line 1433
  acl_datalimit(class);
#line 1437
  limit = acl_getlimit(class, msgfile);
  }
#line 1439
  if (limit == -1) {
    {
#line 1440
    acl_join(class);
    }
#line 1441
    return (1);
  } else {
    {
#line 1439
    tmp___1 = acl_countusers(class);
    }
#line 1439
    if (tmp___1 < limit) {
      {
#line 1440
      acl_join(class);
      }
#line 1441
      return (1);
    } else {
      {
#line 1445
      syslog(5, "ACCESS DENIED (user limit %d; class %s) TO %s", limit, class, remoteident);
#line 1449
      memcpy((void */* __restrict  */)(DelayedMessageFile), (void const   */* __restrict  */)(msgfile),
             sizeof(msgfile));
      }
#line 1453
      return (-1);
    }
  }
}
}
#line 1 "extensions.o"
/* #pragma merger(0,"/tmp/cil-QTD3jw3h.i","-g,-O2") */
#line 145 "/usr/include/stdlib.h"
__inline static  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 165
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
#line 278
__inline static  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 278 "/usr/include/stdlib.h"
__inline static double atof(char const   *__nptr ) 
{ double tmp ;

  {
  {
#line 281
  tmp = strtod((char const   */* __restrict  */)__nptr, (char **/* __restrict  */)((char **)((void *)0)));
  }
#line 281
  return (tmp);
}
}
#line 477 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *getcwd(char *__buf , size_t __size ) ;
#line 194 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t mktime(struct tm *__tp ) ;
#line 94 "proto.h"
int check_newer(char *path , struct stat *st , int flag ) ;
#line 97
int cwd_beenhere(int dircode ) ;
#line 105
int path_compare(char *p1 , char *p2 ) ;
#line 117
int file_compare(char *patterns , char *file ) ;
#line 118
int remote_compare(char *patterns ) ;
#line 556 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 560
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 124 "extensions.c"
char shuttime[30]  ;
#line 124 "extensions.c"
char denytime[30]  ;
#line 124 "extensions.c"
char disctime[30]  ;
#line 126 "extensions.c"
FILE *dout  ;
#line 128 "extensions.c"
time_t newer_time  ;
#line 130 "extensions.c"
int show_fullinfo  ;
#line 156 "extensions.c"
int check_newer(char *path , struct stat *st , int flag ) 
{ char const   *tmp ;
  int tmp___0 ;

  {
#line 158
  if (st->st_mtim.tv_sec > newer_time) {
#line 159
    if (show_fullinfo != 0) {
#line 160
      if (flag == 1) {
        goto _L;
      } else {
#line 160
        if (flag == 2) {
          _L: 
#line 161
          if (flag == 1) {
#line 161
            tmp = "F";
          } else {
#line 161
            tmp = "D";
          }
          {
#line 161
          fprintf((FILE */* __restrict  */)dout, (char const   */* __restrict  */)"%s %u %u %s\n",
                  tmp, st->st_size, st->st_mtim.tv_sec, path);
          }
        }
      }
    } else {
#line 166
      if (flag == 1) {
        {
#line 167
        fprintf((FILE */* __restrict  */)dout, (char const   */* __restrict  */)"%s\n",
                path);
        }
      }
    }
  }
#line 174
  if (ftwflag > 1) {
#line 174
    tmp___0 = 1;
  } else {
#line 174
    tmp___0 = 0;
  }
#line 174
  return (tmp___0);
}
}
#line 208 "extensions.c"
void msg_massage(char const   *inbuf , char *outbuf , size_t outlen ) 
{ char const   *inptr ;
  char *outptr ;
  char buffer___0[4096] ;
  time_t curtime ;
  int limit ;
  struct aclmember *entry ;
  char *tmp ;
  struct aclmember *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 210
  inptr = inbuf;
#line 211
  outptr = outbuf;
#line 231
  acl_getclass(buffer___0);
#line 232
  limit = acl_getlimit(buffer___0, (char *)((void *)0));
  }
#line 234
  while (1) {
#line 234
    if (outlen > 1U) {
#line 234
      if (! ((int const   )*inptr != 0)) {
#line 234
        break;
      }
    } else {
#line 234
      break;
    }
#line 235
    if ((int const   )*inptr != 37) {
#line 236
      tmp = outptr;
#line 236
      outptr ++;
#line 236
      *tmp = (char )*inptr;
#line 237
      outlen --;
    } else {
#line 240
      entry = (struct aclmember *)((void *)0);
#line 241
      inptr ++;
#line 241
      switch ((int )*inptr) {
      case 69: 
#line 244
      if (virtual_mode) {
#line 244
        if (! virtual_ftpaccess) {
#line 244
          if ((int )virtual_email[0] != 0) {
            {
#line 245
            snprintf((char */* __restrict  */)outptr, outlen, (char const   */* __restrict  */)"%s",
                     virtual_email);
            }
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        {
#line 248
        tmp___0 = getaclentry((char *)"email", & entry);
        }
#line 248
        if (tmp___0) {
#line 248
          if (entry->arg[0]) {
            {
#line 249
            snprintf((char */* __restrict  */)outptr, outlen, (char const   */* __restrict  */)"%s",
                     entry->arg[0]);
            }
          } else {
#line 251
            *outptr = (char )'\000';
          }
        } else {
#line 251
          *outptr = (char )'\000';
        }
      }
#line 252
      break;
      case 78: 
      {
#line 255
      tmp___1 = acl_countusers(buffer___0);
#line 255
      snprintf((char */* __restrict  */)outptr, outlen, (char const   */* __restrict  */)"%d",
               tmp___1);
      }
#line 256
      break;
      case 77: 
#line 259
      if (limit == -1) {
        {
#line 260
        __builtin_strncpy(outptr, "unlimited", outlen);
        }
      } else {
        {
#line 262
        snprintf((char */* __restrict  */)outptr, outlen, (char const   */* __restrict  */)"%d",
                 limit);
        }
      }
#line 263
      break;
      case 84: 
      {
#line 266
      time(& curtime);
#line 267
      tmp___2 = ctime((time_t const   *)(& curtime));
#line 267
      __builtin_strncpy(outptr, (char const   *)tmp___2, outlen);
      }
#line 268
      if (outlen > 24U) {
#line 269
        *(outptr + 24) = (char )'\000';
      }
#line 270
      break;
      case 70: 
#line 276
      *outptr = (char )'\000';
#line 278
      break;
      case 67: 
      {
#line 282
      getcwd(outptr, outlen);
      }
#line 287
      break;
      case 82: 
      {
#line 290
      __builtin_strncpy(outptr, (char const   *)(remotehost), outlen);
      }
#line 291
      break;
      case 76: 
      {
#line 294
      __builtin_strncpy(outptr, (char const   *)(hostname), outlen);
      }
#line 295
      break;
      case 85: 
      {
#line 299
      __builtin_strncpy(outptr, (char const   *)(the_user), outlen);
      }
#line 304
      break;
      case 115: 
      {
#line 307
      __builtin_strncpy(outptr, (char const   *)(shuttime), outlen);
      }
#line 308
      if (outlen > 24U) {
#line 309
        *(outptr + 24) = (char )'\000';
      }
#line 310
      break;
      case 100: 
      {
#line 313
      __builtin_strncpy(outptr, (char const   *)(disctime), outlen);
      }
#line 314
      if (outlen > 24U) {
#line 315
        *(outptr + 24) = (char )'\000';
      }
#line 316
      break;
      case 114: 
      {
#line 319
      __builtin_strncpy(outptr, (char const   *)(denytime), outlen);
      }
#line 320
      if (outlen > 24U) {
#line 321
        *(outptr + 24) = (char )'\000';
      }
#line 322
      break;
      case 117: 
#line 326
      if (authenticated) {
        {
#line 327
        __builtin_strncpy(outptr, (char const   *)(authuser), outlen);
        }
      } else {
        {
#line 329
        __builtin_strncpy(outptr, "[unknown]", outlen);
        }
      }
#line 330
      break;
      case 37: 
#line 407
      tmp___3 = outptr;
#line 407
      outptr ++;
#line 407
      *tmp___3 = (char )'%';
#line 408
      outlen --;
#line 409
      *outptr = (char )'\000';
#line 410
      break;
      default: 
#line 413
      tmp___4 = outptr;
#line 413
      outptr ++;
#line 413
      *tmp___4 = (char )'%';
#line 414
      outlen --;
#line 415
      if (outlen > 1U) {
#line 416
        tmp___5 = outptr;
#line 416
        outptr ++;
#line 416
        *tmp___5 = (char )*inptr;
#line 417
        outlen --;
      }
#line 419
      *outptr = (char )'\000';
#line 420
      break;
      }
#line 422
      *(outptr + (outlen - 1U)) = (char )'\000';
#line 423
      while (*outptr) {
#line 424
        outptr ++;
#line 425
        outlen --;
      }
    }
#line 428
    inptr ++;
  }
#line 430
  if (outlen > 0U) {
#line 431
    *outptr = (char )'\000';
  }
#line 432
  return;
}
}
#line 449 "extensions.c"
static struct dirlist *head  =    (struct dirlist *)((void *)0);
#line 441 "extensions.c"
int cwd_beenhere(int dircode ) 
{ struct dirlist *curptr ;
  char cwd___0[4096] ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;

  {
  {
#line 453
  fb_realpath(".", cwd___0);
#line 455
  curptr = head;
  }
#line 455
  while ((unsigned int )curptr != (unsigned int )((void *)0)) {
#line 456
    if (0) {
      {
#line 456
      __s1_len = strlen((char const   *)(curptr->dirname));
#line 456
      __s2_len = strlen((char const   *)(cwd___0));
      }
#line 456
      if (! ((unsigned int )((void const   *)(curptr->dirname + 1)) - (unsigned int )((void const   *)(curptr->dirname)) == 1U)) {
        goto _L___0;
      } else {
#line 456
        if (__s1_len >= 4U) {
          _L___0: 
#line 456
          if (! ((unsigned int )((void const   *)(cwd___0 + 1)) - (unsigned int )((void const   *)(cwd___0)) == 1U)) {
#line 456
            tmp___8 = 1;
          } else {
#line 456
            if (__s2_len >= 4U) {
#line 456
              tmp___8 = 1;
            } else {
#line 456
              tmp___8 = 0;
            }
          }
        } else {
#line 456
          tmp___8 = 0;
        }
      }
#line 456
      if (tmp___8) {
        {
#line 456
        tmp___4 = __builtin_strcmp((char const   *)(curptr->dirname), (char const   *)(cwd___0));
        }
      } else {
        {
#line 456
        tmp___7 = __builtin_strcmp((char const   *)(curptr->dirname), (char const   *)(cwd___0));
#line 456
        tmp___4 = tmp___7;
        }
      }
    } else {
      {
#line 456
      tmp___7 = __builtin_strcmp((char const   *)(curptr->dirname), (char const   *)(cwd___0));
#line 456
      tmp___4 = tmp___7;
      }
    }
#line 456
    if (tmp___4 == 0) {
#line 457
      if (! (curptr->dircode & dircode)) {
#line 458
        curptr->dircode |= dircode;
#line 459
        return (0);
      }
#line 461
      return (1);
    }
#line 455
    curptr = curptr->next;
  }
  {
#line 463
  tmp___9 = strlen((char const   *)(cwd___0));
#line 463
  tmp___10 = malloc((tmp___9 + 1U) + sizeof(struct dirlist ));
#line 463
  curptr = (struct dirlist *)tmp___10;
  }
#line 465
  if ((unsigned int )curptr != (unsigned int )((void *)0)) {
    {
#line 466
    curptr->next = head;
#line 467
    head = curptr;
#line 468
    curptr->dircode = dircode;
#line 469
    strcpy((char */* __restrict  */)(curptr->dirname), (char const   */* __restrict  */)(cwd___0));
    }
  }
#line 471
  return (0);
}
}
#line 480 "extensions.c"
void show_banner(int msgcode ) 
{ char *crptr ;
  char linebuf[1024] ;
  char outbuf[1024] ;
  struct aclmember *entry ;
  FILE *infile ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct aclmember *tmp___5 ;

  {
#line 483
  entry = (struct aclmember *)((void *)0);
#line 491
  if (virtual_mode) {
#line 491
    if (! virtual_ftpaccess) {
      {
#line 492
      infile = fopen((char const   */* __restrict  */)(virtual_banner), (char const   */* __restrict  */)"r");
      }
#line 493
      if (infile) {
#line 494
        while (1) {
          {
#line 494
          tmp___1 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                          (FILE */* __restrict  */)infile);
          }
#line 494
          if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
#line 494
            break;
          }
          {
#line 495
          tmp___0 = __builtin_strchr(linebuf, '\n');
#line 495
          crptr = tmp___0;
          }
#line 495
          if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 496
            *crptr = (char )'\000';
          }
          {
#line 497
          msg_massage((char const   *)(linebuf), outbuf, sizeof(outbuf));
#line 498
          lreply(msgcode, (char *)"%s", outbuf);
          }
        }
        {
#line 500
        fclose(infile);
#line 502
        lreply(msgcode, (char *)"");
        }
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
#line 509
    while (1) {
      {
#line 509
      tmp___5 = getaclentry((char *)"banner", & entry);
      }
#line 509
      if (! tmp___5) {
#line 509
        break;
      }
      {
#line 510
      infile = fopen((char const   */* __restrict  */)entry->arg[0], (char const   */* __restrict  */)"r");
      }
#line 511
      if (infile) {
#line 512
        while (1) {
          {
#line 512
          tmp___4 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                          (FILE */* __restrict  */)infile);
          }
#line 512
          if (! ((unsigned int )tmp___4 != (unsigned int )((void *)0))) {
#line 512
            break;
          }
          {
#line 513
          tmp___3 = __builtin_strchr(linebuf, '\n');
#line 513
          crptr = tmp___3;
          }
#line 513
          if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 514
            *crptr = (char )'\000';
          }
          {
#line 515
          msg_massage((char const   *)(linebuf), outbuf, sizeof(outbuf));
#line 516
          lreply(msgcode, (char *)"%s", outbuf);
          }
        }
        {
#line 518
        fclose(infile);
#line 520
        lreply(msgcode, (char *)"");
        }
      }
    }
  }
#line 527
  return;
}
}
#line 535 "extensions.c"
void show_message(int msgcode , int mode___0 ) 
{ char *crptr ;
  char linebuf[1024] ;
  char outbuf[1024] ;
  char class[4096] ;
  char cwd___0[4096] ;
  int show ;
  int which ;
  struct aclmember *entry ;
  FILE *infile ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  struct aclmember *tmp___19 ;

  {
#line 539
  entry = (struct aclmember *)((void *)0);
#line 542
  if (mode___0 == 1) {
    {
#line 542
    tmp = cwd_beenhere(1);
    }
#line 542
    if (tmp != 0) {
#line 543
      return;
    }
  }
  {
#line 546
  getcwd(cwd___0, 4095U);
#line 550
  acl_getclass(class);
  }
#line 553
  while (1) {
    {
#line 553
    tmp___19 = getaclentry((char *)"message", & entry);
    }
#line 553
    if (! tmp___19) {
#line 553
      break;
    }
#line 554
    if (! entry->arg[0]) {
#line 555
      continue;
    }
#line 556
    show = 0;
#line 558
    if (mode___0 == 0) {
#line 558
      if (! entry->arg[1]) {
        goto _L;
      } else {
        {
#line 558
        tmp___1 = strcasecmp((char const   *)entry->arg[1], "login");
        }
#line 558
        if (! tmp___1) {
          _L: 
#line 559
          if (! entry->arg[2]) {
#line 560
            show ++;
          } else {
#line 562
            which = 2;
#line 562
            while (1) {
#line 562
              if (which < 50) {
#line 562
                if (! entry->arg[which]) {
#line 562
                  break;
                }
              } else {
#line 562
                break;
              }
              {
#line 563
              tmp___0 = strcasecmp((char const   *)(class), (char const   *)entry->arg[which]);
              }
#line 563
              if (tmp___0 == 0) {
#line 564
                show ++;
              }
#line 562
              which ++;
            }
          }
        }
      }
    }
#line 567
    if (mode___0 == 1) {
#line 567
      if (entry->arg[1]) {
        {
#line 566
        tmp___3 = strncasecmp((char const   *)entry->arg[1], "cwd=", 4U);
        }
#line 567
        if (! tmp___3) {
#line 567
          if (0) {
            {
#line 567
            __s1_len = strlen((char const   *)(entry->arg[1] + 4));
#line 567
            __s2_len = strlen((char const   *)(cwd___0));
            }
#line 567
            if (! ((unsigned int )((void const   *)((entry->arg[1] + 4) + 1)) - (unsigned int )((void const   *)(entry->arg[1] + 4)) == 1U)) {
              goto _L___1;
            } else {
#line 567
              if (__s1_len >= 4U) {
                _L___1: 
#line 567
                if (! ((unsigned int )((void const   *)(cwd___0 + 1)) - (unsigned int )((void const   *)(cwd___0)) == 1U)) {
#line 567
                  tmp___13 = 1;
                } else {
#line 567
                  if (__s2_len >= 4U) {
#line 567
                    tmp___13 = 1;
                  } else {
#line 567
                    tmp___13 = 0;
                  }
                }
              } else {
#line 567
                tmp___13 = 0;
              }
            }
#line 567
            if (tmp___13) {
              {
#line 567
              tmp___9 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
              }
            } else {
              {
#line 567
              tmp___12 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
#line 567
              tmp___9 = tmp___12;
              }
            }
          } else {
            {
#line 567
            tmp___12 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
#line 567
            tmp___9 = tmp___12;
            }
          }
#line 567
          if (tmp___9) {
#line 567
            if ((int )*(entry->arg[1] + 4) == 42) {
              goto _L___2;
            } else {
              {
#line 567
              tmp___14 = wu_fnmatch((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0),
                                    1);
              }
#line 567
              if (! tmp___14) {
                _L___2: 
#line 569
                if (! entry->arg[2]) {
#line 570
                  show ++;
                } else {
#line 572
                  which = 2;
#line 572
                  while (1) {
#line 572
                    if (which < 50) {
#line 572
                      if (! entry->arg[which]) {
#line 572
                        break;
                      }
                    } else {
#line 572
                      break;
                    }
                    {
#line 573
                    tmp___2 = strcasecmp((char const   *)(class), (char const   *)entry->arg[which]);
                    }
#line 573
                    if (tmp___2 == 0) {
#line 574
                      show ++;
                    }
#line 572
                    which ++;
                  }
                }
              }
            }
          } else {
            goto _L___2;
          }
        }
      }
    }
#line 576
    if (show) {
      {
#line 576
      tmp___18 = strlen((char const   *)entry->arg[0]);
      }
#line 576
      if ((int )tmp___18 > 0) {
        {
#line 577
        infile = fopen((char const   */* __restrict  */)entry->arg[0], (char const   */* __restrict  */)"r");
        }
#line 578
        if (infile) {
#line 579
          while (1) {
            {
#line 579
            tmp___17 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                             (FILE */* __restrict  */)infile);
            }
#line 579
            if (! ((unsigned int )tmp___17 != (unsigned int )((void *)0))) {
#line 579
              break;
            }
            {
#line 580
            tmp___16 = __builtin_strchr(linebuf, '\n');
#line 580
            crptr = tmp___16;
            }
#line 580
            if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 581
              *crptr = (char )'\000';
            }
            {
#line 582
            msg_massage((char const   *)(linebuf), outbuf, sizeof(outbuf));
#line 583
            lreply(msgcode, (char *)"%s", outbuf);
            }
          }
          {
#line 585
          fclose(infile);
#line 587
          lreply(msgcode, (char *)"");
          }
        }
      }
    }
  }
#line 592
  return;
}
}
#line 601 "extensions.c"
void show_readme(int code , int mode___0 ) 
{ char **filelist ;
  char **sfilelist ;
  char class[4096] ;
  char cwd___0[4096] ;
  int show ;
  int which ;
  int days___0 ;
  time_t clock___0 ;
  struct stat buf___2 ;
  struct tm *tp ;
  struct aclmember *entry ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  struct aclmember *tmp___19 ;

  {
  {
#line 609
  entry = (struct aclmember *)((void *)0);
#line 611
  tmp = cwd_beenhere(2);
  }
#line 611
  if (tmp != 0) {
#line 612
    return;
  }
  {
#line 615
  getcwd(cwd___0, 4095U);
#line 619
  acl_getclass(class);
  }
#line 622
  while (1) {
    {
#line 622
    tmp___19 = getaclentry((char *)"readme", & entry);
    }
#line 622
    if (! tmp___19) {
#line 622
      break;
    }
#line 623
    if (! entry->arg[0]) {
#line 624
      continue;
    }
#line 625
    show = 0;
#line 627
    if (mode___0 == 0) {
#line 627
      if (! entry->arg[1]) {
        goto _L;
      } else {
        {
#line 627
        tmp___1 = strcasecmp((char const   *)entry->arg[1], "login");
        }
#line 627
        if (! tmp___1) {
          _L: 
#line 628
          if (! entry->arg[2]) {
#line 629
            show ++;
          } else {
#line 631
            which = 2;
#line 631
            while (1) {
#line 631
              if (which < 50) {
#line 631
                if (! entry->arg[which]) {
#line 631
                  break;
                }
              } else {
#line 631
                break;
              }
              {
#line 632
              tmp___0 = strcasecmp((char const   *)(class), (char const   *)entry->arg[which]);
              }
#line 632
              if (tmp___0 == 0) {
#line 633
                show ++;
              }
#line 631
              which ++;
            }
          }
        }
      }
    }
#line 636
    if (mode___0 == 1) {
#line 636
      if (entry->arg[1]) {
        {
#line 635
        tmp___3 = strncasecmp((char const   *)entry->arg[1], "cwd=", 4U);
        }
#line 636
        if (! tmp___3) {
#line 636
          if (0) {
            {
#line 636
            __s1_len = strlen((char const   *)(entry->arg[1] + 4));
#line 636
            __s2_len = strlen((char const   *)(cwd___0));
            }
#line 636
            if (! ((unsigned int )((void const   *)((entry->arg[1] + 4) + 1)) - (unsigned int )((void const   *)(entry->arg[1] + 4)) == 1U)) {
              goto _L___1;
            } else {
#line 636
              if (__s1_len >= 4U) {
                _L___1: 
#line 636
                if (! ((unsigned int )((void const   *)(cwd___0 + 1)) - (unsigned int )((void const   *)(cwd___0)) == 1U)) {
#line 636
                  tmp___13 = 1;
                } else {
#line 636
                  if (__s2_len >= 4U) {
#line 636
                    tmp___13 = 1;
                  } else {
#line 636
                    tmp___13 = 0;
                  }
                }
              } else {
#line 636
                tmp___13 = 0;
              }
            }
#line 636
            if (tmp___13) {
              {
#line 636
              tmp___9 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
              }
            } else {
              {
#line 636
              tmp___12 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
#line 636
              tmp___9 = tmp___12;
              }
            }
          } else {
            {
#line 636
            tmp___12 = __builtin_strcmp((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0));
#line 636
            tmp___9 = tmp___12;
            }
          }
#line 636
          if (tmp___9) {
#line 636
            if ((int )*(entry->arg[1] + 4) == 42) {
              goto _L___2;
            } else {
              {
#line 636
              tmp___14 = wu_fnmatch((char const   *)(entry->arg[1] + 4), (char const   *)(cwd___0),
                                    1);
              }
#line 636
              if (! tmp___14) {
                _L___2: 
#line 638
                if (! entry->arg[2]) {
#line 639
                  show ++;
                } else {
#line 641
                  which = 2;
#line 641
                  while (1) {
#line 641
                    if (which < 50) {
#line 641
                      if (! entry->arg[which]) {
#line 641
                        break;
                      }
                    } else {
#line 641
                      break;
                    }
                    {
#line 642
                    tmp___2 = strcasecmp((char const   *)(class), (char const   *)entry->arg[which]);
                    }
#line 642
                    if (tmp___2 == 0) {
#line 643
                      show ++;
                    }
#line 641
                    which ++;
                  }
                }
              }
            }
          } else {
            goto _L___2;
          }
        }
      }
    }
#line 645
    if (show) {
      {
#line 646
      globerr = (char *)((void *)0);
#line 647
      filelist = ftpglob(entry->arg[0]);
#line 648
      sfilelist = filelist;
      }
#line 649
      if (! globerr) {
#line 650
        while (1) {
#line 650
          if (filelist) {
#line 650
            if (! *filelist) {
#line 650
              break;
            }
          } else {
#line 650
            break;
          }
          {
#line 651
          tmp___15 = __errno_location();
#line 651
          *tmp___15 = 0;
#line 652
          tmp___18 = stat((char const   */* __restrict  */)*filelist, (struct stat */* __restrict  */)(& buf___2));
          }
#line 652
          if (! tmp___18) {
#line 652
            if ((buf___2.st_mode & 61440U) == 32768U) {
              {
#line 654
              lreply(code, (char *)"Please read the file %s", *filelist);
#line 655
              time(& clock___0);
#line 656
              tp = localtime((time_t const   *)(& clock___0));
#line 657
              days___0 = 365 * tp->tm_year + tp->tm_yday;
#line 658
              tp = localtime((time_t const   *)(& buf___2.st_mtim.tv_sec));
#line 659
              days___0 -= 365 * tp->tm_year + tp->tm_yday;
              }
#line 666
              if (days___0 == 1) {
#line 666
                tmp___16 = "";
              } else {
#line 666
                tmp___16 = "s";
              }
              {
#line 666
              tmp___17 = ctime((time_t const   *)(& buf___2.st_mtim.tv_sec));
#line 666
              lreply(code, (char *)"  it was last modified on %.24s - %d day%s ago",
                     tmp___17, days___0, tmp___16);
              }
            }
          }
#line 673
          filelist ++;
        }
      }
#line 676
      if (sfilelist) {
        {
#line 677
        blkfree(sfilelist);
#line 678
        free((void *)((char *)sfilelist));
        }
      }
    }
  }
#line 682
  return;
}
}
#line 692 "extensions.c"
int deny_badasciixfer(int msgcode , char *filepath ) 
{ 

  {
#line 695
  if (type == 1) {
#line 695
    if (! *filepath) {
      {
#line 696
      reply(msgcode, (char *)"This is a BINARY file, using ASCII mode to transfer will corrupt it.");
      }
#line 697
      return (1);
    }
  }
#line 701
  return (0);
}
}
#line 712 "extensions.c"
static struct tm tmbuf  ;
#line 713 "extensions.c"
static struct stat s_last  ;
#line 714 "extensions.c"
static time_t last  =    0L;
#line 714 "extensions.c"
static time_t shut  ;
#line 714 "extensions.c"
static time_t deny  ;
#line 714 "extensions.c"
static time_t disc  ;
#line 715 "extensions.c"
static int valid  ;
#line 716 "extensions.c"
static char text[2048]  ;
#line 710 "extensions.c"
int is_shutdown(int quiet , int new___0 ) 
{ struct stat s_cur ;
  FILE *fp ;
  int deny_off ;
  int disc_off ;
  time_t curtime ;
  time_t tmp ;
  char buf___2[1024] ;
  char linebuf[1024] ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 725
  tmp = time((time_t *)((void *)0));
#line 725
  curtime = tmp;
  }
#line 729
  if ((int )Shutdown[0] == 0) {
#line 730
    return (0);
  } else {
    {
#line 729
    tmp___0 = stat((char const   */* __restrict  */)(Shutdown), (struct stat */* __restrict  */)(& s_cur));
    }
#line 729
    if (tmp___0) {
#line 730
      return (0);
    }
  }
#line 732
  if (s_last.st_mtim.tv_sec != s_cur.st_mtim.tv_sec) {
    {
#line 733
    s_last = s_cur;
#line 734
    valid = 0;
#line 736
    fp = fopen((char const   */* __restrict  */)(Shutdown), (char const   */* __restrict  */)"r");
    }
#line 737
    if ((unsigned int )fp == (unsigned int )((void *)0)) {
#line 738
      return (0);
    }
    {
#line 739
    fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2), (FILE */* __restrict  */)fp);
#line 740
    tmp___1 = sscanf((char const   */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d %d %d %d %d %ld %ld",
                     & tmbuf.tm_year, & tmbuf.tm_mon, & tmbuf.tm_mday, & tmbuf.tm_hour,
                     & tmbuf.tm_min, & deny, & disc);
    }
#line 740
    if (tmp___1 != 7) {
      {
#line 742
      fclose(fp);
      }
#line 743
      return (0);
    }
    {
#line 745
    valid = 1;
#line 746
    deny_off = (int )(3600L * (deny / 100L) + 60L * (deny % 100L));
#line 747
    disc_off = (int )(3600L * (disc / 100L) + 60L * (disc % 100L));
#line 749
    tmbuf.tm_year -= 1900;
#line 750
    tmbuf.tm_isdst = -1;
#line 751
    shut = mktime(& tmbuf);
#line 752
    tmp___2 = ctime((time_t const   *)(& shut));
#line 752
    strcpy((char */* __restrict  */)(shuttime), (char const   */* __restrict  */)tmp___2);
#line 754
    disc = shut - (long )disc_off;
#line 755
    tmp___3 = ctime((time_t const   *)(& disc));
#line 755
    strcpy((char */* __restrict  */)(disctime), (char const   */* __restrict  */)tmp___3);
#line 757
    deny = shut - (long )deny_off;
#line 758
    tmp___4 = ctime((time_t const   *)(& deny));
#line 758
    strcpy((char */* __restrict  */)(denytime), (char const   */* __restrict  */)tmp___4);
#line 760
    text[0] = (char )'\000';
    }
#line 762
    while (1) {
      {
#line 762
      tmp___7 = fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2), (FILE */* __restrict  */)fp);
      }
#line 762
      if (! ((unsigned int )tmp___7 != (unsigned int )((void *)0))) {
#line 762
        break;
      }
      {
#line 763
      msg_massage((char const   *)(buf___2), linebuf, sizeof(linebuf));
#line 764
      tmp___5 = strlen((char const   *)(text));
#line 764
      tmp___6 = strlen((char const   *)(linebuf));
      }
#line 764
      if (tmp___5 + tmp___6 < sizeof(text)) {
        {
#line 765
        strcat((char */* __restrict  */)(text), (char const   */* __restrict  */)(linebuf));
        }
      }
    }
    {
#line 768
    fclose(fp);
    }
  }
#line 770
  if (! valid) {
#line 771
    return (0);
  }
#line 774
  if (last == 0L) {
#line 774
    if (! quiet) {
#line 775
      autospout = text;
#line 776
      autospout_free = 0;
#line 777
      last = curtime;
    }
  }
#line 780
  if (new___0) {
#line 780
    if (curtime > deny) {
#line 781
      return (1);
    }
  }
#line 784
  if (curtime > disc) {
#line 785
    return (1);
  }
#line 788
  if (curtime > disc - 60L) {
#line 788
    if (! quiet) {
#line 789
      autospout = text;
#line 790
      autospout_free = 0;
#line 791
      last = curtime;
    }
  }
#line 794
  if (curtime > disc - 900L) {
#line 795
    if (curtime - last > 300L) {
#line 795
      if (! quiet) {
#line 796
        autospout = text;
#line 797
        autospout_free = 0;
#line 798
        last = curtime;
      }
    }
  }
#line 802
  if (curtime < disc - 86400L) {
#line 802
    if (! quiet) {
#line 803
      if (curtime - last > 1800L) {
#line 804
        autospout = text;
#line 805
        autospout_free = 0;
#line 806
        last = curtime;
      }
    }
  }
#line 810
  if (curtime > disc - 86400L) {
#line 810
    if (! quiet) {
#line 811
      if (curtime - last >= 86400L) {
#line 812
        autospout = text;
#line 813
        autospout_free = 0;
#line 814
        last = curtime;
      }
    }
  }
#line 817
  return (0);
}
}
#line 822
extern int ftw(char const   *path , int (*fn)(char * , struct stat * , int  ) , int depth ) ;
#line 820 "extensions.c"
void newer(char *date , char *path , int showlots ) 
{ struct tm tm ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 825
  tmp___0 = sscanf((char const   */* __restrict  */)date, (char const   */* __restrict  */)"%04d%02d%02d%02d%02d%02d",
                   & tm.tm_year, & tm.tm_mon, & tm.tm_mday, & tm.tm_hour, & tm.tm_min,
                   & tm.tm_sec);
  }
#line 825
  if (tmp___0 == 6) {
    {
#line 829
    tm.tm_year -= 1900;
#line 830
    (tm.tm_mon) --;
#line 831
    tm.tm_isdst = -1;
#line 832
    newer_time = mktime(& tm);
#line 833
    dout = dataconn((char *)"file list", -1L, (char *)"w");
    }
#line 835
    if ((unsigned int )dout != (unsigned int )((void *)0)) {
      {
#line 840
      ftwflag = 1;
#line 841
      transflag ++;
#line 842
      show_fullinfo = showlots;
#line 844
      ftw((char const   *)path, & check_newer, -1);
      }
#line 850
      if (ftwflag == 1) {
        {
#line 851
        tmp = ferror(dout);
        }
#line 851
        if (tmp != 0) {
          {
#line 852
          perror_reply(550, (char *)"Data connection");
          }
        } else {
          {
#line 854
          reply(226, (char *)"Transfer complete.");
          }
        }
      }
      {
#line 857
      fclose(dout);
#line 858
      data = -1;
#line 859
      pdata = -1;
#line 860
      transflag = 0;
#line 861
      ftwflag = 0;
      }
    }
  } else {
    {
#line 865
    reply(501, (char *)"Bad DATE format");
    }
  }
#line 866
  return;
}
}
#line 868 "extensions.c"
int type_match(char *typelist ) 
{ char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char class[1024] ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 870
  if (anonymous) {
    {
#line 870
    tmp = strcasestr(typelist, (char *)"anonymous");
    }
#line 870
    if (tmp) {
#line 871
      return (1);
    }
  }
#line 872
  if (guest) {
    {
#line 872
    tmp___0 = strcasestr(typelist, (char *)"guest");
    }
#line 872
    if (tmp___0) {
#line 873
      return (1);
    }
  }
#line 874
  if (! guest) {
#line 874
    if (! anonymous) {
      {
#line 874
      tmp___1 = strcasestr(typelist, (char *)"real");
      }
#line 874
      if (tmp___1) {
#line 875
        return (1);
      }
    }
  }
  {
#line 877
  tmp___3 = strncasecmp((char const   *)typelist, "class=", 6U);
  }
#line 877
  if (tmp___3 == 0) {
    {
#line 880
    acl_getclass(class);
#line 881
    tmp___2 = strcasecmp((char const   *)(typelist + 6), (char const   *)(class));
    }
#line 881
    if (tmp___2 == 0) {
#line 882
      return (1);
    }
  }
#line 885
  return (0);
}
}
#line 888 "extensions.c"
int path_compare(char *p1 , char *p2 ) 
{ size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 890
  if (0) {
    {
#line 890
    __s1_len = strlen((char const   *)p1);
#line 890
    __s2_len = strlen("*");
    }
#line 890
    if (! ((unsigned int )((void const   *)(p1 + 1)) - (unsigned int )((void const   *)p1) == 1U)) {
      goto _L___0;
    } else {
#line 890
      if (__s1_len >= 4U) {
        _L___0: 
#line 890
        if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 890
          tmp___9 = 1;
        } else {
#line 890
          if (__s2_len >= 4U) {
#line 890
            tmp___9 = 1;
          } else {
#line 890
            tmp___9 = 0;
          }
        }
      } else {
#line 890
        tmp___9 = 0;
      }
    }
#line 890
    if (tmp___9) {
      {
#line 890
      tmp___5 = __builtin_strcmp((char const   *)p1, "*");
      }
    } else {
      {
#line 890
      tmp___8 = __builtin_strcmp((char const   *)p1, "*");
#line 890
      tmp___5 = tmp___8;
      }
    }
  } else {
    {
#line 890
    tmp___8 = __builtin_strcmp((char const   *)p1, "*");
#line 890
    tmp___5 = tmp___8;
    }
  }
#line 890
  if (tmp___5 == 0) {
    {
#line 891
    tmp = strlen((char const   *)p1);
    }
#line 891
    return ((int )tmp);
  } else {
    {
#line 890
    tmp___10 = wu_fnmatch((char const   *)p1, (char const   *)p2, 1);
    }
#line 890
    if (tmp___10 == 0) {
      {
#line 891
      tmp = strlen((char const   *)p1);
      }
#line 891
      return ((int )tmp);
    } else {
#line 893
      return (-2);
    }
  }
}
}
#line 896 "extensions.c"
void expand_id(void) 
{ char class[1024] ;
  struct aclmember *entry ;
  char *q ;
  int i ;
  int options ;
  int classfound ;
  int classmatched ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char buf___2[8192] ;
  struct passwd *pwent ;
  struct passwd *tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  struct group *grent ;
  struct group *tmp___26 ;
  size_t tmp___27 ;
  void *tmp___28 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___34 ;
  int tmp___37 ;
  int tmp___38 ;
  struct aclmember *tmp___39 ;

  {
  {
#line 899
  entry = (struct aclmember *)((void *)0);
#line 900
  acl_getclass(class);
  }
#line 901
  while (1) {
    {
#line 901
    tmp___39 = getaclentry((char *)"upload", & entry);
    }
#line 901
    if (! tmp___39) {
#line 901
      break;
    }
#line 903
    i = 0;
#line 904
    options = 1;
#line 905
    classfound = 0;
#line 906
    classmatched = 0;
#line 907
    while (1) {
#line 907
      if (options) {
#line 907
        if (i < 50) {
#line 907
          q = entry->arg[i];
#line 907
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 907
            if (! ((int )*(q + 0) != 0)) {
#line 907
              break;
            }
          } else {
#line 907
            break;
          }
        } else {
#line 907
          break;
        }
      } else {
#line 907
        break;
      }
      {
#line 911
      tmp___12 = strcasecmp((char const   *)q, "absolute");
      }
#line 911
      if (tmp___12 == 0) {
#line 912
        i ++;
      } else {
        {
#line 913
        tmp___11 = strcasecmp((char const   *)q, "relative");
        }
#line 913
        if (tmp___11 == 0) {
#line 914
          i ++;
        } else {
          {
#line 915
          tmp___10 = strncasecmp((char const   *)q, "class=", 6U);
          }
#line 915
          if (tmp___10 == 0) {
            {
#line 916
            i ++;
#line 917
            classfound = 1;
#line 918
            tmp = strcasecmp((char const   *)(q + 6), (char const   *)(class));
            }
#line 918
            if (tmp == 0) {
#line 919
              classmatched = 1;
            }
          } else {
#line 921
            if (0) {
              {
#line 921
              __s1_len = strlen((char const   *)q);
#line 921
              __s2_len = strlen("-");
              }
#line 921
              if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                goto _L___0;
              } else {
#line 921
                if (__s1_len >= 4U) {
                  _L___0: 
#line 921
                  if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 921
                    tmp___9 = 1;
                  } else {
#line 921
                    if (__s2_len >= 4U) {
#line 921
                      tmp___9 = 1;
                    } else {
#line 921
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 921
                  tmp___9 = 0;
                }
              }
#line 921
              if (tmp___9) {
                {
#line 921
                tmp___5 = __builtin_strcmp((char const   *)q, "-");
                }
              } else {
                {
#line 921
                tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 921
                tmp___5 = tmp___8;
                }
              }
            } else {
              {
#line 921
              tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 921
              tmp___5 = tmp___8;
              }
            }
#line 921
            if (tmp___5 == 0) {
#line 922
              i ++;
#line 923
              options = 0;
            } else {
#line 926
              options = 0;
            }
          }
        }
      }
    }
#line 928
    if (! classfound) {
      goto _L___5;
    } else {
#line 928
      if (classmatched) {
        _L___5: 
#line 936
        if (i + 3 < 50) {
#line 933
          q = entry->arg[i + 3];
#line 936
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 936
            if ((int )*(q + 0) != 0) {
#line 936
              if (0) {
                {
#line 936
                __s1_len___0 = strlen((char const   *)q);
#line 936
                __s2_len___0 = strlen("*");
                }
#line 936
                if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                  goto _L___2;
                } else {
#line 936
                  if (__s1_len___0 >= 4U) {
                    _L___2: 
#line 936
                    if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 936
                      tmp___25 = 1;
                    } else {
#line 936
                      if (__s2_len___0 >= 4U) {
#line 936
                        tmp___25 = 1;
                      } else {
#line 936
                        tmp___25 = 0;
                      }
                    }
                  } else {
#line 936
                    tmp___25 = 0;
                  }
                }
#line 936
                if (tmp___25) {
                  {
#line 936
                  tmp___21 = __builtin_strcmp((char const   *)q, "*");
                  }
                } else {
                  {
#line 936
                  tmp___24 = __builtin_strcmp((char const   *)q, "*");
#line 936
                  tmp___21 = tmp___24;
                  }
                }
              } else {
                {
#line 936
                tmp___24 = __builtin_strcmp((char const   *)q, "*");
#line 936
                tmp___21 = tmp___24;
                }
              }
#line 936
              if (tmp___21 != 0) {
#line 937
                if ((int )*(q + 0) == 37) {
                  {
#line 938
                  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s",
                          q + 1);
                  }
                } else {
                  {
#line 940
                  tmp___13 = getpwnam((char const   *)q);
#line 940
                  pwent = tmp___13;
                  }
#line 941
                  if (pwent) {
                    {
#line 942
                    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%u",
                            pwent->pw_uid);
                    }
                  } else {
                    {
#line 944
                    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d",
                            0);
                    }
                  }
                }
                {
#line 946
                tmp___14 = strlen((char const   *)(buf___2));
#line 946
                tmp___15 = malloc(tmp___14 + 1U);
#line 946
                entry->arg[i + 3] = (char *)tmp___15;
                }
#line 947
                if ((unsigned int )entry->arg[i + 3] == (unsigned int )((void *)0)) {
                  {
#line 948
                  syslog(3, "calloc error in expand_id");
#line 949
                  exit(0);
                  }
                }
                {
#line 951
                strcpy((char */* __restrict  */)entry->arg[i + 3], (char const   */* __restrict  */)(buf___2));
                }
              }
            }
          }
        }
#line 959
        if (i + 4 < 50) {
#line 956
          q = entry->arg[i + 4];
#line 959
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 959
            if ((int )*(q + 0) != 0) {
#line 959
              if (0) {
                {
#line 959
                __s1_len___1 = strlen((char const   *)q);
#line 959
                __s2_len___1 = strlen("*");
                }
#line 959
                if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                  goto _L___4;
                } else {
#line 959
                  if (__s1_len___1 >= 4U) {
                    _L___4: 
#line 959
                    if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 959
                      tmp___38 = 1;
                    } else {
#line 959
                      if (__s2_len___1 >= 4U) {
#line 959
                        tmp___38 = 1;
                      } else {
#line 959
                        tmp___38 = 0;
                      }
                    }
                  } else {
#line 959
                    tmp___38 = 0;
                  }
                }
#line 959
                if (tmp___38) {
                  {
#line 959
                  tmp___34 = __builtin_strcmp((char const   *)q, "*");
                  }
                } else {
                  {
#line 959
                  tmp___37 = __builtin_strcmp((char const   *)q, "*");
#line 959
                  tmp___34 = tmp___37;
                  }
                }
              } else {
                {
#line 959
                tmp___37 = __builtin_strcmp((char const   *)q, "*");
#line 959
                tmp___34 = tmp___37;
                }
              }
#line 959
              if (tmp___34 != 0) {
#line 960
                if ((int )*(q + 0) == 37) {
                  {
#line 961
                  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s",
                          q + 1);
                  }
                } else {
                  {
#line 963
                  tmp___26 = getgrnam((char const   *)q);
#line 963
                  grent = tmp___26;
                  }
#line 964
                  if (grent) {
                    {
#line 965
                    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%u",
                            grent->gr_gid);
                    }
                  } else {
                    {
#line 967
                    sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%d",
                            0);
                    }
                  }
                  {
#line 968
                  endgrent();
                  }
                }
                {
#line 970
                tmp___27 = strlen((char const   *)(buf___2));
#line 970
                tmp___28 = malloc(tmp___27 + 1U);
#line 970
                entry->arg[i + 4] = (char *)tmp___28;
                }
#line 971
                if ((unsigned int )entry->arg[i + 4] == (unsigned int )((void *)0)) {
                  {
#line 972
                  syslog(3, "calloc error in expand_id");
#line 973
                  exit(0);
                  }
                }
                {
#line 975
                strcpy((char */* __restrict  */)entry->arg[i + 4], (char const   */* __restrict  */)(buf___2));
                }
              }
            }
          }
        }
      }
    }
  }
#line 979
  return;
}
}
#line 981 "extensions.c"
int fn_check(char *name ) 
{ struct aclmember *entry ;
  int j ;
  char *path ;
  regex_t regexbuf ;
  regmatch_t regmatchbuf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;

  {
#line 986
  entry = (struct aclmember *)((void *)0);
#line 1008
  while (1) {
    {
#line 1008
    tmp___4 = getaclentry((char *)"path-filter", & entry);
    }
#line 1008
    if (tmp___4) {
#line 1008
      if (! ((unsigned int )entry->arg[0] != (unsigned int )((void *)0))) {
#line 1008
        break;
      }
    } else {
#line 1008
      break;
    }
    {
#line 1009
    tmp___3 = type_match(entry->arg[0]);
    }
#line 1009
    if (tmp___3) {
#line 1009
      if (entry->arg[1]) {
#line 1009
        if (entry->arg[2]) {
          {
#line 1015
          path = strrchr((char const   *)name, '/');
          }
#line 1015
          if (path) {
#line 1016
            path ++;
          } else {
#line 1018
            path = name;
          }
          {
#line 1022
          tmp = regcomp((regex_t */* __restrict  */)(& regexbuf), (char const   */* __restrict  */)entry->arg[2],
                        1);
          }
#line 1022
          if (tmp != 0) {
            {
#line 1023
            reply(550, (char *)"HAVE_REGEX error");
            }
#line 1031
            return (0);
          }
          {
#line 1034
          tmp___0 = regexec((regex_t const   */* __restrict  */)(& regexbuf), (char const   */* __restrict  */)path,
                            1U, (regmatch_t */* __restrict  */)(& regmatchbuf), 0);
          }
#line 1034
          if (tmp___0 != 0) {
            {
#line 1046
            pr_mesg(550, entry->arg[1]);
#line 1047
            reply(550, (char *)"%s: Permission denied on server. (Filename (accept))",
                  name);
            }
#line 1048
            return (0);
          }
#line 1052
          j = 3;
#line 1052
          while (j < 50) {
#line 1054
            if (entry->arg[j]) {
              {
#line 1056
              tmp___1 = regcomp((regex_t */* __restrict  */)(& regexbuf), (char const   */* __restrict  */)entry->arg[j],
                                1);
              }
#line 1056
              if (tmp___1 != 0) {
                {
#line 1057
                reply(550, (char *)"HAVE_REGEX error");
                }
#line 1065
                return (0);
              }
              {
#line 1068
              tmp___2 = regexec((regex_t const   */* __restrict  */)(& regexbuf),
                                (char const   */* __restrict  */)path, 1U, (regmatch_t */* __restrict  */)(& regmatchbuf),
                                0);
              }
#line 1068
              if (tmp___2 == 0) {
                {
#line 1080
                pr_mesg(550, entry->arg[1]);
#line 1081
                reply(550, (char *)"%s: Permission denied on server. (Filename (deny))",
                      name);
                }
#line 1082
                return (0);
              }
            }
#line 1052
            j ++;
          }
        }
      }
    }
  }
#line 1088
  return (1);
}
}
#line 1091 "extensions.c"
int dir_check(char *name , uid_t *uid , gid_t *gid , int *d_mode , int *valid___0 ) 
{ struct aclmember *entry ;
  int match_value ;
  char *ap2 ;
  char *ap3 ;
  char *ap4 ;
  char *ap5 ;
  char *ap6 ;
  char *ap7 ;
  char cwdir[4096] ;
  char *pwdir ;
  char abspwdir[4096] ;
  char relpwdir[4096] ;
  char path[4096] ;
  char *sp ;
  struct stat stbuf ;
  int stat_result ;
  char class[1024] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *q ;
  int i ;
  int options ;
  int classfound ;
  int classmatched ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int j ;
  int tmp___17 ;
  struct aclmember *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 1093
  entry = (struct aclmember *)((void *)0);
#line 1094
  match_value = -1;
#line 1095
  ap2 = (char *)((void *)0);
#line 1096
  ap3 = (char *)((void *)0);
#line 1097
  ap4 = (char *)((void *)0);
#line 1098
  ap5 = (char *)((void *)0);
#line 1099
  ap6 = (char *)((void *)0);
#line 1100
  ap7 = (char *)((void *)0);
#line 1108
  stat_result = -1;
#line 1113
  acl_getclass(class);
#line 1115
  *valid___0 = 0;
#line 1122
  tmp = strlen((char const   *)name);
  }
#line 1122
  if (tmp + 1U > sizeof(path)) {
    {
#line 1123
    perror_reply(550, (char *)"Path too long");
    }
#line 1124
    return (-1);
  }
  {
#line 1127
  strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)name);
#line 1128
  sp = strrchr((char const   *)(path), '/');
  }
#line 1129
  if (sp) {
#line 1130
    *sp = (char )'\000';
  } else {
    {
#line 1132
    strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)".");
    }
  }
  {
#line 1134
  tmp___0 = fb_realpath((char const   *)(path), cwdir);
  }
#line 1134
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    {
#line 1135
    perror_reply(550, (char *)"Could not determine cwdir");
    }
#line 1136
    return (-1);
  }
  {
#line 1139
  tmp___1 = fb_realpath((char const   *)home, relpwdir);
  }
#line 1139
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    {
#line 1140
    perror_reply(550, (char *)"Could not determine pwdir");
    }
#line 1141
    return (-1);
  }
  {
#line 1144
  tmp___2 = wu_realpath((char const   *)home, abspwdir, chroot_path);
  }
#line 1144
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
    {
#line 1145
    perror_reply(550, (char *)"Could not determine pwdir");
    }
#line 1146
    return (-1);
  }
#line 1149
  while (1) {
    {
#line 1149
    tmp___18 = getaclentry((char *)"upload", & entry);
    }
#line 1149
    if (! tmp___18) {
#line 1149
      break;
    }
#line 1151
    i = 0;
#line 1152
    options = 1;
#line 1153
    classfound = 0;
#line 1154
    classmatched = 0;
#line 1155
    pwdir = abspwdir;
#line 1156
    while (1) {
#line 1156
      if (options) {
#line 1156
        if (i < 50) {
#line 1156
          q = entry->arg[i];
#line 1156
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1156
            if (! ((int )*(q + 0) != 0)) {
#line 1156
              break;
            }
          } else {
#line 1156
            break;
          }
        } else {
#line 1156
          break;
        }
      } else {
#line 1156
        break;
      }
      {
#line 1160
      tmp___16 = strcasecmp((char const   *)q, "absolute");
      }
#line 1160
      if (tmp___16 == 0) {
#line 1161
        i ++;
#line 1162
        pwdir = abspwdir;
      } else {
        {
#line 1164
        tmp___15 = strcasecmp((char const   *)q, "relative");
        }
#line 1164
        if (tmp___15 == 0) {
#line 1165
          i ++;
#line 1166
          pwdir = relpwdir;
        } else {
          {
#line 1168
          tmp___14 = strncasecmp((char const   *)q, "class=", 6U);
          }
#line 1168
          if (tmp___14 == 0) {
            {
#line 1169
            i ++;
#line 1170
            classfound = 1;
#line 1171
            tmp___3 = strcasecmp((char const   *)(q + 6), (char const   *)(class));
            }
#line 1171
            if (tmp___3 == 0) {
#line 1172
              classmatched = 1;
            }
          } else {
#line 1174
            if (0) {
              {
#line 1174
              __s1_len = strlen((char const   *)q);
#line 1174
              __s2_len = strlen("-");
              }
#line 1174
              if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                goto _L___0;
              } else {
#line 1174
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1174
                  if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 1174
                    tmp___13 = 1;
                  } else {
#line 1174
                    if (__s2_len >= 4U) {
#line 1174
                      tmp___13 = 1;
                    } else {
#line 1174
                      tmp___13 = 0;
                    }
                  }
                } else {
#line 1174
                  tmp___13 = 0;
                }
              }
#line 1174
              if (tmp___13) {
                {
#line 1174
                tmp___9 = __builtin_strcmp((char const   *)q, "-");
                }
              } else {
                {
#line 1174
                tmp___12 = __builtin_strcmp((char const   *)q, "-");
#line 1174
                tmp___9 = tmp___12;
                }
              }
            } else {
              {
#line 1174
              tmp___12 = __builtin_strcmp((char const   *)q, "-");
#line 1174
              tmp___9 = tmp___12;
              }
            }
#line 1174
            if (tmp___9 == 0) {
#line 1175
              i ++;
#line 1176
              options = 0;
            } else {
#line 1179
              options = 0;
            }
          }
        }
      }
    }
#line 1181
    if (! classfound) {
      goto _L___1;
    } else {
#line 1181
      if (classmatched) {
        _L___1: 
#line 1183
        if (i + 1 < 50) {
#line 1183
          q = entry->arg[i];
#line 1183
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1183
            if ((int )*(q + 0) != 0) {
              {
#line 1183
              tmp___17 = path_compare(q, pwdir);
              }
#line 1183
              if (0 < tmp___17) {
                {
#line 1183
                j = path_compare(entry->arg[i + 1], cwdir);
                }
#line 1183
                if (j >= match_value) {
#line 1188
                  match_value = j;
#line 1190
                  ap2 = (char *)((void *)0);
#line 1191
                  if (i + 2 < 50) {
#line 1191
                    q = entry->arg[i + 2];
#line 1191
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1191
                      if ((int )*(q + 0) != 0) {
#line 1194
                        ap2 = q;
                      }
                    }
                  }
#line 1196
                  ap3 = (char *)((void *)0);
#line 1197
                  if (i + 3 < 50) {
#line 1197
                    q = entry->arg[i + 3];
#line 1197
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1197
                      if ((int )*(q + 0) != 0) {
#line 1200
                        ap3 = q;
                      }
                    }
                  }
#line 1202
                  ap4 = (char *)((void *)0);
#line 1203
                  if (i + 4 < 50) {
#line 1203
                    q = entry->arg[i + 4];
#line 1203
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1203
                      if ((int )*(q + 0) != 0) {
#line 1206
                        ap4 = q;
                      }
                    }
                  }
#line 1208
                  ap5 = (char *)((void *)0);
#line 1209
                  if (i + 5 < 50) {
#line 1209
                    q = entry->arg[i + 5];
#line 1209
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1209
                      if ((int )*(q + 0) != 0) {
#line 1212
                        ap5 = q;
                      }
                    }
                  }
#line 1214
                  ap6 = (char *)((void *)0);
#line 1215
                  if (i + 6 < 50) {
#line 1215
                    q = entry->arg[i + 6];
#line 1215
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1215
                      if ((int )*(q + 0) != 0) {
#line 1218
                        ap6 = q;
                      }
                    }
                  }
#line 1220
                  ap7 = (char *)((void *)0);
#line 1221
                  if (i + 7 < 50) {
#line 1221
                    q = entry->arg[i + 7];
#line 1221
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1221
                      if ((int )*(q + 0) != 0) {
#line 1224
                        ap7 = q;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1229
  if (anonymous) {
#line 1229
    if (match_value < 0) {
      {
#line 1230
      reply(550, (char *)"%s: Permission denied on server. (Upload dirs)", name);
      }
#line 1231
      return (0);
    }
  }
#line 1233
  if (ap2) {
    {
#line 1233
    tmp___19 = strcasecmp((char const   *)ap2, "no");
    }
#line 1233
    if (tmp___19) {
      goto _L___3;
    } else {
      {
#line 1236
      reply(550, (char *)"%s: Permission denied on server. (Upload dirs)", name);
      }
#line 1237
      return (0);
    }
  } else {
    _L___3: 
#line 1233
    if (ap3) {
      {
#line 1233
      tmp___20 = strcasecmp((char const   *)ap3, "nodirs");
      }
#line 1233
      if (tmp___20) {
        goto _L___2;
      } else {
        {
#line 1236
        reply(550, (char *)"%s: Permission denied on server. (Upload dirs)", name);
        }
#line 1237
        return (0);
      }
    } else {
      _L___2: 
#line 1233
      if (ap6) {
        {
#line 1233
        tmp___21 = strcasecmp((char const   *)ap6, "nodirs");
        }
#line 1233
        if (! tmp___21) {
          {
#line 1236
          reply(550, (char *)"%s: Permission denied on server. (Upload dirs)", name);
          }
#line 1237
          return (0);
        }
      }
    }
  }
#line 1239
  if (ap3) {
#line 1239
    if ((int )*ap3 == 42) {
      {
#line 1240
      stat_result = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& stbuf));
      }
    } else {
      goto _L___4;
    }
  } else {
    _L___4: 
#line 1239
    if (ap4) {
#line 1239
      if ((int )*ap4 == 42) {
        {
#line 1240
        stat_result = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& stbuf));
        }
      }
    }
  }
#line 1241
  if (ap3) {
#line 1242
    if ((int )*(ap3 + 0) != 42) {
      {
#line 1243
      tmp___22 = atoi((char const   *)ap3);
#line 1243
      *uid = (unsigned int )tmp___22;
      }
    } else {
#line 1242
      if ((int )*(ap3 + 1) != 0) {
        {
#line 1243
        tmp___22 = atoi((char const   *)ap3);
#line 1243
        *uid = (unsigned int )tmp___22;
        }
      } else {
#line 1244
        if (stat_result == 0) {
#line 1245
          *uid = stbuf.st_uid;
        }
      }
    }
  }
#line 1247
  if (ap4) {
#line 1248
    if ((int )*(ap4 + 0) != 42) {
      {
#line 1249
      tmp___23 = atoi((char const   *)ap4);
#line 1249
      *gid = (unsigned int )tmp___23;
      }
    } else {
#line 1248
      if ((int )*(ap4 + 1) != 0) {
        {
#line 1249
        tmp___23 = atoi((char const   *)ap4);
#line 1249
        *gid = (unsigned int )tmp___23;
        }
      } else {
#line 1250
        if (stat_result == 0) {
#line 1251
          *gid = stbuf.st_gid;
        }
      }
    }
  }
#line 1253
  if (ap7) {
    {
#line 1254
    sscanf((char const   */* __restrict  */)ap7, (char const   */* __restrict  */)"%o",
           d_mode);
#line 1255
    *valid___0 = 1;
    }
  } else {
#line 1257
    if (ap5) {
      {
#line 1258
      sscanf((char const   */* __restrict  */)ap5, (char const   */* __restrict  */)"%o",
             d_mode);
      }
#line 1259
      if (*d_mode & 384) {
#line 1260
        *d_mode |= 64;
      }
#line 1261
      if (*d_mode & 48) {
#line 1262
        *d_mode |= 8;
      }
#line 1263
      if (*d_mode & 6) {
#line 1264
        *d_mode |= 1;
      }
#line 1265
      *valid___0 = 1;
    }
  }
#line 1267
  return (1);
}
}
#line 1270 "extensions.c"
int upl_check(char *name , uid_t *uid , gid_t *gid , int *f_mode , int *valid___0 ) 
{ int match_value ;
  char cwdir[4096] ;
  char *pwdir ;
  char abspwdir[4096] ;
  char relpwdir[4096] ;
  char path[4096] ;
  char *sp ;
  struct stat stbuf ;
  int stat_result ;
  char *ap2 ;
  char *ap3 ;
  char *ap4 ;
  char *ap5 ;
  struct aclmember *entry ;
  char class[1024] ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *q ;
  int i ;
  int options ;
  int classfound ;
  int classmatched ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int j ;
  int tmp___17 ;
  struct aclmember *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  {
#line 1272
  match_value = -1;
#line 1280
  stat_result = -1;
#line 1281
  ap2 = (char *)((void *)0);
#line 1282
  ap3 = (char *)((void *)0);
#line 1283
  ap4 = (char *)((void *)0);
#line 1284
  ap5 = (char *)((void *)0);
#line 1285
  entry = (struct aclmember *)((void *)0);
#line 1290
  *valid___0 = 0;
#line 1291
  acl_getclass(class);
#line 1299
  tmp = strlen((char const   *)name);
  }
#line 1299
  if (tmp + 1U > sizeof(path)) {
    {
#line 1300
    perror_reply(553, (char *)"Path too long");
    }
#line 1301
    return (-1);
  }
  {
#line 1304
  strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)name);
#line 1305
  sp = strrchr((char const   *)(path), '/');
  }
#line 1306
  if (sp) {
#line 1307
    *sp = (char )'\000';
  } else {
    {
#line 1309
    strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)".");
    }
  }
  {
#line 1311
  tmp___0 = fb_realpath((char const   *)(path), cwdir);
  }
#line 1311
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    {
#line 1312
    perror_reply(553, (char *)"Could not determine cwdir");
    }
#line 1313
    return (-1);
  }
  {
#line 1316
  tmp___1 = wu_realpath((char const   *)home, abspwdir, chroot_path);
  }
#line 1316
  if ((unsigned int )tmp___1 == (unsigned int )((void *)0)) {
    {
#line 1317
    perror_reply(553, (char *)"Could not determine pwdir");
    }
#line 1318
    return (-1);
  }
  {
#line 1321
  tmp___2 = fb_realpath((char const   *)home, relpwdir);
  }
#line 1321
  if ((unsigned int )tmp___2 == (unsigned int )((void *)0)) {
    {
#line 1322
    perror_reply(553, (char *)"Could not determine pwdir");
    }
#line 1323
    return (-1);
  }
#line 1330
  while (1) {
    {
#line 1330
    tmp___18 = getaclentry((char *)"upload", & entry);
    }
#line 1330
    if (! tmp___18) {
#line 1330
      break;
    }
#line 1332
    i = 0;
#line 1333
    options = 1;
#line 1334
    classfound = 0;
#line 1335
    classmatched = 0;
#line 1336
    pwdir = abspwdir;
#line 1337
    while (1) {
#line 1337
      if (options) {
#line 1337
        if (i < 50) {
#line 1337
          q = entry->arg[i];
#line 1337
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1337
            if (! ((int )*(q + 0) != 0)) {
#line 1337
              break;
            }
          } else {
#line 1337
            break;
          }
        } else {
#line 1337
          break;
        }
      } else {
#line 1337
        break;
      }
      {
#line 1341
      tmp___16 = strcasecmp((char const   *)q, "absolute");
      }
#line 1341
      if (tmp___16 == 0) {
#line 1342
        i ++;
#line 1343
        pwdir = abspwdir;
      } else {
        {
#line 1345
        tmp___15 = strcasecmp((char const   *)q, "relative");
        }
#line 1345
        if (tmp___15 == 0) {
#line 1346
          i ++;
#line 1347
          pwdir = relpwdir;
        } else {
          {
#line 1349
          tmp___14 = strncasecmp((char const   *)q, "class=", 6U);
          }
#line 1349
          if (tmp___14 == 0) {
            {
#line 1350
            i ++;
#line 1351
            classfound = 1;
#line 1352
            tmp___3 = strcasecmp((char const   *)(q + 6), (char const   *)(class));
            }
#line 1352
            if (tmp___3 == 0) {
#line 1353
              classmatched = 1;
            }
          } else {
#line 1355
            if (0) {
              {
#line 1355
              __s1_len = strlen((char const   *)q);
#line 1355
              __s2_len = strlen("-");
              }
#line 1355
              if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                goto _L___0;
              } else {
#line 1355
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1355
                  if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 1355
                    tmp___13 = 1;
                  } else {
#line 1355
                    if (__s2_len >= 4U) {
#line 1355
                      tmp___13 = 1;
                    } else {
#line 1355
                      tmp___13 = 0;
                    }
                  }
                } else {
#line 1355
                  tmp___13 = 0;
                }
              }
#line 1355
              if (tmp___13) {
                {
#line 1355
                tmp___9 = __builtin_strcmp((char const   *)q, "-");
                }
              } else {
                {
#line 1355
                tmp___12 = __builtin_strcmp((char const   *)q, "-");
#line 1355
                tmp___9 = tmp___12;
                }
              }
            } else {
              {
#line 1355
              tmp___12 = __builtin_strcmp((char const   *)q, "-");
#line 1355
              tmp___9 = tmp___12;
              }
            }
#line 1355
            if (tmp___9 == 0) {
#line 1356
              i ++;
#line 1357
              options = 0;
            } else {
#line 1360
              options = 0;
            }
          }
        }
      }
    }
#line 1362
    if (! classfound) {
      goto _L___1;
    } else {
#line 1362
      if (classmatched) {
        _L___1: 
#line 1364
        if (i + 1 < 50) {
#line 1364
          q = entry->arg[i];
#line 1364
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1364
            if ((int )*(q + 0) != 0) {
              {
#line 1364
              tmp___17 = path_compare(q, pwdir);
              }
#line 1364
              if (0 < tmp___17) {
                {
#line 1364
                j = path_compare(entry->arg[i + 1], cwdir);
                }
#line 1364
                if (j >= match_value) {
#line 1369
                  match_value = j;
#line 1371
                  ap2 = (char *)((void *)0);
#line 1372
                  if (i + 2 < 50) {
#line 1372
                    q = entry->arg[i + 2];
#line 1372
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1372
                      if ((int )*(q + 0) != 0) {
#line 1375
                        ap2 = q;
                      }
                    }
                  }
#line 1377
                  ap3 = (char *)((void *)0);
#line 1378
                  if (i + 3 < 50) {
#line 1378
                    q = entry->arg[i + 3];
#line 1378
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1378
                      if ((int )*(q + 0) != 0) {
#line 1381
                        ap3 = q;
                      }
                    }
                  }
#line 1383
                  ap4 = (char *)((void *)0);
#line 1384
                  if (i + 4 < 50) {
#line 1384
                    q = entry->arg[i + 4];
#line 1384
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1384
                      if ((int )*(q + 0) != 0) {
#line 1387
                        ap4 = q;
                      }
                    }
                  }
#line 1389
                  ap5 = (char *)((void *)0);
#line 1390
                  if (i + 5 < 50) {
#line 1390
                    q = entry->arg[i + 5];
#line 1390
                    if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1390
                      if ((int )*(q + 0) != 0) {
#line 1393
                        ap5 = q;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1398
  if (ap3) {
    {
#line 1398
    tmp___19 = strcasecmp("dirs", (char const   *)ap3);
    }
#line 1398
    if (tmp___19) {
      {
#line 1398
      tmp___20 = strcasecmp("nodirs", (char const   *)ap3);
      }
#line 1398
      if (! tmp___20) {
#line 1401
        ap3 = (char *)((void *)0);
      }
    } else {
#line 1401
      ap3 = (char *)((void *)0);
    }
  }
#line 1406
  if (match_value >= 0) {
    {
#line 1407
    tmp___23 = strcasecmp((char const   *)ap2, "yes");
    }
#line 1407
    if (tmp___23) {
      {
#line 1427
      reply(553, (char *)"%s: Permission denied on server. (Upload)", name);
      }
#line 1428
      return (-1);
    } else {
#line 1408
      if (ap3) {
#line 1408
        if ((int )*ap3 == 42) {
          {
#line 1409
          stat_result = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& stbuf));
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
#line 1408
        if (ap4) {
#line 1408
          if ((int )*ap4 == 42) {
            {
#line 1409
            stat_result = stat((char const   */* __restrict  */)(path), (struct stat */* __restrict  */)(& stbuf));
            }
          }
        }
      }
#line 1410
      if (ap3) {
#line 1411
        if ((int )*(ap3 + 0) != 42) {
          {
#line 1412
          tmp___21 = atoi((char const   *)ap3);
#line 1412
          *uid = (unsigned int )tmp___21;
          }
        } else {
#line 1411
          if ((int )*(ap3 + 1) != 0) {
            {
#line 1412
            tmp___21 = atoi((char const   *)ap3);
#line 1412
            *uid = (unsigned int )tmp___21;
            }
          } else {
#line 1413
            if (stat_result == 0) {
#line 1414
              *uid = stbuf.st_uid;
            }
          }
        }
      }
#line 1416
      if (ap4) {
#line 1417
        if ((int )*(ap4 + 0) != 42) {
          {
#line 1418
          tmp___22 = atoi((char const   *)ap4);
#line 1418
          *gid = (unsigned int )tmp___22;
          }
        } else {
#line 1417
          if ((int )*(ap4 + 1) != 0) {
            {
#line 1418
            tmp___22 = atoi((char const   *)ap4);
#line 1418
            *gid = (unsigned int )tmp___22;
            }
          } else {
#line 1419
            if (stat_result == 0) {
#line 1420
              *gid = stbuf.st_gid;
            }
          }
        }
#line 1421
        *valid___0 = 1;
      }
#line 1423
      if (ap5) {
        {
#line 1424
        sscanf((char const   */* __restrict  */)ap5, (char const   */* __restrict  */)"%o",
               f_mode);
        }
      }
    }
  } else {
#line 1436
    if (anonymous) {
      {
#line 1437
      reply(553, (char *)"%s: Permission denied on server. (Upload)", name);
      }
#line 1438
      return (-1);
    }
#line 1440
    return (1);
  }
#line 1443
  return (match_value);
}
}
#line 1446 "extensions.c"
int del_check(char *name ) 
{ int pdelete ;
  int tmp ;
  struct aclmember *entry ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;

  {
#line 1448
  if (anonymous) {
#line 1448
    tmp = 0;
  } else {
#line 1448
    tmp = 1;
  }
#line 1448
  pdelete = tmp;
#line 1449
  entry = (struct aclmember *)((void *)0);
#line 1451
  while (1) {
    {
#line 1451
    tmp___1 = getaclentry((char *)"delete", & entry);
    }
#line 1451
    if (tmp___1) {
#line 1451
      if (entry->arg[0]) {
#line 1451
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 1451
          break;
        }
      } else {
#line 1451
        break;
      }
    } else {
#line 1451
      break;
    }
    {
#line 1452
    tmp___0 = type_match(entry->arg[1]);
    }
#line 1452
    if (tmp___0) {
#line 1453
      if (anonymous) {
#line 1454
        if ((int )*(entry->arg[0]) == 121) {
#line 1455
          pdelete = 1;
        }
      } else {
#line 1457
        if ((int )*(entry->arg[0]) == 110) {
#line 1458
          pdelete = 0;
        }
      }
    }
  }
#line 1466
  if (! pdelete) {
    {
#line 1467
    reply(553, (char *)"%s: Permission denied on server. (Delete)", name);
    }
#line 1468
    return (0);
  } else {
#line 1471
    return (1);
  }
}
}
#line 1479 "extensions.c"
int regexmatch(char *name , char *rgexp ) 
{ regex_t regexbuf ;
  regmatch_t regmatchbuf ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1496
  tmp = regcomp((regex_t */* __restrict  */)(& regexbuf), (char const   */* __restrict  */)rgexp,
                1);
  }
#line 1496
  if (tmp != 0) {
    {
#line 1497
    reply(553, (char *)"HAVE_REGEX error");
    }
#line 1505
    return (0);
  }
  {
#line 1509
  tmp___0 = regexec((regex_t const   */* __restrict  */)(& regexbuf), (char const   */* __restrict  */)name,
                    1U, (regmatch_t */* __restrict  */)(& regmatchbuf), 0);
  }
#line 1509
  if (tmp___0 != 0) {
#line 1521
    return (0);
  }
#line 1523
  return (1);
}
}
#line 1526 "extensions.c"
static int allow_retrieve(char *name ) 
{ char realname[4097] ;
  char localname[4097] ;
  char *whichname ;
  int i ;
  size_t len ;
  struct aclmember *entry ;
  char *p ;
  char *q ;
  int options ;
  int classfound ;
  int classmatched ;
  char class[1024] ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  struct aclmember *tmp___23 ;

  {
  {
#line 1533
  entry = (struct aclmember *)((void *)0);
#line 1542
  acl_getclass(class);
  }
#line 1543
  if ((unsigned int )name == (unsigned int )((char *)((void *)0))) {
#line 1545
    return (0);
  } else {
#line 1543
    if ((int )*name == 0) {
#line 1545
      return (0);
    }
  }
  {
#line 1546
  fb_realpath((char const   *)name, localname);
#line 1547
  wu_realpath((char const   *)name, realname, chroot_path);
  }
#line 1548
  while (1) {
    {
#line 1548
    tmp___23 = getaclentry((char *)"allow-retrieve", & entry);
    }
#line 1548
    if (! tmp___23) {
#line 1548
      break;
    }
#line 1549
    whichname = realname;
#line 1550
    i = 0;
#line 1551
    options = 1;
#line 1552
    classfound = 0;
#line 1553
    classmatched = 0;
#line 1554
    while (1) {
#line 1554
      if (options) {
#line 1554
        if (i < 50) {
#line 1554
          q = entry->arg[i];
#line 1554
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1554
            if (! ((int )*(q + 0) != 0)) {
#line 1554
              break;
            }
          } else {
#line 1554
            break;
          }
        } else {
#line 1554
          break;
        }
      } else {
#line 1554
        break;
      }
      {
#line 1558
      tmp___12 = strcasecmp((char const   *)q, "absolute");
      }
#line 1558
      if (tmp___12 == 0) {
#line 1559
        i ++;
#line 1560
        whichname = realname;
      } else {
        {
#line 1562
        tmp___11 = strcasecmp((char const   *)q, "relative");
        }
#line 1562
        if (tmp___11 == 0) {
#line 1563
          i ++;
#line 1564
          whichname = localname;
        } else {
          {
#line 1566
          tmp___10 = strncasecmp((char const   *)q, "class=", 6U);
          }
#line 1566
          if (tmp___10 == 0) {
            {
#line 1567
            i ++;
#line 1568
            classfound = 1;
#line 1569
            tmp = strcasecmp((char const   *)(q + 6), (char const   *)(class));
            }
#line 1569
            if (tmp == 0) {
#line 1570
              classmatched = 1;
            }
          } else {
#line 1572
            if (0) {
              {
#line 1572
              __s1_len = strlen((char const   *)q);
#line 1572
              __s2_len = strlen("-");
              }
#line 1572
              if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                goto _L___0;
              } else {
#line 1572
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1572
                  if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 1572
                    tmp___9 = 1;
                  } else {
#line 1572
                    if (__s2_len >= 4U) {
#line 1572
                      tmp___9 = 1;
                    } else {
#line 1572
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1572
                  tmp___9 = 0;
                }
              }
#line 1572
              if (tmp___9) {
                {
#line 1572
                tmp___5 = __builtin_strcmp((char const   *)q, "-");
                }
              } else {
                {
#line 1572
                tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 1572
                tmp___5 = tmp___8;
                }
              }
            } else {
              {
#line 1572
              tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 1572
              tmp___5 = tmp___8;
              }
            }
#line 1572
            if (tmp___5 == 0) {
#line 1573
              i ++;
#line 1574
              options = 0;
            } else {
#line 1577
              options = 0;
            }
          }
        }
      }
    }
#line 1579
    if (! classfound) {
      goto _L___1;
    } else {
#line 1579
      if (classmatched) {
        _L___1: 
#line 1580
        while (1) {
#line 1580
          if (i < 50) {
#line 1580
            q = entry->arg[i];
#line 1580
            if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1580
              if (! ((int )*(q + 0) != 0)) {
#line 1580
                break;
              }
            } else {
#line 1580
              break;
            }
          } else {
#line 1580
            break;
          }
          {
#line 1581
          len = strlen((char const   *)q);
          }
#line 1582
          if ((int )*(q + 0) == 47) {
#line 1582
            p = whichname;
          } else {
            {
#line 1582
            tmp___21 = strrchr((char const   *)whichname, '/');
            }
#line 1582
            if (tmp___21) {
              {
#line 1582
              tmp___20 = strrchr((char const   *)whichname, '/');
#line 1582
              p = tmp___20 + 1;
              }
            } else {
#line 1582
              p = whichname;
            }
          }
          {
#line 1583
          tmp___22 = wu_fnmatch((char const   *)q, (char const   *)p, 9);
          }
#line 1583
          if (! tmp___22) {
#line 1584
            return (1);
          }
#line 1580
          i ++;
        }
      }
    }
  }
#line 1589
  return (0);
}
}
#line 1592 "extensions.c"
int checknoretrieve(char *name ) 
{ char realname[4097] ;
  char localname[4097] ;
  char *whichname ;
  int i ;
  size_t len ;
  struct aclmember *entry ;
  char *p ;
  char *q ;
  int options ;
  int classfound ;
  int classmatched ;
  char class[1024] ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  struct aclmember *tmp___24 ;

  {
  {
#line 1599
  entry = (struct aclmember *)((void *)0);
#line 1610
  acl_getclass(class);
  }
#line 1611
  if ((unsigned int )name == (unsigned int )((char *)((void *)0))) {
#line 1613
    return (0);
  } else {
#line 1611
    if ((int )*name == 0) {
#line 1613
      return (0);
    }
  }
  {
#line 1614
  fb_realpath((char const   *)name, localname);
#line 1615
  wu_realpath((char const   *)name, realname, chroot_path);
  }
#line 1616
  while (1) {
    {
#line 1616
    tmp___24 = getaclentry((char *)"noretrieve", & entry);
    }
#line 1616
    if (! tmp___24) {
#line 1616
      break;
    }
#line 1617
    whichname = realname;
#line 1618
    i = 0;
#line 1619
    options = 1;
#line 1620
    classfound = 0;
#line 1621
    classmatched = 0;
#line 1622
    while (1) {
#line 1622
      if (options) {
#line 1622
        if (i < 50) {
#line 1622
          q = entry->arg[i];
#line 1622
          if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1622
            if (! ((int )*(q + 0) != 0)) {
#line 1622
              break;
            }
          } else {
#line 1622
            break;
          }
        } else {
#line 1622
          break;
        }
      } else {
#line 1622
        break;
      }
      {
#line 1626
      tmp___12 = strcasecmp((char const   *)q, "absolute");
      }
#line 1626
      if (tmp___12 == 0) {
#line 1627
        i ++;
#line 1628
        whichname = realname;
      } else {
        {
#line 1630
        tmp___11 = strcasecmp((char const   *)q, "relative");
        }
#line 1630
        if (tmp___11 == 0) {
#line 1631
          i ++;
#line 1632
          whichname = localname;
        } else {
          {
#line 1634
          tmp___10 = strncasecmp((char const   *)q, "class=", 6U);
          }
#line 1634
          if (tmp___10 == 0) {
            {
#line 1635
            i ++;
#line 1636
            classfound = 1;
#line 1637
            tmp = strcasecmp((char const   *)(q + 6), (char const   *)(class));
            }
#line 1637
            if (tmp == 0) {
#line 1638
              classmatched = 1;
            }
          } else {
#line 1640
            if (0) {
              {
#line 1640
              __s1_len = strlen((char const   *)q);
#line 1640
              __s2_len = strlen("-");
              }
#line 1640
              if (! ((unsigned int )((void const   *)(q + 1)) - (unsigned int )((void const   *)q) == 1U)) {
                goto _L___0;
              } else {
#line 1640
                if (__s1_len >= 4U) {
                  _L___0: 
#line 1640
                  if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 1640
                    tmp___9 = 1;
                  } else {
#line 1640
                    if (__s2_len >= 4U) {
#line 1640
                      tmp___9 = 1;
                    } else {
#line 1640
                      tmp___9 = 0;
                    }
                  }
                } else {
#line 1640
                  tmp___9 = 0;
                }
              }
#line 1640
              if (tmp___9) {
                {
#line 1640
                tmp___5 = __builtin_strcmp((char const   *)q, "-");
                }
              } else {
                {
#line 1640
                tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 1640
                tmp___5 = tmp___8;
                }
              }
            } else {
              {
#line 1640
              tmp___8 = __builtin_strcmp((char const   *)q, "-");
#line 1640
              tmp___5 = tmp___8;
              }
            }
#line 1640
            if (tmp___5 == 0) {
#line 1641
              i ++;
#line 1642
              options = 0;
            } else {
#line 1645
              options = 0;
            }
          }
        }
      }
    }
#line 1647
    if (! classfound) {
      goto _L___1;
    } else {
#line 1647
      if (classmatched) {
        _L___1: 
#line 1648
        while (1) {
#line 1648
          if (i < 50) {
#line 1648
            q = entry->arg[i];
#line 1648
            if ((unsigned int )q != (unsigned int )((char *)((void *)0))) {
#line 1648
              if (! ((int )*(q + 0) != 0)) {
#line 1648
                break;
              }
            } else {
#line 1648
              break;
            }
          } else {
#line 1648
            break;
          }
          {
#line 1649
          len = strlen((char const   *)q);
          }
#line 1650
          if ((int )*(q + 0) == 47) {
#line 1650
            p = whichname;
          } else {
            {
#line 1650
            tmp___21 = strrchr((char const   *)whichname, '/');
            }
#line 1650
            if (tmp___21) {
              {
#line 1650
              tmp___20 = strrchr((char const   *)whichname, '/');
#line 1650
              p = tmp___20 + 1;
              }
            } else {
#line 1650
              p = whichname;
            }
          }
          {
#line 1651
          tmp___23 = wu_fnmatch((char const   *)q, (char const   *)p, 9);
          }
#line 1651
          if (! tmp___23) {
            {
#line 1652
            tmp___22 = allow_retrieve(name);
            }
#line 1652
            if (! tmp___22) {
              {
#line 1654
              syslog(5, "%s of %s tried to download %s", pw->pw_name, remoteident,
                     realname);
#line 1656
              reply(550, (char *)"%s is marked unretrievable", localname);
              }
#line 1657
              return (1);
            }
          }
#line 1648
          i ++;
        }
      }
    }
  }
#line 1663
  return (0);
}
}
#line 1936 "extensions.c"
int file_compare(char *patterns , char *file ) 
{ char buf___2[4096] ;
  char *cp ;
  char *cp2 ;
  int i ;
  int matches ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;

  {
  {
#line 1942
  matches = 0;
#line 1944
  __builtin_strncpy(buf___2, (char const   *)patterns, sizeof(buf___2));
#line 1945
  buf___2[sizeof(buf___2) - 1U] = (char )'\000';
#line 1946
  tmp = strlen((char const   *)(buf___2));
#line 1946
  i = (int )tmp;
#line 1947
  tmp___0 = i;
#line 1947
  i ++;
#line 1947
  buf___2[tmp___0] = (char )',';
#line 1948
  tmp___1 = i;
#line 1948
  i ++;
#line 1948
  buf___2[tmp___1] = (char )'\000';
#line 1950
  cp = buf___2;
  }
#line 1951
  while (1) {
    {
#line 1951
    tmp___5 = __builtin_strchr(cp, ',');
#line 1951
    cp2 = tmp___5;
    }
#line 1951
    if (! ((unsigned int )cp2 != (unsigned int )((void *)0))) {
#line 1951
      break;
    }
    {
#line 1952
    tmp___2 = cp2;
#line 1952
    cp2 ++;
#line 1952
    *tmp___2 = (char )'\000';
#line 1953
    tmp___3 = wu_fnmatch((char const   *)cp, (char const   *)file, 1);
    }
#line 1953
    if (tmp___3 == 0) {
#line 1954
      matches = 1;
#line 1955
      break;
    }
  }
#line 1958
  return (matches);
}
}
#line 1961 "extensions.c"
int remote_compare(char *patterns ) 
{ char buf___2[4096] ;
  char *cp ;
  char *cp2 ;
  int i ;
  int matches ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___5 ;

  {
  {
#line 1967
  matches = 0;
#line 1969
  __builtin_strncpy(buf___2, (char const   *)patterns, sizeof(buf___2));
#line 1970
  buf___2[sizeof(buf___2) - 1U] = (char )'\000';
#line 1971
  tmp = strlen((char const   *)(buf___2));
#line 1971
  i = (int )tmp;
#line 1972
  tmp___0 = i;
#line 1972
  i ++;
#line 1972
  buf___2[tmp___0] = (char )',';
#line 1973
  tmp___1 = i;
#line 1973
  i ++;
#line 1973
  buf___2[tmp___1] = (char )'\000';
#line 1975
  cp = buf___2;
  }
#line 1976
  while (1) {
    {
#line 1976
    tmp___5 = __builtin_strchr(cp, ',');
#line 1976
    cp2 = tmp___5;
    }
#line 1976
    if (! ((unsigned int )cp2 != (unsigned int )((void *)0))) {
#line 1976
      break;
    }
    {
#line 1977
    tmp___2 = cp2;
#line 1977
    cp2 ++;
#line 1977
    *tmp___2 = (char )'\000';
#line 1978
    tmp___3 = hostmatch(cp, remoteaddr, remotehost);
    }
#line 1978
    if (tmp___3) {
#line 1979
      matches = 1;
#line 1980
      break;
    }
  }
#line 1983
  return (matches);
}
}
#line 1986 "extensions.c"
void throughput_calc(char *name , int *bps , double *bpsmult ) 
{ int match_value ;
  char cwdir[4096] ;
  char pwdir[4096] ;
  char path[4096] ;
  char file[4096] ;
  char *ap3 ;
  char *ap4 ;
  struct aclmember *entry ;
  char *sp ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;
  int tmp___5 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  {
#line 1988
  match_value = -1;
#line 1993
  ap3 = (char *)((void *)0);
#line 1993
  ap4 = (char *)((void *)0);
#line 1994
  entry = (struct aclmember *)((void *)0);
#line 2001
  *bps = -1;
#line 2002
  *bpsmult = 1.0;
#line 2008
  tmp = strlen((char const   *)name);
  }
#line 2008
  if (tmp + 1U > sizeof(path)) {
#line 2009
    return;
  }
  {
#line 2013
  strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)name);
#line 2014
  sp = strrchr((char const   *)(path), '/');
  }
#line 2014
  if (sp) {
#line 2015
    *sp = (char )'\000';
  } else {
    {
#line 2017
    strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)".");
    }
  }
  {
#line 2018
  sp = strrchr((char const   *)name, '/');
  }
#line 2018
  if (sp) {
    {
#line 2019
    strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(sp + 1));
    }
  } else {
    {
#line 2021
    strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)name);
    }
  }
  {
#line 2022
  tmp___0 = fb_realpath((char const   *)(path), cwdir);
  }
#line 2022
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 2023
    return;
  }
  {
#line 2026
  wu_realpath((char const   *)home, pwdir, chroot_path);
  }
#line 2029
  while (1) {
    {
#line 2029
    tmp___4 = getaclentry((char *)"throughput", & entry);
    }
#line 2029
    if (tmp___4) {
#line 2029
      if (entry->arg[0]) {
#line 2029
        if (entry->arg[1]) {
#line 2029
          if (entry->arg[2]) {
#line 2029
            if (entry->arg[3]) {
#line 2029
              if (entry->arg[4]) {
#line 2029
                if (! ((unsigned int )entry->arg[5] != (unsigned int )((void *)0))) {
#line 2029
                  break;
                }
              } else {
#line 2029
                break;
              }
            } else {
#line 2029
              break;
            }
          } else {
#line 2029
            break;
          }
        } else {
#line 2029
          break;
        }
      } else {
#line 2029
        break;
      }
    } else {
#line 2029
      break;
    }
    {
#line 2030
    tmp___3 = path_compare(entry->arg[0], pwdir);
    }
#line 2030
    if (0 < tmp___3) {
      {
#line 2030
      i = path_compare(entry->arg[1], cwdir);
      }
#line 2030
      if (i >= match_value) {
        {
#line 2033
        tmp___2 = file_compare(entry->arg[2], file);
        }
#line 2033
        if (tmp___2) {
          {
#line 2034
          tmp___1 = remote_compare(entry->arg[5]);
          }
#line 2034
          if (tmp___1) {
#line 2035
            match_value = i;
#line 2036
            ap3 = entry->arg[3];
#line 2037
            ap4 = entry->arg[4];
          }
        }
      }
    }
  }
#line 2044
  if (match_value >= 0) {
    {
#line 2045
    tmp___5 = strcasecmp((char const   *)ap3, "oo");
    }
#line 2045
    if (tmp___5 == 0) {
#line 2046
      *bps = -1;
    } else {
      {
#line 2048
      *bps = atoi((char const   *)ap3);
      }
    }
#line 2049
    if (0) {
      {
#line 2049
      __s1_len = strlen((char const   *)ap4);
#line 2049
      __s2_len = strlen("-");
      }
#line 2049
      if (! ((unsigned int )((void const   *)(ap4 + 1)) - (unsigned int )((void const   *)ap4) == 1U)) {
        goto _L___0;
      } else {
#line 2049
        if (__s1_len >= 4U) {
          _L___0: 
#line 2049
          if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 2049
            tmp___15 = 1;
          } else {
#line 2049
            if (__s2_len >= 4U) {
#line 2049
              tmp___15 = 1;
            } else {
#line 2049
              tmp___15 = 0;
            }
          }
        } else {
#line 2049
          tmp___15 = 0;
        }
      }
#line 2049
      if (tmp___15) {
        {
#line 2049
        tmp___11 = __builtin_strcmp((char const   *)ap4, "-");
        }
      } else {
        {
#line 2049
        tmp___14 = __builtin_strcmp((char const   *)ap4, "-");
#line 2049
        tmp___11 = tmp___14;
        }
      }
    } else {
      {
#line 2049
      tmp___14 = __builtin_strcmp((char const   *)ap4, "-");
#line 2049
      tmp___11 = tmp___14;
      }
    }
#line 2049
    if (tmp___11 == 0) {
#line 2050
      *bpsmult = 1.0;
    } else {
      {
#line 2052
      *bpsmult = atof((char const   *)ap4);
      }
    }
  }
#line 2054
  return;
}
}
#line 2057 "extensions.c"
void throughput_adjust(char *name ) 
{ int match_value ;
  char pwdir[4096] ;
  char cwdir[4096] ;
  char path[4096] ;
  char file[4096] ;
  char buf___2[4096] ;
  char *ap3 ;
  char *ap4 ;
  char **pap3 ;
  struct aclmember *entry ;
  char *sp ;
  int i ;
  size_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 2059
  match_value = -1;
#line 2065
  ap3 = (char *)((void *)0);
#line 2065
  ap4 = (char *)((void *)0);
#line 2067
  entry = (struct aclmember *)((void *)0);
#line 2077
  tmp = strlen((char const   *)name);
  }
#line 2077
  if (tmp + 1U > sizeof(path)) {
#line 2078
    return;
  }
  {
#line 2082
  strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)name);
#line 2083
  sp = strrchr((char const   *)(path), '/');
  }
#line 2083
  if (sp) {
#line 2084
    *sp = (char )'\000';
  } else {
    {
#line 2086
    strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)".");
    }
  }
  {
#line 2087
  sp = strrchr((char const   *)name, '/');
  }
#line 2087
  if (sp) {
    {
#line 2088
    strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)(sp + 1));
    }
  } else {
    {
#line 2090
    strcpy((char */* __restrict  */)(file), (char const   */* __restrict  */)name);
    }
  }
  {
#line 2091
  tmp___0 = fb_realpath((char const   *)(path), cwdir);
  }
#line 2091
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 2092
    return;
  }
  {
#line 2095
  wu_realpath((char const   *)home, pwdir, chroot_path);
  }
#line 2098
  while (1) {
    {
#line 2098
    tmp___4 = getaclentry((char *)"throughput", & entry);
    }
#line 2098
    if (tmp___4) {
#line 2098
      if (entry->arg[0]) {
#line 2098
        if (entry->arg[1]) {
#line 2098
          if (entry->arg[2]) {
#line 2098
            if (entry->arg[3]) {
#line 2098
              if (entry->arg[4]) {
#line 2098
                if (! ((unsigned int )entry->arg[5] != (unsigned int )((void *)0))) {
#line 2098
                  break;
                }
              } else {
#line 2098
                break;
              }
            } else {
#line 2098
              break;
            }
          } else {
#line 2098
            break;
          }
        } else {
#line 2098
          break;
        }
      } else {
#line 2098
        break;
      }
    } else {
#line 2098
      break;
    }
    {
#line 2099
    tmp___3 = path_compare(entry->arg[0], pwdir);
    }
#line 2099
    if (0 < tmp___3) {
      {
#line 2099
      i = path_compare(entry->arg[1], cwdir);
      }
#line 2099
      if (i >= match_value) {
        {
#line 2102
        tmp___2 = file_compare(entry->arg[2], file);
        }
#line 2102
        if (tmp___2) {
          {
#line 2103
          tmp___1 = remote_compare(entry->arg[5]);
          }
#line 2103
          if (tmp___1) {
#line 2104
            match_value = i;
#line 2105
            ap3 = entry->arg[3];
#line 2106
            pap3 = & entry->arg[3];
#line 2107
            ap4 = entry->arg[4];
          }
        }
      }
    }
  }
#line 2114
  if (match_value >= 0) {
    {
#line 2115
    tmp___19 = strcasecmp((char const   *)ap3, "oo");
    }
#line 2115
    if (tmp___19 != 0) {
#line 2116
      if (0) {
        {
#line 2116
        __s1_len = strlen((char const   *)ap4);
#line 2116
        __s2_len = strlen("-");
        }
#line 2116
        if (! ((unsigned int )((void const   *)(ap4 + 1)) - (unsigned int )((void const   *)ap4) == 1U)) {
          goto _L___0;
        } else {
#line 2116
          if (__s1_len >= 4U) {
            _L___0: 
#line 2116
            if (! ((unsigned int )((void const   *)("-" + 1)) - (unsigned int )((void const   *)"-") == 1U)) {
#line 2116
              tmp___18 = 1;
            } else {
#line 2116
              if (__s2_len >= 4U) {
#line 2116
                tmp___18 = 1;
              } else {
#line 2116
                tmp___18 = 0;
              }
            }
          } else {
#line 2116
            tmp___18 = 0;
          }
        }
#line 2116
        if (tmp___18) {
          {
#line 2116
          tmp___14 = __builtin_strcmp((char const   *)ap4, "-");
          }
        } else {
          {
#line 2116
          tmp___17 = __builtin_strcmp((char const   *)ap4, "-");
#line 2116
          tmp___14 = tmp___17;
          }
        }
      } else {
        {
#line 2116
        tmp___17 = __builtin_strcmp((char const   *)ap4, "-");
#line 2116
        tmp___14 = tmp___17;
        }
      }
#line 2116
      if (tmp___14 != 0) {
        {
#line 2117
        tmp___5 = atoi((char const   *)ap3);
#line 2117
        tmp___6 = atof((char const   *)ap4);
#line 2117
        sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%.0f",
                (double )tmp___5 * tmp___6);
#line 2118
        tmp___7 = strlen((char const   *)(buf___2));
#line 2118
        tmp___8 = malloc(tmp___7 + 1U);
#line 2118
        *pap3 = (char *)tmp___8;
        }
#line 2119
        if ((unsigned int )*pap3 == (unsigned int )((void *)0)) {
          {
#line 2120
          syslog(3, "malloc error in throughput_adjust");
#line 2121
          exit(0);
          }
        }
        {
#line 2123
        strcpy((char */* __restrict  */)*pap3, (char const   */* __restrict  */)(buf___2));
        }
      }
    }
  }
#line 2127
  return;
}
}
#line 2132 "extensions.c"
static int CheckMethod  =    0;
#line 2134 "extensions.c"
void SetCheckMethod(char const   *method ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2136
  tmp___1 = strcasecmp(method, "md5");
  }
#line 2136
  if (tmp___1 == 0) {
#line 2138
    CheckMethod = 0;
  } else {
    {
#line 2136
    tmp___2 = strcasecmp(method, "rfc1321");
    }
#line 2136
    if (tmp___2 == 0) {
#line 2138
      CheckMethod = 0;
    } else {
      {
#line 2139
      tmp = strcasecmp(method, "crc");
      }
#line 2139
      if (tmp == 0) {
#line 2141
        CheckMethod = 1;
      } else {
        {
#line 2139
        tmp___0 = strcasecmp(method, "posix");
        }
#line 2139
        if (tmp___0 == 0) {
#line 2141
          CheckMethod = 1;
        } else {
          {
#line 2143
          reply(500, (char *)"Unrecognized checksum method");
          }
#line 2144
          return;
        }
      }
    }
  }
#line 2146
  switch (CheckMethod) {
  default: 
  {
#line 2148
  reply(200, (char *)"Checksum method is now: MD5 (RFC1321)");
  }
#line 2149
  break;
  case 1: 
  {
#line 2151
  reply(200, (char *)"Checksum method is now: CRC (POSIX)");
  }
#line 2152
  break;
  }
#line 2154
  return;
}
}
#line 2156 "extensions.c"
void ShowCheckMethod(void) 
{ 

  {
#line 2158
  switch (CheckMethod) {
  default: 
  {
#line 2160
  reply(200, (char *)"Current checksum method: MD5 (RFC1321)");
  }
#line 2161
  break;
  case 1: 
  {
#line 2163
  reply(200, (char *)"Current checksum method: CRC (POSIX)");
  }
#line 2164
  break;
  }
#line 2166
  return;
}
}
#line 2168 "extensions.c"
void CheckSum(char *pathname ) 
{ char *cmd ;
  char buf___2[4096] ;
  FILE *cmdf ;
  struct stat st ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *crptr ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 2175
  tmp = stat((char const   */* __restrict  */)pathname, (struct stat */* __restrict  */)(& st));
  }
#line 2175
  if (tmp == 0) {
#line 2176
    if ((st.st_mode & 61440U) != 32768U) {
      {
#line 2177
      reply(500, (char *)"%s: not a plain file.", pathname);
      }
#line 2178
      return;
    }
  } else {
    {
#line 2182
    perror_reply(550, pathname);
    }
#line 2183
    return;
  }
#line 2186
  switch (CheckMethod) {
  default: 
#line 2188
  cmd = (char *)"/bin/md5sum";
#line 2189
  break;
  case 1: 
#line 2191
  cmd = (char *)"/bin/cksum";
#line 2192
  break;
  }
  {
#line 2195
  tmp___0 = strlen((char const   *)cmd);
#line 2195
  tmp___1 = strlen((char const   *)pathname);
  }
#line 2195
  if (((tmp___0 + 1U) + tmp___1) + 1U > sizeof(buf___2)) {
    {
#line 2196
    reply(500, (char *)"Pathname too long");
    }
#line 2197
    return;
  }
  {
#line 2199
  sprintf((char */* __restrict  */)(buf___2), (char const   */* __restrict  */)"%s %s",
          cmd, pathname);
#line 2201
  cmdf = ftpd_popen(buf___2, (char *)"r", 0);
  }
#line 2202
  if (! cmdf) {
    {
#line 2203
    perror_reply(550, cmd);
    }
  } else {
    {
#line 2206
    tmp___4 = fgets((char */* __restrict  */)(buf___2), (int )sizeof(buf___2), (FILE */* __restrict  */)cmdf);
    }
#line 2206
    if (tmp___4) {
      {
#line 2207
      tmp___3 = __builtin_strchr(buf___2, '\n');
#line 2207
      crptr = tmp___3;
      }
#line 2208
      if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 2209
        *crptr = (char )'\000';
      }
      {
#line 2210
      reply(200, (char *)"%s", buf___2);
      }
    }
    {
#line 2212
    ftpd_pclose(cmdf);
    }
  }
#line 2214
  return;
}
}
#line 2216 "extensions.c"
void CheckSumLastFile(void) 
{ 

  {
#line 2220
  if ((int )LastFileTransferred[0] == 0) {
    {
#line 2221
    reply(500, (char *)"Nothing transferred yet");
    }
  } else {
    {
#line 2223
    CheckSum(LastFileTransferred);
    }
  }
#line 2224
  return;
}
}
#line 1 "realpath.o"
/* #pragma merger(0,"/tmp/cil-Blb01xh8.i","-g,-O2") */
#line 467 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int fchdir(int __fd ) ;
#line 787
extern  __attribute__((__nothrow__)) ssize_t readlink(char const   * __restrict  __path ,
                                                      char * __restrict  __buf , size_t __len )  __attribute__((__nonnull__(1,2))) ;
#line 55 "realpath.c"
char *wu_realpath(char const   *path , char *resolved_path , char *chroot_path___0 ) 
{ char *ptr ;
  char q[4096] ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 60
  fb_realpath(path, q);
  }
#line 62
  if ((unsigned int )chroot_path___0 == (unsigned int )((void *)0)) {
    {
#line 63
    strcpy((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)(q));
    }
  } else {
    {
#line 65
    strcpy((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)chroot_path___0);
    }
#line 66
    if ((int )q[0] != 47) {
      {
#line 67
      tmp = strlen((char const   *)resolved_path);
#line 67
      tmp___0 = strlen((char const   *)(q));
      }
#line 67
      if (tmp + tmp___0 < 4096U) {
        {
#line 68
        strcat((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)(q));
        }
      } else {
#line 70
        return ((char *)((void *)0));
      }
    } else {
#line 72
      if ((int )q[1] != 0) {
#line 73
        ptr = q;
#line 73
        while ((int )*ptr != 0) {
#line 73
          ptr ++;
        }
#line 74
        if ((unsigned int )ptr == (unsigned int )resolved_path) {
          goto _L;
        } else {
#line 74
          ptr --;
#line 74
          if ((int )*ptr != 47) {
            _L: 
            {
#line 75
            tmp___1 = strlen((char const   *)resolved_path);
#line 75
            tmp___2 = strlen((char const   *)(q));
            }
#line 75
            if (tmp___1 + tmp___2 < 4096U) {
              {
#line 76
              strcat((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)(q));
              }
            } else {
#line 78
              return ((char *)((void *)0));
            }
          } else {
            {
#line 81
            tmp___3 = strlen((char const   *)resolved_path);
#line 81
            tmp___4 = strlen((char const   *)(q));
            }
#line 81
            if ((tmp___3 + tmp___4) - 1U < 4096U) {
              {
#line 82
              strcat((char */* __restrict  */)resolved_path, (char const   */* __restrict  */)(& q[1]));
              }
            } else {
#line 84
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 88
  return (resolved_path);
}
}
#line 98 "realpath.c"
char *fb_realpath(char const   *path , char *resolved ) 
{ struct stat sb ;
  int fd___0 ;
  int n ;
  int rootd ;
  int serrno ;
  char *p ;
  char *q ;
  char wbuf[4096] ;
  int symlinks ;
  int resultcode ;
  int *tmp ;
  uid_t userid ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  uid_t userid___0 ;
  __uid_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  uid_t userid___1 ;
  __uid_t tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  size_t len ;
  size_t tmp___12 ;
  char *tmp___13 ;
  void *tmp___14 ;
  int *tmp___15 ;
  uid_t userid___2 ;
  __uid_t tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  uid_t userid___3 ;
  __uid_t tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  int *tmp___23 ;
  char *tmp___25 ;
  uid_t userid___4 ;
  __uid_t tmp___26 ;
  int *tmp___27 ;
  char *tmp___29 ;
  int *tmp___30 ;
  int *tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  int *tmp___34 ;
  uid_t userid___5 ;
  __uid_t tmp___35 ;
  int *tmp___36 ;
  int *tmp___37 ;
  int *tmp___38 ;
  int *tmp___39 ;
  uid_t userid___6 ;
  __uid_t tmp___40 ;
  int *tmp___41 ;
  int *tmp___42 ;

  {
  {
#line 103
  symlinks = 0;
#line 112
  tmp = __errno_location();
#line 112
  *tmp = 0;
#line 120
  fd___0 = open(".", 0);
#line 122
  tmp___1 = __errno_location();
  }
#line 122
  if (13 == *tmp___1) {
    {
#line 123
    tmp___0 = geteuid();
#line 123
    userid = tmp___0;
#line 124
    delay_signaling();
#line 125
    seteuid(0U);
#line 133
    fd___0 = open(".", 0);
#line 135
    seteuid(userid);
#line 136
    enable_signaling();
    }
  }
#line 141
  if (fd___0 < 0) {
    {
#line 144
    strcpy((char */* __restrict  */)resolved, (char const   */* __restrict  */)".");
    }
#line 145
    return ((char *)((void *)0));
  }
  {
#line 156
  __builtin_strncpy(resolved, path, 4095U);
#line 157
  *(resolved + 4095) = (char )'\000';
  }
  loop: 
  {
#line 159
  q = strrchr((char const   *)resolved, '/');
  }
#line 160
  if ((unsigned int )q != (unsigned int )((void *)0)) {
#line 161
    p = q + 1;
#line 162
    if ((unsigned int )q == (unsigned int )resolved) {
#line 163
      q = (char *)"/";
    } else {
#line 165
      while (1) {
#line 166
        q --;
#line 165
        if ((unsigned int )q > (unsigned int )resolved) {
#line 165
          if (! ((int )*q == 47)) {
#line 165
            break;
          }
        } else {
#line 165
          break;
        }
      }
#line 168
      *(q + 1) = (char )'\000';
#line 169
      q = resolved;
    }
    {
#line 171
    tmp___2 = __errno_location();
#line 171
    *tmp___2 = 0;
#line 172
    resultcode = chdir((char const   *)q);
#line 173
    tmp___5 = __errno_location();
    }
#line 173
    if (13 == *tmp___5) {
      {
#line 174
      tmp___3 = geteuid();
#line 174
      userid___0 = tmp___3;
#line 175
      delay_signaling();
#line 176
      seteuid(0U);
#line 177
      tmp___4 = __errno_location();
#line 177
      *tmp___4 = 0;
#line 178
      resultcode = chdir((char const   *)q);
#line 179
      seteuid(userid___0);
#line 180
      enable_signaling();
      }
    }
#line 182
    if (resultcode < 0) {
      goto err1;
    }
  } else {
#line 186
    p = resolved;
  }
#line 189
  if ((int )*p != 0) {
    {
#line 190
    tmp___6 = __errno_location();
#line 190
    *tmp___6 = 0;
#line 191
    resultcode = lstat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& sb));
#line 192
    tmp___9 = __errno_location();
    }
#line 192
    if (13 == *tmp___9) {
      {
#line 193
      tmp___7 = geteuid();
#line 193
      userid___1 = tmp___7;
#line 194
      delay_signaling();
#line 195
      seteuid(0U);
#line 196
      tmp___8 = __errno_location();
#line 196
      *tmp___8 = 0;
#line 197
      resultcode = lstat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& sb));
#line 198
      seteuid(userid___1);
#line 199
      enable_signaling();
      }
    }
#line 201
    if (resultcode == 0) {
#line 203
      if ((sb.st_mode & 61440U) == 40960U) {
#line 204
        symlinks ++;
#line 204
        if (symlinks > 20) {
          {
#line 205
          tmp___10 = __errno_location();
#line 205
          *tmp___10 = 40;
          }
          goto err1;
        }
        {
#line 208
        tmp___11 = __errno_location();
#line 208
        *tmp___11 = 0;
#line 210
        tmp___12 = strlen((char const   *)p);
#line 210
        len = tmp___12;
#line 211
        tmp___14 = calloc(len + 1U, sizeof(char ));
#line 211
        tmp___13 = (char *)tmp___14;
        }
#line 212
        if ((unsigned int )tmp___13 == (unsigned int )((char *)0)) {
          {
#line 213
          tmp___15 = __errno_location();
#line 213
          serrno = *tmp___15;
          }
          goto err1;
        }
        {
#line 216
        strcpy((char */* __restrict  */)tmp___13, (char const   */* __restrict  */)p);
#line 217
        p = tmp___13;
#line 219
        n = readlink((char const   */* __restrict  */)p, (char */* __restrict  */)resolved,
                     4096U);
#line 220
        tmp___18 = __errno_location();
        }
#line 220
        if (13 == *tmp___18) {
          {
#line 221
          tmp___16 = geteuid();
#line 221
          userid___2 = tmp___16;
#line 222
          delay_signaling();
#line 223
          seteuid(0U);
#line 224
          tmp___17 = __errno_location();
#line 224
          *tmp___17 = 0;
#line 225
          n = readlink((char const   */* __restrict  */)p, (char */* __restrict  */)resolved,
                       4096U);
#line 226
          seteuid(userid___2);
#line 227
          enable_signaling();
          }
        }
#line 229
        if (n < 0) {
          {
#line 230
          free((void *)p);
          }
          goto err1;
        }
        {
#line 233
        free((void *)p);
#line 234
        *(resolved + n) = (char )'\000';
        }
        goto loop;
      }
#line 238
      if ((sb.st_mode & 61440U) == 16384U) {
        {
#line 239
        tmp___19 = __errno_location();
#line 239
        *tmp___19 = 0;
#line 240
        resultcode = chdir((char const   *)p);
#line 241
        tmp___22 = __errno_location();
        }
#line 241
        if (13 == *tmp___22) {
          {
#line 242
          tmp___20 = geteuid();
#line 242
          userid___3 = tmp___20;
#line 243
          delay_signaling();
#line 244
          seteuid(0U);
#line 245
          tmp___21 = __errno_location();
#line 245
          *tmp___21 = 0;
#line 246
          resultcode = chdir((char const   *)p);
#line 247
          seteuid(userid___3);
#line 248
          enable_signaling();
          }
        }
#line 250
        if (resultcode < 0) {
          goto err1;
        }
#line 252
        p = (char *)"";
      }
    }
  }
  {
#line 261
  strcpy((char */* __restrict  */)(wbuf), (char const   */* __restrict  */)p);
#line 262
  tmp___23 = __errno_location();
#line 262
  *tmp___23 = 0;
#line 264
  tmp___25 = getcwd(resolved, 4096U);
  }
#line 264
  if ((unsigned int )tmp___25 == (unsigned int )((void *)0)) {
#line 264
    resultcode = 0;
  } else {
#line 264
    resultcode = 1;
  }
  {
#line 272
  tmp___30 = __errno_location();
  }
#line 272
  if (13 == *tmp___30) {
    {
#line 273
    tmp___26 = geteuid();
#line 273
    userid___4 = tmp___26;
#line 274
    delay_signaling();
#line 275
    seteuid(0U);
#line 276
    tmp___27 = __errno_location();
#line 276
    *tmp___27 = 0;
#line 278
    tmp___29 = getcwd(resolved, 4096U);
    }
#line 278
    if ((unsigned int )tmp___29 == (unsigned int )((void *)0)) {
#line 278
      resultcode = 0;
    } else {
#line 278
      resultcode = 1;
    }
    {
#line 286
    seteuid(userid___4);
#line 287
    enable_signaling();
    }
  }
#line 289
  if (resultcode == 0) {
    goto err1;
  }
#line 296
  if ((int )*(resolved + 0) == 47) {
#line 296
    if ((int )*(resolved + 1) == 0) {
#line 297
      rootd = 1;
    } else {
#line 299
      rootd = 0;
    }
  } else {
#line 299
    rootd = 0;
  }
#line 301
  if (wbuf[0]) {
    {
#line 302
    tmp___32 = strlen((char const   *)resolved);
#line 302
    tmp___33 = strlen((char const   *)(wbuf));
    }
#line 302
    if (((tmp___32 + tmp___33) + (unsigned int )rootd) + 1U > 4096U) {
      {
#line 303
      tmp___31 = __errno_location();
#line 303
      *tmp___31 = 36;
      }
      goto err1;
    }
#line 306
    if (rootd == 0) {
      {
#line 307
      strcat((char */* __restrict  */)resolved, (char const   */* __restrict  */)"/");
      }
    }
    {
#line 308
    strcat((char */* __restrict  */)resolved, (char const   */* __restrict  */)(wbuf));
    }
  }
  {
#line 312
  tmp___34 = __errno_location();
#line 312
  *tmp___34 = 0;
#line 316
  resultcode = fchdir(fd___0);
#line 318
  tmp___37 = __errno_location();
  }
#line 318
  if (13 == *tmp___37) {
    {
#line 319
    tmp___35 = geteuid();
#line 319
    userid___5 = tmp___35;
#line 320
    delay_signaling();
#line 321
    seteuid(0U);
#line 322
    tmp___36 = __errno_location();
#line 322
    *tmp___36 = 0;
#line 326
    resultcode = fchdir(fd___0);
#line 328
    seteuid(userid___5);
#line 329
    enable_signaling();
    }
  }
#line 331
  if (resultcode < 0) {
    {
#line 332
    tmp___38 = __errno_location();
#line 332
    serrno = *tmp___38;
    }
    goto err2;
  }
  {
#line 338
  close(fd___0);
  }
#line 340
  return (resolved);
  err1: 
  {
#line 342
  tmp___39 = __errno_location();
#line 342
  serrno = *tmp___39;
#line 346
  fchdir(fd___0);
#line 348
  tmp___41 = __errno_location();
  }
#line 348
  if (13 == *tmp___41) {
    {
#line 349
    tmp___40 = geteuid();
#line 349
    userid___6 = tmp___40;
#line 350
    delay_signaling();
#line 351
    seteuid(0U);
#line 355
    fchdir(fd___0);
#line 357
    seteuid(userid___6);
#line 358
    enable_signaling();
    }
  }
  err2: 
  {
#line 363
  close(fd___0);
#line 364
  tmp___42 = __errno_location();
#line 364
  *tmp___42 = serrno;
  }
#line 366
  return ((char *)((void *)0));
}
}
#line 1 "acl.o"
/* #pragma merger(0,"/tmp/cil-ZnF2rBR0.i","-g,-O2") */
#line 680 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 50 "acl.c"
char *aclbuf  =    (char *)((void *)0);
#line 51 "acl.c"
static struct aclmember *aclmembers  ;
#line 60 "acl.c"
struct aclmember *getaclentry(char *keyword , struct aclmember **next ) 
{ int tmp ;

  {
#line 62
  while (1) {
#line 63
    if (! *next) {
#line 64
      *next = aclmembers;
    } else {
#line 66
      *next = (*next)->next;
    }
#line 62
    if (*next) {
      {
#line 62
      tmp = strcasecmp((char const   *)((*next)->keyword), (char const   *)keyword);
      }
#line 62
      if (! tmp) {
#line 62
        break;
      }
    } else {
#line 62
      break;
    }
  }
#line 69
  return (*next);
}
}
#line 79 "acl.c"
void parseacl(void) 
{ char *ptr ;
  char *aclptr ;
  char *line___0 ;
  int cnt ;
  struct aclmember *member ;
  struct aclmember *acltail ;
  char *tmp ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 81
  aclptr = aclbuf;
#line 85
  if (! aclbuf) {
#line 86
    return;
  } else {
#line 85
    if (! *aclbuf) {
#line 86
      return;
    }
  }
#line 88
  aclmembers = (struct aclmember *)((void *)0);
#line 89
  acltail = (struct aclmember *)((void *)0);
#line 91
  while ((int )*aclptr != 0) {
#line 92
    line___0 = aclptr;
#line 93
    while (1) {
#line 93
      if (*aclptr) {
#line 93
        if (! ((int )*aclptr != 10)) {
#line 93
          break;
        }
      } else {
#line 93
        break;
      }
#line 94
      aclptr ++;
    }
    {
#line 95
    tmp = aclptr;
#line 95
    aclptr ++;
#line 95
    *tmp = (char )((void *)0);
#line 98
    tmp___1 = __builtin_strchr(line___0, '#');
#line 98
    ptr = tmp___1;
    }
#line 98
    if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 100
      if ((unsigned int )ptr > (unsigned int )aclbuf) {
#line 100
        if ((int )*(ptr - 1) != 92) {
#line 101
          *ptr = (char )'\000';
        }
      }
    }
    {
#line 103
    ptr = strtok((char */* __restrict  */)line___0, (char const   */* __restrict  */)" \t");
    }
#line 104
    if (ptr) {
      {
#line 105
      tmp___2 = calloc(1U, sizeof(struct aclmember ));
#line 105
      member = (struct aclmember *)tmp___2;
      }
#line 107
      if ((unsigned int )member == (unsigned int )((void *)0)) {
        {
#line 108
        syslog(3, "calloc error parsing acl");
#line 109
        exit(0);
        }
      }
      {
#line 111
      strcpy((char */* __restrict  */)(member->keyword), (char const   */* __restrict  */)ptr);
#line 112
      cnt = 0;
      }
#line 113
      while (1) {
        {
#line 113
        ptr = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t");
        }
#line 113
        if (! ((unsigned int )ptr != (unsigned int )((void *)0))) {
#line 113
          break;
        }
#line 114
        if (cnt >= 50) {
          {
#line 115
          syslog(3, "Too many args (>%d) in ftpaccess: %s %s %s %s %s ...", 49, member->keyword,
                 member->arg[0], member->arg[1], member->arg[2], member->arg[3]);
          }
#line 119
          break;
        }
#line 121
        tmp___3 = cnt;
#line 121
        cnt ++;
#line 121
        member->arg[tmp___3] = ptr;
      }
#line 123
      if (acltail) {
#line 124
        acltail->next = member;
      }
#line 125
      acltail = member;
#line 126
      if (! aclmembers) {
#line 127
        aclmembers = member;
      }
    }
  }
#line 130
  return;
}
}
#line 139 "acl.c"
int readacl(char *aclpath ) 
{ FILE *aclfile ;
  struct stat finfo ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;

  {
#line 145
  if (! use_accessfile) {
#line 146
    return (0);
  }
  {
#line 148
  aclfile = fopen((char const   */* __restrict  */)aclpath, (char const   */* __restrict  */)"r");
  }
#line 148
  if ((unsigned int )aclfile == (unsigned int )((void *)0)) {
    {
#line 149
    tmp = __errno_location();
#line 149
    tmp___0 = strerror(*tmp);
#line 149
    syslog(3, "cannot open access file %s: %s", aclpath, tmp___0);
    }
#line 151
    return (0);
  }
  {
#line 153
  tmp___3 = fileno(aclfile);
#line 153
  tmp___4 = fstat(tmp___3, & finfo);
  }
#line 153
  if (tmp___4 != 0) {
    {
#line 154
    tmp___1 = __errno_location();
#line 154
    tmp___2 = strerror(*tmp___1);
#line 154
    syslog(3, "cannot fstat access file %s: %s", aclpath, tmp___2);
#line 156
    fclose(aclfile);
    }
#line 157
    return (0);
  }
#line 159
  if (finfo.st_size == 0L) {
    {
#line 160
    tmp___5 = calloc(1U, 1U);
#line 160
    aclbuf = (char *)tmp___5;
    }
  } else {
    {
#line 163
    tmp___6 = malloc((unsigned int )finfo.st_size + 1U);
#line 163
    aclbuf = (char *)tmp___6;
    }
#line 163
    if (! aclbuf) {
      {
#line 164
      syslog(3, "could not malloc aclbuf (%d bytes)", finfo.st_size + 1L);
#line 165
      fclose(aclfile);
      }
#line 166
      return (0);
    }
    {
#line 168
    tmp___9 = fread((void */* __restrict  */)aclbuf, (unsigned int )finfo.st_size,
                    1U, (FILE */* __restrict  */)aclfile);
    }
#line 168
    if (! tmp___9) {
      {
#line 169
      tmp___7 = __errno_location();
#line 169
      tmp___8 = strerror(*tmp___7);
#line 169
      syslog(3, "error reading acl file %s: %s", aclpath, tmp___8);
#line 171
      free((void *)aclbuf);
#line 172
      aclbuf = (char *)((void *)0);
#line 173
      fclose(aclfile);
      }
#line 174
      return (0);
    }
#line 176
    *(aclbuf + finfo.st_size) = (char )'\000';
  }
  {
#line 178
  fclose(aclfile);
  }
#line 179
  return (1);
}
}
#line 1 "private.o"
/* #pragma merger(0,"/tmp/cil-5UamUmZu.i","-g,-O2") */
#line 1204 "/usr/include/bits/string2.h"
extern char *__strsep_g(char **__stringp , char const   *__delim ) ;
#line 103 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 246 "proto.h"
void parsepriv(void) ;
#line 72 "private.c"
char *passbuf  =    (char *)((void *)0);
#line 73 "private.c"
char groupname[100]  ;
#line 74 "private.c"
int group_given  =    0;
#line 84 "private.c"
struct acgrp *privptr  ;
#line 88 "private.c"
int group_attempts  ;
#line 90 "private.c"
void parsepriv(void) 
{ char *ptr ;
  char *acptr ;
  char *line___0 ;
  char *argv[3] ;
  char *p ;
  char *val ;
  struct acgrp *aptr ;
  struct acgrp *privtail ;
  struct group *gr ;
  int n ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___17 ;
  gid_t gid ;
  int tmp___18 ;
  void *tmp___19 ;
  void *tmp___20 ;

  {
#line 93
  acptr = passbuf;
#line 95
  privtail = (struct acgrp *)((void *)0);
#line 99
  if (! passbuf) {
#line 100
    return;
  } else {
#line 99
    if (! *passbuf) {
#line 100
      return;
    }
  }
#line 103
  while ((int )*acptr != 0) {
#line 104
    line___0 = acptr;
#line 105
    while (1) {
#line 105
      if (*acptr) {
#line 105
        if (! ((int )*acptr != 10)) {
#line 105
          break;
        }
      } else {
#line 105
        break;
      }
#line 106
      acptr ++;
    }
    {
#line 107
    tmp = acptr;
#line 107
    acptr ++;
#line 107
    *tmp = (char )'\000';
#line 110
    tmp___1 = __builtin_strchr(line___0, '#');
#line 110
    ptr = tmp___1;
    }
#line 110
    if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 111
      *ptr = (char )'\000';
    }
#line 113
    if ((int )*line___0 == 0) {
#line 114
      continue;
    }
#line 117
    n = 0;
#line 117
    p = line___0;
#line 117
    while (1) {
#line 117
      if (n < 3) {
#line 117
        if (! ((unsigned int )p != (unsigned int )((void *)0))) {
#line 117
          break;
        }
      } else {
#line 117
        break;
      }
      {
#line 118
      tmp___17 = __strsep_g(& p, ":\n");
#line 118
      val = tmp___17;
#line 119
      argv[n] = val;
      }
#line 120
      if ((int )*(argv[n] + 0) == 32) {
#line 121
        argv[n] = (char *)((void *)0);
      } else {
#line 120
        if ((int )*(argv[n] + 0) == 0) {
#line 121
          argv[n] = (char *)((void *)0);
        }
      }
#line 117
      n ++;
    }
#line 124
    if (n != 3) {
#line 125
      continue;
    } else {
#line 124
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 125
        continue;
      }
    }
#line 127
    if (argv[0]) {
#line 127
      if (argv[2]) {
#line 128
        if ((int )*(argv[2] + 0) == 37) {
          {
#line 129
          tmp___18 = atoi((char const   *)(argv[2] + 1));
#line 129
          gid = (unsigned int )tmp___18;
#line 130
          gr = getgrgid(gid);
          }
#line 130
          if ((unsigned int )gr != (unsigned int )((void *)0)) {
            {
#line 131
            tmp___19 = calloc(1U, sizeof(struct acgrp ));
#line 131
            aptr = (struct acgrp *)tmp___19;
            }
#line 132
            if ((unsigned int )aptr == (unsigned int )((void *)0)) {
              {
#line 133
              syslog(3, "calloc error in parsepriv");
#line 134
              exit(0);
              }
            }
#line 138
            if (privtail) {
#line 139
              privtail->next = aptr;
            }
#line 140
            privtail = aptr;
#line 141
            if (! privptr) {
#line 142
              privptr = aptr;
            }
            {
#line 144
            strcpy((char */* __restrict  */)(aptr->gname), (char const   */* __restrict  */)argv[0]);
            }
#line 145
            if ((unsigned int )argv[1] == (unsigned int )((void *)0)) {
#line 146
              aptr->gpass[0] = (char )'\000';
            } else {
              {
#line 148
              strcpy((char */* __restrict  */)(aptr->gpass), (char const   */* __restrict  */)argv[1]);
              }
            }
            {
#line 149
            strcpy((char */* __restrict  */)(aptr->gr_name), (char const   */* __restrict  */)gr->gr_name);
#line 150
            aptr->gr_gid = gid;
            }
          }
        } else {
          {
#line 154
          gr = getgrnam((char const   *)argv[2]);
          }
#line 154
          if ((unsigned int )gr != (unsigned int )((void *)0)) {
            {
#line 155
            tmp___20 = calloc(1U, sizeof(struct acgrp ));
#line 155
            aptr = (struct acgrp *)tmp___20;
            }
#line 156
            if ((unsigned int )aptr == (unsigned int )((void *)0)) {
              {
#line 157
              syslog(3, "calloc error in parsepriv");
#line 158
              exit(0);
              }
            }
#line 162
            if (privtail) {
#line 163
              privtail->next = aptr;
            }
#line 164
            privtail = aptr;
#line 165
            if (! privptr) {
#line 166
              privptr = aptr;
            }
            {
#line 168
            strcpy((char */* __restrict  */)(aptr->gname), (char const   */* __restrict  */)argv[0]);
            }
#line 169
            if ((unsigned int )argv[1] == (unsigned int )((void *)0)) {
#line 170
              aptr->gpass[0] = (char )'\000';
            } else {
              {
#line 172
              strcpy((char */* __restrict  */)(aptr->gpass), (char const   */* __restrict  */)argv[1]);
              }
            }
            {
#line 173
            strcpy((char */* __restrict  */)(aptr->gr_name), (char const   */* __restrict  */)argv[2]);
#line 174
            aptr->gr_gid = gr->gr_gid;
            }
          }
        }
        {
#line 177
        endgrent();
        }
      }
    }
  }
#line 180
  return;
}
}
#line 188 "private.c"
void priv_setup(char *path ) 
{ FILE *prvfile ;
  struct stat finfo ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 193
  passbuf = (char *)((void *)0);
#line 195
  prvfile = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"r");
  }
#line 195
  if ((unsigned int )prvfile == (unsigned int )((void *)0)) {
    {
#line 196
    tmp___1 = __errno_location();
    }
#line 196
    if (*tmp___1 != 2) {
      {
#line 197
      tmp = __errno_location();
#line 197
      tmp___0 = strerror(*tmp);
#line 197
      syslog(3, "cannot open private access file %s: %s", path, tmp___0);
      }
    }
#line 199
    return;
  }
  {
#line 201
  tmp___4 = fileno(prvfile);
#line 201
  tmp___5 = fstat(tmp___4, & finfo);
  }
#line 201
  if (tmp___5 != 0) {
    {
#line 202
    tmp___2 = __errno_location();
#line 202
    tmp___3 = strerror(*tmp___2);
#line 202
    syslog(3, "cannot fstat private access file %s: %s", path, tmp___3);
#line 204
    fclose(prvfile);
    }
#line 205
    return;
  }
#line 207
  if (finfo.st_size == 0L) {
    {
#line 208
    tmp___6 = calloc(1U, 1U);
#line 208
    passbuf = (char *)tmp___6;
    }
  } else {
    {
#line 211
    tmp___7 = malloc((unsigned int )finfo.st_size + 1U);
#line 211
    passbuf = (char *)tmp___7;
    }
#line 211
    if (! passbuf) {
      {
#line 212
      syslog(3, "could not malloc passbuf (%d bytes)", finfo.st_size + 1L);
#line 214
      fclose(prvfile);
      }
#line 215
      return;
    }
    {
#line 217
    tmp___10 = fread((void */* __restrict  */)passbuf, (unsigned int )finfo.st_size,
                     1U, (FILE */* __restrict  */)prvfile);
    }
#line 217
    if (! tmp___10) {
      {
#line 218
      tmp___8 = __errno_location();
#line 218
      tmp___9 = strerror(*tmp___8);
#line 218
      syslog(3, "error reading private access file %s: %s", path, tmp___9);
#line 220
      fclose(prvfile);
      }
#line 221
      return;
    }
#line 223
    *(passbuf + finfo.st_size) = (char )'\000';
  }
  {
#line 225
  fclose(prvfile);
#line 226
  parsepriv();
  }
#line 227
  return;
}
}
#line 236 "private.c"
static struct acgrp *priv_getent(char *group ) 
{ struct acgrp *ptr ;
  int tmp ;

  {
#line 240
  ptr = privptr;
#line 240
  while (ptr) {
    {
#line 241
    tmp = strcasecmp((char const   *)group, (char const   *)(ptr->gname));
    }
#line 241
    if (! tmp) {
#line 242
      return (ptr);
    }
#line 240
    ptr = ptr->next;
  }
#line 244
  return ((struct acgrp *)((void *)0));
}
}
#line 253 "private.c"
void priv_group(char *group ) 
{ size_t tmp ;

  {
  {
#line 255
  tmp = strlen((char const   *)group);
  }
#line 255
  if ((int )tmp < 100) {
    {
#line 256
    __builtin_strncpy(groupname, (char const   *)group, 100U);
#line 257
    group_given = 1;
#line 258
    reply(200, (char *)"Request for access to group %s accepted.", group);
    }
  } else {
    {
#line 261
    group_given = 0;
#line 262
    reply(500, (char *)"Illegal group name");
    }
  }
#line 265
  return;
}
}
#line 274 "private.c"
void priv_gpass(char *gpass ) 
{ char *xgpass ;
  struct acgrp *grp ;
  uid_t uid ;
  gid_t gid ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 276
  xgpass = (char *)((void *)0);
#line 281
  if (group_given == 0) {
    {
#line 282
    reply(503, (char *)"Give group name with SITE GROUP first.");
    }
#line 283
    return;
  }
  {
#line 287
  group_given = 0;
#line 289
  grp = priv_getent(groupname);
  }
#line 290
  if (passbuf) {
#line 290
    if (gpass) {
#line 290
      if ((int )*gpass != 0) {
#line 290
        if (grp) {
#line 290
          if ((int )grp->gpass[0] != 0) {
            {
#line 294
            xgpass = crypt((char const   *)gpass, (char const   *)(grp->gpass));
            }
          }
        }
      }
    }
  }
#line 301
  if ((unsigned int )gpass != (unsigned int )((void *)0)) {
#line 301
    if ((int )*gpass != 0) {
#line 301
      if ((unsigned int )grp != (unsigned int )((void *)0)) {
#line 301
        if ((int )grp->gpass[0] != 0) {
#line 301
          if (0) {
            {
#line 301
            __s1_len = strlen((char const   *)xgpass);
#line 301
            __s2_len = strlen((char const   *)(grp->gpass));
            }
#line 301
            if (! ((unsigned int )((void const   *)(xgpass + 1)) - (unsigned int )((void const   *)xgpass) == 1U)) {
              goto _L___0;
            } else {
#line 301
              if (__s1_len >= 4U) {
                _L___0: 
#line 301
                if (! ((unsigned int )((void const   *)(grp->gpass + 1)) - (unsigned int )((void const   *)(grp->gpass)) == 1U)) {
#line 301
                  tmp___8 = 1;
                } else {
#line 301
                  if (__s2_len >= 4U) {
#line 301
                    tmp___8 = 1;
                  } else {
#line 301
                    tmp___8 = 0;
                  }
                }
              } else {
#line 301
                tmp___8 = 0;
              }
            }
#line 301
            if (tmp___8) {
              {
#line 301
              tmp___4 = __builtin_strcmp((char const   *)xgpass, (char const   *)(grp->gpass));
              }
            } else {
              {
#line 301
              tmp___7 = __builtin_strcmp((char const   *)xgpass, (char const   *)(grp->gpass));
#line 301
              tmp___4 = tmp___7;
              }
            }
          } else {
            {
#line 301
            tmp___7 = __builtin_strcmp((char const   *)xgpass, (char const   *)(grp->gpass));
#line 301
            tmp___4 = tmp___7;
            }
          }
#line 301
          if (! (tmp___4 == 0)) {
            goto _L___7;
          }
        } else {
          goto _L___7;
        }
      } else {
        goto _L___7;
      }
    } else {
      goto _L___7;
    }
  } else {
    _L___7: 
#line 301
    if ((unsigned int )gpass == (unsigned int )((void *)0)) {
      goto _L___3;
    } else {
#line 301
      if ((int )*gpass == 0) {
        _L___3: 
#line 301
        if ((unsigned int )grp != (unsigned int )((void *)0)) {
#line 301
          if (! ((int )grp->gpass[0] == 0)) {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        {
#line 307
        reply(530, (char *)"Group access request incorrect.");
#line 308
        grp = (struct acgrp *)((void *)0);
#line 309
        group_attempts ++;
        }
#line 309
        if (group_attempts >= lgi_failure_threshold) {
          {
#line 310
          syslog(5, "repeated group access failures from %s, group %s", remoteident,
                 groupname);
#line 313
          exit(0);
          }
        }
        {
#line 315
        sleep((unsigned int )group_attempts);
        }
#line 316
        return;
      }
    }
  }
  {
#line 319
  uid = geteuid();
#line 320
  gid = grp->gr_gid;
#line 322
  delay_signaling();
#line 323
  seteuid(0U);
#line 324
  setegid(gid);
#line 325
  seteuid(uid);
#line 326
  enable_signaling();
#line 328
  reply(200, (char *)"Group access enabled.");
#line 329
  group_attempts = 0;
  }
#line 330
  return;
}
}
#line 1 "authenticate.o"
/* #pragma merger(0,"/tmp/cil-6YhdKxV7.i","-g,-O2") */
#line 48 "authenticate.c"
int wu_authenticate(void) 
{ char *user___0 ;

  {
  {
#line 56
  authenticated = 0;
#line 58
  user___0 = (char *)"*";
#line 73
  __builtin_strncpy(authuser, (char const   *)user___0, sizeof(authuser));
#line 74
  authuser[99] = (char )'\000';
  }
#line 75
  return (0);
}
}
#line 1 "conversions.o"
/* #pragma merger(0,"/tmp/cil-A1QsU3gs.i","-g,-O2") */
#line 150 "pathnames.h"
char _path_cvt[4096]  ;
#line 55 "conversions.c"
char *convbuf  =    (char *)((void *)0);
#line 63 "conversions.c"
struct str2int c_list[7]  = {      {(char *)"T_REG", 1}, 
        {(char *)"T_ASCII", 4}, 
        {(char *)"T_DIR", 2}, 
        {(char *)"O_COMPRESS", 1}, 
        {(char *)"O_UNCOMPRESS", 1 << 1}, 
        {(char *)"O_TAR", 1 << 2}, 
        {(char *)((void *)0), 0}};
#line 74 "conversions.c"
static int conv(char *str ) 
{ int rc ;
  int counter ;
  char *tmp ;

  {
#line 76
  rc = 0;
#line 81
  if (str) {
#line 82
    counter = 0;
#line 82
    while (c_list[counter].string) {
      {
#line 83
      tmp = strstr((char const   *)str, (char const   *)c_list[counter].string);
      }
#line 83
      if (tmp) {
#line 84
        rc |= c_list[counter].value;
      }
#line 82
      counter ++;
    }
  }
#line 85
  return (rc);
}
}
#line 88 "conversions.c"
static int readconv(char *convpath ) 
{ FILE *convfile ;
  struct stat finfo ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 93
  convfile = fopen((char const   */* __restrict  */)convpath, (char const   */* __restrict  */)"r");
  }
#line 93
  if ((unsigned int )convfile == (unsigned int )((void *)0)) {
    {
#line 94
    tmp___1 = __errno_location();
    }
#line 94
    if (*tmp___1 != 2) {
      {
#line 95
      tmp = __errno_location();
#line 95
      tmp___0 = strerror(*tmp);
#line 95
      syslog(3, "cannot open conversion file %s: %s", convpath, tmp___0);
      }
    }
#line 97
    return (0);
  }
  {
#line 99
  tmp___4 = fileno(convfile);
#line 99
  tmp___5 = fstat(tmp___4, & finfo);
  }
#line 99
  if (tmp___5 != 0) {
    {
#line 100
    tmp___2 = __errno_location();
#line 100
    tmp___3 = strerror(*tmp___2);
#line 100
    syslog(3, "cannot fstat conversion file %s: %s", convpath, tmp___3);
#line 102
    fclose(convfile);
    }
#line 103
    return (0);
  }
#line 105
  if (finfo.st_size == 0L) {
    {
#line 106
    tmp___6 = calloc(1U, 1U);
#line 106
    convbuf = (char *)tmp___6;
    }
  } else {
    {
#line 109
    tmp___7 = malloc((unsigned int )finfo.st_size + 1U);
#line 109
    convbuf = (char *)tmp___7;
    }
#line 109
    if (! convbuf) {
      {
#line 110
      syslog(3, "could not malloc convbuf (%d bytes)", finfo.st_size + 1L);
#line 111
      fclose(convfile);
      }
#line 112
      return (0);
    }
    {
#line 114
    tmp___10 = fread((void */* __restrict  */)convbuf, (unsigned int )finfo.st_size,
                     1U, (FILE */* __restrict  */)convfile);
    }
#line 114
    if (! tmp___10) {
      {
#line 115
      tmp___8 = __errno_location();
#line 115
      tmp___9 = strerror(*tmp___8);
#line 115
      syslog(3, "error reading conv file %s: %s", convpath, tmp___9);
#line 117
      convbuf = (char *)((void *)0);
#line 118
      fclose(convfile);
      }
#line 119
      return (0);
    }
#line 121
    *(convbuf + finfo.st_size) = (char )'\000';
  }
  {
#line 123
  fclose(convfile);
  }
#line 124
  return (1);
}
}
#line 127 "conversions.c"
static void parseconv(void) 
{ char *ptr ;
  char *convptr ;
  char *line___0 ;
  char *argv[8] ;
  char *p ;
  char *val ;
  struct convert *cptr ;
  struct convert *cvttail ;
  int n ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___17 ;
  void *tmp___18 ;

  {
#line 130
  convptr = convbuf;
#line 132
  cvttail = (struct convert *)((void *)0);
#line 135
  if (! convbuf) {
#line 136
    return;
  } else {
#line 135
    if (! *convbuf) {
#line 136
      return;
    }
  }
#line 139
  while ((int )*convptr != 0) {
#line 140
    line___0 = convptr;
#line 141
    while (1) {
#line 141
      if (*convptr) {
#line 141
        if (! ((int )*convptr != 10)) {
#line 141
          break;
        }
      } else {
#line 141
        break;
      }
#line 142
      convptr ++;
    }
    {
#line 143
    tmp = convptr;
#line 143
    convptr ++;
#line 143
    *tmp = (char )'\000';
#line 146
    tmp___1 = __builtin_strchr(line___0, '#');
#line 146
    ptr = tmp___1;
    }
#line 146
    if ((unsigned int )ptr != (unsigned int )((void *)0)) {
#line 147
      *ptr = (char )'\000';
    }
#line 149
    if ((int )*line___0 == 0) {
#line 150
      continue;
    }
#line 153
    n = 0;
#line 153
    p = line___0;
#line 153
    while (1) {
#line 153
      if (n < 8) {
#line 153
        if (! ((unsigned int )p != (unsigned int )((void *)0))) {
#line 153
          break;
        }
      } else {
#line 153
        break;
      }
      {
#line 154
      tmp___17 = __strsep_g(& p, ":\n");
#line 154
      val = tmp___17;
#line 155
      argv[n] = val;
      }
#line 156
      if ((int )*(argv[n] + 0) == 32) {
#line 157
        argv[n] = (char *)((void *)0);
      } else {
#line 156
        if ((int )*(argv[n] + 0) == 0) {
#line 157
          argv[n] = (char *)((void *)0);
        }
      }
#line 153
      n ++;
    }
#line 160
    if (n != 8) {
#line 161
      continue;
    } else {
#line 160
      if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 161
        continue;
      }
    }
#line 164
    if (! argv[0]) {
#line 164
      if (! argv[1]) {
#line 164
        if (! argv[2]) {
#line 164
          if (! argv[3]) {
#line 165
            continue;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
#line 164
      if (! argv[4]) {
#line 165
        continue;
      } else {
#line 164
        if (! argv[7]) {
#line 165
          continue;
        }
      }
    }
    {
#line 168
    tmp___18 = calloc(1U, sizeof(struct convert ));
#line 168
    cptr = (struct convert *)tmp___18;
    }
#line 170
    if ((unsigned int )cptr == (unsigned int )((void *)0)) {
      {
#line 171
      syslog(3, "calloc error parsing ftpconversions");
#line 172
      exit(0);
      }
    }
#line 174
    if (cvttail) {
#line 175
      cvttail->next = cptr;
    }
#line 176
    cvttail = cptr;
#line 177
    if (! cvtptr) {
#line 178
      cvtptr = cptr;
    }
    {
#line 180
    cptr->stripprefix = argv[0];
#line 181
    cptr->stripfix = argv[1];
#line 182
    cptr->prefix = argv[2];
#line 183
    cptr->postfix = argv[3];
#line 184
    cptr->external_cmd = argv[4];
#line 185
    cptr->types = conv(argv[5]);
#line 186
    cptr->options = conv(argv[6]);
#line 187
    cptr->name = argv[7];
    }
  }
#line 189
  return;
}
}
#line 191 "conversions.c"
void conv_init(void) 
{ int tmp ;

  {
  {
#line 197
  tmp = readconv(_path_cvt);
  }
#line 197
  if (tmp < 0) {
#line 198
    return;
  }
  {
#line 199
  parseconv();
  }
#line 200
  return;
}
}
#line 1 "rdservers.o"
/* #pragma merger(0,"/tmp/cil-6bsRyLQg.i","-g,-O2") */
#line 43 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 46 "rdservers.c"
int read_servers_line(FILE *svrfp , char *hostaddress___0 , char *accesspath ) ;
#line 50 "rdservers.c"
static char buffer[8192]  ;
#line 48 "rdservers.c"
int read_servers_line(FILE *svrfp , char *hostaddress___0 , char *accesspath ) 
{ struct hostent *hp ;
  char *hcp ;
  char *acp ;
  char *bcp ;
  char *ecp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  struct in_addr in ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 56
  while (1) {
    {
#line 56
    tmp___6 = fgets((char */* __restrict  */)(buffer), 8192, (FILE */* __restrict  */)svrfp);
    }
#line 56
    if (! ((unsigned int )tmp___6 != (unsigned int )((void *)0))) {
#line 56
      break;
    }
#line 59
    bcp = buffer;
#line 59
    while (1) {
#line 59
      if (! ((int )*bcp == 9)) {
#line 59
        if (! ((int )*bcp == 32)) {
#line 59
          break;
        }
      }
#line 59
      bcp ++;
    }
    {
#line 62
    tmp___0 = __builtin_strchr(buffer, '#');
#line 62
    ecp = tmp___0;
    }
#line 62
    if ((unsigned int )ecp != (unsigned int )((void *)0)) {
#line 63
      *ecp = (char )'\000';
    }
#line 66
    if ((unsigned int )bcp == (unsigned int )ecp) {
#line 67
      continue;
    } else {
#line 66
      if ((int )*bcp == 10) {
#line 67
        continue;
      }
    }
#line 71
    hcp = bcp;
#line 72
    acp = hcp;
#line 72
    while (1) {
#line 72
      if (*acp) {
        {
#line 72
        tmp___1 = __ctype_b_loc();
        }
#line 72
        if ((int const   )*(*tmp___1 + (int )*acp) & 8192) {
#line 72
          break;
        }
      } else {
#line 72
        break;
      }
#line 72
      acp ++;
    }
#line 76
    if (! *acp) {
#line 77
      continue;
    }
#line 79
    tmp___2 = acp;
#line 79
    acp ++;
#line 79
    *tmp___2 = (char )'\000';
#line 81
    while (1) {
#line 81
      if (*acp) {
        {
#line 81
        tmp___3 = __ctype_b_loc();
        }
#line 81
        if (! ((int const   )*(*tmp___3 + (int )*acp) & 8192)) {
#line 81
          break;
        }
      } else {
#line 81
        break;
      }
#line 82
      acp ++;
    }
#line 85
    if (! *acp) {
#line 86
      continue;
    }
#line 88
    ecp = acp;
#line 90
    while (1) {
#line 90
      if (*ecp) {
        {
#line 90
        tmp___4 = __ctype_b_loc();
        }
#line 90
        if ((int const   )*(*tmp___4 + (int )*ecp) & 8192) {
#line 90
          break;
        } else {
#line 90
          if (! ((int )*ecp != 10)) {
#line 90
            break;
          }
        }
      } else {
#line 90
        break;
      }
#line 91
      ecp ++;
    }
    {
#line 93
    *ecp = (char )'\000';
#line 95
    hp = gethostbyname((char const   *)hcp);
    }
#line 95
    if ((unsigned int )hp != (unsigned int )((void *)0)) {
      {
#line 97
      memmove((void *)(& in), (void const   *)*(hp->h_addr_list + 0), sizeof(in));
#line 98
      tmp___5 = inet_ntoa(in);
#line 98
      strcpy((char */* __restrict  */)hostaddress___0, (char const   */* __restrict  */)tmp___5);
      }
    } else {
      {
#line 101
      strcpy((char */* __restrict  */)hostaddress___0, (char const   */* __restrict  */)hcp);
      }
    }
    {
#line 103
    strcpy((char */* __restrict  */)accesspath, (char const   */* __restrict  */)acp);
    }
#line 105
    return (1);
  }
#line 107
  return (0);
}
}
#line 1 "paths.o"
/* #pragma merger(0,"/tmp/cil-XD1fBhZO.i","-g,-O2") */
#line 258 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int access(char const   *__name , int __type )  __attribute__((__nonnull__(1))) ;
#line 147 "pathnames.h"
char _path_ftpusers[4096]  ;
#line 148 "pathnames.h"
char _path_ftphosts[4096]  ;
#line 51 "paths.c"
int virtual_mode  =    0;
#line 52 "paths.c"
int virtual_ftpaccess  =    0;
#line 112 "paths.c"
void setup_paths(void) 
{ char *sp ;
  char configdir[4096] ;
  char filepath[4096] ;
  char hostaddress___0[32] ;
  char linebuf[8192] ;
  FILE *svrfp ;
  struct hostent *shp ;
  struct stat st ;
  int virtual_len ;
  struct sockaddr_in virtual_addr ;
  struct sockaddr_in *virtual_ptr ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___32 ;
  char *tmp___33 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;

  {
  {
#line 132
  strcpy((char */* __restrict  */)(_path_ftpaccess), (char const   */* __restrict  */)"/etc/ftpaccess");
#line 133
  strcpy((char */* __restrict  */)(_path_ftpusers), (char const   */* __restrict  */)"/etc/ftpusers");
#line 134
  strcpy((char */* __restrict  */)(_path_private), (char const   */* __restrict  */)"/etc/ftpgroups");
#line 135
  strcpy((char */* __restrict  */)(_path_cvt), (char const   */* __restrict  */)"/etc/ftpconversions");
#line 136
  strcpy((char */* __restrict  */)(logfile), (char const   */* __restrict  */)"/var/log/xferlog");
#line 139
  strcpy((char */* __restrict  */)(_path_ftphosts), (char const   */* __restrict  */)"/etc/ftphosts");
#line 148
  svrfp = fopen((char const   */* __restrict  */)"/etc/ftpservers", (char const   */* __restrict  */)"r");
  }
#line 148
  if ((unsigned int )svrfp != (unsigned int )((void *)0)) {
    {
#line 170
    virtual_len = (int )sizeof(virtual_addr);
#line 171
    tmp___58 = getsockname(0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& virtual_addr)),
                           (socklen_t */* __restrict  */)(& virtual_len));
    }
#line 171
    if (tmp___58 == 0) {
#line 172
      virtual_ptr = & virtual_addr;
#line 174
      while (1) {
        {
#line 174
        tmp___57 = read_servers_line(svrfp, hostaddress___0, configdir);
        }
#line 174
        if (! (tmp___57 == 1)) {
#line 174
          break;
        }
#line 175
        if (0) {
          {
#line 175
          __s1_len = strlen((char const   *)(hostaddress___0));
#line 175
          tmp___53 = inet_ntoa(virtual_ptr->sin_addr);
#line 175
          __s2_len = strlen((char const   *)tmp___53);
          }
#line 175
          if (! ((unsigned int )((void const   *)(hostaddress___0 + 1)) - (unsigned int )((void const   *)(hostaddress___0)) == 1U)) {
            goto _L___0;
          } else {
#line 175
            if (__s1_len >= 4U) {
              _L___0: 
              {
#line 175
              tmp___54 = inet_ntoa(virtual_ptr->sin_addr);
#line 175
              tmp___55 = inet_ntoa(virtual_ptr->sin_addr);
              }
#line 175
              if ((unsigned int )((void const   *)(tmp___54 + 1)) - (unsigned int )((void const   *)tmp___55) == 1U) {
#line 175
                if (__s2_len >= 4U) {
#line 175
                  tmp___56 = 1;
                } else {
#line 175
                  tmp___56 = 0;
                }
              } else {
#line 175
                tmp___56 = 1;
              }
            } else {
#line 175
              tmp___56 = 0;
            }
          }
#line 175
          if (tmp___56) {
            {
#line 175
            tmp___33 = inet_ntoa(virtual_ptr->sin_addr);
#line 175
            tmp___32 = __builtin_strcmp((char const   *)(hostaddress___0), (char const   *)tmp___33);
            }
          } else {
            {
#line 175
            tmp___50 = inet_ntoa(virtual_ptr->sin_addr);
#line 175
            tmp___51 = __builtin_strcmp((char const   *)(hostaddress___0), (char const   *)tmp___50);
#line 175
            tmp___32 = tmp___51;
            }
          }
        } else {
          {
#line 175
          tmp___50 = inet_ntoa(virtual_ptr->sin_addr);
#line 175
          tmp___51 = __builtin_strcmp((char const   *)(hostaddress___0), (char const   *)tmp___50);
#line 175
          tmp___32 = tmp___51;
          }
        }
#line 175
        if (! tmp___32) {
          {
#line 176
          tmp = inet_ntoa(virtual_ptr->sin_addr);
#line 176
          sprintf((char */* __restrict  */)(linebuf), (char const   */* __restrict  */)"VirtualFTP Connect to: %s",
                  tmp);
#line 178
          syslog(5, "%s", linebuf);
          }
#line 180
          if ((unsigned int )(hostname) != (unsigned int )((void *)0)) {
            {
#line 182
            shp = gethostbyaddr((void const   *)((char *)(& virtual_ptr->sin_addr)),
                                sizeof(struct in_addr ), 2);
            }
#line 183
            if ((unsigned int )shp != (unsigned int )((void *)0)) {
              {
#line 184
              __builtin_strncpy(hostname, (char const   *)shp->h_name, 64U);
              }
            }
          }
          {
#line 188
          tmp___0 = strlen((char const   *)(configdir));
#line 188
          sp = configdir + (tmp___0 - 1U);
          }
#line 189
          if ((int )*sp == 47) {
#line 190
            *sp = (char )'\000';
          }
          {
#line 197
          tmp___6 = stat((char const   */* __restrict  */)(configdir), (struct stat */* __restrict  */)(& st));
          }
#line 197
          if (tmp___6 == 0) {
#line 197
            if ((st.st_mode & 61440U) == 16384U) {
              {
#line 200
              sprintf((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"%s/ftpaccess",
                      configdir);
#line 201
              tmp___1 = access((char const   *)(filepath), 4);
              }
#line 201
              if (tmp___1 == 0) {
                {
#line 202
                strcpy((char */* __restrict  */)(_path_ftpaccess), (char const   */* __restrict  */)(filepath));
#line 203
                virtual_mode = 1;
#line 204
                virtual_ftpaccess = 1;
                }
              }
              {
#line 207
              sprintf((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"%s/ftpusers",
                      configdir);
#line 208
              tmp___2 = access((char const   *)(filepath), 4);
              }
#line 208
              if (tmp___2 == 0) {
                {
#line 209
                strcpy((char */* __restrict  */)(_path_ftpusers), (char const   */* __restrict  */)(filepath));
                }
              }
              {
#line 211
              sprintf((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"%s/ftpgroups",
                      configdir);
#line 212
              tmp___3 = access((char const   *)(filepath), 4);
              }
#line 212
              if (tmp___3 == 0) {
                {
#line 213
                strcpy((char */* __restrict  */)(_path_private), (char const   */* __restrict  */)(filepath));
                }
              }
              {
#line 215
              sprintf((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"%s/ftphosts",
                      configdir);
#line 216
              tmp___4 = access((char const   *)(filepath), 4);
              }
#line 216
              if (tmp___4 == 0) {
                {
#line 217
                strcpy((char */* __restrict  */)(_path_ftphosts), (char const   */* __restrict  */)(filepath));
                }
              }
              {
#line 219
              sprintf((char */* __restrict  */)(filepath), (char const   */* __restrict  */)"%s/ftpconversions",
                      configdir);
#line 220
              tmp___5 = access((char const   *)(filepath), 4);
              }
#line 220
              if (tmp___5 == 0) {
                {
#line 221
                strcpy((char */* __restrict  */)(_path_cvt), (char const   */* __restrict  */)(filepath));
                }
              }
            }
          }
#line 223
          return;
        }
      }
    }
  }
#line 230
  return;
}
}
#line 1 "hostacc.o"
/* #pragma merger(0,"/tmp/cil-FXe_fH9f.i","-g,-O2") */
#line 799 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int feof(FILE *__stream ) ;
#line 298 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void bcopy(void const   *__src , void *__dest ,
                                                size_t __n )  __attribute__((__nonnull__(1,2))) ;
#line 74 "hostacc.h"
static int sethacc(void) ;
#line 75
static int endhacc(void) ;
#line 76
static hacc_t *gethacc(void) ;
#line 77
static void fatalmsg(char *pcMsg ) ;
#line 78
static char *strnsav(char *pcStr , int iLen ) ;
#line 49 "hostacc.c"
static char linbuf[1024]  ;
#line 50 "hostacc.c"
static char unibuf[1024]  ;
#line 51 "hostacc.c"
static hacc_t *ha_arr  ;
#line 53 "hostacc.c"
static FILE *ptFp  ;
#line 54 "hostacc.c"
static int iHaInd  =    0;
#line 55 "hostacc.c"
static int iHaSize  ;
#line 56 "hostacc.c"
static int iFirstTim  =    1;
#line 66 "hostacc.c"
int rhost_ok(char *pcRuser , char *pcRhost , char *pcRaddr ) 
{ hacc_t *ptHtmp ;
  char *pcHost ;
  char *ha_login ;
  int iInd ;
  int iLineMatch ;
  int iUserSeen ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
  {
#line 71
  iLineMatch = 0;
#line 71
  iUserSeen = 0;
#line 73
  tmp = sethacc();
  }
#line 73
  switch (tmp) {
  case 1: 
#line 76
  return (1);
  case -1: 
  {
#line 79
  syslog(6, "rhost_ok: sethacc failed");
#line 80
  endhacc();
  }
#line 81
  return (0);
  default: ;
#line 84
  break;
  }
  {
#line 88
  tmp___0 = strcasecmp((char const   *)pcRuser, "anonymous");
  }
#line 88
  if (! tmp___0) {
#line 89
    pcRuser = (char *)"ftp";
  }
#line 91
  while (1) {
    {
#line 91
    ptHtmp = gethacc();
    }
#line 91
    if ((unsigned int )ptHtmp != (unsigned int )((hacc_t *)((void *)0))) {
#line 91
      if (! (! iLineMatch)) {
#line 91
        break;
      }
    } else {
#line 91
      break;
    }
    {
#line 92
    tmp___1 = strcasecmp((char const   *)ptHtmp->ha_login, "anonymous");
    }
#line 92
    if (tmp___1) {
#line 93
      ha_login = ptHtmp->ha_login;
    } else {
#line 95
      ha_login = (char *)"ftp";
    }
    {
#line 97
    tmp___2 = strcasecmp((char const   *)pcRuser, (char const   *)ha_login);
    }
#line 97
    if (tmp___2) {
#line 97
      if (0) {
        {
#line 97
        __s1_len = strlen((char const   *)ha_login);
#line 97
        __s2_len = strlen("*");
        }
#line 97
        if (! ((unsigned int )((void const   *)(ha_login + 1)) - (unsigned int )((void const   *)ha_login) == 1U)) {
          goto _L___0;
        } else {
#line 97
          if (__s1_len >= 4U) {
            _L___0: 
#line 97
            if (! ((unsigned int )((void const   *)("*" + 1)) - (unsigned int )((void const   *)"*") == 1U)) {
#line 97
              tmp___12 = 1;
            } else {
#line 97
              if (__s2_len >= 4U) {
#line 97
                tmp___12 = 1;
              } else {
#line 97
                tmp___12 = 0;
              }
            }
          } else {
#line 97
            tmp___12 = 0;
          }
        }
#line 97
        if (tmp___12) {
          {
#line 97
          tmp___8 = __builtin_strcmp((char const   *)ha_login, "*");
          }
        } else {
          {
#line 97
          tmp___11 = __builtin_strcmp((char const   *)ha_login, "*");
#line 97
          tmp___8 = tmp___11;
          }
        }
      } else {
        {
#line 97
        tmp___11 = __builtin_strcmp((char const   *)ha_login, "*");
#line 97
        tmp___8 = tmp___11;
        }
      }
#line 97
      if (tmp___8) {
#line 99
        continue;
      }
    }
#line 105
    iUserSeen = 1;
#line 107
    iInd = 0;
#line 107
    pcHost = ptHtmp->ha_hosts[0];
#line 107
    while (1) {
#line 107
      if (iInd < 12) {
#line 107
        if ((unsigned int )pcHost != (unsigned int )((void *)0)) {
#line 107
          if (! (! iLineMatch)) {
#line 107
            break;
          }
        } else {
#line 107
          break;
        }
      } else {
#line 107
        break;
      }
      {
#line 110
      iLineMatch = hostmatch(pcHost, pcRaddr, pcRhost);
      }
#line 111
      if (iLineMatch) {
#line 112
        if ((int )ptHtmp->ha_type == 1) {
#line 112
          iLineMatch = 1;
        } else {
#line 112
          iLineMatch = 0;
        }
        goto match;
      }
#line 107
      iInd ++;
#line 107
      pcHost = ptHtmp->ha_hosts[iInd];
    }
  }
  match: 
  {
#line 126
  tmp___13 = endhacc();
  }
#line 126
  if (tmp___13) {
    {
#line 127
    syslog(6, "rhost_ok: endhacc failed");
    }
#line 128
    return (0);
  }
#line 131
  if (iUserSeen) {
#line 132
    if ((unsigned int )ptHtmp == (unsigned int )((void *)0)) {
#line 132
      tmp___14 = 0;
    } else {
#line 132
      tmp___14 = iLineMatch;
    }
#line 132
    return (tmp___14);
  } else {
#line 135
    return (1);
  }
}
}
#line 146 "hostacc.c"
static int sethacc(void) 
{ int iHaHind ;
  char *pcBegin ;
  char *pcEnd ;
  char *pcColon ;
  char *pcTmp1 ;
  char *pcTmp2 ;
  int iHaMalloc ;
  int *tmp ;
  void *tmp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int tmp___19 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___45 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  int tmp___66 ;
  int tmp___67 ;

  {
  {
#line 148
  iHaHind = 0;
#line 151
  iHaMalloc = 0;
#line 153
  iHaInd = 0;
#line 154
  iFirstTim = 1;
#line 156
  ptFp = fopen((char const   */* __restrict  */)(_path_ftphosts), (char const   */* __restrict  */)"r");
  }
#line 156
  if ((unsigned int )ptFp == (unsigned int )((void *)0)) {
    {
#line 157
    tmp = __errno_location();
    }
#line 157
    if (*tmp == 2) {
#line 158
      return (1);
    } else {
      {
#line 160
      fatalmsg((char *)"Can\'t open host access file");
#line 161
      iHaSize = iHaInd;
      }
#line 162
      return (-1);
    }
  }
  {
#line 165
  iHaMalloc = 10;
#line 165
  tmp___0 = malloc((unsigned int )iHaMalloc * sizeof(hacc_t ));
#line 165
  ha_arr = (hacc_t *)tmp___0;
  }
#line 166
  if ((unsigned int )ha_arr == (unsigned int )((void *)0)) {
    {
#line 167
    syslog(3, "malloc error in sethacc");
#line 168
    exit(0);
    }
  }
#line 171
  while (1) {
    {
#line 171
    tmp___64 = fgets((char */* __restrict  */)(linbuf), 1024, (FILE */* __restrict  */)ptFp);
    }
#line 171
    if (! ((unsigned int )tmp___64 != (unsigned int )((void *)0))) {
#line 171
      break;
    }
#line 172
    iHaHind = 0;
#line 175
    pcBegin = linbuf;
#line 175
    while (1) {
#line 175
      if (! ((int )*pcBegin == 9)) {
#line 175
        if (! ((int )*pcBegin == 32)) {
#line 175
          break;
        }
      }
#line 175
      pcBegin ++;
    }
    {
#line 180
    tmp___2 = __builtin_strchr(linbuf, '#');
#line 180
    pcEnd = tmp___2;
    }
#line 180
    if ((unsigned int )pcEnd != (unsigned int )((void *)0)) {
#line 181
      *pcEnd = (char )'\000';
    }
#line 185
    if ((unsigned int )pcBegin == (unsigned int )pcEnd) {
#line 186
      continue;
    } else {
#line 185
      if ((int )*pcBegin == 10) {
#line 186
        continue;
      }
    }
#line 196
    pcTmp1 = pcBegin;
#line 196
    pcTmp2 = unibuf;
#line 196
    while (*pcTmp1) {
#line 197
      if ((int )*pcTmp1 != 9) {
#line 197
        if ((int )*pcTmp1 != 32) {
#line 197
          if ((int )*pcTmp1 != 10) {
#line 198
            tmp___3 = pcTmp2;
#line 198
            pcTmp2 ++;
#line 198
            *tmp___3 = *pcTmp1;
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
#line 201
        if ((int )*(pcTmp2 - 1) == 58) {
          goto __Cont;
        } else {
#line 204
          tmp___4 = pcTmp2;
#line 204
          pcTmp2 ++;
#line 204
          *tmp___4 = (char )':';
        }
      }
      __Cont: 
#line 196
      pcTmp1 ++;
    }
#line 211
    if ((int )*(pcTmp2 - 1) == 58) {
#line 211
      pcEnd = pcTmp2 - 1;
    } else {
#line 211
      pcEnd = pcTmp2;
    }
#line 212
    *pcEnd = (char )'\000';
#line 218
    if (iHaInd >= iHaMalloc) {
      {
#line 219
      iHaMalloc += 10;
#line 219
      tmp___5 = realloc((void *)ha_arr, (unsigned int )iHaMalloc * sizeof(hacc_t ));
#line 219
      ha_arr = (hacc_t *)tmp___5;
      }
#line 220
      if (! ha_arr) {
        {
#line 221
        fatalmsg((char *)"Failed to realloc host access array");
#line 222
        iHaSize = iHaInd;
        }
#line 223
        return (-1);
      }
    }
#line 232
    pcBegin = unibuf;
#line 233
    if (0) {
#line 233
      if (0) {
        {
#line 233
        __s1_len___2 = strlen((char const   *)pcBegin);
#line 233
        __s2_len___2 = strlen("deny");
        }
#line 233
        if (! ((unsigned int )((void const   *)(pcBegin + 1)) - (unsigned int )((void const   *)pcBegin) == 1U)) {
          goto _L___8;
        } else {
#line 233
          if (__s1_len___2 >= 4U) {
            _L___8: 
#line 233
            if (! ((unsigned int )((void const   *)("deny" + 1)) - (unsigned int )((void const   *)"deny") == 1U)) {
#line 233
              tmp___55 = 1;
            } else {
#line 233
              if (__s2_len___2 >= 4U) {
#line 233
                tmp___55 = 1;
              } else {
#line 233
                tmp___55 = 0;
              }
            }
          } else {
#line 233
            tmp___55 = 0;
          }
        }
#line 233
        if (tmp___55) {
          {
#line 233
          tmp___51 = __builtin_strcmp((char const   *)pcBegin, "deny");
          }
        } else {
          {
#line 233
          tmp___54 = __builtin_strcmp((char const   *)pcBegin, "deny");
#line 233
          tmp___51 = tmp___54;
          }
        }
      } else {
        {
#line 233
        tmp___54 = __builtin_strcmp((char const   *)pcBegin, "deny");
#line 233
        tmp___51 = tmp___54;
        }
      }
#line 233
      tmp___45 = tmp___51;
    } else {
      {
#line 233
      tmp___45 = strncmp((char const   *)pcBegin, "deny", 4U);
      }
    }
#line 233
    if (tmp___45) {
#line 237
      if (0) {
#line 237
        if (0) {
          {
#line 237
          __s1_len___0 = strlen((char const   *)pcBegin);
#line 237
          __s2_len___0 = strlen("allow");
          }
#line 237
          if (! ((unsigned int )((void const   *)(pcBegin + 1)) - (unsigned int )((void const   *)pcBegin) == 1U)) {
            goto _L___4;
          } else {
#line 237
            if (__s1_len___0 >= 4U) {
              _L___4: 
#line 237
              if (! ((unsigned int )((void const   *)("allow" + 1)) - (unsigned int )((void const   *)"allow") == 1U)) {
#line 237
                tmp___29 = 1;
              } else {
#line 237
                if (__s2_len___0 >= 4U) {
#line 237
                  tmp___29 = 1;
                } else {
#line 237
                  tmp___29 = 0;
                }
              }
            } else {
#line 237
              tmp___29 = 0;
            }
          }
#line 237
          if (tmp___29) {
            {
#line 237
            tmp___25 = __builtin_strcmp((char const   *)pcBegin, "allow");
            }
          } else {
            {
#line 237
            tmp___28 = __builtin_strcmp((char const   *)pcBegin, "allow");
#line 237
            tmp___25 = tmp___28;
            }
          }
        } else {
          {
#line 237
          tmp___28 = __builtin_strcmp((char const   *)pcBegin, "allow");
#line 237
          tmp___25 = tmp___28;
          }
        }
#line 237
        tmp___19 = tmp___25;
      } else {
        {
#line 237
        tmp___19 = strncmp((char const   *)pcBegin, "allow", 5U);
        }
      }
#line 237
      if (tmp___19) {
        {
#line 242
        fatalmsg((char *)"Format error in host access file");
#line 243
        iHaSize = iHaInd;
        }
#line 244
        return (-1);
      } else {
#line 238
        (ha_arr + iHaInd)->ha_type = (short)1;
#line 239
        pcBegin += 6;
      }
    } else {
#line 234
      (ha_arr + iHaInd)->ha_type = (short)2;
#line 235
      pcBegin += 5;
    }
    {
#line 247
    tmp___59 = __builtin_strchr(pcBegin, ':');
#line 247
    pcColon = tmp___59;
    }
#line 247
    if ((unsigned int )pcColon != (unsigned int )((void *)0)) {
      {
#line 248
      (ha_arr + iHaInd)->ha_login = strnsav(pcBegin, pcColon - pcBegin);
      }
    } else {
      {
#line 251
      fatalmsg((char *)"Format error in host access file");
#line 252
      iHaSize = iHaInd;
      }
#line 253
      return (-1);
    }
#line 256
    pcBegin = pcColon + 1;
#line 257
    while (1) {
      {
#line 257
      tmp___62 = __builtin_strchr(pcBegin, ':');
#line 257
      pcColon = tmp___62;
      }
#line 257
      if (! ((unsigned int )pcColon != (unsigned int )((void *)0))) {
#line 257
        break;
      }
      {
#line 258
      tmp___60 = iHaHind;
#line 258
      iHaHind ++;
#line 258
      (ha_arr + iHaInd)->ha_hosts[tmp___60] = strnsav(pcBegin, pcColon - pcBegin);
#line 260
      pcBegin = pcColon + 1;
      }
#line 261
      if (iHaHind >= 12) {
        {
#line 262
        fatalmsg((char *)"Line too long");
#line 263
        iHaSize = iHaInd;
        }
#line 264
        return (-1);
      }
    }
    {
#line 267
    tmp___63 = iHaHind;
#line 267
    iHaHind ++;
#line 267
    (ha_arr + iHaInd)->ha_hosts[tmp___63] = strnsav(pcBegin, pcEnd - pcBegin);
#line 269
    (ha_arr + iHaInd)->ha_hosts[iHaHind] = (char *)((void *)0);
#line 270
    iHaInd ++;
    }
  }
  {
#line 272
  iHaSize = iHaInd;
#line 273
  tmp___67 = feof(ptFp);
  }
#line 273
  if (tmp___67) {
#line 273
    tmp___66 = 0;
  } else {
#line 273
    tmp___66 = -1;
  }
#line 273
  return (tmp___66);
}
}
#line 285 "hostacc.c"
static int iHaInd___0  ;
#line 286 "hostacc.c"
static hacc_t ptTmp  ;
#line 283 "hostacc.c"
static hacc_t *gethacc(void) 
{ 

  {
#line 288
  if (iFirstTim) {
#line 289
    iFirstTim = 0;
#line 290
    iHaInd___0 = 0;
  }
#line 292
  if (iHaInd___0 >= iHaSize) {
#line 293
    return ((hacc_t *)((void *)0));
  } else {
    {
#line 298
    bcopy((void const   *)(ha_arr + iHaInd___0), (void *)(& ptTmp), sizeof(hacc_t ));
#line 300
    iHaInd___0 ++;
    }
#line 301
    return (& ptTmp);
  }
}
}
#line 312 "hostacc.c"
static int endhacc(void) 
{ int iInd ;
  hacc_t *ptHtmp ;
  int tmp ;

  {
#line 317
  if ((unsigned int )ha_arr == (unsigned int )((hacc_t *)((void *)0))) {
#line 318
    return (0);
  }
#line 320
  ptHtmp = ha_arr;
#line 320
  while (1) {
#line 320
    if ((unsigned int )ptHtmp < (unsigned int )(ha_arr + iHaSize)) {
#line 320
      if (! ptHtmp->ha_type) {
#line 320
        break;
      }
    } else {
#line 320
      break;
    }
#line 323
    ptHtmp->ha_type = (short)0;
#line 324
    if (ptHtmp->ha_login) {
      {
#line 325
      free((void *)ptHtmp->ha_login);
#line 326
      ptHtmp->ha_login = (char *)((void *)0);
      }
    }
#line 328
    iInd = 0;
#line 328
    while (1) {
#line 328
      if (iInd < 12) {
#line 328
        if (! ptHtmp->ha_hosts[iInd]) {
#line 328
          break;
        }
      } else {
#line 328
        break;
      }
      {
#line 331
      free((void *)ptHtmp->ha_hosts[iInd]);
#line 332
      ptHtmp->ha_hosts[iInd] = (char *)((void *)0);
#line 328
      iInd ++;
      }
    }
#line 320
    ptHtmp ++;
  }
  {
#line 335
  free((void *)ha_arr);
#line 336
  ha_arr = (hacc_t *)((void *)0);
  }
#line 338
  if (ptFp) {
    {
#line 338
    tmp = fclose(ptFp);
    }
#line 338
    if (tmp) {
#line 339
      return (-1);
    }
  }
#line 340
  return (0);
}
}
#line 345 "hostacc.c"
static void fatalmsg(char *pcMsg ) 
{ 

  {
  {
#line 347
  syslog(6, "host_access: %s", pcMsg);
  }
#line 348
  return;
}
}
#line 350 "hostacc.c"
static char *strnsav(char *pcStr , int iLen ) 
{ char *pcBuf ;
  void *tmp ;

  {
  {
#line 354
  tmp = malloc((unsigned int )(iLen + 1));
#line 354
  pcBuf = (char *)tmp;
  }
#line 354
  if ((unsigned int )pcBuf == (unsigned int )((void *)0)) {
#line 355
    return ((char *)((void *)0));
  }
  {
#line 356
  __builtin_strncpy(pcBuf, (char const   *)pcStr, (unsigned int )iLen);
#line 357
  *(pcBuf + iLen) = (char )'\000';
  }
#line 358
  return (pcBuf);
}
}
#line 1 "sigfix.o"
/* #pragma merger(0,"/tmp/cil-hHL4bInf.i","-g,-O2") */
#line 54 "sigfix.c"
int enable_signaling(void) 
{ 

  {
#line 65
  return (0);
}
}
#line 69 "sigfix.c"
int delay_signaling(void) 
{ 

  {
#line 80
  return (0);
}
}
#line 1 "auth.o"
/* #pragma merger(0,"/tmp/cil-OJoYvbun.i","-g,-O2") */
#line 1 "routevector.o"
/* #pragma merger(0,"/tmp/cil-XR6RzhVn.i","-g,-O2") */
#line 83 "routevector.c"
static struct sockaddr_in *vector_ptr  =    (struct sockaddr_in *)((void *)0);
#line 134 "routevector.c"
static struct v_index *VECTORS  =    (struct v_index *)((void *)0);
#line 135 "routevector.c"
static struct v_ports *PORTS  =    (struct v_ports *)((void *)0);
#line 143
static struct v_index *initvectstruct(int num ) ;
#line 144
static struct v_ports *initportstruct(int num ) ;
#line 145
static void makeportentry(v_paddr *p , u_long entry , u_short s_sig , char *minport_in ,
                          char *maxport_in ) ;
#line 146
static void makevectentry(v_addr *p , u_long external_identity , u_long vector , u_short s_sig ) ;
#line 147
static void addportentry(char *address_in , char *minport_in , char *maxport_in ) ;
#line 148
static void addvectentry(char *external_identity_in , char *vector_in ) ;
#line 149
static void initportvectors(void) ;
#line 150
static int addr_cmp(u_long s1 , u_short s1_sig , u_long s2 , u_short s2_sig ) ;
#line 151
static int addr_smatch(u_long s1 , u_long s2 , u_short shift_in ) ;
#line 152
static v_paddr *find_passive_port_entry(u_long addr ) ;
#line 153
static v_addr *find_passive_vect_entry(u_long addr ) ;
#line 155 "routevector.c"
int routevector(void) 
{ int vect_addr_set ;
  u_long entry ;
  v_addr *vaddr ;
  register unsigned int __v ;
  register unsigned int __x ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;

  {
  {
#line 161
  vect_addr_set = 0;
#line 163
  initportvectors();
  }
#line 164
  if ((unsigned int )VECTORS != (unsigned int )((void *)0)) {
#line 165
    __x = his_addr.sin_addr.s_addr;
#line 165
    __asm__  ("rorw $8, %w0;"
              "rorl $16, %0;"
              "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 165
    entry = (unsigned long )__v;
#line 166
    if ((int )entry != -1) {
      {
#line 167
      vaddr = find_passive_vect_entry(entry);
      }
#line 168
      if ((unsigned int )vaddr != (unsigned int )((void *)0)) {
#line 169
        __x___0 = (unsigned int )vaddr->s_external_identity;
#line 169
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 169
        vect_addr.sin_addr.s_addr = __v___0;
#line 170
        vect_addr.sin_family = (unsigned short)2;
#line 171
        vect_addr_set = 1;
#line 172
        vector_ptr = & vect_addr;
      }
    }
  }
#line 183
  return (vect_addr_set);
}
}
#line 188 "routevector.c"
void checkports(void) 
{ u_long entry ;
  v_paddr *addr ;

  {
#line 193
  passive_port_min = -1;
#line 194
  passive_port_max = -1;
#line 195
  if ((unsigned int )PORTS != (unsigned int )((void *)0)) {
#line 196
    entry = (unsigned long )his_addr.sin_addr.s_addr;
#line 197
    if ((int )entry != -1) {
      {
#line 198
      addr = find_passive_port_entry(entry);
      }
#line 199
      if ((unsigned int )addr != (unsigned int )((void *)0)) {
#line 200
        passive_port_min = addr->minport;
#line 201
        passive_port_max = addr->maxport;
      }
    }
  }
#line 207
  return;
}
}
#line 211 "routevector.c"
static struct v_index *initvectstruct(int num ) 
{ int i ;
  v_addr *ptr ;
  v_addr **index___0 ;
  v_index *v ;
  register unsigned int __v ;
  register unsigned int __x ;
  in_addr_t tmp ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  in_addr_t tmp___0 ;
  v_addr **tmp___1 ;
  v_addr *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 217
  tmp___5 = malloc(sizeof(v_index ));
#line 217
  v = (v_index *)tmp___5;
  }
#line 217
  if ((unsigned int )v == (unsigned int )((v_index *)((void *)0))) {
    {
#line 218
    syslog(6, "ERROR allocating memory for index record");
#line 219
    perror_reply(421, (char *)"Local resource failure: malloc");
#line 220
    dologout(1);
    }
  } else {
    {
#line 223
    v->count = (unsigned short)0;
#line 224
    v->slots = (unsigned short)0;
#line 225
    v->index = (v_addr **)((void *)0);
#line 226
    tmp___4 = malloc(sizeof(v_addr ) * (unsigned int )num);
#line 226
    v->memory = (v_addr *)tmp___4;
    }
#line 226
    if ((unsigned int )v->memory == (unsigned int )((v_addr *)((void *)0))) {
      {
#line 227
      syslog(6, "ERROR allocating memory for port addresses");
#line 228
      perror_reply(421, (char *)"Local resource failure: malloc");
#line 229
      dologout(1);
      }
    } else {
      {
#line 232
      tmp___3 = malloc(sizeof(v_addr *) * (unsigned int )num);
#line 232
      v->index = (v_addr **)tmp___3;
      }
#line 232
      if ((unsigned int )v->index == (unsigned int )((v_addr **)((void *)0))) {
        {
#line 233
        syslog(6, "ERROR allocating memory for vector index");
#line 234
        perror_reply(421, (char *)"Local resource failure: malloc");
#line 235
        dologout(1);
        }
      } else {
#line 238
        v->slots = (unsigned short )num;
#line 239
        i = 0;
#line 239
        ptr = v->memory;
#line 239
        index___0 = v->index;
#line 239
        while (i < num) {
          {
#line 240
          tmp = inet_addr("0.0.0.0");
#line 240
          __x = tmp;
#line 240
          __asm__  ("rorw $8, %w0;"
                    "rorl $16, %0;"
                    "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 240
          ptr->s_external_identity = (unsigned long )__v;
#line 241
          tmp___0 = inet_addr("0.0.0.0");
#line 241
          __x___0 = tmp___0;
#line 241
          __asm__  ("rorw $8, %w0;"
                    "rorl $16, %0;"
                    "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 241
          ptr->s_vector = (unsigned long )__v___0;
#line 242
          ptr->s_sig = (unsigned short)0;
#line 243
          tmp___1 = index___0;
#line 243
          index___0 ++;
#line 243
          tmp___2 = ptr;
#line 243
          ptr ++;
#line 243
          *tmp___1 = tmp___2;
#line 239
          i ++;
          }
        }
      }
    }
  }
#line 248
  return (v);
}
}
#line 253 "routevector.c"
static struct v_ports *initportstruct(int num ) 
{ int i ;
  v_paddr *ptr ;
  v_ports *v ;
  register unsigned int __v ;
  register unsigned int __x ;
  in_addr_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 259
  tmp___2 = malloc(sizeof(v_ports ));
#line 259
  v = (v_ports *)tmp___2;
  }
#line 259
  if ((unsigned int )v == (unsigned int )((v_ports *)((void *)0))) {
    {
#line 260
    syslog(6, "ERROR allocating memory for index record");
#line 261
    perror_reply(421, (char *)"Local resource failure: malloc");
#line 262
    dologout(1);
    }
  } else {
    {
#line 265
    v->slots = (unsigned short)0;
#line 266
    v->count = (unsigned short)0;
#line 267
    v->index = (v_paddr **)((void *)0);
#line 268
    tmp___1 = malloc(sizeof(v_paddr ) * (unsigned int )(num + 1));
#line 268
    v->memory = (v_paddr *)tmp___1;
    }
#line 268
    if ((unsigned int )v->memory == (unsigned int )((v_paddr *)((void *)0))) {
      {
#line 269
      syslog(6, "ERROR allocating memory for port addresses");
#line 270
      perror_reply(421, (char *)"Local resource failure: malloc");
#line 271
      dologout(1);
      }
    } else {
      {
#line 274
      tmp___0 = malloc(sizeof(v_paddr *) * (unsigned int )num);
#line 274
      v->index = (v_paddr **)tmp___0;
      }
#line 274
      if ((unsigned int )v->index == (unsigned int )((v_paddr **)((void *)0))) {
        {
#line 275
        syslog(6, "ERROR allocating memory for port index");
#line 276
        perror_reply(421, (char *)"Local resource failure: malloc");
#line 277
        dologout(1);
        }
      } else {
#line 280
        v->slots = (unsigned short )num;
#line 281
        i = 0;
#line 281
        ptr = v->memory;
#line 281
        while (i < num) {
          {
#line 282
          *(v->index + i) = ptr;
#line 283
          tmp = inet_addr("0.0.0.0");
#line 283
          __x = tmp;
#line 283
          __asm__  ("rorw $8, %w0;"
                    "rorl $16, %0;"
                    "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 283
          ptr->s_address = (unsigned long )__v;
#line 284
          ptr->minport = -1;
#line 285
          ptr->maxport = -1;
#line 286
          ptr->s_sig = (unsigned short)0;
#line 281
          i ++;
#line 281
          ptr ++;
          }
        }
      }
    }
  }
#line 291
  return (v);
}
}
#line 296 "routevector.c"
static void makeportentry(v_paddr *p , u_long entry , u_short s_sig , char *minport_in ,
                          char *maxport_in ) 
{ 

  {
  {
#line 298
  p->s_address = entry;
#line 299
  p->s_sig = s_sig;
#line 300
  p->minport = atoi((char const   *)minport_in);
#line 301
  p->maxport = atoi((char const   *)maxport_in);
  }
#line 303
  if (p->maxport < p->minport) {
#line 304
    p->minport = -1;
#line 305
    p->maxport = -1;
  }
#line 307
  return;
}
}
#line 310 "routevector.c"
static void makevectentry(v_addr *p , u_long external_identity , u_long vector , u_short s_sig ) 
{ 

  {
#line 312
  p->s_external_identity = external_identity;
#line 313
  p->s_vector = vector;
#line 314
  p->s_sig = s_sig;
#line 315
  return;
}
}
#line 319 "routevector.c"
static void addportentry(char *address_in , char *minport_in , char *maxport_in ) 
{ u_long entry ;
  int cmp ;
  u_short s_sig ;
  char *s1 ;
  char *s2 ;
  char addrstr[65] ;
  register unsigned short i ;
  register unsigned short fnd ;
  int tmp ;
  v_paddr *vp ;
  v_paddr *p1 ;
  register unsigned int __v ;
  register unsigned int __x ;
  in_addr_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 327
  s_sig = (unsigned short)0;
#line 329
  if ((unsigned int )PORTS == (unsigned int )((void *)0)) {
    {
#line 330
    syslog(6, "ERROR port index addition, invalid ptr");
#line 331
    perror_reply(421, (char *)"Local resource failure: malloc");
#line 332
    dologout(1);
    }
  } else {
    {
#line 335
    tmp___1 = strlen((char const   *)address_in);
    }
#line 335
    if (tmp___1 > 64U) {
      {
#line 336
      syslog(6, "ERROR ftpaccess port entry<%s> too large", address_in);
      }
    } else {
#line 341
      i = (unsigned short)0;
#line 341
      while ((int )i < 64) {
#line 342
        addrstr[i] = (char )'\000';
#line 341
        i = (unsigned short )((int )i + 1);
      }
#line 343
      s1 = address_in;
#line 343
      s2 = addrstr;
#line 343
      while (1) {
#line 343
        if (*s1) {
#line 343
          if (! ((int )*s1 != 47)) {
#line 343
            break;
          }
        } else {
#line 343
          break;
        }
#line 344
        *s2 = *s1;
#line 343
        s1 ++;
#line 343
        s2 ++;
      }
#line 345
      *s2 = (char )'\000';
#line 346
      if ((int )*s1 == 47) {
#line 347
        s1 ++;
#line 348
        if (*s1) {
          {
#line 349
          tmp = atoi((char const   *)s1);
#line 349
          s_sig = (unsigned short )tmp;
          }
        }
      }
      {
#line 351
      tmp___0 = inet_addr((char const   *)(addrstr));
#line 351
      __x = tmp___0;
#line 351
      __asm__  ("rorw $8, %w0;"
                "rorl $16, %0;"
                "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 351
      entry = (unsigned long )__v;
      }
#line 351
      if ((int )entry == -1) {
        {
#line 352
        syslog(6, "ERROR ftpaccess port entry<%s> invalid", address_in);
        }
      } else {
#line 354
        i = (unsigned short)0;
#line 354
        fnd = (unsigned short)0;
#line 354
        while (1) {
#line 354
          if ((int )i < (int )PORTS->count) {
#line 354
            if ((int )fnd == 0) {
#line 354
              if (! (entry != 0UL)) {
#line 354
                break;
              }
            } else {
#line 354
              break;
            }
          } else {
#line 354
            break;
          }
          {
#line 355
          vp = *(PORTS->index + (int )i);
#line 356
          cmp = addr_cmp(vp->s_address, vp->s_sig, entry, s_sig);
          }
#line 357
          if (cmp == 0) {
            {
#line 358
            fnd = (unsigned short)1;
#line 359
            makeportentry(vp, entry, s_sig, minport_in, maxport_in);
            }
          } else {
#line 361
            if (cmp > 0) {
#line 363
              p1 = *(PORTS->index + (int )PORTS->count);
#line 363
              while ((unsigned int )p1 >= (unsigned int )vp) {
#line 364
                *p1 = *(p1 - 1);
#line 363
                p1 --;
              }
              {
#line 365
              fnd = (unsigned short)2;
#line 366
              makeportentry(vp, entry, s_sig, minport_in, maxport_in);
#line 367
              PORTS->count = (unsigned short )((int )PORTS->count + 1);
              }
            }
          }
#line 354
          i = (unsigned short )((int )i + 1);
        }
#line 370
        if ((int )fnd == 0) {
          {
#line 371
          makeportentry(*(PORTS->index + (int )PORTS->count), entry, s_sig, minport_in,
                        maxport_in);
#line 372
          PORTS->count = (unsigned short )((int )PORTS->count + 1);
          }
        }
#line 374
        if ((int )i == (int )PORTS->slots) {
          {
#line 375
          syslog(6, "ERROR bad slot count  for port index record");
#line 376
          perror_reply(421, (char *)"Local resource failure: malloc");
#line 377
          dologout(1);
          }
        }
      }
    }
  }
#line 382
  return;
}
}
#line 386 "routevector.c"
static void addvectentry(char *external_identity_in , char *vector_in ) 
{ u_long external_identity ;
  u_long vector ;
  int cmp ;
  u_short s_sig ;
  char *s1 ;
  char *s2 ;
  char addrstr[65] ;
  register unsigned short i ;
  register unsigned short fnd ;
  int tmp ;
  v_addr *vp ;
  v_addr *p1 ;
  register unsigned int __v ;
  register unsigned int __x ;
  in_addr_t tmp___0 ;
  register unsigned int __v___0 ;
  register unsigned int __x___0 ;
  in_addr_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
#line 394
  s_sig = (unsigned short)0;
#line 396
  if ((unsigned int )VECTORS == (unsigned int )((void *)0)) {
    {
#line 397
    syslog(6, "ERROR vector index addition, invalid ptr");
#line 398
    perror_reply(421, (char *)"Local resource failure: malloc");
#line 399
    dologout(1);
    }
  } else {
    {
#line 402
    tmp___3 = strlen((char const   *)external_identity_in);
    }
#line 402
    if (tmp___3 > 64U) {
      {
#line 403
      syslog(6, "ERROR ftpaccess passive entry <%s> to large", external_identity_in);
      }
    } else {
      {
#line 405
      tmp___2 = strlen((char const   *)vector_in);
      }
#line 405
      if (tmp___2 > 64U) {
        {
#line 406
        syslog(6, "ERROR ftpaccess vector entry<%s> to large", vector_in);
        }
      } else {
#line 411
        i = (unsigned short)0;
#line 411
        while ((int )i < 64) {
#line 412
          addrstr[i] = (char )'\000';
#line 411
          i = (unsigned short )((int )i + 1);
        }
#line 413
        s1 = vector_in;
#line 413
        s2 = addrstr;
#line 413
        while (1) {
#line 413
          if (*s1) {
#line 413
            if (! ((int )*s1 != 47)) {
#line 413
              break;
            }
          } else {
#line 413
            break;
          }
#line 414
          *s2 = *s1;
#line 413
          s1 ++;
#line 413
          s2 ++;
        }
#line 415
        *s2 = (char )'\000';
#line 416
        if ((int )*s1 == 47) {
#line 417
          s1 ++;
#line 418
          if (*s1) {
            {
#line 419
            tmp = atoi((char const   *)s1);
#line 419
            s_sig = (unsigned short )tmp;
            }
          }
        }
        {
#line 421
        tmp___1 = inet_addr((char const   *)(addrstr));
#line 421
        __x___0 = tmp___1;
#line 421
        __asm__  ("rorw $8, %w0;"
                  "rorl $16, %0;"
                  "rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 421
        vector = (unsigned long )__v___0;
        }
#line 421
        if ((int )vector == -1) {
          {
#line 422
          syslog(6, "ERROR ftpaccess vector entry<%s> invalid", vector_in);
          }
        } else {
          {
#line 424
          tmp___0 = inet_addr((char const   *)external_identity_in);
#line 424
          __x = tmp___0;
#line 424
          __asm__  ("rorw $8, %w0;"
                    "rorl $16, %0;"
                    "rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 424
          external_identity = (unsigned long )__v;
          }
#line 424
          if ((int )external_identity == -1) {
            {
#line 425
            syslog(6, "ERROR ftpaccess vector entry<%s> invalid", external_identity_in);
            }
          } else {
#line 427
            i = (unsigned short)0;
#line 427
            fnd = (unsigned short)0;
#line 427
            while (1) {
#line 427
              if ((int )i < (int )VECTORS->count) {
#line 427
                if ((int )fnd == 0) {
#line 427
                  if (! (vector != 0UL)) {
#line 427
                    break;
                  }
                } else {
#line 427
                  break;
                }
              } else {
#line 427
                break;
              }
              {
#line 428
              vp = *(VECTORS->index + (int )i);
#line 429
              cmp = addr_cmp(vp->s_vector, vp->s_sig, vector, s_sig);
              }
#line 430
              if (cmp == 0) {
                {
#line 431
                fnd = (unsigned short)1;
#line 432
                makevectentry(vp, external_identity, vector, s_sig);
                }
              } else {
#line 434
                if (cmp > 0) {
#line 436
                  p1 = *(VECTORS->index + (int )VECTORS->count);
#line 436
                  while ((unsigned int )p1 >= (unsigned int )vp) {
#line 437
                    *p1 = *(p1 - 1);
#line 436
                    p1 --;
                  }
                  {
#line 438
                  fnd = (unsigned short)2;
#line 439
                  makevectentry(vp, external_identity, vector, s_sig);
#line 440
                  VECTORS->count = (unsigned short )((int )VECTORS->count + 1);
                  }
                }
              }
#line 427
              i = (unsigned short )((int )i + 1);
            }
#line 443
            if ((int )fnd == 0) {
              {
#line 444
              makevectentry(*(VECTORS->index + (int )VECTORS->count), external_identity,
                            vector, s_sig);
#line 445
              VECTORS->count = (unsigned short )((int )VECTORS->count + 1);
              }
            }
#line 447
            if ((int )i >= (int )VECTORS->slots) {
              {
#line 448
              syslog(6, "ERROR bad slot count  for passive vectors index record");
#line 449
              perror_reply(421, (char *)"Local resource failure: malloc");
#line 450
              dologout(1);
              }
            }
          }
        }
      }
    }
  }
#line 457
  return;
}
}
#line 461 "routevector.c"
static void initportvectors(void) 
{ struct aclmember *entry ;
  int pcnt ;
  int acnt ;
  int tmp ;
  int tmp___0 ;
  struct aclmember *tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  struct aclmember *tmp___6 ;

  {
#line 463
  entry = (struct aclmember *)((void *)0);
#line 467
  pcnt = 0;
#line 468
  acnt = 0;
#line 470
  entry = (struct aclmember *)((void *)0);
#line 472
  while (1) {
    {
#line 472
    tmp___1 = getaclentry((char *)"passive", & entry);
    }
#line 472
    if (! tmp___1) {
#line 472
      break;
    }
    {
#line 473
    tmp = strcasecmp((char const   *)entry->arg[0], "ports");
    }
#line 473
    if (! tmp) {
#line 474
      if (! entry->arg[0]) {
#line 475
        continue;
      } else {
#line 474
        if (! entry->arg[1]) {
#line 475
          continue;
        } else {
#line 474
          if (! entry->arg[2]) {
#line 475
            continue;
          }
        }
      }
#line 476
      pcnt ++;
    }
    {
#line 478
    tmp___0 = strcasecmp((char const   *)entry->arg[0], "address");
    }
#line 478
    if (! tmp___0) {
#line 479
      if (! entry->arg[0]) {
#line 480
        continue;
      } else {
#line 479
        if (! entry->arg[1]) {
#line 480
          continue;
        } else {
#line 479
          if (! entry->arg[2]) {
#line 480
            continue;
          }
        }
      }
#line 481
      acnt ++;
    }
  }
#line 484
  if (pcnt > 0) {
    {
#line 484
    PORTS = initportstruct(pcnt);
    }
  } else {
#line 484
    PORTS = (struct v_ports *)((void *)0);
  }
#line 485
  if (acnt > 0) {
    {
#line 485
    VECTORS = initvectstruct(acnt);
    }
  } else {
#line 485
    VECTORS = (struct v_index *)((void *)0);
  }
#line 486
  while (1) {
    {
#line 486
    tmp___6 = getaclentry((char *)"passive", & entry);
    }
#line 486
    if (! tmp___6) {
#line 486
      break;
    }
    {
#line 487
    tmp___5 = strcasecmp((char const   *)entry->arg[0], "ports");
    }
#line 487
    if (tmp___5) {
      {
#line 489
      tmp___4 = strcasecmp((char const   *)entry->arg[0], "address");
      }
#line 489
      if (! tmp___4) {
        {
#line 490
        addvectentry(entry->arg[1], entry->arg[2]);
        }
      }
    } else {
      {
#line 488
      addportentry(entry->arg[1], entry->arg[2], entry->arg[3]);
      }
    }
  }
#line 492
  return;
}
}
#line 499 "routevector.c"
static int addr_cmp(u_long s1 , u_short s1_sig , u_long s2 , u_short s2_sig ) 
{ 

  {
#line 501
  if ((int )s1_sig > (int )s2_sig) {
#line 502
    return (-1);
  }
#line 503
  if ((int )s1_sig < (int )s2_sig) {
#line 504
    return (1);
  }
#line 505
  if (s1 < s2) {
#line 506
    return (-1);
  }
#line 507
  if (s1 > s2) {
#line 508
    return (1);
  }
#line 509
  return (0);
}
}
#line 524 "routevector.c"
static int addr_smatch(u_long s1 , u_long s2 , u_short shift_in ) 
{ u_long sh1 ;
  u_long sh2 ;
  int shift ;

  {
#line 529
  if ((int )shift_in > 0) {
#line 530
    shift = (int )(sizeof(u_long ) * 8U);
#line 531
    if (shift >= (int )shift_in) {
#line 532
      shift -= (int )shift_in;
    }
#line 533
    if (shift > 0) {
#line 534
      sh2 = (s2 >> shift) << shift;
#line 535
      sh1 = (s1 >> shift) << shift;
    } else {
#line 538
      sh2 = s2;
#line 539
      sh1 = s1;
    }
#line 541
    if (sh1 < sh2) {
#line 542
      return (-1);
    }
#line 543
    if (sh1 > sh2) {
#line 544
      return (1);
    }
  }
#line 546
  return (0);
}
}
#line 551 "routevector.c"
static v_paddr *find_passive_port_entry(u_long addr ) 
{ register int i ;
  v_paddr *p ;
  int tmp ;

  {
#line 556
  if ((unsigned int )PORTS != (unsigned int )((void *)0)) {
#line 557
    i = 0;
#line 557
    while (i < (int )PORTS->count) {
      {
#line 558
      p = *(PORTS->index + i);
#line 559
      tmp = addr_smatch(addr, p->s_address, p->s_sig);
      }
#line 559
      if (tmp == 0) {
#line 560
        return (p);
      }
#line 557
      i ++;
    }
  }
#line 562
  return ((v_paddr *)((void *)0));
}
}
#line 567 "routevector.c"
static v_addr *find_passive_vect_entry(u_long addr ) 
{ register int i ;
  v_addr *p ;
  int tmp ;

  {
#line 572
  if ((unsigned int )VECTORS != (unsigned int )((void *)0)) {
#line 573
    i = 0;
#line 573
    while (i < (int )VECTORS->count) {
      {
#line 574
      p = *(VECTORS->index + i);
#line 575
      tmp = addr_smatch(addr, p->s_vector, p->s_sig);
      }
#line 575
      if (tmp == 0) {
#line 576
        return (p);
      }
#line 573
      i ++;
    }
  }
#line 578
  return ((v_addr *)((void *)0));
}
}
#line 1 "restrict.o"
/* #pragma merger(0,"/tmp/cil-shi7RqoY.i","-g,-O2") */
#line 62 "restrict.c"
int restrict_check(char *name ) 
{ int tmp ;

  {
  {
#line 64
  tmp = test_restriction(name);
  }
#line 64
  if (! tmp) {
#line 65
    return (0);
  }
  {
#line 66
  reply(550, (char *)"Permission denied on server.  You are restricted to your account.");
  }
#line 67
  return (1);
}
}
#line 70 "restrict.c"
int test_restriction(char *name ) 
{ char rhome[4097] ;
  char rname[4097] ;
  char path[4097] ;
  char curwd[4097] ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___19 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t tmp___30 ;

  {
#line 75
  if (restricted_user == 0) {
#line 76
    return (0);
  }
  {
#line 79
  fb_realpath((char const   *)home, rhome);
#line 81
  path[0] = (char )'\000';
  }
#line 84
  if ((int )*(name + 0) != 47) {
    {
#line 90
    tmp = getcwd(curwd, 4096U);
    }
#line 90
    if ((unsigned int )tmp == (unsigned int )((char *)((void *)0))) {
#line 94
      return (1);
    }
    {
#line 97
    strcpy((char */* __restrict  */)(path), (char const   */* __restrict  */)(curwd));
#line 98
    strcat((char */* __restrict  */)(path), (char const   */* __restrict  */)"/");
    }
  }
  {
#line 102
  tmp___0 = strlen((char const   *)(path));
#line 102
  tmp___1 = strlen((char const   *)name);
  }
#line 102
  if ((tmp___0 + tmp___1) + 2U > sizeof(path)) {
#line 103
    return (1);
  }
  {
#line 106
  strcat((char */* __restrict  */)(path), (char const   */* __restrict  */)name);
#line 107
  fb_realpath((char const   *)(path), rname);
#line 108
  strcat((char */* __restrict  */)(rname), (char const   */* __restrict  */)"/");
  }
#line 110
  if (0) {
#line 110
    if (0) {
      {
#line 110
      __s1_len___0 = strlen((char const   *)(rhome));
#line 110
      __s2_len___0 = strlen((char const   *)(rname));
      }
#line 110
      if (! ((unsigned int )((void const   *)(rhome + 1)) - (unsigned int )((void const   *)(rhome)) == 1U)) {
        goto _L___2;
      } else {
#line 110
        if (__s1_len___0 >= 4U) {
          _L___2: 
#line 110
          if (! ((unsigned int )((void const   *)(rname + 1)) - (unsigned int )((void const   *)(rname)) == 1U)) {
#line 110
            tmp___29 = 1;
          } else {
#line 110
            if (__s2_len___0 >= 4U) {
#line 110
              tmp___29 = 1;
            } else {
#line 110
              tmp___29 = 0;
            }
          }
        } else {
#line 110
          tmp___29 = 0;
        }
      }
#line 110
      if (tmp___29) {
        {
#line 110
        tmp___25 = __builtin_strcmp((char const   *)(rhome), (char const   *)(rname));
        }
      } else {
        {
#line 110
        tmp___28 = __builtin_strcmp((char const   *)(rhome), (char const   *)(rname));
#line 110
        tmp___25 = tmp___28;
        }
      }
    } else {
      {
#line 110
      tmp___28 = __builtin_strcmp((char const   *)(rhome), (char const   *)(rname));
#line 110
      tmp___25 = tmp___28;
      }
    }
#line 110
    tmp___19 = tmp___25;
  } else {
    {
#line 110
    tmp___30 = strlen((char const   *)(rhome));
#line 110
    tmp___19 = strncmp((char const   *)(rhome), (char const   *)(rname), tmp___30);
    }
  }
#line 110
  if (tmp___19) {
#line 111
    return (1);
  }
#line 114
  return (0);
}
}
#line 117 "restrict.c"
int restrict_list_check(char *name ) 
{ char *beg ;
  char *copy___0 ;
  char *end ;
  int flag ;
  unsigned short const   **tmp ;
  char *tmp___9 ;
  int tmp___10 ;

  {
#line 122
  beg = name;
#line 124
  while ((int )*beg != 0) {
#line 126
    flag = 0;
#line 127
    end = beg;
#line 128
    while (1) {
#line 128
      if (*end) {
        {
#line 128
        tmp = __ctype_b_loc();
        }
#line 128
        if ((int const   )*(*tmp + (int )*end) & 8192) {
#line 128
          break;
        }
      } else {
#line 128
        break;
      }
#line 129
      end ++;
    }
#line 130
    if (! *end) {
#line 131
      flag = 1;
    }
#line 132
    if (! flag) {
#line 133
      *end = (char )'\000';
    }
    {
#line 134
    tmp___9 = __strdup((char const   *)beg);
#line 134
    copy___0 = tmp___9;
    }
#line 135
    if (! flag) {
#line 136
      *end = (char )' ';
    }
#line 138
    if (! copy___0) {
      {
#line 139
      reply(550, (char *)"Permission denied on server.  Out of memory.");
      }
#line 140
      return (1);
    }
    {
#line 144
    tmp___10 = restrict_check(copy___0);
    }
#line 144
    if (tmp___10) {
      {
#line 145
      free((void *)copy___0);
      }
#line 146
      return (1);
    }
    {
#line 148
    free((void *)copy___0);
#line 149
    beg = end;
    }
#line 150
    if (! flag) {
#line 151
      beg ++;
    }
  }
#line 155
  return (0);
}
}
#line 1 "domain.o"
/* #pragma merger(0,"/tmp/cil-bpu2Owmo.i","-g,-O2") */
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
#line 243 "/usr/include/resolv.h"
extern struct __res_state *__res_state(void)  __attribute__((__const__)) ;
#line 267
extern  __attribute__((__nothrow__)) int __res_init(void) ;
#line 271
extern  __attribute__((__nothrow__)) int __res_query(char const   * , int  , int  ,
                                                     u_char * , int  ) ;
#line 333
extern  __attribute__((__nothrow__)) int __dn_skipname(u_char const   * , u_char const   * ) ;
#line 351
extern  __attribute__((__nothrow__)) int __dn_expand(u_char const   * , u_char const   * ,
                                                     u_char const   * , char * , int  ) ;
#line 80 "domain.c"
struct t_resolver_options resolver_options[17]  = 
#line 80 "domain.c"
  {      {(char *)"debug", 2}, 
        {(char *)"aaonly", 4}, 
        {(char *)"usevc", 8}, 
        {(char *)"stayopen", 256}, 
        {(char *)"primary", 16}, 
        {(char *)"igntc", 32}, 
        {(char *)"recurse", 64}, 
        {(char *)"defnames", 128}, 
        {(char *)"dnsrch", 512}, 
        {(char *)"insecure1", 1024}, 
        {(char *)"insecure2", 2048}, 
        {(char *)"noaliases", 4096}, 
        {(char *)"use_inet6", 8192}, 
        {(char *)"rotate", 16384}, 
        {(char *)"nocheckname", 32768}, 
        {(char *)"default", 524992}, 
        {(char *)((void *)0), 0}};
#line 176 "domain.c"
int resolver_initialized  =    0;
#line 177 "domain.c"
char *remote_hostname  =    (char *)((void *)0);
#line 178 "domain.c"
char *remote_address  =    (char *)((void *)0);
#line 179 "domain.c"
int has_reverse_dns  =    0;
#line 180 "domain.c"
int has_matching_dns  =    0;
#line 184
int lookup_ip(char *ip , char **fqdn ) ;
#line 185
int check_name_for_ip(char *name , char *ip ) ;
#line 263
extern int _getshort() ;
#line 269
extern int _getlong() ;
#line 205 "domain.c"
int lookup_name(char *name , char **ip ) 
{ u_char *msg_end ;
  u_char *msg_ptr ;
  querybuf answer ;
  int rc ;
  int num_answers ;
  int num_query ;
  int q_type ;
  int q_class ;
  int q_ttl ;
  int q_len ;
  char query_name[1026] ;
  struct in_addr inaddr ;
  char *result ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 233
  rc = __res_query((char const   *)name, 1, 1, answer.qb2, (int )sizeof(querybuf ));
  }
#line 236
  if (rc < 0) {
#line 237
    return (0);
  }
#line 240
  msg_end = (u_char *)(& answer) + rc;
#line 242
  __x = (unsigned short )answer.qb1.ancount;
#line 242
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 242
  num_answers = (int )__v;
#line 243
  __x___0 = (unsigned short )answer.qb1.qdcount;
#line 243
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 243
  num_query = (int )__v___0;
#line 245
  if (num_answers < 1) {
#line 247
    return (0);
  }
#line 250
  msg_ptr = answer.qb2 + 12;
#line 253
  while (1) {
#line 253
    if (num_query > 0) {
#line 253
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 253
        break;
      }
    } else {
#line 253
      break;
    }
    {
#line 254
    tmp = __dn_skipname((u_char const   *)msg_ptr, (u_char const   *)msg_end);
#line 254
    msg_ptr += tmp + 4;
#line 253
    num_query --;
    }
  }
#line 257
  while (1) {
#line 257
    if (num_answers > 0) {
#line 257
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 257
        break;
      }
    } else {
#line 257
      break;
    }
    {
#line 259
    rc = __dn_expand((u_char const   *)(answer.qb2), (u_char const   *)msg_end, (u_char const   *)msg_ptr,
                     (char *)((void *)(query_name)), 1025);
#line 261
    msg_ptr += rc;
#line 263
    q_type = _getshort(msg_ptr);
#line 264
    msg_ptr += 2;
#line 266
    q_class = _getshort(msg_ptr);
#line 267
    msg_ptr += 2;
#line 269
    q_ttl = _getlong(msg_ptr);
#line 270
    msg_ptr += 4;
#line 272
    q_len = _getshort(msg_ptr);
#line 273
    msg_ptr += 2;
    }
#line 277
    switch (q_type) {
    case 5: 
#line 280
    msg_ptr += q_len;
#line 281
    break;
    case 1: 
    {
#line 283
    bcopy((void const   *)msg_ptr, (void *)((char *)(& inaddr)), 4U);
#line 284
    msg_ptr += q_len;
#line 285
    result = inet_ntoa(inaddr);
#line 287
    tmp___0 = strlen((char const   *)result);
#line 287
    tmp___1 = malloc(tmp___0 + 1U);
#line 287
    *ip = (char *)tmp___1;
    }
#line 288
    if ((unsigned int )*ip == (unsigned int )((void *)0)) {
#line 289
      return (0);
    }
    {
#line 290
    strcpy((char */* __restrict  */)*ip, (char const   */* __restrict  */)result);
    }
#line 291
    return (1);
    default: ;
#line 294
    return (0);
    }
#line 257
    num_answers --;
  }
#line 300
  return (0);
}
}
#line 307 "domain.c"
int lookup_ip(char *ip , char **fqdn ) 
{ u_char *msg_end ;
  u_char *msg_ptr ;
  querybuf answer ;
  int rc ;
  int num_answers ;
  int num_query ;
  int q_type ;
  int q_class ;
  int q_ttl ;
  int q_len ;
  char query_name[1026] ;
  char in_addr[1026] ;
  unsigned int a ;
  unsigned int b ;
  unsigned int c ;
  unsigned int d ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 321
  d = 0U;
#line 321
  c = d;
#line 321
  b = c;
#line 321
  a = b;
#line 322
  sscanf((char const   */* __restrict  */)ip, (char const   */* __restrict  */)"%u.%u.%u.%u",
         & a, & b, & c, & d);
#line 323
  sprintf((char */* __restrict  */)(in_addr), (char const   */* __restrict  */)"%u.%u.%u.%u.in-addr.arpa",
          d, c, b, a);
#line 334
  rc = __res_query((char const   *)(in_addr), 1, 12, answer.qb2, (int )sizeof(querybuf ));
  }
#line 337
  if (rc < 0) {
#line 338
    return (0);
  }
#line 341
  msg_end = (u_char *)(& answer) + rc;
#line 343
  __x = (unsigned short )answer.qb1.ancount;
#line 343
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 343
  num_answers = (int )__v;
#line 344
  __x___0 = (unsigned short )answer.qb1.qdcount;
#line 344
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 344
  num_query = (int )__v___0;
#line 346
  if (num_answers < 1) {
#line 348
    return (0);
  }
#line 351
  msg_ptr = answer.qb2 + 12;
#line 354
  while (1) {
#line 354
    if (num_query > 0) {
#line 354
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 354
        break;
      }
    } else {
#line 354
      break;
    }
    {
#line 355
    tmp = __dn_skipname((u_char const   *)msg_ptr, (u_char const   *)msg_end);
#line 355
    msg_ptr += tmp + 4;
#line 354
    num_query --;
    }
  }
#line 358
  while (1) {
#line 358
    if (num_answers > 0) {
#line 358
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 358
        break;
      }
    } else {
#line 358
      break;
    }
    {
#line 360
    rc = __dn_expand((u_char const   *)(answer.qb2), (u_char const   *)msg_end, (u_char const   *)msg_ptr,
                     (char *)((void *)(query_name)), 1025);
#line 363
    msg_ptr += rc;
#line 366
    q_type = _getshort(msg_ptr);
#line 367
    msg_ptr += 2;
#line 369
    q_class = _getshort(msg_ptr);
#line 370
    msg_ptr += 2;
#line 372
    q_ttl = _getlong(msg_ptr);
#line 373
    msg_ptr += 4;
#line 375
    q_len = _getshort(msg_ptr);
#line 376
    msg_ptr += 2;
    }
#line 378
    switch (q_type) {
    case 12: 
    {
#line 382
    rc = __dn_expand((u_char const   *)(answer.qb2), (u_char const   *)msg_end, (u_char const   *)msg_ptr,
                     (char *)((void *)(query_name)), 1025);
    }
#line 384
    if (rc >= 0) {
      {
#line 385
      tmp___0 = strlen((char const   *)(query_name));
#line 385
      tmp___1 = malloc(tmp___0 + 1U);
#line 385
      *fqdn = (char *)tmp___1;
      }
#line 386
      if ((unsigned int )*fqdn == (unsigned int )((void *)0)) {
#line 387
        return (0);
      }
      {
#line 389
      strcpy((char */* __restrict  */)*fqdn, (char const   */* __restrict  */)(query_name));
      }
#line 390
      return (1);
    }
#line 392
    break;
    default: 
#line 395
    msg_ptr += q_len;
    }
#line 358
    num_answers --;
  }
#line 401
  return (0);
}
}
#line 411 "domain.c"
int check_name_for_ip(char *name , char *ip ) 
{ querybuf answer ;
  u_char *msg_end ;
  u_char *msg_ptr ;
  char query_name[1026] ;
  int rc ;
  int num_answers ;
  int num_query ;
  int q_type ;
  int q_class ;
  int q_ttl ;
  int q_len ;
  struct in_addr inaddr ;
  struct in_addr qaddr ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 426
  qaddr.s_addr = inet_addr((char const   *)ip);
  }
#line 426
  if ((unsigned long )qaddr.s_addr == 4294967295UL) {
#line 427
    return (0);
  }
  {
#line 439
  rc = __res_query((char const   *)name, 1, 1, answer.qb2, (int )sizeof(querybuf ));
  }
#line 442
  if (rc < 0) {
#line 443
    return (0);
  }
#line 446
  msg_end = (u_char *)(& answer) + rc;
#line 448
  __x = (unsigned short )answer.qb1.ancount;
#line 448
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 448
  num_answers = (int )__v;
#line 449
  __x___0 = (unsigned short )answer.qb1.qdcount;
#line 449
  __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 449
  num_query = (int )__v___0;
#line 451
  if (num_answers < 1) {
#line 453
    return (0);
  }
#line 456
  msg_ptr = answer.qb2 + 12;
#line 459
  while (1) {
#line 459
    if (num_query > 0) {
#line 459
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 459
        break;
      }
    } else {
#line 459
      break;
    }
    {
#line 460
    tmp = __dn_skipname((u_char const   *)msg_ptr, (u_char const   *)msg_end);
#line 460
    msg_ptr += tmp + 4;
#line 459
    num_query --;
    }
  }
#line 463
  while (1) {
#line 463
    if (num_answers > 0) {
#line 463
      if (! ((unsigned int )msg_ptr < (unsigned int )msg_end)) {
#line 463
        break;
      }
    } else {
#line 463
      break;
    }
    {
#line 464
    rc = __dn_expand((u_char const   *)(answer.qb2), (u_char const   *)msg_end, (u_char const   *)msg_ptr,
                     (char *)((void *)(query_name)), 1025);
#line 466
    msg_ptr += rc;
#line 468
    q_type = _getshort(msg_ptr);
#line 469
    msg_ptr += 2;
#line 471
    q_class = _getshort(msg_ptr);
#line 472
    msg_ptr += 2;
#line 474
    q_ttl = _getlong(msg_ptr);
#line 475
    msg_ptr += 4;
#line 477
    q_len = _getshort(msg_ptr);
#line 478
    msg_ptr += 2;
    }
#line 482
    switch (q_type) {
    case 5: 
#line 485
    msg_ptr += q_len;
#line 486
    break;
    case 1: 
    {
#line 488
    bcopy((void const   *)msg_ptr, (void *)((char *)(& inaddr)), 4U);
#line 489
    msg_ptr += q_len;
#line 490
    tmp___0 = memcmp((void const   *)(& inaddr), (void const   *)(& qaddr), sizeof(struct in_addr ));
    }
#line 490
    if (tmp___0 == 0) {
#line 491
      return (1);
    }
#line 493
    break;
    default: ;
#line 496
    return (0);
    }
#line 463
    num_answers --;
  }
#line 503
  return (0);
}
}
#line 512 "domain.c"
int initialize_dns(struct sockaddr_in *remote_socket ) 
{ struct aclmember *entry ;
  char *temp_pointer ;
  int tmp ;
  struct __res_state *tmp___0 ;
  int arg_count ;
  int operation ;
  char *option ;
  int table_index ;
  int option_bitvalue ;
  int tmp___1 ;
  struct __res_state *tmp___2 ;
  struct __res_state *tmp___3 ;
  int tmp___4 ;
  struct aclmember *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 516
  entry = (struct aclmember *)((void *)0);
#line 519
  if (resolver_initialized) {
#line 520
    return (1);
  }
  {
#line 523
  tmp___0 = __res_state();
  }
#line 523
  if ((tmp___0->options & 1UL) == 0UL) {
    {
#line 524
    tmp = __res_init();
    }
#line 524
    if (tmp == -1) {
#line 526
      return (0);
    }
  }
#line 532
  while (1) {
    {
#line 532
    tmp___5 = getaclentry((char *)"dns", & entry);
    }
#line 532
    if (tmp___5) {
#line 532
      if (entry->arg[0]) {
#line 532
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 532
          break;
        }
      } else {
#line 532
        break;
      }
    } else {
#line 532
      break;
    }
    {
#line 534
    tmp___4 = strcasecmp((char const   *)entry->arg[0], "resolveroptions");
    }
#line 534
    if (! tmp___4) {
#line 538
      arg_count = 1;
#line 538
      while ((unsigned int )entry->arg[arg_count] != (unsigned int )((void *)0)) {
#line 539
        operation = 0;
#line 544
        if ((int )*(entry->arg[arg_count] + 0) == 45) {
#line 545
          operation = -1;
#line 546
          option = entry->arg[arg_count] + 1;
        } else {
#line 548
          if ((int )*(entry->arg[arg_count] + 0) == 43) {
#line 549
            operation = 1;
#line 550
            option = entry->arg[arg_count] + 1;
          }
        }
#line 553
        if (operation == 0) {
#line 555
          operation = 1;
#line 556
          option = entry->arg[arg_count] + 0;
        }
#line 559
        option_bitvalue = 0;
#line 562
        table_index = 0;
#line 562
        while ((unsigned int )resolver_options[table_index].token != (unsigned int )((void *)0)) {
          {
#line 564
          tmp___1 = strcasecmp((char const   *)option, (char const   *)resolver_options[table_index].token);
          }
#line 564
          if (! tmp___1) {
#line 565
            option_bitvalue = resolver_options[table_index].value;
          }
#line 562
          table_index ++;
        }
#line 570
        if (option_bitvalue == 0) {
          goto __Cont;
        }
#line 577
        if (operation < 0) {
          {
#line 579
          tmp___2 = __res_state();
#line 579
          tmp___2->options &= (unsigned long )(~ option_bitvalue);
          }
        } else {
          {
#line 582
          tmp___3 = __res_state();
#line 582
          tmp___3->options |= (unsigned long )option_bitvalue;
          }
        }
        __Cont: 
#line 538
        arg_count ++;
      }
    }
  }
  {
#line 589
  temp_pointer = inet_ntoa(remote_socket->sin_addr);
#line 590
  tmp___6 = strlen((char const   *)temp_pointer);
#line 590
  tmp___7 = malloc(tmp___6 + 1U);
#line 590
  remote_address = (char *)tmp___7;
  }
#line 591
  if ((unsigned int )remote_address == (unsigned int )((void *)0)) {
#line 593
    return (0);
  }
  {
#line 596
  strcpy((char */* __restrict  */)remote_address, (char const   */* __restrict  */)temp_pointer);
  }
#line 601
  if (0) {
    {
#line 601
    __s1_len = strlen((char const   *)remote_address);
#line 601
    __s2_len = strlen("0.0.0.0");
    }
#line 601
    if (! ((unsigned int )((void const   *)(remote_address + 1)) - (unsigned int )((void const   *)remote_address) == 1U)) {
      goto _L___0;
    } else {
#line 601
      if (__s1_len >= 4U) {
        _L___0: 
#line 601
        if (! ((unsigned int )((void const   *)("0.0.0.0" + 1)) - (unsigned int )((void const   *)"0.0.0.0") == 1U)) {
#line 601
          tmp___21 = 1;
        } else {
#line 601
          if (__s2_len >= 4U) {
#line 601
            tmp___21 = 1;
          } else {
#line 601
            tmp___21 = 0;
          }
        }
      } else {
#line 601
        tmp___21 = 0;
      }
    }
#line 601
    if (tmp___21) {
      {
#line 601
      tmp___17 = __builtin_strcmp((char const   *)remote_address, "0.0.0.0");
      }
    } else {
      {
#line 601
      tmp___20 = __builtin_strcmp((char const   *)remote_address, "0.0.0.0");
#line 601
      tmp___17 = tmp___20;
      }
    }
  } else {
    {
#line 601
    tmp___20 = __builtin_strcmp((char const   *)remote_address, "0.0.0.0");
#line 601
    tmp___17 = tmp___20;
    }
  }
#line 601
  if (tmp___17) {
    {
#line 604
    tmp___11 = lookup_ip(remote_address, & temp_pointer);
    }
#line 604
    if (tmp___11) {
      {
#line 605
      has_reverse_dns = 1;
#line 608
      tmp___8 = strlen((char const   *)temp_pointer);
#line 608
      tmp___9 = malloc(tmp___8 + 1U);
#line 608
      remote_hostname = (char *)tmp___9;
      }
#line 609
      if ((unsigned int )remote_hostname == (unsigned int )((void *)0)) {
#line 611
        return (0);
      }
      {
#line 614
      strcpy((char */* __restrict  */)remote_hostname, (char const   */* __restrict  */)temp_pointer);
#line 619
      tmp___10 = inet_ntoa(remote_socket->sin_addr);
#line 619
      has_matching_dns = check_name_for_ip(remote_hostname, tmp___10);
      }
    } else {
#line 622
      has_reverse_dns = 0;
#line 623
      has_matching_dns = 1;
    }
  } else {
#line 602
    remote_hostname = (char *)"localhost";
  }
#line 626
  resolver_initialized = 1;
#line 630
  return (1);
}
}
#line 635 "domain.c"
int check_reverse_dns(void) 
{ struct aclmember *entry ;
  int rc ;
  FILE *msg_file ;
  char linebuf[4096] ;
  char outbuf[4096] ;
  int code ;
  char *crptr ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;

  {
#line 639
  entry = (struct aclmember *)((void *)0);
#line 640
  rc = 1;
#line 643
  while (1) {
    {
#line 643
    tmp___4 = getaclentry((char *)"dns", & entry);
    }
#line 643
    if (tmp___4) {
#line 643
      if (entry->arg[0]) {
#line 643
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 643
          break;
        }
      } else {
#line 643
        break;
      }
    } else {
#line 643
      break;
    }
    {
#line 645
    tmp___3 = strcasecmp((char const   *)entry->arg[0], "refuse_no_reverse");
    }
#line 645
    if (! tmp___3) {
#line 649
      code = 530;
#line 654
      if (! has_reverse_dns) {
#line 658
        if (entry->arg[2]) {
          {
#line 658
          tmp = strcasecmp((char const   *)entry->arg[2], "override");
          }
#line 658
          if (! tmp) {
#line 660
            code = 220;
          }
        }
        {
#line 663
        msg_file = fopen((char const   */* __restrict  */)entry->arg[1], (char const   */* __restrict  */)"r");
        }
#line 664
        if ((unsigned int )msg_file != (unsigned int )((void *)0)) {
#line 665
          while (1) {
            {
#line 665
            tmp___2 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                            (FILE */* __restrict  */)msg_file);
            }
#line 665
            if (! tmp___2) {
#line 665
              break;
            }
            {
#line 666
            tmp___1 = __builtin_strchr(linebuf, '\n');
#line 666
            crptr = tmp___1;
            }
#line 666
            if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 667
              *crptr = (char )'\000';
            }
            {
#line 668
            msg_massage((char const   *)(linebuf), outbuf, sizeof(outbuf));
#line 669
            lreply(code, (char *)"%s", outbuf);
            }
          }
          {
#line 671
          fclose(msg_file);
#line 673
          lreply(code, (char *)"");
          }
#line 675
          if (code == 530) {
            {
#line 676
            reply(code, (char *)"");
#line 677
            rc = 0;
            }
          } else {
            {
#line 680
            lreply(code, (char *)"Administrative Override. Permission granted.");
#line 681
            lreply(code, (char *)"");
            }
          }
        }
      }
    }
  }
#line 688
  return (rc);
}
}
#line 696 "domain.c"
int check_matching_dns(void) 
{ struct aclmember *entry ;
  int rc ;
  FILE *msg_file ;
  char linebuf[4096] ;
  char outbuf[4096] ;
  int code ;
  char *crptr ;
  int tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct aclmember *tmp___4 ;

  {
#line 699
  entry = (struct aclmember *)((void *)0);
#line 700
  rc = 1;
#line 703
  while (1) {
    {
#line 703
    tmp___4 = getaclentry((char *)"dns", & entry);
    }
#line 703
    if (tmp___4) {
#line 703
      if (entry->arg[0]) {
#line 703
        if (! ((unsigned int )entry->arg[1] != (unsigned int )((void *)0))) {
#line 703
          break;
        }
      } else {
#line 703
        break;
      }
    } else {
#line 703
      break;
    }
    {
#line 704
    tmp___3 = strcasecmp((char const   *)entry->arg[0], "refuse_mismatch");
    }
#line 704
    if (! tmp___3) {
#line 708
      code = 530;
#line 713
      if (! has_matching_dns) {
#line 717
        if (entry->arg[2]) {
          {
#line 717
          tmp = strcasecmp((char const   *)entry->arg[2], "override");
          }
#line 717
          if (! tmp) {
#line 719
            code = 220;
          }
        }
        {
#line 722
        msg_file = fopen((char const   */* __restrict  */)entry->arg[1], (char const   */* __restrict  */)"r");
        }
#line 723
        if ((unsigned int )msg_file != (unsigned int )((void *)0)) {
#line 724
          while (1) {
            {
#line 724
            tmp___2 = fgets((char */* __restrict  */)(linebuf), (int )sizeof(linebuf),
                            (FILE */* __restrict  */)msg_file);
            }
#line 724
            if (! tmp___2) {
#line 724
              break;
            }
            {
#line 725
            tmp___1 = __builtin_strchr(linebuf, '\n');
#line 725
            crptr = tmp___1;
            }
#line 725
            if ((unsigned int )crptr != (unsigned int )((void *)0)) {
#line 726
              *crptr = (char )'\000';
            }
            {
#line 727
            msg_massage((char const   *)(linebuf), outbuf, sizeof(outbuf));
#line 728
            lreply(code, (char *)"%s", outbuf);
            }
          }
          {
#line 730
          fclose(msg_file);
#line 732
          lreply(code, (char *)"");
          }
#line 734
          if (code == 530) {
            {
#line 735
            reply(code, (char *)"");
#line 736
            rc = 0;
            }
          } else {
            {
#line 739
            lreply(code, (char *)"Administrative Override. Permission granted.");
#line 740
            lreply(code, (char *)"");
            }
          }
        }
      }
    }
  }
#line 746
  return (rc);
}
}
#line 1 "wu_fnmatch.o"
/* #pragma merger(0,"/tmp/cil-DPe6Xrax.i","-g,-O2") */
#line 44 "wu_fnmatch.c"
static char const   *rangematch(char const   *pattern , char const   *string , int flags ) 
{ char test ;
  boolean negate ;
  int tmp ;
  boolean ok ;
  int __res ;
  __int32_t const   **tmp___2 ;
  char c ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  int __res___0 ;
  __int32_t const   **tmp___7 ;
  char c2 ;
  char const   *tmp___8 ;
  int __res___1 ;
  __int32_t const   **tmp___11 ;
  char const   *tmp___12 ;

  {
#line 52
  test = (char )*string;
#line 53
  if ((int const   )*pattern == 33) {
#line 53
    tmp = 1;
  } else {
#line 53
    if ((int const   )*pattern == 94) {
#line 53
      tmp = 1;
    } else {
#line 53
      tmp = 0;
    }
  }
#line 53
  negate = tmp;
#line 54
  ok = 0;
#line 55
  if (negate) {
#line 56
    pattern ++;
  }
#line 57
  if (flags & 16) {
#line 58
    if (sizeof((unsigned char )test) > 1U) {
      {
#line 58
      __res = tolower((int )((unsigned char )test));
      }
    } else {
      {
#line 58
      tmp___2 = __ctype_tolower_loc();
#line 58
      __res = (int )*(*tmp___2 + (int )((unsigned char )test));
      }
    }
#line 58
    test = (char )__res;
  }
#line 59
  while ((int const   )*pattern != 93) {
#line 60
    tmp___3 = pattern;
#line 60
    pattern ++;
#line 60
    c = (char )*tmp___3;
#line 61
    if ((int )c == 92) {
#line 61
      if (! (flags & 2)) {
#line 62
        tmp___4 = pattern;
#line 62
        pattern ++;
#line 62
        c = (char )*tmp___4;
      }
    }
#line 63
    if ((int )c == 0) {
#line 64
      return ((char const   *)((void *)0));
    }
#line 65
    if (flags & 16) {
#line 66
      if (sizeof((unsigned char )c) > 1U) {
        {
#line 66
        __res___0 = tolower((int )((unsigned char )c));
        }
      } else {
        {
#line 66
        tmp___7 = __ctype_tolower_loc();
#line 66
        __res___0 = (int )*(*tmp___7 + (int )((unsigned char )c));
        }
      }
#line 66
      c = (char )__res___0;
    }
#line 67
    if ((int const   )*pattern == 45) {
#line 68
      c2 = (char )*(pattern + 1);
#line 69
      if ((int )c2 != 0) {
#line 69
        if ((int )c2 != 93) {
#line 71
          pattern += 2;
#line 72
          if ((int )c2 == 92) {
#line 72
            if (! (flags & 2)) {
#line 73
              tmp___8 = pattern;
#line 73
              pattern ++;
#line 73
              c2 = (char )*tmp___8;
            }
          }
#line 74
          if ((int )c2 == 0) {
#line 75
            return ((char const   *)((void *)0));
          }
#line 76
          if (flags & 16) {
#line 77
            if (sizeof((unsigned char )c2) > 1U) {
              {
#line 77
              __res___1 = tolower((int )((unsigned char )c2));
              }
            } else {
              {
#line 77
              tmp___11 = __ctype_tolower_loc();
#line 77
              __res___1 = (int )*(*tmp___11 + (int )((unsigned char )c2));
              }
            }
#line 77
            c2 = (char )__res___1;
          }
#line 79
          if ((int )c <= (int )test) {
#line 79
            if ((int )test <= (int )c2) {
#line 80
              ok = 1;
            }
          }
        } else {
          goto _L;
        }
      } else {
        _L: 
#line 82
        if ((int )c == (int )test) {
#line 83
          ok = 1;
        }
      }
    } else {
#line 85
      if ((int )c == (int )test) {
#line 86
        ok = 1;
      }
    }
  }
#line 88
  if (ok == negate) {
#line 88
    tmp___12 = (char const   *)((void *)0);
  } else {
#line 88
    tmp___12 = pattern;
  }
#line 88
  return (tmp___12);
}
}
#line 91 "wu_fnmatch.c"
int wu_fnmatch(char const   *pattern , char const   *string , int flags ) 
{ char const   *stringstart ;
  char test ;
  char c ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___3 ;
  char *tmp___5 ;
  char *tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int __res ;
  __int32_t const   **tmp___12 ;
  int __res___0 ;
  __int32_t const   **tmp___15 ;

  {
#line 93
  stringstart = string;
#line 94
  while (1) {
#line 96
    tmp = pattern;
#line 96
    pattern ++;
#line 96
    c = (char )*tmp;
#line 97
    switch ((int )c) {
    case 0: 
#line 100
    if (flags & 8) {
#line 100
      if ((int const   )*string == 47) {
#line 102
        return (0);
      }
    }
#line 111
    if (flags & 8) {
#line 111
      if ((unsigned int )string != (unsigned int )stringstart) {
#line 111
        if (flags & 1) {
#line 111
          if ((int const   )*(string - 1) == 47) {
#line 115
            return (0);
          }
        }
      }
    }
#line 117
    if ((int const   )*string == 0) {
#line 117
      tmp___0 = 0;
    } else {
#line 117
      tmp___0 = 1;
    }
#line 117
    return (tmp___0);
    case 63: 
#line 119
    if ((int const   )*string == 0) {
#line 120
      return (1);
    }
#line 121
    if ((int const   )*string == 47) {
#line 121
      if (flags & 1) {
#line 123
        return (1);
      }
    }
#line 124
    if ((int const   )*string == 46) {
#line 124
      if (flags & 4) {
#line 124
        if ((unsigned int )string == (unsigned int )stringstart) {
#line 129
          return (1);
        } else {
#line 124
          if (flags & 1) {
#line 124
            if ((int const   )*(string - 1) == 47) {
#line 129
              return (1);
            }
          }
        }
      }
    }
#line 130
    string ++;
#line 131
    break;
    case 42: 
#line 133
    c = (char )*pattern;
#line 134
    while ((int )c == 42) {
#line 135
      pattern ++;
#line 135
      c = (char )*pattern;
    }
#line 136
    if ((int const   )*string == 46) {
#line 136
      if (flags & 4) {
#line 136
        if ((unsigned int )string == (unsigned int )stringstart) {
#line 141
          return (1);
        } else {
#line 136
          if (flags & 1) {
#line 136
            if ((int const   )*(string - 1) == 47) {
#line 141
              return (1);
            }
          }
        }
      }
    }
#line 143
    if ((int )c == 0) {
#line 144
      if (flags & 1) {
#line 146
        if (flags & 8) {
#line 147
          return (0);
        }
        {
#line 149
        tmp___5 = __builtin_strchr((char *)string, '/');
        }
#line 149
        if ((unsigned int )tmp___5 == (unsigned int )((void *)0)) {
#line 149
          tmp___3 = 0;
        } else {
#line 149
          tmp___3 = 1;
        }
#line 149
        return (tmp___3);
      } else {
#line 152
        return (0);
      }
    } else {
#line 153
      if ((int )c == 47) {
#line 153
        if (flags & 1) {
          {
#line 155
          tmp___7 = __builtin_strchr((char *)string, '/');
#line 155
          string = (char const   *)tmp___7;
          }
#line 156
          if ((unsigned int )string == (unsigned int )((void *)0)) {
#line 157
            return (1);
          }
#line 158
          break;
        }
      }
    }
#line 161
    test = (char )*string;
#line 161
    while ((int )test != 0) {
      {
#line 162
      tmp___8 = wu_fnmatch(pattern, string, flags & -5);
      }
#line 162
      if (! tmp___8) {
#line 163
        return (0);
      }
#line 164
      if ((int )test == 47) {
#line 164
        if (flags & 1) {
#line 166
          break;
        }
      }
#line 161
      string ++;
#line 161
      test = (char )*string;
    }
#line 168
    return (1);
    case 91: 
#line 170
    if ((int const   )*string == 0) {
#line 171
      return (1);
    }
#line 172
    if ((int const   )*string == 47) {
#line 172
      if (flags & 1) {
#line 174
        return (1);
      }
    }
    {
#line 175
    pattern = rangematch(pattern, string, flags);
    }
#line 176
    if ((unsigned int )pattern == (unsigned int )((void *)0)) {
#line 177
      return (1);
    }
#line 178
    string ++;
#line 179
    break;
    case 92: 
#line 181
    if (! (flags & 2)) {
#line 182
      tmp___9 = pattern;
#line 182
      pattern ++;
#line 182
      c = (char )*tmp___9;
#line 183
      if ((int )c == 0) {
#line 184
        c = (char )'\\';
#line 185
        pattern --;
      }
    }
    default: ;
#line 190
    if (! ((int )c == (int )*string)) {
#line 193
      if (flags & 16) {
#line 193
        if (sizeof((unsigned char )c) > 1U) {
          {
#line 193
          __res = tolower((int )((unsigned char )c));
          }
        } else {
          {
#line 193
          tmp___12 = __ctype_tolower_loc();
#line 193
          __res = (int )*(*tmp___12 + (int )((unsigned char )c));
          }
        }
#line 193
        if (sizeof((unsigned char )*string) > 1U) {
          {
#line 193
          __res___0 = tolower((int )((unsigned char )*string));
          }
        } else {
          {
#line 193
          tmp___15 = __ctype_tolower_loc();
#line 193
          __res___0 = (int )*(*tmp___15 + (int )((unsigned char )*string));
          }
        }
#line 193
        if (! (__res == __res___0)) {
#line 196
          return (1);
        }
      } else {
#line 196
        return (1);
      }
    }
#line 197
    string ++;
#line 198
    break;
    }
  }
}
}
#line 1 "timeout.o"
/* #pragma merger(0,"/tmp/cil-5Y4k8U1S.i","-g,-O2") */
#line 36 "timeout.c"
unsigned int timeout_idle  =    900U;
#line 37 "timeout.c"
unsigned int timeout_maxidle  =    7200U;
#line 38 "timeout.c"
unsigned int timeout_data  =    1200U;
#line 39 "timeout.c"
unsigned int timeout_rfc931  =    10U;
#line 40 "timeout.c"
unsigned int timeout_accept  =    120U;
#line 41 "timeout.c"
unsigned int timeout_connect  =    120U;
#line 43 "timeout.c"
void load_timeouts(void) 
{ struct aclmember *entry ;
  unsigned long value ;
  unsigned long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  struct aclmember *tmp___6 ;

  {
#line 45
  entry = (struct aclmember *)((void *)0);
#line 46
  while (1) {
    {
#line 46
    tmp___6 = getaclentry((char *)"timeout", & entry);
    }
#line 46
    if (! tmp___6) {
#line 46
      break;
    }
#line 47
    if ((unsigned int )entry->arg[0] != (unsigned int )((void *)0)) {
#line 47
      if ((unsigned int )entry->arg[1] != (unsigned int )((void *)0)) {
        {
#line 48
        tmp = strtoul((char const   */* __restrict  */)entry->arg[1], (char **/* __restrict  */)((void *)0),
                      0);
#line 48
        value = tmp;
#line 49
        tmp___5 = strcasecmp((char const   *)entry->arg[0], "rfc931");
        }
#line 49
        if (tmp___5 == 0) {
#line 50
          timeout_rfc931 = (unsigned int )value;
        } else {
#line 51
          if (value > 0UL) {
            {
#line 52
            tmp___4 = strcasecmp((char const   *)entry->arg[0], "idle");
            }
#line 52
            if (tmp___4 == 0) {
#line 53
              timeout_idle = (unsigned int )value;
            } else {
              {
#line 54
              tmp___3 = strcasecmp((char const   *)entry->arg[0], "maxidle");
              }
#line 54
              if (tmp___3 == 0) {
#line 55
                timeout_maxidle = (unsigned int )value;
              } else {
                {
#line 56
                tmp___2 = strcasecmp((char const   *)entry->arg[0], "data");
                }
#line 56
                if (tmp___2 == 0) {
#line 57
                  timeout_data = (unsigned int )value;
                } else {
                  {
#line 58
                  tmp___1 = strcasecmp((char const   *)entry->arg[0], "accept");
                  }
#line 58
                  if (tmp___1 == 0) {
#line 59
                    timeout_accept = (unsigned int )value;
                  } else {
                    {
#line 60
                    tmp___0 = strcasecmp((char const   *)entry->arg[0], "connect");
                    }
#line 60
                    if (tmp___0 == 0) {
#line 61
                      timeout_connect = (unsigned int )value;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 64
  return;
}
}
