/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.31 from the
 * contents of if_perl.xs. Do not edit this file, edit if_perl.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "if_perl.xs"
/* vi:set ts=8 sts=4 sw=4:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 */
/*
 * if_perl.xs: Main code for Perl interface support.
 *		Mostly written by Sven Verdoolaege.
 */

#define _memory_h	/* avoid memset redeclaration */
#define IN_PERL_FILE	/* don't include if_perl.pro from prot.h */

#include "vim.h"
#include "globals.h"
#include "proto.h"

/*
 * Avoid clashes between Perl and Vim namespace.
 */
#undef MAGIC
#undef NORMAL
#undef STRLEN
#undef FF
#undef OP_DELETE

#include <EXTERN.h>
#include <perl.h>
#include <XSUB.h>

/*
 * Work around clashes between Perl and Vim namespace.	proto.h doesn't
 * include if_perl.pro and perlsfio.pro when IN_PERL_FILE is defined, because
 * we need the CV typedef.  proto.h can't be moved to after including
 * if_perl.h, because we get all sorts of name clashes then.
 */
#ifndef PROTO
# include "proto/if_perl.pro"
# include "proto/if_perlsfio.pro"
#endif

static void *perl_interp = NULL;
static void xs_init __ARGS((void));
static void VIM_init __ARGS((void));

/*
 * perl_init(): initialize perl interpreter
 * We have to call perl_parse to initialize some structures,
 * there's nothing to actually parse.
 */
    static void
perl_init()
{
    char	*bootargs[] = { "VI", NULL };
    static char *args[] = { "", "-e", "" };

    perl_interp = perl_alloc();
    perl_construct(perl_interp);
    perl_parse(perl_interp, xs_init, 3, args, 0);
    perl_call_argv("VIM::bootstrap", G_DISCARD, bootargs);
    VIM_init();
#ifdef USE_SFIO
    sfdisc(PerlIO_stdout(), sfdcnewvim());
    sfdisc(PerlIO_stderr(), sfdcnewvim());
    sfsetbuf(PerlIO_stdout(), NULL, 0);
    sfsetbuf(PerlIO_stderr(), NULL, 0);
#endif
}

/*
 * perl_end(): clean up after ourselves
 */
    void
perl_end()
{
    if (perl_interp)
    {
	perl_run(perl_interp);
	perl_destruct(perl_interp);
	perl_free(perl_interp);
    }
}

/*
 * msg_split(): send a message to the message handling routines
 * split at '\n' first though.
 */
    void
msg_split(s, attr)
    char_u	*s;
    int		attr;	/* highlighting attributes */
{
    char *next;
    char *token = (char *)s;

    while ((next = strchr(token, '\n')))
    {
	*next++ = '\0';			/* replace \n with \0 */
	msg_attr((char_u *)token, attr);
	token = next;
    }
    if (*token)
	msg_attr((char_u *)token, attr);
}

#ifndef WANT_EVAL
/*
 * This stub is needed because an "#ifdef WANT_EVAL" around Eval() doesn't work properly.
 */
    char_u *
eval_to_string(arg, nextcmd)
    char_u	*arg;
    char_u	**nextcmd;
{
    return NULL;
}
#endif

/*
 * Create a new reference to an SV pointing to the SCR structure
 * The perl_private part of the SCR structure points to the SV,
 * so there can only be one such SV for a particular SCR structure.
 * When the last reference has gone (DESTROY is called),
 * perl_private is reset; When the screen goes away before
 * all references are gone, the value of the SV is reset;
 * any subsequent use of any of those reference will produce
 * a warning. (see typemap)
 */
#define newANYrv(TYPE)						\
static SV *							\
new ## TYPE ## rv(rv, ptr)					\
    SV *rv;							\
    TYPE *ptr;							\
{								\
    sv_upgrade(rv, SVt_RV);					\
    if (!ptr->perl_private)					\
    {								\
	ptr->perl_private = newSV(0);				\
	sv_setiv(ptr->perl_private, (IV)ptr);			\
    }								\
    else							\
	SvREFCNT_inc(ptr->perl_private);			\
    SvRV(rv) = ptr->perl_private;				\
    SvROK_on(rv);						\
    return sv_bless(rv, gv_stashpv("VI" #TYPE, TRUE));		\
}

newANYrv(WIN)
newANYrv(BUF)

/*
 * perl_win_free
 *	Remove all refences to the window to be destroyed
 */
    void
perl_win_free(wp)
    WIN *wp;
{
    if (wp->perl_private)
	sv_setiv((SV *)wp->perl_private, 0);
    return;
}

    void
perl_buf_free(bp)
    BUF *bp;
{
    if (bp->perl_private)
	sv_setiv((SV *)bp->perl_private, 0);
    return;
}

#ifndef PROTO
I32 cur_val(IV iv, SV *sv);

/*
 * Handler for the magic variables $main::curwin and $main::curbuf.
 * The handler is put into the magic vtbl for these variables.
 * (This is effectively a C-level equivalent of a tied variable).
 * There is no "set" function as the variables are read-only.
 */
I32 cur_val(IV iv, SV *sv)
{
    SV *rv;
    if (iv == 0)
	rv = newWINrv(newSV(0), curwin);
    else
	rv = newBUFrv(newSV(0), curbuf);
    sv_setsv(sv, rv);
    return 0;
}
#endif /* !PROTO */

struct ufuncs cw_funcs = { cur_val, 0, 0 };
struct ufuncs cb_funcs = { cur_val, 0, 1 };

/*
 * VIM_init(): Vim-specific initialisation.
 * Make the magical main::curwin and main::curbuf variables
 */
    static void
VIM_init()
{
    static char cw[] = "main::curwin";
    static char cb[] = "main::curbuf";
    MAGIC *m;
    SV *sv;

    sv = perl_get_sv(cw, TRUE);
    sv_magic(sv, NULL, 'U', cw, strlen(cw));
    m = mg_find(sv, 'U');
    m->mg_ptr = (char *)&cw_funcs;
    SvREADONLY_on(sv);

    sv = perl_get_sv(cb, TRUE);
    sv_magic(sv, NULL, 'U', cb, strlen(cb));
    m = mg_find(sv, 'U');
    m->mg_ptr = (char *)&cb_funcs;
    SvREADONLY_on(sv);
}

    int
do_perl(eap)
    EXARG	*eap;
{
    char	*err;
    STRLEN	length;
    SV		*sv;
    dSP;

    if (!perl_interp)
    {
	perl_init();
	SPAGAIN;
    }

    ENTER;
    SAVETMPS;

    sv = newSVpv((char *)eap->arg, 0);
    perl_eval_sv(sv, G_DISCARD | G_NOARGS);
    SvREFCNT_dec(sv);

    err = SvPV(GvSV(errgv), length);

    FREETMPS;
    LEAVE;

    if (!length)
	return OK;

    msg_split((char_u *)err, highlight_attr[HLF_E]);
    return FAIL;
    
}

    static int
replace_line(line, end)
    linenr_t	*line, *end;
{
    char *str;

    if (SvOK(GvSV(defgv)))
    {
	str = SvPV(GvSV(defgv),na);
	ml_replace(*line, (char_u *)str, 1);
    }
    else
    {
	mark_adjust(*line, *line, MAXLNUM, -1);
	ml_delete((*line)--, FALSE);
	(*end)--;
    }
    CHANGED;
    return OK;
}

    int
do_perldo(eap)
    EXARG	*eap;
{
    STRLEN	length;
    SV		*sv;
    char	*str;
    linenr_t	i;
    dSP;

    if (bufempty())
	return FAIL;

    if (!perl_interp)
    {
	perl_init();
	SPAGAIN;
    }
    length = strlen((char *)eap->arg);
    sv = newSV(length + sizeof("sub VIM::perldo {")-1 + 1);
    sv_setpvn(sv, "sub VIM::perldo {", sizeof("sub VIM::perldo {")-1);
    sv_catpvn(sv, (char *)eap->arg, length);
    sv_catpvn(sv, "}", 1);
    perl_eval_sv(sv, G_DISCARD | G_NOARGS);
    SvREFCNT_dec(sv);
    str = SvPV(GvSV(errgv), length);
    if (length)
	goto err;

    if (u_save(eap->line1 - 1, eap->line2 + 1) != OK)
	return FAIL;

    ENTER;
    SAVETMPS;
    for (i = eap->line1; i <= eap->line2; i++)
    {
	sv_setpv(GvSV(defgv),(char *)ml_get(i));
	PUSHMARK(sp);
	perl_call_pv("VIM::perldo", G_SCALAR | G_EVAL);
	str = SvPV(GvSV(errgv), length);
	if (length)
	    break;
	SPAGAIN;
	if (SvTRUEx(POPs))
	{
	    if (replace_line(&i, &eap->line2) != OK)
	    {
		PUTBACK;
		break;
	    }
	}
	PUTBACK;
    }
    FREETMPS;
    LEAVE;
    adjust_cursor();
    update_screen(NOT_VALID);
    if (!length)
	return OK;

err:
    msg_split((char_u *)str, highlight_attr[HLF_E]);
    return FAIL;
}

/* Register any extra external extensions */

extern void boot_DynaLoader _((CV* cv));
extern void boot_VIM _((CV* cv));

    static void
xs_init()
{
#if 0
    dXSUB_SYS;	    /* causes an error with Perl 5.003_97 */
#endif
    char *file = __FILE__;

    newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
    newXS("VIM::bootstrap", boot_VIM, file);
}

typedef WIN *	VIWIN;
typedef BUF *	VIBUF;

#line 375 "if_perl.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 519 "if_perl.c"

XS_EUPXS(XS_VIM_Msg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_Msg)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "text, hl=NULL");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	text = (char *)SvPV_nolen(ST(0))
;
	char *	hl;
#line 373 "if_perl.xs"
    int		attr;
    int		id;

#line 537 "if_perl.c"

	if (items < 2)
	    hl = NULL;
	else {
	    hl = (char *)SvPV_nolen(ST(1))
;
	}
#line 377 "if_perl.xs"
    if (text != NULL)
    {
	attr = 0;
	if (hl != NULL)
	{
	    id = syn_name2id((char_u *)hl);
	    if (id != 0)
		attr = syn_id2attr(id);
	}
	msg_split((char_u *)text, attr);
    }
#line 557 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIM_SetOption); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_SetOption)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "line");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	line = (char *)SvPV_nolen(ST(0))
;
#line 394 "if_perl.xs"
    if (line != NULL)
	do_set((char_u *)line);
    update_screen(NOT_VALID);
#line 579 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIM_DoCommand); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_DoCommand)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "line");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	line = (char *)SvPV_nolen(ST(0))
;
#line 403 "if_perl.xs"
    if (line != NULL)
	do_cmdline((char_u *)line, NULL, NULL, DOCMD_VERBOSE + DOCMD_NOWAIT);
#line 600 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIM_Eval); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_Eval)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "str");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	char *	str = (char *)SvPV_nolen(ST(0))
;
#line 411 "if_perl.xs"
	char_u *value;
#line 620 "if_perl.c"
#line 413 "if_perl.xs"
	value = eval_to_string((char_u *)str, (char_u**)0);
	if (value == NULL)
	{
	    XPUSHs(sv_2mortal(newSViv(0)));
	    XPUSHs(sv_2mortal(newSVpv("", 0)));
	}
	else
	{
	    XPUSHs(sv_2mortal(newSViv(1)));
	    XPUSHs(sv_2mortal(newSVpv((char *)value, 0)));
	    vim_free(value);
	}
#line 634 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIM_Buffers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_Buffers)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 430 "if_perl.xs"
    BUF *vimbuf;
    int i, b;

#line 653 "if_perl.c"
#line 434 "if_perl.xs"
    if (items == 0)
    {
	if (GIMME == G_SCALAR)
	{
	    i = 0;
	    for (vimbuf = firstbuf; vimbuf; vimbuf = vimbuf->b_next)
		++i;

	    XPUSHs(sv_2mortal(newSViv(i)));
	}
	else
	{
	    for (vimbuf = firstbuf; vimbuf; vimbuf = vimbuf->b_next)
		XPUSHs(newBUFrv(newSV(0), vimbuf));
	}
    }
    else
    {
	for (i = 0; i < items; i++)
	{
	    SV *sv = ST(i);
	    if (SvIOK(sv))
		b = SvIV(ST(i));
	    else
	    {
		char_u *pat;
		int len;
		pat = (char_u *)SvPV(sv, len);
		++emsg_off;
		b = buflist_findpat(pat, pat+len);
		--emsg_off;
	    }

	    if (b >= 0)
	    {
		vimbuf = buflist_findnr(b);
		if (vimbuf)
		    XPUSHs(newBUFrv(newSV(0), vimbuf));
	    }
	}
    }
#line 696 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIM_Windows); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIM_Windows)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 480 "if_perl.xs"
    WIN *vimwin;
    int i, w;

#line 715 "if_perl.c"
#line 484 "if_perl.xs"
    if (items == 0)
    {
	if (GIMME == G_SCALAR)
	    XPUSHs(sv_2mortal(newSViv(win_count())));
	else
	{
	    for (vimwin = firstwin; vimwin != NULL; vimwin = vimwin->w_next)
		XPUSHs(newWINrv(newSV(0), vimwin));
	}
    }
    else
    {
	for (i = 0; i < items; i++)
	{
	    w = SvIV(ST(i));
	    vimwin = win_goto_nr(w);
	    if (vimwin)
		XPUSHs(newWINrv(newSV(0), vimwin));
	}
    }
#line 737 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIWIN_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIWIN_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	VIWIN	win;

	if (sv_isa(ST(0), "VIWIN")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    win = (VIWIN) tmp;
	    if (!tmp)
		croak("VIWIN no longer exists");
	}
	else
	    croak("win is not of type VIWIN")
;
#line 512 "if_perl.xs"
    if (win_valid(win))
	win->perl_private = 0;
#line 765 "if_perl.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_VIWIN_Buffer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIWIN_Buffer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "win");
    {
	VIWIN	win;
	SV *	RETVAL;

	if (sv_isa(ST(0), "VIWIN")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    win = (VIWIN) tmp;
	    if (!tmp)
		croak("VIWIN no longer exists");
	}
	else
	    croak("win is not of type VIWIN")
;
#line 520 "if_perl.xs"
    if (!win_valid(win))
	win = curwin;
    RETVAL = newBUFrv(newSV(0), win->w_buffer);
#line 794 "if_perl.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_VIWIN_SetHeight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIWIN_SetHeight)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "win, height");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIWIN	win;
	int	height = (int)SvIV(ST(1))
;
#line 532 "if_perl.xs"
    WIN *savewin;

#line 817 "if_perl.c"

	if (sv_isa(ST(0), "VIWIN")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    win = (VIWIN) tmp;
	    if (!tmp)
		croak("VIWIN no longer exists");
	}
	else
	    croak("win is not of type VIWIN")
;
#line 535 "if_perl.xs"
    if (!win_valid(win))
	win = curwin;
    savewin = curwin;
    curwin = win;
    win_setheight(height);
    curwin = savewin;
#line 835 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIWIN_Cursor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIWIN_Cursor)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "win, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIWIN	win;

	if (sv_isa(ST(0), "VIWIN")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    win = (VIWIN) tmp;
	    if (!tmp)
		croak("VIWIN no longer exists");
	}
	else
	    croak("win is not of type VIWIN")
;
#line 547 "if_perl.xs"
    if(items == 1)
    {
      EXTEND(sp, 2);
      if (!win_valid(win))
	  win = curwin;
      PUSHs(sv_2mortal(newSViv(win->w_cursor.lnum)));
      PUSHs(sv_2mortal(newSViv(win->w_cursor.col)));
    }
    else if(items == 3)
    {
      int lnum, col;

      if (!win_valid(win))
	  win = curwin;
      lnum = SvIV(ST(1));
      col = SvIV(ST(2));
      win->w_cursor.lnum = lnum;
      win->w_cursor.col = col;
      adjust_cursor();		    /* put cursor on an existing line */
      update_screen(NOT_VALID);
    }
#line 884 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vimbuf");
    {
	VIBUF	vimbuf;

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 576 "if_perl.xs"
    if (buf_valid(vimbuf))
	vimbuf->perl_private = 0;
#line 912 "if_perl.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_VIBUF_Name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vimbuf");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 584 "if_perl.xs"
    if (!buf_valid(vimbuf))
	vimbuf = curbuf;
    /* No file name returns an empty string */
    if (vimbuf->b_fname == NULL)
	XPUSHs(sv_2mortal(newSVpv("", 0)));
    else
	XPUSHs(sv_2mortal(newSVpv((char *)vimbuf->b_fname, 0)));
#line 946 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_Count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "vimbuf");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 597 "if_perl.xs"
    if (!buf_valid(vimbuf))
	vimbuf = curbuf;
    XPUSHs(sv_2mortal(newSViv(vimbuf->b_ml.ml_line_count)));
#line 977 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_Get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Get)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "vimbuf, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;
#line 606 "if_perl.xs"
    char_u *line;
    int i;
    long lnum;
#line 998 "if_perl.c"

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 610 "if_perl.xs"
    if (buf_valid(vimbuf))
    {
	for (i = 1; i < items; i++)
	{
	    lnum = SvIV(ST(i));
	    if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)
	    {
		line = ml_get_buf(vimbuf, lnum, FALSE);
		XPUSHs(sv_2mortal(newSVpv((char *)line, 0)));
	    }
	}
    }
#line 1022 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_Set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Set)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "vimbuf, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;
#line 628 "if_perl.xs"
    int i;
    long lnum;
    char *line;
    BUF *savebuf;
#line 1044 "if_perl.c"

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 633 "if_perl.xs"
    if (buf_valid(vimbuf))
    {
	if (items < 3)
	    croak("Usage: VIBUF::Set(vimbuf, lnum, @lines)");

	lnum = SvIV(ST(1));
	for(i=2; i<items; i++, lnum++)
	{
	    line = SvPV(ST(i),na);
	    if(lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
	    {
		savebuf = curbuf;
		curbuf = vimbuf;
		if (u_savesub(lnum) == OK)
		{
		    ml_replace(lnum, (char_u *)line, TRUE);
		    CHANGED;
		}
		curbuf = savebuf;
		update_curbuf(NOT_VALID);
	    }
	}
    }
#line 1079 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_Delete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Delete)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "vimbuf, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;
#line 662 "if_perl.xs"
    long i, lnum = 0, count = 0;
    BUF *savebuf;
#line 1099 "if_perl.c"

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 665 "if_perl.xs"
    if (buf_valid(vimbuf))
    {
	if (items == 2)
	{
	    lnum = SvIV(ST(1));
	    count = 1;
	}
	else if (items == 3)
	{
	    lnum = SvIV(ST(1));
	    count = 1 + SvIV(ST(2)) - lnum;
	    if(count == 0)
		count = 1;
	    if(count < 0)
	    {
		lnum -= count;
		count = -count;
	    }
	}
	if (items >= 2)
	{
	    for (i=0; i<count; i++)
	    {
		if (lnum > 0 && lnum <= vimbuf->b_ml.ml_line_count)
		{
		    savebuf = curbuf;
		    curbuf = vimbuf;
		    if (u_savedel(lnum, 1) == OK)
		    {
			mark_adjust(lnum, lnum, MAXLNUM, -1);
			ml_delete(lnum, 0);
			CHANGED;
		    }
		    curbuf = savebuf;
		    update_curbuf(NOT_VALID);
		}
	    }
	}
    }
#line 1150 "if_perl.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_VIBUF_Append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_VIBUF_Append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "vimbuf, ...");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	VIBUF	vimbuf;
#line 710 "if_perl.xs"
    int i;
    long lnum;
    char *line;
    BUF *savebuf;
#line 1172 "if_perl.c"

	if (sv_isa(ST(0), "VIBUF")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    vimbuf = (VIBUF) tmp;
	    if (!tmp)
		croak("VIBUF no longer exists");
	}
	else
	    croak("vimbuf is not of type VIBUF")
;
#line 715 "if_perl.xs"
    if (buf_valid(vimbuf))
    {
	if (items < 3)
	    croak("Usage: VIBUF::Append(vimbuf, lnum, @lines)");

	lnum = SvIV(ST(1));
	for(i=2; i<items; i++, lnum++)
	{
	    line = SvPV(ST(i),na);
	    if(lnum >= 0 && lnum <= vimbuf->b_ml.ml_line_count && line != NULL)
	    {
		savebuf = curbuf;
		curbuf = vimbuf;
		if (u_inssub(lnum + 1) == OK)
		{
		    mark_adjust(lnum + 1, MAXLNUM, 1L, 0L);
		    ml_append(lnum, (char_u *)line, (colnr_t)0, FALSE);
		    CHANGED;
		}
		curbuf = savebuf;
		update_curbuf(NOT_VALID);
	    }
	}
    }
#line 1208 "if_perl.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_VIM); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_VIM)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("VIM::Msg", XS_VIM_Msg, file, "$;$");
        (void)newXSproto_portable("VIM::SetOption", XS_VIM_SetOption, file, "$");
        (void)newXSproto_portable("VIM::DoCommand", XS_VIM_DoCommand, file, "$");
        (void)newXSproto_portable("VIM::Eval", XS_VIM_Eval, file, "$");
        (void)newXSproto_portable("VIM::Buffers", XS_VIM_Buffers, file, ";@");
        (void)newXSproto_portable("VIM::Windows", XS_VIM_Windows, file, ";@");
        (void)newXSproto_portable("VIWIN::DESTROY", XS_VIWIN_DESTROY, file, "$");
        (void)newXSproto_portable("VIWIN::Buffer", XS_VIWIN_Buffer, file, "$");
        (void)newXSproto_portable("VIWIN::SetHeight", XS_VIWIN_SetHeight, file, "$$");
        (void)newXSproto_portable("VIWIN::Cursor", XS_VIWIN_Cursor, file, "$;@");
        (void)newXSproto_portable("VIBUF::DESTROY", XS_VIBUF_DESTROY, file, "$");
        (void)newXSproto_portable("VIBUF::Name", XS_VIBUF_Name, file, "$");
        (void)newXSproto_portable("VIBUF::Count", XS_VIBUF_Count, file, "$");
        (void)newXSproto_portable("VIBUF::Get", XS_VIBUF_Get, file, "$;@");
        (void)newXSproto_portable("VIBUF::Set", XS_VIBUF_Set, file, "$;@");
        (void)newXSproto_portable("VIBUF::Delete", XS_VIBUF_Delete, file, "$;@");
        (void)newXSproto_portable("VIBUF::Append", XS_VIBUF_Append, file, "$;@");
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

