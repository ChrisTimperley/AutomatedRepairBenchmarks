#!/bin/bash
#
# Generates a set of expected outputs for the problem in the given directory
# across its test suite (i.e. an oracle is produced).
#
# Usage:
# generate-oracle <path_to_exe> <program-version>
EXECUTABLE=$1
PROGRAM_VER=$2

# Generate a list of test commands and save to "test.commands"
mts . ${EXECUTABLE} ${UNIVERSE_FILE} R test.sh NULL NULL &&\
  grep "^${EXECUTABLE}" test.sh |\
  sed "s# > \./outputs/.*##g; s#\.\./inputs/#inputs/#g" > test.commands &&\
  rm test.sh

#&&\
#  grep "^${EXECUTABLE}" | sponge test.sh &&\ 
#  sed -i "s#> ../outputs.*##g" test.sh && \
#  cat test.sh &&\
#  (./test.sh; exit 0) &&\
#  mkdir ../oracle &&\
#  mv ../outputs/* ../oracle
#&&\
  #rm test.sh


#  tail -n +11 test.sh | grep "^${EXECUTABLE}" |\
#  tee | sed 's#../inputs/#inputs/#g; s#> ./outputs/.*$##g' > test.commands &&\
#  rm test.sh

# Count the number of tests
num_tests=$(wc -l < test.commands)
#
## Create the oracle directory
mkdir oracle

## Execute each of the tests and save the output to oracle/t*
for (( i = 1; i<${num_tests}; i++ )); do
  cmd=$(sed "${i}q;d" test.commands)
  echo "$cmd"
  $cmd &> "oracle/t${i}"
done
exit 0
