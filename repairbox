#!/usr/bin/env python
#
# TODO: Implement a Resource class
#
import os
import yaml
import subprocess
import argparse
import time
import json
from tabulate import tabulate

DEVNULL = open(os.devnull, 'w')

def error(msg):
    print("Error: {}".format(msg))
    exit(1)

"""
Determines which version of a given resource is installed (via its tag)
"""
def get_image_version(tag):
    tag = "squareslab/repairbox:{}".format(tag)
    try:
        cmd = "docker inspect {}".format(tag)
        data = json.loads(subprocess.check_output(cmd, stderr=DEVNULL, shell=True))
        version = data[0]['Config']["Labels"]["RBOX_IMAGE_VERSION"]
        return Version.from_string(version)
    except KeyError:
        error("failed to find `RBOX_IMAGE_VERSION` label for image: {}".format(tag))
    except subprocess.CalledProcessError as e:
        return None


"""
Attempts to push a container image with a given tag (suffix) to DockerHub
"""
def dockerpush(tag):
    tag = "squareslab/repairbox:{}".format(tag)
    cmd = "docker push {}".format(tag)
    try:
        subprocess.check_call(cmd, shell=True)
    except subprocess.CalledProcessError as e:
        exit("failed to push container image: {}".format(tag))


"""
Attempts to launch an ephemeral container using a given RepairBox image
"""
def dockerrun(tag):
    tag = "squareslab/repairbox:{}".format(tag)
    cmd = "docker run --rm --log-driver none -it {}".format(tag)
    p = subprocess.Popen(cmd, shell=True)
    p.communicate()


"""
Builds a docker container image using a given Dockerfile, tag, and set of
build-time arguments

@param  fn      The Dockerfile for this container image
@param  tag     The tag for container image
@param  version The version of this container image
@param  parent  The tag for the parent container image, if any
@param  args    An optional dict of build-time arguments
"""
def dockerbuild(fn, tag, version, parent=None, args={}):

    # we actually create a clone of the original Dockerfile, with a few
    # nifty changes
    d = os.path.dirname(fn)
    contents = []
    with open(fn, "r") as f:
        contents = [line.rstrip('\n') for line in f]

        # inject a FROM command, if relevant
        if not parent is None:
            contents = [l for l in contents if not l.startswith('FROM ')]
            contents.insert(0, "FROM squareslab/repairbox:{}".format(parent))

        # inject a LABEL command
        contents.append("LABEL RBOX_IMAGE_VERSION={}".format(str(version)))

    # we then write the modified Dockerfile to the directory of the original
    # Dockerfile
    tmp_fn = os.path.join(d, ".Dockerfile")
    with open(tmp_fn, "w") as f:
        f.write("\n".join(contents)) 

    tag = "squareslab/repairbox:{}".format(tag)
    args = ["--build-arg {}='{}'".format(k,v) for (k,v) in args.items()]
    args = ' '.join(args)
    cmd = "docker build -f {} {} -t {} {}".format(tmp_fn, args, tag, d)
    crashfile = "{}.rbox.crash".format(int(time.time()))

    try:
        out = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True)
        status = out.splitlines()[-1].startswith('Successfully built ')
    except subprocess.CalledProcessError as e:
        # save crash log
        with open(crashfile, "w") as cf:
            cf.write("Attempting to build image: {}\n".format(tag))
            cf.write("Command: {}\n".format(cmd))
            cf.write(e.output)
        status = False
    finally:
        os.remove(tmp_fn)

    if not status:
        print("Failed to build image: {}".format(tag))
        print("Saved error log to: {}".format(crashfile))
        exit(1)
 

"""
Represents a version of a particular resource
"""
class Version(object):
    @staticmethod
    def from_string(s):
        parts = [int(k) for k in s.split('.')]
        parent = None
        version = None
        for part in parts:
            parent = version = Version(part, parent)
        return version

    def __init__(self, num, parent=None):
        assert(type(num) is int)
        assert(num >= 0)
        self.__num = num
        self.__parent = parent

    def suffix(self):
        return self.__num
    def prefix(self):
        return self.__parent
    
    def __str__(self):
        s = "{}.".format(str(self.__parent)) if self.__parent else ""
        s += str(self.__num)
        return s

    def __eq__(self, other):
        return (not other is None) \
            and self.__num == other.suffix() \
            and self.__parent == other.prefix()


"""
All datasets must sit on top of a base image. Ideally, all bug scenarios should
only use one base image, but there are cases where different base images may
be needed (e.g., 32-bit containers).
"""
class BaseImage(object):
    @staticmethod
    def load(fn):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                version_latest = Version(data['version'])
                return BaseImage(fn, data['base'], data['dockerfile'], version_latest)
            except yaml.YAMLError as exc:
                raise Exception("Failed to load base image: {}".format(fn))

    def __init__(self, location, name, dockerfile, version_latest):
        self.location = location
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.__version_latest = version_latest

        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for base image: {}".format(name)

    def tag(self):
        return "{}".format(self.name)

    def version_latest(self):
        return self.__version_latest

    def version_installed(self):
        try:
            return self.__version_installed
        except AttributeError:
            self.__version_installed = get_image_version(self.tag())
            return self.__version_installed

    def is_built(self):
        return self.version_latest() == self.version_installed()

    def build(self):
        if self.is_built():
            return
        print("building base image: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag(), self.__version_latest)
        self.__version_installed = self.__version_latest

class Dataset(object):
    @staticmethod
    def load(fn, bases):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                base = data['base']
                base = bases[base]
                version_latest = Version(data['version'], base.version_latest())
                return Dataset(fn, data['dataset'], base, data['dockerfile'], version_latest)
            except yaml.YAMLError as exc:
                raise Exception("Failed to load dataset: {}".format(fn))

    def __init__(self, location, name, base, dockerfile, version_latest):
        self.location = location
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.base = base
        self.__version_latest = version_latest

        assert not base is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for dataset: {}".format(name)

    def tag(self):
        return "{}-base".format(self.name)

    def version_latest(self):
        return self.__version_latest

    def version_installed(self):
        try:
            return self.__version_installed
        except AttributeError:
            self.__version_installed = get_image_version(self.tag())
            return self.__version_installed

    def is_built(self):
        return self.version_latest() == self.version_installed()

    def build(self):
        if self.is_built():
            return
        self.base.build()
        print("building dataset: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag(), self.__version_latest, self.base.tag())
        self.__version_installed = self.__version_latest


"""
All programs must belong to a dataset.
"""
class Program(object):
    @staticmethod
    def find(dataset, program, database):
        identifier = "{}:{}".format(dataset, program)
        return database[identifier]

    @staticmethod
    def load(fn, datasets):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                dsname = data['dataset']
                dataset = datasets[dsname]
                assert not dataset is None, "no dataset found: {}".format(dsname)

                version_latest = Version(data['version'], dataset.version_latest())
                return Program(fn, data['program'], dataset, data['dockerfile'], version_latest)
            except yaml.YAMLError as exc:
                raise Exception("Failed to load program: {}".format(fn))

    def __init__(self, location, name, dataset, dockerfile, version_latest):
        self.location = location
        self.dataset = dataset
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.__version_latest = version_latest

        assert not self.__version_latest is None
        assert not dataset is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for program: {}".format(name)

    def identifier(self):
        return "{}:{}".format(self.dataset.name, self.name)

    def tag(self):
        return "{}-{}-base".format(self.dataset.name, self.name)

    def version_latest(self):
        return self.__version_latest

    def version_installed(self):
        try:
            return self.__version_installed
        except AttributeError:
            self.__version_installed = get_image_version(self.tag())
            return self.__version_installed

    def is_built(self):
        return self.version_latest() == self.version_installed()

    def build(self):
        if self.is_built():
            return
        self.dataset.build()
        print("building program: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag(), self.__version_latest, self.dataset.tag())
        self.__version_installed = self.__version_latest


"""
All bugs must belong to a dataset, but they need not belong to a program.
"""
class Bug(object):
    @staticmethod
    def load(fn, programs, datasets):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)

                # find the dataset to which the bug belongs
                dsname = data['dataset']
                dataset = datasets[dsname]
                assert not dataset is None, "no dataset found: {}".format(dsname)

                # find the program to which the bug belongs, if any
                if 'program' in data:
                    program = Program.find(dsname, data['program'], programs)
                else:
                    program = None

                buildargs = data.get('build-arguments', [])

                return Bug(fn, data['bug'], dataset, program, data['dockerfile'], buildargs, data['version'])

            except yaml.YAMLError as exc:
                print(exc)
                raise Exception("Failed to load bug: {}".format(fn))

    def __init__(self, location, name, dataset, program, dockerfile, buildargs, version_suffix):
        self.location = location
        self.dataset = dataset
        self.program = program
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.buildargs = buildargs
        self.name = name

        parent = program if program else dataset
        self.__version_latest = Version(version_suffix, parent.version_latest())

        assert not dataset is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for bug: {}".format(name)

    def identifier(self):
        if self.program:
            return "{}:{}".format(self.program.identifier(), self.name)
        else:
            return "{}:{}".format(self.dataset.name, self.name)

    def tag(self):
        if self.program:
            return "{}-{}-{}".format(self.dataset.name, self.program.name, self.name)
        return "{}-{}".format(self.dataset.name, self.name)

    def version_latest(self):
        return self.__version_latest

    def version_installed(self):
        try:
            return self.__version_installed
        except AttributeError:
            self.__version_installed = get_image_version(self.tag())
            return self.__version_installed

    def is_built(self):
        return self.version_latest() == self.version_installed()

    """
    Constructs the Docker container for this bug, and if necessary, its
    dependencies
    """
    def build(self):
        if self.is_built():
            return

        if self.program:
            parent = self.program
            self.program.build()
        elif self.dataset:
            parent = self.dataset
            self.dataset.build()

        print("building bug: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag(), self.__version_latest, parent.tag(), self.buildargs)
        self.__version_installed = self.__version_latest

    """
    Attempts to upload the container image for this bug to DockerHub
    """
    def upload(self):
        assert(self.built)
        print("uploading bug: {}".format(self.name))
        dockerpush(self.tag())

    """
    Attempts to download the container image for this bug to DockerHub
    """
    def download(self):
        print("downloading bug: {}".format(self.name))
        self.built = True

    """
    Launches the associated container for this bug
    """
    def launch(self):
        assert(self.built)
        print("launching bug: {}".format(self.name))
        dockerrun(self.tag())


class RepairBox(object):

    """
    Constructs a new RepairBox interface
    """
    def __init__(self, location=os.path.dirname(os.path.realpath(__file__))):
        self.location = location
        
        # find all bases, datasets, programs and bugs
        self.bases = []
        self.datasets = []
        self.programs = []
        self.bugs = []

        for (root, dirs, files) in os.walk(location):
            self.bases += \
                [os.path.join(root, f) for f in files if f.endswith(".base.yaml")]
            self.datasets += \
                [os.path.join(root, f) for f in files if f.endswith(".dataset.yaml")]
            self.programs += \
                [os.path.join(root, f) for f in files if f.endswith(".program.yaml")]
            self.bugs += \
                [os.path.join(root, f) for f in files if f.endswith(".bug.yaml")]

        # parse and type check manifests
        self.bases = [BaseImage.load(fn) for fn in self.bases]
        self.bases = {base.name: base for base in self.bases}
        self.datasets = [Dataset.load(fn, self.bases) for fn in self.datasets]
        self.datasets = {ds.name: ds for ds in self.datasets}
        self.programs = [Program.load(fn, self.datasets) for fn in self.programs]
        self.programs = {p.identifier(): p for p in self.programs}
        self.bugs = [Bug.load(fn, self.programs, self.datasets) for fn in self.bugs]
        self.bugs = {bug.identifier(): bug for bug in self.bugs}

    """
    Gets a list of all bugs belonging to a given resource identifier
    """
    def get(self, identifier):
        parts = len(identifier.split(':'))

        if identifier == 'all':
            return [b for b in self.bugs] # avoid perturbing original list

        elif parts == 3 or (parts == 2 and identifier in self.bugs):
            if not identifier in self.bugs:
                error("failed to find bug: {}".format(identifier))
            return [self.bugs[identifier]]

        elif parts == 2:
            if not identifier in self.programs:
                error("failed to find program: {}".format(identifier))
            program = self.programs[identifier]
            return [bug for bug in self.bugs.values() if bug.program == program]

        elif parts == 1:
            if not identifier in self.datasets:
                error("failed to find dataset: {}".format(identifier))
            dataset = self.datasets[identifier]
            return [bug for bug in self.bugs.values() if bug.dataset == dataset]

        else:
            error("illegal resource identifier")

    """
    Prints a list of all the bug scenarios within RepairBox, sorted alphabetically
    """
    def list(self):
        hdrs = ["Bug", "Latest", "Installed", "Remote"]
        tbl = []
        for bug in sorted(self.bugs.keys()):
            bug = self.bugs[bug]
            vlatest = bug.version_latest()
            vinstalled = bug.version_installed()
            tbl.append([bug.identifier(), str(vlatest), str(vinstalled), "???"])
        print(tabulate(tbl, hdrs))

    """
    Builds all bug images belonging to a given resource identifier
    """
    def build(self, identifier):
        for bug in self.get(identifier):
            bug.build()

    """
    Uploads all bug images belonging to a given resource identifier
    """
    def upload(self, identifier):
        for bug in self.get(identifier):
            bug.build()
            bug.upload()

    """
    Downloads all bug images belonging to a given resource identifier
    """
    def download(self, identifier):
        for bug in self.get(identifier):
            bug.download()

    """
    Launches a named repair box
    """
    def launch(self, name):
        if not name in self.bugs:
            error("failed to locate bug with identifier: {}".format(name))
        bug = self.bugs[name]
        bug.build()
        bug.launch()


if __name__ == "__main__":
    rbox = RepairBox()

    parser = argparse.ArgumentParser()
    subparsers = parser.add_subparsers()
    parser.add_argument('--version', action='version', version='0.0.1')

    # action: build
    build_parser = subparsers.add_parser('build')
    build_parser.add_argument('identifier',
                            help='identifier of the resource whose boxes should be built')
    build_parser.set_defaults(func=lambda args: rbox.build(args.identifier))

    # action: upload
    upload_parser = subparsers.add_parser('upload')
    upload_parser.add_argument('identifier',
                            help='identifier of the resource whose boxes should be uploaded')
    upload_parser.set_defaults(func=lambda args: rbox.upload(args.identifier))

    # action: download
    download_parser = subparsers.add_parser('download')
    download_parser.add_argument('identifier',
                            help='identifier of the resource whose boxes should be downloaded')
    download_parser.set_defaults(func=lambda args: rbox.download(args.identifier))

    # action: list
    list_parser = subparsers.add_parser('list')
    list_parser.set_defaults(func=lambda args: rbox.list())

    # action: launch
    launch_parser = subparsers.add_parser('launch')
    launch_parser.add_argument('bug',
                            help='identifier for the bug whose container should be launched')
    launch_parser.set_defaults(func=lambda args: rbox.launch(args.bug))

    args = parser.parse_args()
    if 'func' in vars(args):
        args.func(args)
