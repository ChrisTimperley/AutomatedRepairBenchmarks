#!/usr/bin/env python
import os
import yaml
import subprocess

def error(msg):
    print("Error: {}".format(msg))
    exit(1)

def dockerbuild(f, tag, args={}):
    d = os.path.dirname(f)
    tag = "squareslab/repairbox:{}".format(tag)
    args = ["--build-arg {}='{}'".format(k,v) for (k,v) in args.items()]
    args = ' '.join(args)
    cmd = "docker build {} -f {} -t {} {}".format(args, f, tag, d)
    
    out = subprocess.check_output(cmd, shell=True)
    status = out.splitlines()[-1].startswith('Successfully built ')
    assert status

"""
All datasets must sit on top of a base image. Ideally, all bug scenarios should
only use one base image, but there are cases where different base images may
be needed (e.g., 32-bit containers).
"""
class BaseImage(object):
    @staticmethod
    def load(fn):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                return BaseImage(fn, data['base'], data['dockerfile'])
            except yaml.YAMLError as exc:
                raise Exception("Failed to load base image: {}".format(fn))

    def __init__(self, location, name, dockerfile):
        self.location = location
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.built = False

        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for base image: {}".format(name)

    def tag(self):
        return "{}".format(self.name)

    def build(self):
        if self.built:
            return
        print("building base image: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag())
        self.built = True


class Dataset(object):
    @staticmethod
    def load(fn, bases):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                base = data['base']
                base = bases[base]
                return Dataset(fn, data['dataset'], base, data['dockerfile'])
            except yaml.YAMLError as exc:
                raise Exception("Failed to load dataset: {}".format(fn))

    def __init__(self, location, name, base, dockerfile):
        self.location = location
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.base = base
        self.built = False

        assert not base is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for dataset: {}".format(name)

    def tag(self):
        return "{}-base".format(self.name)

    def build(self):
        if self.built:
            return
        self.base.build()
        print("building dataset: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag())
        self.built = True


"""
All programs must belong to a dataset.
"""
class Program(object):
    @staticmethod
    def find(dataset, program, database):
        identifier = "{}:{}".format(dataset, program)
        return database[identifier]

    @staticmethod
    def load(fn, datasets):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)
                dsname = data['dataset']
                dataset = datasets[dsname]
                assert not dataset is None, "no dataset found: {}".format(dsname)
                return Program(fn, data['program'], dataset, data['dockerfile'])
            except yaml.YAMLError as exc:
                raise Exception("Failed to load dataset: {}".format(fn))

    def __init__(self, location, name, dataset, dockerfile):
        self.location = location
        self.dataset = dataset
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.name = name
        self.built = False

        assert not dataset is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for program: {}".format(name)

    def identifier(self):
        return "{}:{}".format(self.dataset.name, self.name)

    def tag(self):
        return "{}-{}-base".format(self.dataset.name, self.name)

    def build(self):
        if self.built:
            return
        self.dataset.build()
        print("building program: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag())
        self.built = True


"""
All bugs must belong to a dataset, but they need not belong to a program.
"""
class Bug(object):
    @staticmethod
    def find(dataset, program, bug, database):
        identifier = "{}:{}:{}".format(dataset, program, bug)
        return database[identifier]

    @staticmethod
    def load(fn, programs, datasets):
        with open(fn, "r") as f:
            try:
                data = yaml.load(f)

                # find the dataset to which the bug belongs
                dsname = data['dataset']
                dataset = datasets[dsname]
                assert not dataset is None, "no dataset found: {}".format(dsname)

                # find the program to which the bug belongs, if any
                if 'program' in data:
                    program = Program.find(dsname, data['program'], programs)
                else:
                    program = None

                buildargs = data.get('build-arguments', [])

                return Bug(fn, data['bug'], dataset, program, data['dockerfile'], buildargs)

            except yaml.YAMLError as exc:
                raise Exception("Failed to load dataset: {}".format(fn))

    def __init__(self, location, name, dataset, program, dockerfile, buildargs):
        self.location = location
        self.dataset = dataset
        self.program = program
        self.dockerfile = os.path.join(os.path.dirname(location), dockerfile)
        self.buildargs = buildargs
        self.name = name
        self.built = False

        assert not dataset is None
        assert os.path.isfile(self.dockerfile), \
            "Dockerfile not found for bug: {}".format(name)

    def identifier(self):
        if self.program:
            return "{}:{}".format(self.program.identifier(), self.name)
        else:
            return "{}:{}".format(self.dataset.name, self.name)

    def tag(self):
        if self.program:
            return "{}-{}-{}".format(self.program.name, self.dataset.name, self.name)
        return "{}-{}".format(self.dataset.name, self.name)


    """
    Constructs the Docker container for this bug, and if necessary, its
    dependencies
    """
    def build(self):
        if self.built:
            return
        if self.program:
            self.program.build()
        elif self.dataset:
            self.dataset.build()

        print("building bug: {}".format(self.name))
        dockerbuild(self.dockerfile, self.tag(), self.buildargs)
        self.built = True

class RepairBox(object):

    """
    Constructs a new RepairBox interface
    """
    def __init__(self, location=os.path.dirname(os.path.realpath(__file__))):
        self.location = location
        
        # find all bases, datasets, programs and bugs
        self.bases = []
        self.datasets = []
        self.programs = []
        self.bugs = []

        for (root, dirs, files) in os.walk(location):
            self.bases += \
                [os.path.join(root, f) for f in files if f.endswith(".base.yaml")]
            self.datasets += \
                [os.path.join(root, f) for f in files if f.endswith(".dataset.yaml")]
            self.programs += \
                [os.path.join(root, f) for f in files if f.endswith(".program.yaml")]
            self.bugs += \
                [os.path.join(root, f) for f in files if f.endswith(".bug.yaml")]

        # parse and type check manifests
        self.bases = [BaseImage.load(fn) for fn in self.bases]
        self.bases = {base.name: base for base in self.bases}
        self.datasets = [Dataset.load(fn, self.bases) for fn in self.datasets]
        self.datasets = {ds.name: ds for ds in self.datasets}
        self.programs = [Program.load(fn, self.datasets) for fn in self.programs]
        self.programs = {p.identifier(): p for p in self.programs}
        self.bugs = [Bug.load(fn, self.programs, self.datasets) for fn in self.bugs]
        self.bugs = {bug.identifier(): bug for bug in self.bugs}


if __name__ == "__main__":
    rbox = RepairBox()
    bug = rbox.bugs["manybugs:php:php-2011-01-06-e7a1d5004e-3571c955b5"]
    bug.build()
